#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef unsigned char __u8;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __u8 u8;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef s32 int32_t;

typedef u32 uint32_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef u64 dma_addr_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u64 phys_addr_t;

typedef struct {
	int counter;
} atomic_t;

typedef struct {
	s64 counter;
} atomic64_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct lock_class_key {};

struct fs_context;

struct fs_parameter_spec;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
};

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

struct raw_spinlock {
	arch_spinlock_t raw_lock;
	unsigned int magic;
	unsigned int owner_cpu;
	void *owner;
};

typedef struct raw_spinlock raw_spinlock_t;

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
	unsigned int magic;
	unsigned int owner_cpu;
	void *owner;
} rwlock_t;

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, bool);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
};

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct pollfd;

struct restart_block {
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct thread_info {
	long unsigned int flags;
	u32 status;
};

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct sched_statistics {
	u64 wait_start;
	u64 wait_max;
	u64 wait_count;
	u64 wait_sum;
	u64 iowait_count;
	u64 iowait_sum;
	u64 sleep_start;
	u64 sleep_max;
	s64 sum_sleep_runtime;
	u64 block_start;
	u64 block_max;
	u64 exec_max;
	u64 slice_max;
	u64 nr_migrations_cold;
	u64 nr_failed_migrations_affine;
	u64 nr_failed_migrations_running;
	u64 nr_failed_migrations_hot;
	u64 nr_forced_migrations;
	u64 nr_wakeups;
	u64 nr_wakeups_sync;
	u64 nr_wakeups_migrate;
	u64 nr_wakeups_local;
	u64 nr_wakeups_remote;
	u64 nr_wakeups_affine;
	u64 nr_wakeups_affine_attempts;
	u64 nr_wakeups_passive;
	u64 nr_wakeups_idle;
};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	struct util_est util_est;
};

struct cfs_rq;

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	struct sched_statistics statistics;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	long unsigned int runnable_weight;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_boosted: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
};

struct cpumask {
	long unsigned int bits[2];
};

typedef struct cpumask cpumask_t;

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {
	long unsigned int pcount;
	long long unsigned int run_delay;
	long long unsigned int last_arrival;
	long long unsigned int last_queued;
};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct vmacache {
	u64 seqnum;
	struct vm_area_struct *vmas[4];
};

struct task_rss_stat {
	int events;
	int count[4];
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct posix_cputimers_work {
	struct callback_head work;
	unsigned int scheduled;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[1];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

typedef struct {
	uid_t val;
} kuid_t;

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {
	u64 rchar;
	u64 wchar;
	u64 syscr;
	u64 syscw;
	u64 read_bytes;
	u64 write_bytes;
	u64 cancelled_write_bytes;
};

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

typedef atomic64_t atomic_long_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
	void *magic;
};

struct arch_tlbflush_unmap_batch {
	struct cpumask cpumask;
};

struct tlbflush_unmap_batch {
	struct arch_tlbflush_unmap_batch arch;
	bool flush_required;
	bool writable;
};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct desc_struct {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 4;
	u16 s: 1;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 avl: 1;
	u16 l: 1;
	u16 d: 1;
	u16 g: 1;
	u16 base2: 8;
};

struct fregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u32 status;
};

struct fxregs_state {
	u16 cwd;
	u16 swd;
	u16 twd;
	u16 fop;
	union {
		struct {
			u64 rip;
			u64 rdp;
		};
		struct {
			u32 fip;
			u32 fcs;
			u32 foo;
			u32 fos;
		};
	};
	u32 mxcsr;
	u32 mxcsr_mask;
	u32 st_space[32];
	u32 xmm_space[64];
	u32 padding[12];
	union {
		u32 padding1[12];
		u32 sw_reserved[12];
	};
};

struct math_emu_info;

struct swregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u8 ftop;
	u8 changed;
	u8 lookahead;
	u8 no_update;
	u8 rm;
	u8 alimit;
	struct math_emu_info *info;
	u32 entry_eip;
};

struct xstate_header {
	u64 xfeatures;
	u64 xcomp_bv;
	u64 reserved[6];
};

struct xregs_state {
	struct fxregs_state i387;
	struct xstate_header header;
	u8 extended_state_area[0];
};

union fpregs_state {
	struct fregs_state fsave;
	struct fxregs_state fxsave;
	struct swregs_state soft;
	struct xregs_state xsave;
	u8 __padding[4096];
};

struct fpu {
	unsigned int last_cpu;
	long unsigned int avx512_timestamp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union fpregs_state state;
};

struct perf_event;

struct io_bitmap;

struct thread_struct {
	struct desc_struct tls_array[3];
	long unsigned int sp;
	short unsigned int es;
	short unsigned int ds;
	short unsigned int fsindex;
	short unsigned int gsindex;
	long unsigned int fsbase;
	long unsigned int gsbase;
	struct perf_event *ptrace_bps[4];
	long unsigned int virtual_dr6;
	long unsigned int ptrace_dr7;
	long unsigned int cr2;
	long unsigned int trap_nr;
	long unsigned int error_code;
	struct io_bitmap *io_bitmap;
	long unsigned int iopl_emul;
	unsigned int sig_on_uaccess_err: 1;
	long: 63;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct fpu fpu;
};

struct sched_class;

struct task_group;

struct mm_struct;

struct pid;

struct completion;

struct cred;

struct key;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct audit_context;

struct rt_mutex_waiter;

struct mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct compat_robust_list_head;

struct futex_pi_state;

struct perf_event_context;

struct mempolicy;

struct numa_group;

struct rseq;

struct task_delay_info;

struct ftrace_ret_stack;

struct mem_cgroup;

struct request_queue;

struct uprobe_task;

struct vm_struct;

struct task_struct {
	struct thread_info thread_info;
	volatile long int state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int cpu;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct task_group *sched_task_group;
	struct sched_dl_entity dl;
	struct hlist_head preempt_notifiers;
	unsigned int btrace_seq;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t cpus_mask;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	bool trc_reader_checked;
	struct list_head trc_holdout_list;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct vmacache vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	unsigned int sched_remote_wakeup: 1;
	unsigned int sched_psi_wake_requeue: 1;
	int: 27;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int restore_sigmask: 1;
	unsigned int in_user_fault: 1;
	unsigned int brk_randomized: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	unsigned int in_memstall: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	struct posix_cputimers_work posix_cputimers_work;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	long unsigned int last_switch_count;
	long unsigned int last_switch_time;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	struct mutex_waiter *blocked_on;
	int non_block_count;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	unsigned int psi_flags;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_spinlock_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	int cpuset_slab_spread_rotor;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct compat_robust_list_head *compat_robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short int il_prev;
	short int pref_node_fork;
	int numa_scan_seq;
	unsigned int numa_scan_period;
	unsigned int numa_scan_period_max;
	int numa_preferred_nid;
	long unsigned int numa_migrate_retry;
	u64 node_stamp;
	u64 last_task_numa_placement;
	u64 last_sum_exec_runtime;
	struct callback_head numa_work;
	struct numa_group *numa_group;
	long unsigned int *numa_faults;
	long unsigned int total_numa_faults;
	long unsigned int numa_faults_locality[3];
	long unsigned int numa_pages_migrated;
	struct rseq *rseq;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	struct task_delay_info *delays;
	int make_it_fail;
	unsigned int fail_nth;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	long long unsigned int ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct request_queue *throttle_queue;
	struct uprobe_task *utask;
	unsigned int sequential_io;
	unsigned int sequential_io_avg;
	long unsigned int task_state_change;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	void *security;
	void *mce_vaddr;
	__u64 mce_kflags;
	u64 mce_addr;
	__u64 mce_ripv: 1;
	__u64 mce_whole_page: 1;
	__u64 __mce_reserved: 62;
	struct callback_head mce_kill_me;
	long: 64;
	long: 64;
	long: 64;
	struct thread_struct thread;
};

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct apm_bios_info {
	__u16 version;
	__u16 cseg;
	__u32 offset;
	__u16 cseg_16;
	__u16 dseg;
	__u16 flags;
	__u16 cseg_len;
	__u16 cseg_16_len;
	__u16 dseg_len;
};

struct edd_device_params {
	__u16 length;
	__u16 info_flags;
	__u32 num_default_cylinders;
	__u32 num_default_heads;
	__u32 sectors_per_track;
	__u64 number_of_sectors;
	__u16 bytes_per_sector;
	__u32 dpte_ptr;
	__u16 key;
	__u8 device_path_info_length;
	__u8 reserved2;
	__u16 reserved3;
	__u8 host_bus_type[4];
	__u8 interface_type[8];
	union {
		struct {
			__u16 base_address;
			__u16 reserved1;
			__u32 reserved2;
		} isa;
		struct {
			__u8 bus;
			__u8 slot;
			__u8 function;
			__u8 channel;
			__u32 reserved;
		} pci;
		struct {
			__u64 reserved;
		} ibnd;
		struct {
			__u64 reserved;
		} xprs;
		struct {
			__u64 reserved;
		} htpt;
		struct {
			__u64 reserved;
		} unknown;
	} interface_path;
	union {
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} ata;
		struct {
			__u8 device;
			__u8 lun;
			__u8 reserved1;
			__u8 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} atapi;
		struct {
			__u16 id;
			__u64 lun;
			__u16 reserved1;
			__u32 reserved2;
		} __attribute__((packed)) scsi;
		struct {
			__u64 serial_number;
			__u64 reserved;
		} usb;
		struct {
			__u64 eui;
			__u64 reserved;
		} i1394;
		struct {
			__u64 wwid;
			__u64 lun;
		} fibre;
		struct {
			__u64 identity_tag;
			__u64 reserved;
		} i2o;
		struct {
			__u32 array_number;
			__u32 reserved1;
			__u64 reserved2;
		} raid;
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} sata;
		struct {
			__u64 reserved1;
			__u64 reserved2;
		} unknown;
	} device_path;
	__u8 reserved4;
	__u8 checksum;
} __attribute__((packed));

struct edd_info {
	__u8 device;
	__u8 version;
	__u16 interface_support;
	__u16 legacy_max_cylinder;
	__u8 legacy_max_head;
	__u8 legacy_sectors_per_track;
	struct edd_device_params params;
} __attribute__((packed));

struct ist_info {
	__u32 signature;
	__u32 command;
	__u32 event;
	__u32 perf_level;
};

struct edid_info {
	unsigned char dummy[128];
};

struct setup_header {
	__u8 setup_sects;
	__u16 root_flags;
	__u32 syssize;
	__u16 ram_size;
	__u16 vid_mode;
	__u16 root_dev;
	__u16 boot_flag;
	__u16 jump;
	__u32 header;
	__u16 version;
	__u32 realmode_swtch;
	__u16 start_sys_seg;
	__u16 kernel_version;
	__u8 type_of_loader;
	__u8 loadflags;
	__u16 setup_move_size;
	__u32 code32_start;
	__u32 ramdisk_image;
	__u32 ramdisk_size;
	__u32 bootsect_kludge;
	__u16 heap_end_ptr;
	__u8 ext_loader_ver;
	__u8 ext_loader_type;
	__u32 cmd_line_ptr;
	__u32 initrd_addr_max;
	__u32 kernel_alignment;
	__u8 relocatable_kernel;
	__u8 min_alignment;
	__u16 xloadflags;
	__u32 cmdline_size;
	__u32 hardware_subarch;
	__u64 hardware_subarch_data;
	__u32 payload_offset;
	__u32 payload_length;
	__u64 setup_data;
	__u64 pref_address;
	__u32 init_size;
	__u32 handover_offset;
	__u32 kernel_info_offset;
} __attribute__((packed));

struct sys_desc_table {
	__u16 length;
	__u8 table[14];
};

struct olpc_ofw_header {
	__u32 ofw_magic;
	__u32 ofw_version;
	__u32 cif_handler;
	__u32 irq_desc_table;
};

struct efi_info {
	__u32 efi_loader_signature;
	__u32 efi_systab;
	__u32 efi_memdesc_size;
	__u32 efi_memdesc_version;
	__u32 efi_memmap;
	__u32 efi_memmap_size;
	__u32 efi_systab_hi;
	__u32 efi_memmap_hi;
};

struct boot_e820_entry {
	__u64 addr;
	__u64 size;
	__u32 type;
} __attribute__((packed));

struct boot_params {
	struct screen_info screen_info;
	struct apm_bios_info apm_bios_info;
	__u8 _pad2[4];
	__u64 tboot_addr;
	struct ist_info ist_info;
	__u64 acpi_rsdp_addr;
	__u8 _pad3[8];
	__u8 hd0_info[16];
	__u8 hd1_info[16];
	struct sys_desc_table sys_desc_table;
	struct olpc_ofw_header olpc_ofw_header;
	__u32 ext_ramdisk_image;
	__u32 ext_ramdisk_size;
	__u32 ext_cmd_line_ptr;
	__u8 _pad4[116];
	struct edid_info edid_info;
	struct efi_info efi_info;
	__u32 alt_mem_k;
	__u32 scratch;
	__u8 e820_entries;
	__u8 eddbuf_entries;
	__u8 edd_mbr_sig_buf_entries;
	__u8 kbd_status;
	__u8 secure_boot;
	__u8 _pad5[2];
	__u8 sentinel;
	__u8 _pad6[1];
	struct setup_header hdr;
	__u8 _pad7[36];
	__u32 edd_mbr_sig_buffer[16];
	struct boot_e820_entry e820_table[128];
	__u8 _pad8[48];
	struct edd_info eddbuf[6];
	__u8 _pad9[276];
} __attribute__((packed));

enum x86_hardware_subarch {
	X86_SUBARCH_PC = 0,
	X86_SUBARCH_LGUEST = 1,
	X86_SUBARCH_XEN = 2,
	X86_SUBARCH_INTEL_MID = 3,
	X86_SUBARCH_CE4100 = 4,
	X86_NR_SUBARCHS = 5,
};

struct range {
	u64 start;
	u64 end;
};

struct pt_regs {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	long unsigned int cs;
	long unsigned int flags;
	long unsigned int sp;
	long unsigned int ss;
};

struct math_emu_info {
	long int ___orig_eip;
	struct pt_regs *regs;
};

typedef long unsigned int pteval_t;

typedef long unsigned int pmdval_t;

typedef long unsigned int pudval_t;

typedef long unsigned int p4dval_t;

typedef long unsigned int pgdval_t;

typedef long unsigned int pgprotval_t;

typedef struct {
	pteval_t pte;
} pte_t;

struct pgprot {
	pgprotval_t pgprot;
};

typedef struct pgprot pgprot_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

typedef struct {
	pgd_t pgd;
} p4d_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef struct page *pgtable_t;

struct address_space;

struct kmem_cache;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			dma_addr_t dma_addr;
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page *next;
					int pages;
					int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
			unsigned int compound_nr;
		};
		struct {
			long unsigned int _compound_pad_1;
			atomic_t hpage_pinned_refcount;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t *ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
	long unsigned int memcg_data;
};

struct idt_bits {
	u16 ist: 3;
	u16 zero: 5;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
};

struct gate_struct {
	u16 offset_low;
	u16 segment;
	struct idt_bits bits;
	u16 offset_middle;
	u32 offset_high;
	u32 reserved;
};

typedef struct gate_struct gate_desc;

struct desc_ptr {
	short unsigned int size;
	long unsigned int address;
} __attribute__((packed));

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum tlb_infos {
	ENTRIES = 0,
	NR_INFO = 1,
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct ww_acquire_ctx;

struct ww_class;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
	struct ww_class *ww_class;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
	unsigned int done_acquire;
	struct ww_class *ww_class;
	struct ww_mutex *contending_lock;
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
	void *magic;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

struct vm_userfaultfd_ctx {};

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct *vm_next;
	struct vm_area_struct *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

struct ldt_struct;

struct vdso_image;

typedef struct {
	u64 ctx_id;
	atomic64_t tlb_gen;
	struct rw_semaphore ldt_usr_sem;
	struct ldt_struct *ldt;
	short unsigned int ia32_compat;
	struct mutex lock;
	void *vdso;
	const struct vdso_image *vdso_image;
	atomic_t perf_rdpmc_allowed;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct linux_binfmt;

struct core_state;

struct kioctx_table;

struct user_namespace;

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct vm_area_struct *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int mmap_compat_base;
		long unsigned int mmap_compat_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_t has_pinned;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[46];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		struct core_state *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct *owner;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		long unsigned int numa_next_scan;
		long unsigned int numa_scan_offset;
		int numa_scan_seq;
		atomic_t tlb_flush_pending;
		bool tlb_flush_batched;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		u32 pasid;
	};
	long unsigned int cpu_bitmap[0];
};

struct arch_uprobe_task {
	long unsigned int saved_scratch_register;
	unsigned int saved_trap_nr;
	unsigned int saved_tf;
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct return_instance {
	struct uprobe *uprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

struct vdso_image {
	void *data;
	long unsigned int size;
	long unsigned int alt;
	long unsigned int alt_len;
	long int sym_vvar_start;
	long int sym_vvar_page;
	long int sym_pvclock_page;
	long int sym_hvclock_page;
	long int sym_timens_page;
	long int sym_VDSO32_NOTE_MASK;
	long int sym___kernel_sigreturn;
	long int sym___kernel_rt_sigreturn;
	long int sym___kernel_vsyscall;
	long int sym_int80_landing_pad;
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int nrexceptional;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

struct vmem_altmap {
	const long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_FS_DAX = 2,
	MEMORY_DEVICE_GENERIC = 3,
	MEMORY_DEVICE_PCI_P2PDMA = 4,
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref *ref;
	struct percpu_ref internal_ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct range ranges[0];
	};
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	struct file_ra_state f_ra;
	u64 f_version;
	void *f_security;
	void *private_data;
	struct list_head f_ep_links;
	struct list_head f_tfile_llink;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	void (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct vm_fault {
	struct vm_area_struct *vma;
	unsigned int flags;
	gfp_t gfp_mask;
	long unsigned int pgoff;
	long unsigned int address;
	pmd_t *pmd;
	pud_t *pud;
	pte_t orig_pte;
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_CMA = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_STAT_ITEMS = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_PAGETABLE = 8,
	NR_BOUNCE = 9,
	NR_FREE_CMA_PAGES = 10,
	NR_VM_ZONE_STAT_ITEMS = 11,
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_KERNEL_MISC_RECLAIMABLE = 33,
	NR_FOLL_PIN_ACQUIRED = 34,
	NR_FOLL_PIN_RELEASED = 35,
	NR_KERNEL_STACK_KB = 36,
	NR_VM_NODE_STAT_ITEMS = 37,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

typedef unsigned int isolate_mode_t;

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	NR_WMARK = 3,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	void (*kill)(struct dev_pagemap *);
	void (*cleanup)(struct dev_pagemap *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
};

struct pid_namespace;

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

typedef struct {
	gid_t val;
} kgid_t;

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hrtimer_clock_base clock_base[8];
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t *__sigrestore_t;

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct user_struct {
	refcount_t __count;
	atomic_t processes;
	atomic_t sigpending;
	atomic_long_t epoll_watches;
	long unsigned int mq_bytes;
	long unsigned int locked_shm;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct pacct_struct {
	int ac_flag;
	long int ac_exitcode;
	long unsigned int ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	long unsigned int ac_minflt;
	long unsigned int ac_majflt;
};

struct tty_struct;

struct taskstats;

struct tty_audit_buf;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct mutex exec_update_mutex;
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	union {
		__u64 ptr64;
		__u64 ptr;
	} rseq_cs;
	__u32 flags;
	long: 32;
	long: 64;
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

struct rq;

struct rq_flags;

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *, int);
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct group_info;

struct cred {
	atomic_t usage;
	atomic_t subscribers;
	void *put_addr;
	unsigned int magic;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	atomic_t nr_tasks;
	spinlock_t lock;
	short unsigned int ioprio;
	struct xarray icq_tree;
	struct io_cq *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum fixed_addresses {
	VSYSCALL_PAGE = 511,
	FIX_DBGP_BASE = 512,
	FIX_EARLYCON_MEM_BASE = 513,
	FIX_APIC_BASE = 514,
	FIX_IO_APIC_BASE_0 = 515,
	FIX_IO_APIC_BASE_END = 642,
	__end_of_permanent_fixed_addresses = 643,
	FIX_BTMAP_END = 1024,
	FIX_BTMAP_BEGIN = 1535,
	FIX_TBOOT_BASE = 1536,
	__end_of_fixed_addresses = 1537,
};

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct posix_acl;

struct inode_operations;

struct bdi_writeback;

struct file_lock_context;

struct block_device;

struct cdev;

struct fsnotify_mark_connector;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	void *i_security;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct block_device *i_bdev;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	long: 64;
	long: 64;
	long: 64;
};

struct mtd_info;

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct workqueue_struct;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler **s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_inode_refs;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 32;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one *lru[0];
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	struct list_lru_memcg *memcg_lrus;
	long int nr_items;
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	union {
		unsigned int ki_cookie;
		struct wait_page_queue *ki_waitq;
	};
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct writeback_control;

struct readahead_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*readpage)(struct file *, struct page *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	int (*set_page_dirty)(struct page *);
	int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidatepage)(struct page *, unsigned int, unsigned int);
	int (*releasepage)(struct page *, gfp_t);
	void (*freepage)(struct page *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
	bool (*isolate_page)(struct page *, isolate_mode_t);
	void (*putback_page)(struct page *);
	int (*launder_page)(struct page *);
	int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
};

struct fiemap_extent_info;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct dentry *, struct iattr *);
	int (*getattr)(const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct inode *, struct posix_acl *, int);
	long: 64;
	long: 64;
	long: 64;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct fasync_struct;

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
};

struct lock_manager_operations {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
};

struct iomap;

struct fid;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

struct p_log;

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	HUGETLB_PAGE_DTOR = 2,
	TRANSHUGE_PAGE_DTOR = 3,
	NR_COMPOUND_DTORS = 4,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGSCAN_KSWAPD = 27,
	PGSCAN_DIRECT = 28,
	PGSCAN_DIRECT_THROTTLE = 29,
	PGSCAN_ANON = 30,
	PGSCAN_FILE = 31,
	PGSTEAL_ANON = 32,
	PGSTEAL_FILE = 33,
	PGSCAN_ZONE_RECLAIM_FAILED = 34,
	PGINODESTEAL = 35,
	SLABS_SCANNED = 36,
	KSWAPD_INODESTEAL = 37,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 38,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 39,
	PAGEOUTRUN = 40,
	PGROTATED = 41,
	DROP_PAGECACHE = 42,
	DROP_SLAB = 43,
	OOM_KILL = 44,
	NUMA_PTE_UPDATES = 45,
	NUMA_HUGE_PTE_UPDATES = 46,
	NUMA_HINT_FAULTS = 47,
	NUMA_HINT_FAULTS_LOCAL = 48,
	NUMA_PAGE_MIGRATE = 49,
	PGMIGRATE_SUCCESS = 50,
	PGMIGRATE_FAIL = 51,
	THP_MIGRATION_SUCCESS = 52,
	THP_MIGRATION_FAIL = 53,
	THP_MIGRATION_SPLIT = 54,
	COMPACTMIGRATE_SCANNED = 55,
	COMPACTFREE_SCANNED = 56,
	COMPACTISOLATED = 57,
	COMPACTSTALL = 58,
	COMPACTFAIL = 59,
	COMPACTSUCCESS = 60,
	KCOMPACTD_WAKE = 61,
	KCOMPACTD_MIGRATE_SCANNED = 62,
	KCOMPACTD_FREE_SCANNED = 63,
	HTLB_BUDDY_PGALLOC = 64,
	HTLB_BUDDY_PGALLOC_FAIL = 65,
	UNEVICTABLE_PGCULLED = 66,
	UNEVICTABLE_PGSCANNED = 67,
	UNEVICTABLE_PGRESCUED = 68,
	UNEVICTABLE_PGMLOCKED = 69,
	UNEVICTABLE_PGMUNLOCKED = 70,
	UNEVICTABLE_PGCLEARED = 71,
	UNEVICTABLE_PGSTRANDED = 72,
	THP_FAULT_ALLOC = 73,
	THP_FAULT_FALLBACK = 74,
	THP_FAULT_FALLBACK_CHARGE = 75,
	THP_COLLAPSE_ALLOC = 76,
	THP_COLLAPSE_ALLOC_FAILED = 77,
	THP_FILE_ALLOC = 78,
	THP_FILE_FALLBACK = 79,
	THP_FILE_FALLBACK_CHARGE = 80,
	THP_FILE_MAPPED = 81,
	THP_SPLIT_PAGE = 82,
	THP_SPLIT_PAGE_FAILED = 83,
	THP_DEFERRED_SPLIT_PAGE = 84,
	THP_SPLIT_PMD = 85,
	THP_SPLIT_PUD = 86,
	THP_ZERO_PAGE_ALLOC = 87,
	THP_ZERO_PAGE_ALLOC_FAILED = 88,
	THP_SWPOUT = 89,
	THP_SWPOUT_FALLBACK = 90,
	BALLOON_INFLATE = 91,
	BALLOON_DEFLATE = 92,
	BALLOON_MIGRATE = 93,
	SWAP_RA = 94,
	SWAP_RA_HIT = 95,
	NR_VM_EVENT_ITEMS = 96,
};

struct tlb_context {
	u64 ctx_id;
	u64 tlb_gen;
};

struct tlb_state {
	struct mm_struct *loaded_mm;
	union {
		struct mm_struct *last_user_mm;
		long unsigned int last_user_mm_ibpb;
	};
	u16 loaded_mm_asid;
	u16 next_asid;
	bool is_lazy;
	bool invalidate_other;
	short unsigned int user_pcid_flush_mask;
	long unsigned int cr4;
	struct tlb_context ctxs[6];
};

struct boot_params_to_save {
	unsigned int start;
	unsigned int len;
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_SHARE_CPUCAPACITY = 6,
	__SD_SHARE_PKG_RESOURCES = 7,
	__SD_SERIALIZE = 8,
	__SD_ASYM_PACKING = 9,
	__SD_PREFER_SIBLING = 10,
	__SD_OVERLAP = 11,
	__SD_NUMA = 12,
	__SD_FLAG_CNT = 13,
};

struct x86_legacy_devices {
	int pnpbios;
};

enum x86_legacy_i8042_state {
	X86_LEGACY_I8042_PLATFORM_ABSENT = 0,
	X86_LEGACY_I8042_FIRMWARE_ABSENT = 1,
	X86_LEGACY_I8042_EXPECTED_PRESENT = 2,
};

struct x86_legacy_features {
	enum x86_legacy_i8042_state i8042;
	int rtc;
	int warm_reset;
	int no_vga;
	int reserve_bios_regions;
	struct x86_legacy_devices devices;
};

struct ghcb;

struct x86_hyper_runtime {
	void (*pin_vcpu)(int);
	void (*sev_es_hcall_prepare)(struct ghcb *, struct pt_regs *);
	bool (*sev_es_hcall_finish)(struct ghcb *, struct pt_regs *);
};

struct x86_platform_ops {
	long unsigned int (*calibrate_cpu)();
	long unsigned int (*calibrate_tsc)();
	void (*get_wallclock)(struct timespec64 *);
	int (*set_wallclock)(const struct timespec64 *);
	void (*iommu_shutdown)();
	bool (*is_untracked_pat_range)(u64, u64);
	void (*nmi_init)();
	unsigned char (*get_nmi_reason)();
	void (*save_sched_clock_state)();
	void (*restore_sched_clock_state)();
	void (*apic_post_init)();
	struct x86_legacy_features legacy;
	void (*set_legacy_features)();
	struct x86_hyper_runtime hyper;
};

typedef signed char __s8;

typedef short int __s16;

typedef __s8 s8;

typedef __s16 s16;

typedef long unsigned int irq_hw_number_t;

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

typedef int (*initcall_t)();

typedef int initcall_entry_t;

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

struct lockdep_map {};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_RUNNING = 2,
	SYSTEM_HALT = 3,
	SYSTEM_POWER_OFF = 4,
	SYSTEM_RESTART = 5,
	SYSTEM_SUSPEND = 6,
};

struct jump_entry {
	s32 code;
	s32 target;
	long int key;
};

struct static_key_mod;

struct static_key {
	atomic_t enabled;
	union {
		long unsigned int type;
		struct jump_entry *entries;
		struct static_key_mod *next;
	};
};

struct static_key_false {
	struct static_key key;
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	short unsigned int line;
	short unsigned int flags;
};

typedef struct cpumask cpumask_var_t[1];

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct static_call_key;

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

struct static_call_mod;

struct static_call_site;

struct static_call_key {
	void *func;
	union {
		long unsigned int type;
		struct static_call_mod *mods;
		struct static_call_site *sites;
	};
};

typedef const int tracepoint_ptr_t;

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct orc_entry {
	s16 sp_offset;
	s16 bp_offset;
	unsigned int sp_reg: 4;
	unsigned int bp_reg: 4;
	unsigned int type: 2;
	unsigned int end: 1;
} __attribute__((packed));

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 __reserved_1: 30;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct arch_hw_breakpoint {
	long unsigned int address;
	long unsigned int mask;
	u8 len;
	u8 type;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct list_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct irq_work {
	union {
		struct __call_single_node node;
		struct {
			struct llist_node llnode;
			atomic_t flags;
		};
	};
	void (*func)(struct irq_work *);
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct ftrace_ops;

typedef void (*ftrace_func_t)(long unsigned int, long unsigned int, struct ftrace_ops *, struct pt_regs *);

struct ftrace_hash;

struct ftrace_ops_hash {
	struct ftrace_hash *notrace_hash;
	struct ftrace_hash *filter_hash;
	struct mutex regex_lock;
};

struct ftrace_ops {
	ftrace_func_t func;
	struct ftrace_ops *next;
	long unsigned int flags;
	void *private;
	ftrace_func_t saved_func;
	struct ftrace_ops_hash local_hash;
	struct ftrace_ops_hash *func_hash;
	struct ftrace_ops_hash old_hash;
	long unsigned int trampoline;
	long unsigned int trampoline_size;
	struct list_head list;
};

struct pmu;

struct perf_buffer;

struct perf_addr_filter_range;

struct bpf_prog;

struct trace_event_call;

struct event_filter;

struct perf_cgroup;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	u64 shadow_ctx_time;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	int pending_wakeup;
	int pending_kill;
	int pending_disable;
	struct irq_work pending;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct perf_cgroup *cgrp;
	void *security;
	struct list_head sb_list;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
};

struct ctl_table;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct ucounts;

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	atomic_t count;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	int ucount_max[10];
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	union {
		struct __call_single_node node;
		struct {
			struct llist_node llist;
			unsigned int flags;
			u16 src;
			u16 dst;
		};
	};
	smp_call_func_t func;
	void *info;
};

struct smp_ops {
	void (*smp_prepare_boot_cpu)();
	void (*smp_prepare_cpus)(unsigned int);
	void (*smp_cpus_done)(unsigned int);
	void (*stop_other_cpus)(int);
	void (*crash_stop_other_cpus)();
	void (*smp_send_reschedule)(int);
	int (*cpu_up)(unsigned int, struct task_struct *);
	int (*cpu_disable)();
	void (*cpu_die)(unsigned int);
	void (*play_dead)();
	void (*send_call_func_ipi)(const struct cpumask *);
	void (*send_call_func_single_ipi)(int);
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	u8 enabled;
	u8 offloaded;
};

struct srcu_node;

struct srcu_struct;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node node[9];
	struct srcu_node *level[3];
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_last_gp_end;
	struct srcu_data *sda;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	struct delayed_work work;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	unsigned int degree;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

struct mempolicy {
	atomic_t refcnt;
	short unsigned int mode;
	short unsigned int flags;
	union {
		short int preferred_node;
		nodemask_t nodes;
	} v;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

struct free_area {
	struct list_head free_list[6];
	long unsigned int nr_free;
};

struct zone_padding {
	char x[0];
};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
	struct pglist_data *pgdat;
};

struct per_cpu_pageset;

struct zone {
	long unsigned int _watermark[3];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[4];
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pageset *pageset;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	int initialized;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	struct free_area free_area[11];
	long unsigned int flags;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	short: 16;
	struct zone_padding _pad3_;
	atomic_long_t vm_stat[11];
	atomic_long_t vm_numa_stat[6];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[257];
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	__MAX_NR_ZONES = 4,
};

struct deferred_split {
	spinlock_t split_queue_lock;
	struct list_head split_queue;
	long unsigned int split_queue_len;
};

struct per_cpu_nodestat;

struct pglist_data {
	struct zone node_zones[4];
	struct zonelist node_zonelists[2];
	int nr_zones;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	long unsigned int totalreserve_pages;
	long unsigned int min_unmapped_pages;
	long unsigned int min_slab_pages;
	struct zone_padding _pad1_;
	spinlock_t lru_lock;
	struct deferred_split deferred_split_queue;
	struct lruvec __lruvec;
	long unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[37];
	long: 64;
	long: 64;
};

struct per_cpu_pages {
	int count;
	int high;
	int batch;
	struct list_head lists[3];
};

struct per_cpu_pageset {
	struct per_cpu_pages pcp;
	s8 expire;
	u16 vm_numa_stat_diff[6];
	s8 stat_threshold;
	s8 vm_stat_diff[11];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[37];
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
};

struct irq_domain_ops;

struct fwnode_handle;

struct irq_domain_chip_generic;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_tree_mutex;
	unsigned int linear_revmap[0];
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

typedef struct elf64_sym Elf64_Sym;

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
};

struct kernfs_node;

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	u64 id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct kobject;

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct kref {
	refcount_t refcount;
};

struct kset;

struct kobj_type;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kset *, struct kobject *);
	const char * (* const name)(struct kset *, struct kobject *);
	int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};

struct kernel_param;

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct mod_arch_specific {
	unsigned int num_orcs;
	int *orc_unwind_ip;
	struct orc_entry *orc_unwind;
};

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct module_attribute;

struct exception_table_entry;

struct module_sect_attrs;

struct module_notes_attrs;

struct trace_eval_map;

struct error_injection_entry;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool sig_ok;
	bool async_probe_requested;
	const struct kernel_symbol *gpl_future_syms;
	const s32 *gpl_future_crcs;
	unsigned int num_gpl_future_syms;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	long: 64;
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	void *btf_data;
	struct jump_entry *jump_entries;
	unsigned int num_jump_entries;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	long unsigned int *ftrace_callsites;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	int num_static_call_sites;
	struct static_call_site *static_call_sites;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	struct error_injection_entry *ei_funcs;
	unsigned int num_ei_funcs;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct error_injection_entry {
	long unsigned int addr;
	int etype;
};

struct static_call_site {
	s32 addr;
	s32 key;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct exception_table_entry {
	int insn;
	int fixup;
	int handler;
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct bpf_prog_array;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	void *mod;
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct cgroup;

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct page_counter {
	atomic_long_t usage;
	long unsigned int min;
	long unsigned int low;
	long unsigned int high;
	long unsigned int max;
	struct page_counter *parent;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int failcnt;
};

struct vmpressure {
	long unsigned int scanned;
	long unsigned int reclaimed;
	long unsigned int tree_scanned;
	long unsigned int tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct mem_cgroup_threshold_ary;

struct mem_cgroup_thresholds {
	struct mem_cgroup_threshold_ary *primary;
	struct mem_cgroup_threshold_ary *spare;
};

struct memcg_padding {
	char x[0];
};

enum memcg_kmem_state {
	KMEM_NONE = 0,
	KMEM_ALLOCATED = 1,
	KMEM_ONLINE = 2,
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct memcg_cgwb_frn {
	u64 bdi_id;
	int memcg_id;
	u64 at;
	struct wb_completion done;
};

struct memcg_vmstats_percpu;

struct obj_cgroup;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	struct page_counter memory;
	union {
		struct page_counter swap;
		struct page_counter memsw;
	};
	struct page_counter kmem;
	struct page_counter tcpmem;
	struct work_struct high_work;
	long unsigned int soft_limit;
	struct vmpressure vmpressure;
	bool use_hierarchy;
	bool oom_group;
	bool oom_lock;
	int under_oom;
	int swappiness;
	int oom_kill_disable;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct mutex thresholds_lock;
	struct mem_cgroup_thresholds thresholds;
	struct mem_cgroup_thresholds memsw_thresholds;
	struct list_head oom_notify;
	long unsigned int move_charge_at_immigrate;
	spinlock_t move_lock;
	long unsigned int move_lock_flags;
	long: 64;
	long: 64;
	struct memcg_padding _pad1_;
	atomic_t moving_account;
	struct task_struct *move_lock_task;
	struct memcg_vmstats_percpu *vmstats_local;
	struct memcg_vmstats_percpu *vmstats_percpu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct memcg_padding _pad2_;
	atomic_long_t vmstats[40];
	atomic_long_t vmevents[96];
	atomic_long_t memory_events[8];
	atomic_long_t memory_events_local[8];
	long unsigned int socket_pressure;
	bool tcpmem_active;
	int tcpmem_pressure;
	int kmemcg_id;
	enum memcg_kmem_state kmem_state;
	struct obj_cgroup *objcg;
	struct list_head objcg_list;
	struct list_head cgwb_list;
	struct wb_domain cgwb_domain;
	struct memcg_cgwb_frn cgwb_frn[4];
	struct list_head event_list;
	spinlock_t event_list_lock;
	struct deferred_split deferred_split_queue;
	struct mem_cgroup_per_node *nodeinfo[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct fs_pin;

struct pid_namespace {
	struct kref kref;
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct blk_plug {
	struct list_head mq_list;
	struct list_head cb_list;
	short unsigned int rq_count;
	bool multiple_queues;
	bool nowait;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	struct percpu_counter stat[4];
	long unsigned int congested;
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
	struct percpu_ref refcnt;
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css;
	struct cgroup_subsys_state *blkcg_css;
	struct list_head memcg_node;
	struct list_head blkcg_node;
	union {
		struct work_struct release_work;
		struct callback_head rcu;
	};
};

struct device;

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	struct bdi_writeback wb;
	struct list_head wb_list;
	struct xarray cgwb_tree;
	struct mutex cgwb_release_mutex;
	struct rw_semaphore wb_switch_rwsem;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct css_set {
	struct cgroup_subsys_state *subsys[10];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[10];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

typedef u32 compat_uptr_t;

struct compat_robust_list {
	compat_uptr_t next;
};

typedef s32 compat_long_t;

struct compat_robust_list_head {
	struct compat_robust_list list;
	compat_long_t futex_offset;
	compat_uptr_t list_op_pending;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	void *task_ctx_data;
	struct callback_head callback_head;
};

struct task_delay_info {
	raw_spinlock_t lock;
	unsigned int flags;
	u64 blkio_start;
	u64 blkio_delay;
	u64 swapin_delay;
	u32 blkio_count;
	u32 swapin_count;
	u64 freepages_start;
	u64 freepages_delay;
	u64 thrashing_start;
	u64 thrashing_delay;
	u32 freepages_count;
	u32 thrashing_count;
};

struct ftrace_ret_stack {
	long unsigned int ret;
	long unsigned int func;
	long long unsigned int calltime;
	long unsigned int *retp;
};

enum rpm_status {
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	long unsigned int bounce_pfn;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_write_same_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
};

struct bsg_ops;

struct bsg_class_device {
	struct device *class_dev;
	int minor;
	struct request_queue *queue;
	const struct bsg_ops *ops;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
};

struct request;

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_stat_callback;

struct blkcg_gq;

struct blk_trace;

struct blk_flush_queue;

struct throtl_data;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int queue_depth;
	struct blk_mq_hw_ctx **queue_hw_ctx;
	unsigned int nr_hw_queues;
	struct backing_dev_info *backing_dev_info;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	gfp_t bounce_gfp;
	spinlock_t queue_lock;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct device *dev;
	enum rpm_status rpm_status;
	unsigned int nr_pending;
	long unsigned int nr_requests;
	unsigned int dma_pad_mask;
	unsigned int dma_alignment;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	struct blk_rq_stat poll_stat[16];
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_sbitmap;
	struct list_head icq_list;
	long unsigned int blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	int node;
	struct mutex debugfs_mutex;
	struct blk_trace *blk_trace;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct bsg_class_device bsg_dev;
	struct throtl_data *td;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct bio_set bio_split;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	bool mq_sysfs_init_done;
	size_t cmd_size;
	u64 write_hints[5];
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct psi_group_cpu;

struct psi_group {
	struct mutex avgs_lock;
	struct psi_group_cpu *pcpu;
	u64 avg_total[5];
	u64 avg_last_update;
	u64 avg_next_update;
	struct delayed_work avgs_work;
	u64 total[10];
	long unsigned int avg[15];
	struct task_struct *poll_task;
	struct timer_list poll_timer;
	wait_queue_head_t poll_wait;
	atomic_t poll_wakeup;
	struct mutex trigger_lock;
	struct list_head triggers;
	u32 nr_triggers[5];
	u32 poll_states;
	u64 poll_min_period;
	u64 polling_total[5];
	u64 polling_next_update;
	u64 polling_until;
};

struct cgroup_bpf {
	struct bpf_prog_array *effective[38];
	struct list_head progs[38];
	u32 flags[38];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[10];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[10];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	u64 ancestor_ids[0];
};

struct taskstats {
	__u16 version;
	__u32 ac_exitcode;
	__u8 ac_flag;
	__u8 ac_nice;
	__u64 cpu_count;
	__u64 cpu_delay_total;
	__u64 blkio_count;
	__u64 blkio_delay_total;
	__u64 swapin_count;
	__u64 swapin_delay_total;
	__u64 cpu_run_real_total;
	__u64 cpu_run_virtual_total;
	char ac_comm[32];
	__u8 ac_sched;
	__u8 ac_pad[3];
	int: 32;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u64 ac_etime;
	__u64 ac_utime;
	__u64 ac_stime;
	__u64 ac_minflt;
	__u64 ac_majflt;
	__u64 coremem;
	__u64 virtmem;
	__u64 hiwater_rss;
	__u64 hiwater_vm;
	__u64 read_char;
	__u64 write_char;
	__u64 read_syscalls;
	__u64 write_syscalls;
	__u64 read_bytes;
	__u64 write_bytes;
	__u64 cancelled_write_bytes;
	__u64 nvcsw;
	__u64 nivcsw;
	__u64 ac_utimescaled;
	__u64 ac_stimescaled;
	__u64 cpu_scaled_run_real_total;
	__u64 freepages_count;
	__u64 freepages_delay_total;
	__u64 thrashing_count;
	__u64 thrashing_delay_total;
	__u64 ac_btime64;
};

typedef struct {
	__u8 b[16];
} guid_t;

struct wait_page_queue {
	struct page *page;
	int bit_nr;
	wait_queue_entry_t wait;
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
	struct bdi_writeback *wb;
	struct inode *inode;
	int wb_id;
	int wb_lcand_id;
	int wb_tcand_id;
	size_t wb_bytes;
	size_t wb_lcand_bytes;
	size_t wb_tcand_bytes;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
};

struct iovec;

struct kvec;

struct bio_vec;

struct iov_iter {
	unsigned int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct pipe_inode_info *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
	};
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int *cluster_next_cpu;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct hd_struct;

struct gendisk;

struct block_device {
	dev_t bd_dev;
	int bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	struct mutex bd_mutex;
	void *bd_claiming;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct list_head bd_holder_disks;
	struct block_device *bd_contains;
	u8 bd_partno;
	struct hd_struct *bd_part;
	unsigned int bd_part_count;
	spinlock_t bd_size_lock;
	struct gendisk *bd_disk;
	struct backing_dev_info *bd_bdi;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
};

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bio {
	struct bio *bi_next;
	struct gendisk *bi_disk;
	unsigned int bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	short unsigned int bi_write_hint;
	blk_status_t bi_status;
	u8 bi_partno;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	union {	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	loff_t written;
	loff_t pos;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head needs_suppliers;
	struct list_head defer_hook;
	bool need_for_probe;
	enum dl_dev_state status;
};

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct dev_archdata {};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct dma_map_ops;

struct bus_dma_region;

struct device_dma_parameters;

struct cma;

struct device_node;

struct class;

struct iommu_group;

struct dev_iommu;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct irq_domain *msi_domain;
	struct list_head msi_list;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct cma *cma_area;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
};

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	struct list_head clock_list;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_INTR_REMAP = 1,
	IOMMU_CAP_NOEXEC = 2,
};

enum iommu_attr {
	DOMAIN_ATTR_GEOMETRY = 0,
	DOMAIN_ATTR_PAGING = 1,
	DOMAIN_ATTR_WINDOWS = 2,
	DOMAIN_ATTR_FSL_PAMU_STASH = 3,
	DOMAIN_ATTR_FSL_PAMU_ENABLE = 4,
	DOMAIN_ATTR_FSL_PAMUV1 = 5,
	DOMAIN_ATTR_NESTING = 6,
	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE = 7,
	DOMAIN_ATTR_MAX = 8,
};

enum iommu_dev_features {
	IOMMU_DEV_FEAT_AUX = 0,
	IOMMU_DEV_FEAT_SVA = 1,
};

struct iommu_domain;

struct iommu_iotlb_gather;

struct iommu_device;

struct iommu_resv_region;

struct of_phandle_args;

struct iommu_sva;

struct iommu_fault_event;

struct iommu_page_response;

struct iommu_cache_invalidate_info;

struct iommu_gpasid_bind_data;

struct iommu_ops {
	bool (*capable)(enum iommu_cap);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	void (*domain_free)(struct iommu_domain *);
	int (*attach_dev)(struct iommu_domain *, struct device *);
	void (*detach_dev)(struct iommu_domain *, struct device *);
	int (*map)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	size_t (*unmap)(struct iommu_domain *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	void (*iotlb_sync_map)(struct iommu_domain *);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	int (*domain_get_attr)(struct iommu_domain *, enum iommu_attr, void *);
	int (*domain_set_attr)(struct iommu_domain *, enum iommu_attr, void *);
	void (*get_resv_regions)(struct device *, struct list_head *);
	void (*put_resv_regions)(struct device *, struct list_head *);
	void (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *);
	int (*domain_window_enable)(struct iommu_domain *, u32, phys_addr_t, u64, int);
	void (*domain_window_disable)(struct iommu_domain *, u32);
	int (*of_xlate)(struct device *, struct of_phandle_args *);
	bool (*is_attach_deferred)(struct iommu_domain *, struct device *);
	bool (*dev_has_feat)(struct device *, enum iommu_dev_features);
	bool (*dev_feat_enabled)(struct device *, enum iommu_dev_features);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	int (*aux_attach_dev)(struct iommu_domain *, struct device *);
	void (*aux_detach_dev)(struct iommu_domain *, struct device *);
	int (*aux_get_pasid)(struct iommu_domain *, struct device *);
	struct iommu_sva * (*sva_bind)(struct device *, struct mm_struct *, void *);
	void (*sva_unbind)(struct iommu_sva *);
	u32 (*sva_get_pasid)(struct iommu_sva *);
	int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);
	int (*cache_invalidate)(struct iommu_domain *, struct device *, struct iommu_cache_invalidate_info *);
	int (*sva_bind_gpasid)(struct iommu_domain *, struct device *, struct iommu_gpasid_bind_data *);
	int (*sva_unbind_gpasid)(struct device *, u32);
	int (*def_domain_type)(struct device *);
	long unsigned int pgsize_bitmap;
	struct module *owner;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[9];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	long unsigned int segment_boundary_mask;
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	void * (*alloc_noncoherent)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_noncoherent)(struct device *, size_t, void *, dma_addr_t, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	long unsigned int _flags;
	void *data;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_VMSTAT_DEAD = 14,
	CPUHP_SOFTIRQ_DEAD = 15,
	CPUHP_NET_MVNETA_DEAD = 16,
	CPUHP_CPUIDLE_DEAD = 17,
	CPUHP_ARM64_FPSIMD_DEAD = 18,
	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
	CPUHP_IRQ_POLL_DEAD = 20,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
	CPUHP_ACPI_CPUDRV_DEAD = 22,
	CPUHP_S390_PFAULT_DEAD = 23,
	CPUHP_BLK_MQ_DEAD = 24,
	CPUHP_FS_BUFF_DEAD = 25,
	CPUHP_PRINTK_DEAD = 26,
	CPUHP_MM_MEMCQ_DEAD = 27,
	CPUHP_PERCPU_CNT_DEAD = 28,
	CPUHP_RADIX_DEAD = 29,
	CPUHP_PAGE_ALLOC_DEAD = 30,
	CPUHP_NET_DEV_DEAD = 31,
	CPUHP_PCI_XGENE_DEAD = 32,
	CPUHP_IOMMU_INTEL_DEAD = 33,
	CPUHP_LUSTRE_CFS_DEAD = 34,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
	CPUHP_PADATA_DEAD = 36,
	CPUHP_WORKQUEUE_PREP = 37,
	CPUHP_POWER_NUMA_PREPARE = 38,
	CPUHP_HRTIMERS_PREPARE = 39,
	CPUHP_PROFILE_PREPARE = 40,
	CPUHP_X2APIC_PREPARE = 41,
	CPUHP_SMPCFD_PREPARE = 42,
	CPUHP_RELAY_PREPARE = 43,
	CPUHP_SLAB_PREPARE = 44,
	CPUHP_MD_RAID5_PREPARE = 45,
	CPUHP_RCUTREE_PREP = 46,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
	CPUHP_POWERPC_PMAC_PREPARE = 48,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
	CPUHP_XEN_PREPARE = 50,
	CPUHP_XEN_EVTCHN_PREPARE = 51,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
	CPUHP_SH_SH3X_PREPARE = 53,
	CPUHP_NET_FLOW_PREPARE = 54,
	CPUHP_TOPOLOGY_PREPARE = 55,
	CPUHP_NET_IUCV_PREPARE = 56,
	CPUHP_ARM_BL_PREPARE = 57,
	CPUHP_TRACE_RB_PREPARE = 58,
	CPUHP_MM_ZS_PREPARE = 59,
	CPUHP_MM_ZSWP_MEM_PREPARE = 60,
	CPUHP_MM_ZSWP_POOL_PREPARE = 61,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 62,
	CPUHP_ZCOMP_PREPARE = 63,
	CPUHP_TIMERS_PREPARE = 64,
	CPUHP_MIPS_SOC_PREPARE = 65,
	CPUHP_BP_PREPARE_DYN = 66,
	CPUHP_BP_PREPARE_DYN_END = 86,
	CPUHP_BRINGUP_CPU = 87,
	CPUHP_AP_IDLE_DEAD = 88,
	CPUHP_AP_OFFLINE = 89,
	CPUHP_AP_SCHED_STARTING = 90,
	CPUHP_AP_RCUTREE_DYING = 91,
	CPUHP_AP_CPU_PM_STARTING = 92,
	CPUHP_AP_IRQ_GIC_STARTING = 93,
	CPUHP_AP_IRQ_HIP04_STARTING = 94,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 95,
	CPUHP_AP_IRQ_BCM2836_STARTING = 96,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 97,
	CPUHP_AP_IRQ_RISCV_STARTING = 98,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 99,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 100,
	CPUHP_AP_MICROCODE_LOADER = 101,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 102,
	CPUHP_AP_PERF_X86_STARTING = 103,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 104,
	CPUHP_AP_PERF_X86_CQM_STARTING = 105,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 106,
	CPUHP_AP_PERF_XTENSA_STARTING = 107,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 108,
	CPUHP_AP_ARM_SDEI_STARTING = 109,
	CPUHP_AP_ARM_VFP_STARTING = 110,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 111,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 112,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 113,
	CPUHP_AP_PERF_ARM_STARTING = 114,
	CPUHP_AP_ARM_L2X0_STARTING = 115,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 116,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 117,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 118,
	CPUHP_AP_JCORE_TIMER_STARTING = 119,
	CPUHP_AP_ARM_TWD_STARTING = 120,
	CPUHP_AP_QCOM_TIMER_STARTING = 121,
	CPUHP_AP_TEGRA_TIMER_STARTING = 122,
	CPUHP_AP_ARMADA_TIMER_STARTING = 123,
	CPUHP_AP_MARCO_TIMER_STARTING = 124,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 125,
	CPUHP_AP_ARC_TIMER_STARTING = 126,
	CPUHP_AP_RISCV_TIMER_STARTING = 127,
	CPUHP_AP_CLINT_TIMER_STARTING = 128,
	CPUHP_AP_CSKY_TIMER_STARTING = 129,
	CPUHP_AP_HYPERV_TIMER_STARTING = 130,
	CPUHP_AP_KVM_STARTING = 131,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 132,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 133,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 134,
	CPUHP_AP_DUMMY_TIMER_STARTING = 135,
	CPUHP_AP_ARM_XEN_STARTING = 136,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 137,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 138,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 139,
	CPUHP_AP_SMPCFD_DYING = 140,
	CPUHP_AP_X86_TBOOT_DYING = 141,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 142,
	CPUHP_AP_ONLINE = 143,
	CPUHP_TEARDOWN_CPU = 144,
	CPUHP_AP_ONLINE_IDLE = 145,
	CPUHP_AP_SMPBOOT_THREADS = 146,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 147,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 148,
	CPUHP_AP_BLK_MQ_ONLINE = 149,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 150,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 151,
	CPUHP_AP_PERF_ONLINE = 152,
	CPUHP_AP_PERF_X86_ONLINE = 153,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 154,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 155,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 156,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 157,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 158,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 159,
	CPUHP_AP_PERF_S390_CF_ONLINE = 160,
	CPUHP_AP_PERF_S390_SF_ONLINE = 161,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 162,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 163,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 164,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 165,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 166,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 167,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 168,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 169,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 170,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 171,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 172,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 173,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 174,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 175,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 176,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 177,
	CPUHP_AP_WATCHDOG_ONLINE = 178,
	CPUHP_AP_WORKQUEUE_ONLINE = 179,
	CPUHP_AP_RCUTREE_ONLINE = 180,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 181,
	CPUHP_AP_ONLINE_DYN = 182,
	CPUHP_AP_ONLINE_DYN_END = 212,
	CPUHP_AP_X86_HPET_ONLINE = 213,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 214,
	CPUHP_AP_ACTIVE = 215,
	CPUHP_ONLINE = 216,
};

struct static_call_mod {
	struct static_call_mod *next;
	struct module *mod;
	struct static_call_site *sites;
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	loff_t readpos;
};

struct trace_seq {
	unsigned char buffer[4096];
	struct seq_buf seq;
	int full;
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_MAX = 11,
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_rsvd: 24;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 reserved: 40;
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct kref kref;
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct cgroup_namespace {
	refcount_t count;
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	int count;
	atomic_t ucount[10];
};

struct perf_cpu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct u64_stats_sync {};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RECLAIM = 1,
	KMALLOC_DMA = 2,
	NR_KMALLOC_TYPES = 3,
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	struct bpf_cgroup_storage *cgroup_storage[2];
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct psi_group_cpu {
	seqcount_t seq;
	unsigned int tasks[4];
	u32 state_mask;
	u32 times[6];
	u64 state_start;
	long: 64;
	u32 times_prev[12];
	long: 64;
	long: 64;
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	bool broken_hierarchy: 1;
	bool warned_broken_hierarchy: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup cgrp;
	u64 cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct perf_cgroup *cgrp;
	struct list_head cgrp_cpuctx_entry;
	int sched_cb_usage;
	int online;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 addr;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 period;
	u64 weight;
	u64 txn;
	union perf_mem_data_src data_src;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	u64 aux_size;
	struct perf_regs regs_user;
	struct pt_regs regs_user_copy;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	u64 cgroup;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info *info;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_buffer;

struct trace_event_file;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	long unsigned int flags;
	int pc;
	struct pt_regs *regs;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_PTR_STRING = 3,
	FILTER_TRACE_FN = 4,
	FILTER_COMM = 5,
	FILTER_CPU = 6,
};

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	int (*add_links)(const struct fwnode_handle *, struct device *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_data;

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct disk_stats;

struct partition_meta_info;

struct hd_struct {
	sector_t start_sect;
	sector_t nr_sects;
	long unsigned int stamp;
	struct disk_stats *dkstats;
	struct percpu_ref ref;
	struct device __dev;
	struct kobject *holder_dir;
	int policy;
	int partno;
	struct partition_meta_info *info;
	struct rcu_work rcu_work;
};

struct disk_part_tbl;

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct cdrom_device_info;

struct badblocks;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct disk_part_tbl *part_tbl;
	struct hd_struct part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	int flags;
	long unsigned int state;
	struct rw_semaphore lookup_sem;
	struct kobject *slave_dir;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	struct cdrom_device_info *cdi;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
};

struct blkg_iostat {
	u64 bytes[3];
	u64 ios[3];
};

struct blkg_iostat_set {
	struct u64_stats_sync sync;
	struct blkg_iostat cur;
	struct blkg_iostat last;
};

struct blkcg;

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_iostat_set *iostat_cpu;
	struct blkg_iostat_set iostat;
	struct blkg_policy_data *pd[5];
	spinlock_t async_bio_lock;
	struct bio_list async_bios;
	struct work_struct async_bio_work;
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

typedef unsigned int blk_qc_t;

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct disk_part_tbl {
	struct callback_head callback_head;
	int len;
	struct hd_struct *last_lookup;
	struct hd_struct *part[0];
};

struct blk_zone;

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	blk_qc_t (*submit_bio)(struct bio *);
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*revalidate_disk)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	struct module *owner;
	const struct pr_ops *pr_ops;
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct bsg_ops {
	int (*check_proto)(struct sg_io_v4 *);
	int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t);
	int (*complete_rq)(struct request *, struct sg_io_v4 *);
	void (*free_rq)(struct request *);
};

typedef __u32 req_flags_t;

typedef void rq_end_io_fn(struct request *, blk_status_t);

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	unsigned int cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	struct list_head queuelist;
	union {
		struct hlist_node hash;
		struct list_head ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
		int error_count;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	struct gendisk *rq_disk;
	struct hd_struct *part;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int write_hint;
	short unsigned int ioprio;
	enum mq_rq_state state;
	refcount_t ref;
	unsigned int timeout;
	long unsigned int deadline;
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct elevator_type;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct blk_mq_hw_ctx *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct blk_mq_debugfs_attr;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	bool (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *);
	enum blk_eh_timer_return (*timeout)(struct request *, bool);
	int (*poll)(struct blk_mq_hw_ctx *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*initialize_rq_fn)(struct request *);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	int (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

enum blkg_iostat_type {
	BLKG_IOSTAT_READ = 0,
	BLKG_IOSTAT_WRITE = 1,
	BLKG_IOSTAT_DISCARD = 2,
	BLKG_IOSTAT_NR = 3,
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	refcount_t online_pin;
	struct xarray blkg_tree;
	struct blkcg_gq *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[5];
	struct list_head all_blkcgs_node;
	struct list_head cgwb_list;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
};

typedef long unsigned int efi_status_t;

typedef u8 efi_bool_t;

typedef u16 efi_char16_t;

typedef guid_t efi_guid_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_status_t (*get_time)(efi_time_t *, efi_time_cap_t *);
		efi_status_t (*set_time)(efi_time_t *);
		efi_status_t (*get_wakeup_time)(efi_bool_t *, efi_bool_t *, efi_time_t *);
		efi_status_t (*set_wakeup_time)(efi_bool_t, efi_time_t *);
		efi_status_t (*set_virtual_address_map)(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);
		void *convert_pointer;
		efi_status_t (*get_variable)(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);
		efi_status_t (*get_next_variable)(long unsigned int *, efi_char16_t *, efi_guid_t *);
		efi_status_t (*set_variable)(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);
		efi_status_t (*get_next_high_mono_count)(u32 *);
		void (*reset_system)(int, efi_status_t, long unsigned int, efi_char16_t *);
		efi_status_t (*update_capsule)(efi_capsule_header_t **, long unsigned int, long unsigned int);
		efi_status_t (*query_capsule_caps)(efi_capsule_header_t **, long unsigned int, u64 *, int *);
		efi_status_t (*query_variable_info)(u32, u64 *, u64 *, u64 *);
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int esrt;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mokvar_table;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

enum memcg_stat_item {
	MEMCG_SWAP = 37,
	MEMCG_SOCK = 38,
	MEMCG_PERCPU_B = 39,
	MEMCG_NR_STAT = 40,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_SWAP_HIGH = 5,
	MEMCG_SWAP_MAX = 6,
	MEMCG_SWAP_FAIL = 7,
	MEMCG_NR_MEMORY_EVENTS = 8,
};

enum mem_cgroup_events_target {
	MEM_CGROUP_TARGET_THRESH = 0,
	MEM_CGROUP_TARGET_SOFTLIMIT = 1,
	MEM_CGROUP_NTARGETS = 2,
};

struct memcg_vmstats_percpu {
	long int stat[40];
	long unsigned int events[96];
	long unsigned int nr_page_events;
	long unsigned int targets[2];
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	unsigned int generation;
};

struct lruvec_stat {
	long int count[37];
};

struct memcg_shrinker_map {
	struct callback_head rcu;
	long unsigned int map[0];
};

struct mem_cgroup_per_node {
	struct lruvec lruvec;
	struct lruvec_stat *lruvec_stat_local;
	struct lruvec_stat *lruvec_stat_cpu;
	atomic_long_t lruvec_stat[37];
	long unsigned int lru_zone_size[20];
	struct mem_cgroup_reclaim_iter iter;
	struct memcg_shrinker_map *shrinker_map;
	struct rb_node tree_node;
	long unsigned int usage_in_excess;
	bool on_tree;
	struct mem_cgroup *memcg;
};

struct eventfd_ctx;

struct mem_cgroup_threshold {
	struct eventfd_ctx *eventfd;
	long unsigned int threshold;
};

struct mem_cgroup_threshold_ary {
	int current_threshold;
	unsigned int size;
	struct mem_cgroup_threshold entries[0];
};

struct obj_cgroup {
	struct percpu_ref refcnt;
	struct mem_cgroup *memcg;
	atomic_t nr_charged_bytes;
	union {
		struct list_head list;
		struct callback_head rcu;
	};
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

typedef __u32 Elf32_Word;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

typedef __u16 __le16;

typedef __u16 __be16;

typedef __u32 __be32;

typedef __u64 __be64;

typedef __u32 __wsum;

typedef unsigned int slab_flags_t;

struct llist_head {
	struct llist_node *first;
};

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {
	struct net *net;
} possible_net_t;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sk_buff;

struct sk_buff_head {
	struct sk_buff *next;
	struct sk_buff *prev;
	__u32 qlen;
	spinlock_t lock;
};

typedef u64 netdev_features_t;

struct sock_cgroup_data {
	union {
		struct {
			u8 is_data: 1;
			u8 no_refcnt: 1;
			u8 unused: 6;
			u8 padding;
			u16 prioidx;
			u32 classid;
		};
		u64 val;
	};
};

struct sk_filter;

struct socket_wq;

struct xfrm_policy;

struct dst_entry;

struct socket;

struct sock_reuseport;

struct bpf_local_storage;

struct sock {
	struct sock_common __sk_common;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff *sk_rx_skb_cache;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct xfrm_policy *sk_policy[2];
	struct dst_entry *sk_rx_dst;
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff *sk_tx_skb_cache;
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	netdev_features_t sk_route_nocaps;
	netdev_features_t sk_route_forced_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_padding: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	u8 sk_prefer_busy_poll;
	u16 sk_busy_poll_budget;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	u16 sk_tsflags;
	u8 sk_shutdown;
	u32 sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	void *sk_security;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
};

struct rhash_head {
	struct rhash_head *next;
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

typedef short unsigned int __kernel_sa_family_t;

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct msghdr {
	void *msg_name;
	int msg_namelen;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
	struct kiocb *msg_iocb;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct tty_driver;

struct tty_operations;

struct tty_ldisc;

struct termiox;

struct tty_port;

struct tty_struct {
	int magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	spinlock_t ctrl_lock;
	spinlock_t flow_lock;
	struct ktermios termios;
	struct ktermios termios_locked;
	struct termiox *termiox;
	char name[64];
	struct pid *pgrp;
	struct pid *session;
	long unsigned int flags;
	int count;
	struct winsize winsize;
	long unsigned int stopped: 1;
	long unsigned int flow_stopped: 1;
	int: 30;
	long unsigned int unused: 62;
	int hw_stopped;
	long unsigned int ctrl_status: 8;
	long unsigned int packet: 1;
	int: 23;
	long unsigned int unused_ctrl: 55;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

struct termiox {
	__u16 x_hflag;
	__u16 x_cflag;
	__u16 x_rflag[5];
	__u16 x_sflag;
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	int (*write_room)(struct tty_struct *);
	int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*set_termiox)(struct tty_struct *, struct termiox *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct proc_dir_entry;

struct tty_driver {
	int magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	unsigned char low_latency: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_ldisc_ops {
	int magic;
	char *name;
	int num;
	int flags;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	int (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, char *, int);
	struct module *owner;
	int refcount;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int *sock_inuse;
	struct prot_inuse *prot_inuse;
};

struct tcp_mib;

struct ipstats_mib;

struct linux_mib;

struct udp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct linux_tls_mib;

struct netns_mib {
	struct tcp_mib *tcp_statistics;
	struct ipstats_mib *ip_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udplite_statistics;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
	struct udp_mib *udp_stats_in6;
	struct udp_mib *udplite_stats_in6;
	struct ipstats_mib *ipv6_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct linux_tls_mib *tls_statistics;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_unix {
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	atomic_t tw_count;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct ipv4_devconf;

struct ip_ra_chain;

struct fib_rules_ops;

struct fib_table;

struct inet_peer_base;

struct fqdir;

struct xt_table;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct mr_table;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	bool fib_has_custom_rules;
	unsigned int fib_rules_require_fldissect;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	bool fib_has_custom_local_routes;
	int fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	bool fib_offload_disabled;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct sock **tcp_sk;
	struct fqdir *fqdir;
	struct xt_table *iptable_filter;
	struct xt_table *iptable_mangle;
	struct xt_table *iptable_raw;
	struct xt_table *arptable_filter;
	struct xt_table *iptable_security;
	struct xt_table *nat_table;
	int sysctl_icmp_echo_ignore_all;
	int sysctl_icmp_echo_ignore_broadcasts;
	int sysctl_icmp_ignore_bogus_error_responses;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_errors_use_inbound_ifaddr;
	struct local_ports ip_local_ports;
	int sysctl_tcp_ecn;
	int sysctl_tcp_ecn_fallback;
	int sysctl_ip_default_ttl;
	int sysctl_ip_no_pmtu_disc;
	int sysctl_ip_fwd_use_pmtu;
	int sysctl_ip_fwd_update_priority;
	int sysctl_ip_nonlocal_bind;
	int sysctl_ip_autobind_reuse;
	int sysctl_ip_dynaddr;
	int sysctl_ip_early_demux;
	int sysctl_tcp_early_demux;
	int sysctl_udp_early_demux;
	int sysctl_nexthop_compat_mode;
	int sysctl_fwmark_reflect;
	int sysctl_tcp_fwmark_accept;
	int sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_probes;
	int sysctl_tcp_keepalive_intvl;
	int sysctl_tcp_syn_retries;
	int sysctl_tcp_synack_retries;
	int sysctl_tcp_syncookies;
	int sysctl_tcp_reordering;
	int sysctl_tcp_retries1;
	int sysctl_tcp_retries2;
	int sysctl_tcp_orphan_retries;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_tw_reuse;
	int sysctl_tcp_sack;
	int sysctl_tcp_window_scaling;
	int sysctl_tcp_timestamps;
	int sysctl_tcp_early_retrans;
	int sysctl_tcp_recovery;
	int sysctl_tcp_thin_linear_timeouts;
	int sysctl_tcp_slow_start_after_idle;
	int sysctl_tcp_retrans_collapse;
	int sysctl_tcp_stdurg;
	int sysctl_tcp_rfc1337;
	int sysctl_tcp_abort_on_overflow;
	int sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_dsack;
	int sysctl_tcp_app_win;
	int sysctl_tcp_adv_win_scale;
	int sysctl_tcp_frto;
	int sysctl_tcp_nometrics_save;
	int sysctl_tcp_no_ssthresh_metrics_save;
	int sysctl_tcp_moderate_rcvbuf;
	int sysctl_tcp_tso_win_divisor;
	int sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_tso_segs;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_autocorking;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	int sysctl_tcp_comp_sack_nr;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_timewait_death_row tcp_death_row;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	spinlock_t tcp_fastopen_ctx_lock;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_tcp_reflect_tos;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_llm_reports;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct mr_table *mrt;
	int sysctl_fib_multipath_use_neigh;
	int sysctl_fib_multipath_hash_policy;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int bindv6only;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	int multipath_hash_policy;
	int flowlabel_consistency;
	int auto_flowlabels;
	int icmpv6_time;
	int icmpv6_echo_ignore_all;
	int icmpv6_echo_ignore_multicast;
	int icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	int anycast_src_echo_reply;
	int ip_nonlocal_bind;
	int fwmark_reflect;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_state_ranges;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	bool skip_notify_on_dev_down;
};

struct net_device;

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct xt_table *ip6table_filter;
	struct xt_table *ip6table_mangle;
	struct xt_table *ip6table_raw;
	struct xt_table *ip6table_security;
	struct xt_table *ip6table_nat;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	long: 64;
	long: 64;
	struct dst_ops ip6_dst_ops;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	unsigned int ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned int fib6_rules_require_fldissect;
	bool fib6_has_custom_rules;
	unsigned int fib6_routes_require_src;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	long: 64;
	long: 64;
	long: 64;
};

struct sctp_mib;

struct netns_sctp {
	struct sctp_mib *sctp_statistics;
	struct proc_dir_entry *proc_net_sctp;
	struct ctl_table_header *sysctl_header;
	struct sock *ctl_sock;
	struct sock *udp4_sock;
	struct sock *udp6_sock;
	int udp_port;
	int encap_port;
	struct list_head local_addr_list;
	struct list_head addr_waitq;
	struct timer_list addr_wq_timer;
	struct list_head auto_asconf_splist;
	spinlock_t addr_wq_lock;
	spinlock_t local_addr_lock;
	unsigned int rto_initial;
	unsigned int rto_min;
	unsigned int rto_max;
	int rto_alpha;
	int rto_beta;
	int max_burst;
	int cookie_preserve_enable;
	char *sctp_hmac_alg;
	unsigned int valid_cookie_life;
	unsigned int sack_timeout;
	unsigned int hb_interval;
	int max_retrans_association;
	int max_retrans_path;
	int max_retrans_init;
	int pf_retrans;
	int ps_retrans;
	int pf_enable;
	int pf_expose;
	int sndbuf_policy;
	int rcvbuf_policy;
	int default_auto_asconf;
	int addip_enable;
	int addip_noauth;
	int prsctp_enable;
	int reconf_enable;
	int auth_enable;
	int intl_enable;
	int ecn_enable;
	int scope_policy;
	int rwnd_upd_shift;
	long unsigned int max_autoclose;
};

struct netns_dccp {
	struct sock *v4_ctl_sk;
	struct sock *v6_ctl_sk;
};

struct nf_queue_handler;

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_queue_handler *queue_handler;
	const struct nf_logger *nf_loggers[13];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	struct nf_hook_entries *hooks_arp[3];
	struct nf_hook_entries *hooks_bridge[5];
	struct nf_hook_entries *hooks_decnet[7];
	bool defrag_ipv6;
};

struct ebt_table;

struct netns_xt {
	struct list_head tables[13];
	bool notrack_deprecated_warning;
	bool clusterip_deprecated_warning;
	struct ebt_table *broute_table;
	struct ebt_table *frame_filter;
	struct ebt_table *frame_nat;
};

struct netns_nf_frag {
	struct fqdir *fqdir;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct xfrm_policy_hash {
	struct hlist_head *table;
	unsigned int hmask;
	u8 dbits4;
	u8 sbits4;
	u8 dbits6;
	u8 sbits6;
};

struct xfrm_policy_hthresh {
	struct work_struct work;
	seqlock_t lock;
	u8 lbits4;
	u8 rbits4;
	u8 lbits6;
	u8 rbits6;
};

struct netns_xfrm {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	struct hlist_head policy_inexact[3];
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	struct ctl_table_header *sysctl_hdr;
	long: 64;
	long: 64;
	struct dst_ops xfrm4_dst_ops;
	struct dst_ops xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	long: 64;
	long: 64;
};

struct netns_ipvs;

struct mpls_route;

struct netns_mpls {
	int ip_ttl_propagate;
	int default_ttl;
	size_t platform_labels;
	struct mpls_route **platform_label;
	struct ctl_table_header *ctl;
};

struct netns_xdp {
	struct mutex lock;
	struct hlist_head list;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	refcount_t count;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_sctp sctp;
	struct netns_dccp dccp;
	struct netns_nf nf;
	struct netns_xt xt;
	struct netns_nf_frag nf_frag;
	struct ctl_table_header *nf_frag_frags_hdr;
	struct sock *nfnl;
	struct sock *nfnl_stash;
	struct net_generic *gen;
	struct netns_bpf bpf;
	struct netns_xfrm xfrm;
	atomic64_t net_cookie;
	struct netns_ipvs *ipvs;
	struct netns_mpls mpls;
	struct netns_xdp xdp;
	struct sock *diag_nlsk;
};

typedef struct {
	local64_t v;
} u64_stats_t;

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	__MAX_BPF_ATTACH_TYPE = 38,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
		};
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct btf_type;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	struct mem_cgroup *memcg;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	u64 writecnt;
	long: 64;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[56];
	bool kernel_btf;
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[128];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_prog_ops;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_stats;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	enum bpf_tramp_prog_type trampoline_prog_type;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	void *security;
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	struct bpf_prog_stats *stats;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct sock_filter insns[0];
	struct bpf_insn insnsi[0];
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

struct net_device_stats {
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	long unsigned int rx_errors;
	long unsigned int tx_errors;
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int multicast;
	long unsigned int collisions;
	long unsigned int rx_length_errors;
	long unsigned int rx_over_errors;
	long unsigned int rx_crc_errors;
	long unsigned int rx_frame_errors;
	long unsigned int rx_fifo_errors;
	long unsigned int rx_missed_errors;
	long unsigned int tx_aborted_errors;
	long unsigned int tx_carrier_errors;
	long unsigned int tx_fifo_errors;
	long unsigned int tx_heartbeat_errors;
	long unsigned int tx_window_errors;
	long unsigned int rx_compressed;
	long unsigned int tx_compressed;
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
};

struct tipc_bearer;

struct dn_dev;

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

struct pcpu_dstats;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct ethtool_ops;

struct ndisc_ops;

struct header_ops;

struct vlan_info;

struct in_device;

struct inet6_dev;

struct wireless_dev;

struct wpan_dev;

struct netdev_rx_queue;

struct mini_Qdisc;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct netpoll_info;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct rtnl_link_ops;

struct dcbnl_rtnl_ops;

struct phy_device;

struct udp_tunnel_nic_info;

struct udp_tunnel_nic;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	int irq;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	int ifindex;
	int group;
	struct net_device_stats stats;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct net_device_ops *netdev_ops;
	const struct ethtool_ops *ethtool_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct header_ops *header_ops;
	unsigned int flags;
	unsigned int priv_flags;
	short unsigned int gflags;
	short unsigned int padded;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned int mtu;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	short unsigned int hard_header_len;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	spinlock_t addr_list_lock;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct vlan_info *vlan_info;
	struct tipc_bearer *tipc_ptr;
	void *atalk_ptr;
	struct in_device *ip_ptr;
	struct dn_dev *dn_ptr;
	struct inet6_dev *ip6_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	int napi_defer_hard_irqs;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct mini_Qdisc *miniq_ingress;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct xps_dev_maps *xps_cpus_map;
	struct xps_dev_maps *xps_rxqs_map;
	struct mini_Qdisc *miniq_egress;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	struct netpoll_info *npinfo;
	possible_net_t nd_net;
	union {
		void *ml_priv;
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	const struct dcbnl_rtnl_ops *dcbnl_ops;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	struct lock_class_key *qdisc_running_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
	long: 64;
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_VALUE_OR_NULL = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCKET_OR_NULL = 12,
	PTR_TO_SOCK_COMMON = 13,
	PTR_TO_SOCK_COMMON_OR_NULL = 14,
	PTR_TO_TCP_SOCK = 15,
	PTR_TO_TCP_SOCK_OR_NULL = 16,
	PTR_TO_TP_BUFFER = 17,
	PTR_TO_XDP_SOCK = 18,
	PTR_TO_BTF_ID = 19,
	PTR_TO_BTF_ID_OR_NULL = 20,
	PTR_TO_MEM = 21,
	PTR_TO_MEM_OR_NULL = 22,
	PTR_TO_RDONLY_BUF = 23,
	PTR_TO_RDONLY_BUF_OR_NULL = 24,
	PTR_TO_RDWR_BUF = 25,
	PTR_TO_RDWR_BUF_OR_NULL = 26,
	PTR_TO_PERCPU_BTF_ID = 27,
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_prog_stats {
	u64 cnt;
	u64 nsecs;
	struct u64_stats_sync syncp;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
};

struct bpf_trampoline {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	void *image;
	u64 selector;
	struct bpf_ksym ksym;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

typedef unsigned int sk_buff_data_t;

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
	};
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 active_extensions;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 ndisc_nodetype: 2;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	__u8 tc_skip_classify: 1;
	__u8 tc_at_ingress: 1;
	__u8 redirected: 1;
	__u8 from_ingress: 1;
	__u16 tc_index;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	__u32 secmark;
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	struct {
		__le16 dport;
		__le16 sport;
	} dnports;
	__be32 spi;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowidn {
	struct flowi_common __fl_common;
	__le16 daddr;
	__le16 saddr;
	union flowi_uli uli;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
		struct flowidn dn;
	} u;
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct linux_mib {
	long unsigned int mibs[124];
};

struct linux_tls_mib {
	long unsigned int mibs[11];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 56;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	atomic_long_t mem;
	struct work_struct destroy_work;
	long: 64;
	long: 64;
	long: 64;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

struct fib_rule;

struct fib_lookup_arg;

struct fib_rule_hdr;

struct nlattr;

struct netlink_ext_ack;

struct nla_policy;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	const struct nla_policy *policy;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	u32 (*undo_cwnd)(struct sock *);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct xfrm_state;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	struct xfrm_state *xfrm;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	atomic_t __refcnt;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[12];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	__u8 flags;
	__u8 nud_state;
	__u8 type;
	__u8 dead;
	u8 protocol;
	seqlock_t ha_lock;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct callback_head rcu;
	struct net_device *dev;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_ra_rtr_pref;
	__s32 rtr_probe_interval;
	__s32 accept_ra_rt_info_min_plen;
	__s32 accept_ra_rt_info_max_plen;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	struct ctl_table_header *sysctl_header;
};

struct nf_queue_entry;

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

typedef u8 u_int8_t;

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct proto_ops {
	int family;
	unsigned int flags;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[2];
	u8 chunks;
	char: 8;
	char data[0];
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	long: 32;
	long: 64;
	long: 64;
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 reserved1[1];
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		u8 __link_ext_substate;
	};
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
};

struct ethtool_pause_stats {
	u64 tx_pause_frames;
	u64 rx_pause_frames;
};

struct ethtool_ops {
	u32 supported_coalesce_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	u8 cookie[20];
	u8 cookie_len;
};

struct ieee_ets {
	__u8 willing;
	__u8 ets_cap;
	__u8 cbs;
	__u8 tc_tx_bw[8];
	__u8 tc_rx_bw[8];
	__u8 tc_tsa[8];
	__u8 prio_tc[8];
	__u8 tc_reco_bw[8];
	__u8 tc_reco_tsa[8];
	__u8 reco_prio_tc[8];
};

struct ieee_maxrate {
	__u64 tc_maxrate[8];
};

struct ieee_qcn {
	__u8 rpg_enable[8];
	__u32 rppp_max_rps[8];
	__u32 rpg_time_reset[8];
	__u32 rpg_byte_reset[8];
	__u32 rpg_threshold[8];
	__u32 rpg_max_rate[8];
	__u32 rpg_ai_rate[8];
	__u32 rpg_hai_rate[8];
	__u32 rpg_gd[8];
	__u32 rpg_min_dec_fac[8];
	__u32 rpg_min_rate[8];
	__u32 cndd_state_machine[8];
};

struct ieee_qcn_stats {
	__u64 rppp_rp_centiseconds[8];
	__u32 rppp_created_rps[8];
};

struct ieee_pfc {
	__u8 pfc_cap;
	__u8 pfc_en;
	__u8 mbc;
	__u16 delay;
	__u64 requests[8];
	__u64 indications[8];
};

struct dcbnl_buffer {
	__u8 prio2buffer[8];
	__u32 buffer_size[8];
	__u32 total_size;
};

struct cee_pg {
	__u8 willing;
	__u8 error;
	__u8 pg_en;
	__u8 tcs_supported;
	__u8 pg_bw[8];
	__u8 prio_pg[8];
};

struct cee_pfc {
	__u8 willing;
	__u8 error;
	__u8 pfc_en;
	__u8 tcs_supported;
};

struct dcb_app {
	__u8 selector;
	__u8 priority;
	__u16 protocol;
};

struct dcb_peer_app_info {
	__u8 willing;
	__u8 error;
};

struct dcbnl_rtnl_ops {
	int (*ieee_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_setets)(struct net_device *, struct ieee_ets *);
	int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *);
	int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_getapp)(struct net_device *, struct dcb_app *);
	int (*ieee_setapp)(struct net_device *, struct dcb_app *);
	int (*ieee_delapp)(struct net_device *, struct dcb_app *);
	int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *);
	u8 (*getstate)(struct net_device *);
	u8 (*setstate)(struct net_device *, u8);
	void (*getpermhwaddr)(struct net_device *, u8 *);
	void (*setpgtccfgtx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgtx)(struct net_device *, int, u8);
	void (*setpgtccfgrx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgrx)(struct net_device *, int, u8);
	void (*getpgtccfgtx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgtx)(struct net_device *, int, u8 *);
	void (*getpgtccfgrx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgrx)(struct net_device *, int, u8 *);
	void (*setpfccfg)(struct net_device *, int, u8);
	void (*getpfccfg)(struct net_device *, int, u8 *);
	u8 (*setall)(struct net_device *);
	u8 (*getcap)(struct net_device *, int, u8 *);
	int (*getnumtcs)(struct net_device *, int, u8 *);
	int (*setnumtcs)(struct net_device *, int, u8);
	u8 (*getpfcstate)(struct net_device *);
	void (*setpfcstate)(struct net_device *, u8);
	void (*getbcncfg)(struct net_device *, int, u32 *);
	void (*setbcncfg)(struct net_device *, int, u32);
	void (*getbcnrp)(struct net_device *, int, u8 *);
	void (*setbcnrp)(struct net_device *, int, u8);
	int (*setapp)(struct net_device *, u8, u16, u8);
	int (*getapp)(struct net_device *, u8, u16);
	u8 (*getfeatcfg)(struct net_device *, int, u8 *);
	u8 (*setfeatcfg)(struct net_device *, int, u8);
	u8 (*getdcbx)(struct net_device *);
	u8 (*setdcbx)(struct net_device *, u8);
	int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *);
	int (*peer_getapptable)(struct net_device *, struct dcb_app *);
	int (*cee_peer_getpg)(struct net_device *, struct cee_pg *);
	int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *);
	int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *);
	int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *);
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	unsigned int napi_id;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize: 8;
	u32 frame_sz: 24;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		struct netlink_range_validation *range;
		struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
		u16 strict_start_type;
	};
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct xsk_buff_pool;

struct netdev_queue {
	struct net_device *dev;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	int numa_node;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device *sb_dev;
	struct xsk_buff_pool *pool;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	long: 64;
	long: 64;
	struct dql dql;
};

struct net_rate_estimator;

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_packed {
	__u64 bytes;
	__u64 packets;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct gnet_stats_basic_cpu;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t busylock;
	spinlock_t seqlock;
	bool empty;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long int privdata[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct netdev_rx_queue {
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct xsk_buff_pool *pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	struct xps_map *attr_map[0];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum tc_setup_type {
	TC_SETUP_QDISC_MQPRIO = 0,
	TC_SETUP_CLSU32 = 1,
	TC_SETUP_CLSFLOWER = 2,
	TC_SETUP_CLSMATCHALL = 3,
	TC_SETUP_CLSBPF = 4,
	TC_SETUP_BLOCK = 5,
	TC_SETUP_QDISC_CBS = 6,
	TC_SETUP_QDISC_RED = 7,
	TC_SETUP_QDISC_PRIO = 8,
	TC_SETUP_QDISC_MQ = 9,
	TC_SETUP_QDISC_ETF = 10,
	TC_SETUP_ROOT_QDISC = 11,
	TC_SETUP_QDISC_GRED = 12,
	TC_SETUP_QDISC_TAPRIO = 13,
	TC_SETUP_FT = 14,
	TC_SETUP_QDISC_ETS = 15,
	TC_SETUP_QDISC_TBF = 16,
	TC_SETUP_QDISC_FIFO = 17,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct udp_tunnel_info;

struct devlink_port;

struct ip_tunnel_parm;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	void (*ndo_poll_controller)(struct net_device *);
	int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *);
	void (*ndo_netpoll_cleanup)(struct net_device *);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *);
	void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_change_proto_down)(struct net_device *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	int data[13];
	long unsigned int data_state[1];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	spinlock_t mc_lock;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct timer_list mc_gq_timer;
	struct timer_list mc_ifc_timer;
	struct timer_list mc_dad_timer;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
};

struct tcf_proto;

struct tcf_block;

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	void (*setup)(struct net_device *);
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_stats_basic_cpu {
	struct gnet_stats_basic_packed bstats;
	struct u64_stats_sync syncp;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, bool, bool, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_GC_STALETIME = 7,
	NEIGH_VAR_QUEUE_LEN_BYTES = 8,
	NEIGH_VAR_PROXY_QLEN = 9,
	NEIGH_VAR_ANYCAST_DELAY = 10,
	NEIGH_VAR_PROXY_DELAY = 11,
	NEIGH_VAR_LOCKTIME = 12,
	NEIGH_VAR_QUEUE_LEN = 13,
	NEIGH_VAR_RETRANS_TIME_MS = 14,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,
	NEIGH_VAR_GC_INTERVAL = 16,
	NEIGH_VAR_GC_THRESH1 = 17,
	NEIGH_VAR_GC_THRESH2 = 18,
	NEIGH_VAR_GC_THRESH3 = 19,
	NEIGH_VAR_MAX = 20,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	u8 flags;
	u8 protocol;
	u8 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct smc_hashinfo;

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*compat_ioctl)(struct sock *, unsigned int, long unsigned int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*stream_memory_read)(const struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	struct percpu_counter *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct timer_list mca_timer;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	spinlock_t mca_lock;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_opts_ri;
	struct nd_opt_hdr *nd_opts_ri_end;
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 18,
};

enum exception_stack_ordering {
	ESTACK_DF = 0,
	ESTACK_NMI = 1,
	ESTACK_DB = 2,
	ESTACK_MCE = 3,
	ESTACK_VC = 4,
	ESTACK_VC2 = 5,
	N_EXCEPTION_STACKS = 6,
};

enum {
	TSK_TRACE_FL_TRACE_BIT = 0,
	TSK_TRACE_FL_GRAPH_BIT = 1,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

typedef __u32 __le32;

typedef __u64 __le64;

struct minix_super_block {
	__u16 s_ninodes;
	__u16 s_nzones;
	__u16 s_imap_blocks;
	__u16 s_zmap_blocks;
	__u16 s_firstdatazone;
	__u16 s_log_zone_size;
	__u32 s_max_size;
	__u16 s_magic;
	__u16 s_state;
	__u32 s_zones;
};

struct romfs_super_block {
	__be32 word0;
	__be32 word1;
	__be32 size;
	__be32 checksum;
	char name[0];
};

struct cramfs_inode {
	__u32 mode: 16;
	__u32 uid: 16;
	__u32 size: 24;
	__u32 gid: 8;
	__u32 namelen: 6;
	__u32 offset: 26;
};

struct cramfs_info {
	__u32 crc;
	__u32 edition;
	__u32 blocks;
	__u32 files;
};

struct cramfs_super {
	__u32 magic;
	__u32 size;
	__u32 flags;
	__u32 future;
	__u8 signature[16];
	struct cramfs_info fsid;
	__u8 name[16];
	struct cramfs_inode root;
};

struct squashfs_super_block {
	__le32 s_magic;
	__le32 inodes;
	__le32 mkfs_time;
	__le32 block_size;
	__le32 fragments;
	__le16 compression;
	__le16 block_log;
	__le16 flags;
	__le16 no_ids;
	__le16 s_major;
	__le16 s_minor;
	__le64 root_inode;
	__le64 bytes_used;
	__le64 id_table_start;
	__le64 xattr_id_table_start;
	__le64 inode_table_start;
	__le64 directory_table_start;
	__le64 fragment_table_start;
	__le64 lookup_table_start;
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

typedef phys_addr_t resource_size_t;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	char *name;
	time64_t mtime;
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_COUNTS = 10,
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_MAX = 28,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	__LINUX_MIB_MAX = 124,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	__LINUX_MIB_TLSMAX = 11,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO = 13,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

enum skb_ext_id {
	SKB_EXT_BRIDGE_NF = 0,
	SKB_EXT_SEC_PATH = 1,
	SKB_EXT_NUM = 2,
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

typedef long int (*sys_call_ptr_t)(const struct pt_regs *);

struct io_bitmap {
	u64 sequence;
	refcount_t refcnt;
	unsigned int max;
	long unsigned int bitmap[1024];
};

enum {
	EI_ETYPE_NONE = 0,
	EI_ETYPE_NULL = 1,
	EI_ETYPE_ERRNO = 2,
	EI_ETYPE_ERRNO_NULL = 3,
	EI_ETYPE_TRUE = 4,
};

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

struct alt_instr {
	s32 instr_offset;
	s32 repl_offset;
	u16 cpuid;
	u8 instrlen;
	u8 replacementlen;
	u8 padlen;
} __attribute__((packed));

struct timens_offset {
	s64 sec;
	u64 nsec;
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_HINDEX_MASK = 983040,
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct kref kref;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct pvclock_vsyscall_time_info {
	struct pvclock_vcpu_time_info pvti;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_TSC = 1,
	VDSO_CLOCKMODE_PVCLOCK = 2,
	VDSO_CLOCKMODE_HVCLOCK = 3,
	VDSO_CLOCKMODE_MAX = 4,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct arch_vdso_data {};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

struct ms_hyperv_tsc_page {
	volatile u32 tsc_sequence;
	u32 reserved1;
	volatile u64 tsc_scale;
	volatile s64 tsc_offset;
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum psi_task_count {
	NR_IOWAIT = 0,
	NR_MEMSTALL = 1,
	NR_RUNNING = 2,
	NR_ONCPU = 3,
	NR_PSI_TASK_COUNTS = 4,
};

enum psi_states {
	PSI_IO_SOME = 0,
	PSI_IO_FULL = 1,
	PSI_MEM_SOME = 2,
	PSI_MEM_FULL = 3,
	PSI_CPU_SOME = 4,
	PSI_NONIDLE = 5,
	NR_PSI_STATES = 6,
};

enum psi_aggregators {
	PSI_AVGS = 0,
	PSI_POLL = 1,
	NR_PSI_AGGREGATORS = 2,
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	memory_cgrp_id = 4,
	devices_cgrp_id = 5,
	freezer_cgrp_id = 6,
	net_cls_cgrp_id = 7,
	perf_event_cgrp_id = 8,
	hugetlb_cgrp_id = 9,
	CGROUP_SUBSYS_COUNT = 10,
};

struct cpuinfo_x86 {
	__u8 x86;
	__u8 x86_vendor;
	__u8 x86_model;
	__u8 x86_stepping;
	int x86_tlbsize;
	__u32 vmx_capability[3];
	__u8 x86_virt_bits;
	__u8 x86_phys_bits;
	__u8 x86_coreid_bits;
	__u8 cu_id;
	__u32 extended_cpuid_level;
	int cpuid_level;
	union {
		__u32 x86_capability[20];
		long unsigned int x86_capability_alignment;
	};
	char x86_vendor_id[16];
	char x86_model_id[64];
	unsigned int x86_cache_size;
	int x86_cache_alignment;
	int x86_cache_max_rmid;
	int x86_cache_occ_scale;
	int x86_cache_mbm_width_offset;
	int x86_power;
	long unsigned int loops_per_jiffy;
	u16 x86_max_cores;
	u16 apicid;
	u16 initial_apicid;
	u16 x86_clflush_size;
	u16 booted_cores;
	u16 phys_proc_id;
	u16 logical_proc_id;
	u16 cpu_core_id;
	u16 cpu_die_id;
	u16 logical_die_id;
	u16 cpu_index;
	u32 microcode;
	u8 x86_cache_bits;
	unsigned int initialized: 1;
};

enum x86_pf_error_code {
	X86_PF_PROT = 1,
	X86_PF_WRITE = 2,
	X86_PF_USER = 4,
	X86_PF_RSVD = 8,
	X86_PF_INSTR = 16,
	X86_PF_PK = 32,
};

struct trace_event_raw_emulate_vsyscall {
	struct trace_entry ent;
	int nr;
	char __data[0];
};

struct trace_event_data_offsets_emulate_vsyscall {};

typedef void (*btf_trace_emulate_vsyscall)(void *, int);

enum {
	EMULATE = 0,
	XONLY = 1,
	NONE = 2,
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_MAX = 4194304,
	__PERF_SAMPLE_CALLCHAIN_EARLY = 0,
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_MAX = 262144,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct ldt_struct {
	struct desc_struct *entries;
	unsigned int nr_entries;
	int slot;
};

struct physid_mask {
	long unsigned int mask[512];
};

typedef struct physid_mask physid_mask_t;

struct x86_pmu_capability {
	int version;
	int num_counters_gp;
	int num_counters_fixed;
	int bit_width_gp;
	int bit_width_fixed;
	unsigned int events_mask;
	int events_mask_len;
};

struct debug_store {
	u64 bts_buffer_base;
	u64 bts_index;
	u64 bts_absolute_maximum;
	u64 bts_interrupt_threshold;
	u64 pebs_buffer_base;
	u64 pebs_index;
	u64 pebs_absolute_maximum;
	u64 pebs_interrupt_threshold;
	u64 pebs_event_reset[12];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum stack_type {
	STACK_TYPE_UNKNOWN = 0,
	STACK_TYPE_TASK = 1,
	STACK_TYPE_IRQ = 2,
	STACK_TYPE_SOFTIRQ = 3,
	STACK_TYPE_ENTRY = 4,
	STACK_TYPE_EXCEPTION = 5,
	STACK_TYPE_EXCEPTION_LAST = 10,
};

struct stack_info {
	enum stack_type type;
	long unsigned int *begin;
	long unsigned int *end;
	long unsigned int *next_sp;
};

struct stack_frame {
	struct stack_frame *next_frame;
	long unsigned int return_address;
};

struct stack_frame_ia32 {
	u32 next_frame;
	u32 return_address;
};

struct perf_guest_switch_msr {
	unsigned int msr;
	u64 host;
	u64 guest;
};

struct perf_guest_info_callbacks {
	int (*is_in_guest)();
	int (*is_user_mode)();
	long unsigned int (*get_guest_ip)();
	void (*handle_intel_pt_intr)();
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

enum perf_event_x86_regs {
	PERF_REG_X86_AX = 0,
	PERF_REG_X86_BX = 1,
	PERF_REG_X86_CX = 2,
	PERF_REG_X86_DX = 3,
	PERF_REG_X86_SI = 4,
	PERF_REG_X86_DI = 5,
	PERF_REG_X86_BP = 6,
	PERF_REG_X86_SP = 7,
	PERF_REG_X86_IP = 8,
	PERF_REG_X86_FLAGS = 9,
	PERF_REG_X86_CS = 10,
	PERF_REG_X86_SS = 11,
	PERF_REG_X86_DS = 12,
	PERF_REG_X86_ES = 13,
	PERF_REG_X86_FS = 14,
	PERF_REG_X86_GS = 15,
	PERF_REG_X86_R8 = 16,
	PERF_REG_X86_R9 = 17,
	PERF_REG_X86_R10 = 18,
	PERF_REG_X86_R11 = 19,
	PERF_REG_X86_R12 = 20,
	PERF_REG_X86_R13 = 21,
	PERF_REG_X86_R14 = 22,
	PERF_REG_X86_R15 = 23,
	PERF_REG_X86_32_MAX = 16,
	PERF_REG_X86_64_MAX = 24,
	PERF_REG_X86_XMM0 = 32,
	PERF_REG_X86_XMM1 = 34,
	PERF_REG_X86_XMM2 = 36,
	PERF_REG_X86_XMM3 = 38,
	PERF_REG_X86_XMM4 = 40,
	PERF_REG_X86_XMM5 = 42,
	PERF_REG_X86_XMM6 = 44,
	PERF_REG_X86_XMM7 = 46,
	PERF_REG_X86_XMM8 = 48,
	PERF_REG_X86_XMM9 = 50,
	PERF_REG_X86_XMM10 = 52,
	PERF_REG_X86_XMM11 = 54,
	PERF_REG_X86_XMM12 = 56,
	PERF_REG_X86_XMM13 = 58,
	PERF_REG_X86_XMM14 = 60,
	PERF_REG_X86_XMM15 = 62,
	PERF_REG_X86_XMM_MAX = 64,
};

typedef struct {
	u16 __softirq_pending;
	u8 kvm_cpu_l1tf_flush_l1d;
	unsigned int __nmi_count;
	unsigned int apic_timer_irqs;
	unsigned int irq_spurious_count;
	unsigned int icr_read_retry_count;
	unsigned int kvm_posted_intr_ipis;
	unsigned int kvm_posted_intr_wakeup_ipis;
	unsigned int kvm_posted_intr_nested_ipis;
	unsigned int x86_platform_ipis;
	unsigned int apic_perf_irqs;
	unsigned int apic_irq_work_irqs;
	unsigned int irq_resched_count;
	unsigned int irq_call_count;
	unsigned int irq_tlb_count;
	unsigned int irq_thermal_count;
	unsigned int irq_threshold_count;
	unsigned int irq_deferred_error_count;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct perf_pmu_events_ht_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str_ht;
	const char *event_str_noht;
};

struct apic {
	void (*eoi_write)(u32, u32);
	void (*native_eoi_write)(u32, u32);
	void (*write)(u32, u32);
	u32 (*read)(u32);
	void (*wait_icr_idle)();
	u32 (*safe_wait_icr_idle)();
	void (*send_IPI)(int, int);
	void (*send_IPI_mask)(const struct cpumask *, int);
	void (*send_IPI_mask_allbutself)(const struct cpumask *, int);
	void (*send_IPI_allbutself)(int);
	void (*send_IPI_all)(int);
	void (*send_IPI_self)(int);
	u32 dest_logical;
	u32 disable_esr;
	u32 irq_delivery_mode;
	u32 irq_dest_mode;
	u32 (*calc_dest_apicid)(unsigned int);
	u64 (*icr_read)();
	void (*icr_write)(u32, u32);
	int (*probe)();
	int (*acpi_madt_oem_check)(char *, char *);
	int (*apic_id_valid)(u32);
	int (*apic_id_registered)();
	bool (*check_apicid_used)(physid_mask_t *, int);
	void (*init_apic_ldr)();
	void (*ioapic_phys_id_map)(physid_mask_t *, physid_mask_t *);
	void (*setup_apic_routing)();
	int (*cpu_present_to_apicid)(int);
	void (*apicid_to_cpu_present)(int, physid_mask_t *);
	int (*check_phys_apicid_present)(int);
	int (*phys_pkg_id)(int, int);
	u32 (*get_apic_id)(long unsigned int);
	u32 (*set_apic_id)(unsigned int);
	int (*wakeup_secondary_cpu)(int, long unsigned int);
	void (*inquire_remote_apic)(int);
	char *name;
};

enum {
	NMI_LOCAL = 0,
	NMI_UNKNOWN = 1,
	NMI_SERR = 2,
	NMI_IO_CHECK = 3,
	NMI_MAX = 4,
};

typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);

struct nmiaction {
	struct list_head list;
	nmi_handler_t handler;
	u64 max_duration;
	long unsigned int flags;
	const char *name;
};

struct gdt_page {
	struct desc_struct gdt[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cyc2ns_data {
	u32 cyc2ns_mul;
	u32 cyc2ns_shift;
	u64 cyc2ns_offset;
};

struct unwind_state {
	struct stack_info stack_info;
	long unsigned int stack_mask;
	struct task_struct *task;
	int graph_idx;
	bool error;
	bool signal;
	bool full_regs;
	long unsigned int sp;
	long unsigned int bp;
	long unsigned int ip;
	struct pt_regs *regs;
	struct pt_regs *prev_regs;
};

enum extra_reg_type {
	EXTRA_REG_NONE = 4294967295,
	EXTRA_REG_RSP_0 = 0,
	EXTRA_REG_RSP_1 = 1,
	EXTRA_REG_LBR = 2,
	EXTRA_REG_LDLAT = 3,
	EXTRA_REG_FE = 4,
	EXTRA_REG_MAX = 5,
};

struct event_constraint {
	union {
		long unsigned int idxmsk[1];
		u64 idxmsk64;
	};
	u64 code;
	u64 cmask;
	int weight;
	int overlap;
	int flags;
	unsigned int size;
};

struct amd_nb {
	int nb_id;
	int refcnt;
	struct perf_event *owners[64];
	struct event_constraint event_constraints[64];
};

struct er_account {
	raw_spinlock_t lock;
	u64 config;
	u64 reg;
	atomic_t ref;
};

struct intel_shared_regs {
	struct er_account regs[5];
	int refcnt;
	unsigned int core_id;
};

enum intel_excl_state_type {
	INTEL_EXCL_UNUSED = 0,
	INTEL_EXCL_SHARED = 1,
	INTEL_EXCL_EXCLUSIVE = 2,
};

struct intel_excl_states {
	enum intel_excl_state_type state[64];
	bool sched_started;
};

struct intel_excl_cntrs {
	raw_spinlock_t lock;
	struct intel_excl_states states[2];
	union {
		u16 has_exclusive[2];
		u32 exclusive_present;
	};
	int refcnt;
	unsigned int core_id;
};

enum {
	X86_PERF_KFREE_SHARED = 0,
	X86_PERF_KFREE_EXCL = 1,
	X86_PERF_KFREE_MAX = 2,
};

struct cpu_hw_events {
	struct perf_event *events[64];
	long unsigned int active_mask[1];
	long unsigned int running[1];
	int enabled;
	int n_events;
	int n_added;
	int n_txn;
	int n_txn_pair;
	int n_txn_metric;
	int assign[64];
	u64 tags[64];
	struct perf_event *event_list[64];
	struct event_constraint *event_constraint[64];
	int n_excl;
	unsigned int txn_flags;
	int is_fake;
	struct debug_store *ds;
	void *ds_pebs_vaddr;
	void *ds_bts_vaddr;
	u64 pebs_enabled;
	int n_pebs;
	int n_large_pebs;
	int n_pebs_via_pt;
	int pebs_output;
	u64 pebs_data_cfg;
	u64 active_pebs_data_cfg;
	int pebs_record_size;
	int lbr_users;
	int lbr_pebs_users;
	struct perf_branch_stack lbr_stack;
	struct perf_branch_entry lbr_entries[32];
	union {
		struct er_account *lbr_sel;
		struct er_account *lbr_ctl;
	};
	u64 br_sel;
	void *last_task_ctx;
	int last_log_id;
	int lbr_select;
	void *lbr_xsave;
	u64 intel_ctrl_guest_mask;
	u64 intel_ctrl_host_mask;
	struct perf_guest_switch_msr guest_switch_msrs[64];
	u64 intel_cp_status;
	struct intel_shared_regs *shared_regs;
	struct event_constraint *constraint_list;
	struct intel_excl_cntrs *excl_cntrs;
	int excl_thread_id;
	u64 tfa_shadow;
	int n_metric;
	struct amd_nb *amd_nb;
	u64 perf_ctr_virt_mask;
	int n_pair;
	void *kfree_on_online[2];
};

struct extra_reg {
	unsigned int event;
	unsigned int msr;
	u64 config_mask;
	u64 valid_mask;
	int idx;
	bool extra_msr_access;
};

union perf_capabilities {
	struct {
		u64 lbr_format: 6;
		u64 pebs_trap: 1;
		u64 pebs_arch_reg: 1;
		u64 pebs_format: 4;
		u64 smm_freeze: 1;
		u64 full_width_write: 1;
		u64 pebs_baseline: 1;
		u64 perf_metrics: 1;
		u64 pebs_output_pt_available: 1;
	};
	u64 capabilities;
};

struct x86_pmu_quirk {
	struct x86_pmu_quirk *next;
	void (*func)();
};

enum {
	x86_lbr_exclusive_lbr = 0,
	x86_lbr_exclusive_bts = 1,
	x86_lbr_exclusive_pt = 2,
	x86_lbr_exclusive_max = 3,
};

struct x86_pmu {
	const char *name;
	int version;
	int (*handle_irq)(struct pt_regs *);
	void (*disable_all)();
	void (*enable_all)(int);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	void (*add)(struct perf_event *);
	void (*del)(struct perf_event *);
	void (*read)(struct perf_event *);
	int (*hw_config)(struct perf_event *);
	int (*schedule_events)(struct cpu_hw_events *, int, int *);
	unsigned int eventsel;
	unsigned int perfctr;
	int (*addr_offset)(int, bool);
	int (*rdpmc_index)(int);
	u64 (*event_map)(int);
	int max_events;
	int num_counters;
	int num_counters_fixed;
	int cntval_bits;
	u64 cntval_mask;
	union {
		long unsigned int events_maskl;
		long unsigned int events_mask[1];
	};
	int events_mask_len;
	int apic;
	u64 max_period;
	struct event_constraint * (*get_event_constraints)(struct cpu_hw_events *, int, struct perf_event *);
	void (*put_event_constraints)(struct cpu_hw_events *, struct perf_event *);
	void (*start_scheduling)(struct cpu_hw_events *);
	void (*commit_scheduling)(struct cpu_hw_events *, int, int);
	void (*stop_scheduling)(struct cpu_hw_events *);
	struct event_constraint *event_constraints;
	struct x86_pmu_quirk *quirks;
	int perfctr_second_write;
	u64 (*limit_period)(struct perf_event *, u64);
	unsigned int late_ack: 1;
	unsigned int enabled_ack: 1;
	unsigned int counter_freezing: 1;
	int attr_rdpmc_broken;
	int attr_rdpmc;
	struct attribute **format_attrs;
	ssize_t (*events_sysfs_show)(char *, u64);
	const struct attribute_group **attr_update;
	long unsigned int attr_freeze_on_smi;
	int (*cpu_prepare)(int);
	void (*cpu_starting)(int);
	void (*cpu_dying)(int);
	void (*cpu_dead)(int);
	void (*check_microcode)();
	void (*sched_task)(struct perf_event_context *, bool);
	u64 intel_ctrl;
	union perf_capabilities intel_cap;
	unsigned int bts: 1;
	unsigned int bts_active: 1;
	unsigned int pebs: 1;
	unsigned int pebs_active: 1;
	unsigned int pebs_broken: 1;
	unsigned int pebs_prec_dist: 1;
	unsigned int pebs_no_tlb: 1;
	unsigned int pebs_no_isolation: 1;
	int pebs_record_size;
	int pebs_buffer_size;
	int max_pebs_events;
	void (*drain_pebs)(struct pt_regs *);
	struct event_constraint *pebs_constraints;
	void (*pebs_aliases)(struct perf_event *);
	long unsigned int large_pebs_flags;
	u64 rtm_abort_event;
	unsigned int lbr_tos;
	unsigned int lbr_from;
	unsigned int lbr_to;
	unsigned int lbr_info;
	unsigned int lbr_nr;
	union {
		u64 lbr_sel_mask;
		u64 lbr_ctl_mask;
	};
	union {
		const int *lbr_sel_map;
		int *lbr_ctl_map;
	};
	bool lbr_double_abort;
	bool lbr_pt_coexist;
	unsigned int lbr_depth_mask: 8;
	unsigned int lbr_deep_c_reset: 1;
	unsigned int lbr_lip: 1;
	unsigned int lbr_cpl: 1;
	unsigned int lbr_filter: 1;
	unsigned int lbr_call_stack: 1;
	unsigned int lbr_mispred: 1;
	unsigned int lbr_timed_lbr: 1;
	unsigned int lbr_br_type: 1;
	void (*lbr_reset)();
	void (*lbr_read)(struct cpu_hw_events *);
	void (*lbr_save)(void *);
	void (*lbr_restore)(void *);
	atomic_t lbr_exclusive[3];
	u64 (*update_topdown_event)(struct perf_event *);
	int (*set_topdown_event_period)(struct perf_event *);
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	unsigned int amd_nb_constraints: 1;
	u64 perf_ctr_pair_en;
	struct extra_reg *extra_regs;
	unsigned int flags;
	struct perf_guest_switch_msr * (*guest_get_msrs)(int *);
	int (*check_period)(struct perf_event *, u64);
	int (*aux_output_match)(struct perf_event *);
};

struct sched_state {
	int weight;
	int event;
	int counter;
	int unassigned;
	int nr_gp;
	u64 used;
};

struct perf_sched {
	int max_weight;
	int max_events;
	int max_gp;
	int saved_states;
	struct event_constraint **constraints;
	struct sched_state state;
	struct sched_state saved[2];
};

struct perf_msr {
	u64 msr;
	struct attribute_group *grp;
	bool (*test)(int, void *);
	bool no_check;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

struct amd_uncore {
	int id;
	int refcnt;
	int cpu;
	int num_counters;
	int rdpmc_base;
	u32 msr_base;
	cpumask_t *active_mask;
	struct pmu *pmu;
	struct perf_event *events[6];
	struct hlist_node node;
};

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef short unsigned int pci_dev_flags_t;

struct pci_bus;

struct pci_slot;

struct pci_driver;

struct pcie_link_state;

struct pci_vpd;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int runtime_d3cold: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	int l1ss;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[17];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int reset_fn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *rom_attr;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[17];
	struct bin_attribute *res_attr_wc[17];
	const struct attribute_group **msi_irq_groups;
	struct pci_vpd *vpd;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	char *driver_override;
	long unsigned int priv_flags;
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
};

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

typedef short unsigned int pci_bus_flags_t;

struct pci_ops;

struct msi_controller;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	struct msi_controller *msi;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_IOV_RESOURCES = 7,
	PCI_IOV_RESOURCE_END = 12,
	PCI_BRIDGE_RESOURCES = 13,
	PCI_BRIDGE_RESOURCE_END = 16,
	PCI_NUM_RESOURCES = 17,
	DEVICE_COUNT_RESOURCE = 17,
};

typedef unsigned int pcie_reset_state_t;

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	struct device_driver driver;
	struct pci_dynids dynids;
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

enum ibs_states {
	IBS_ENABLED = 0,
	IBS_STARTED = 1,
	IBS_STOPPING = 2,
	IBS_STOPPED = 3,
	IBS_MAX_STATES = 4,
};

struct cpu_perf_ibs {
	struct perf_event *event;
	long unsigned int state[1];
};

struct perf_ibs {
	struct pmu pmu;
	unsigned int msr;
	u64 config_mask;
	u64 cnt_mask;
	u64 enable_mask;
	u64 valid_mask;
	u64 max_period;
	long unsigned int offset_mask[1];
	int offset_max;
	unsigned int fetch_count_reset_broken: 1;
	struct cpu_perf_ibs *pcpu;
	struct attribute **format_attrs;
	struct attribute_group format_group;
	const struct attribute_group *attr_groups[2];
	u64 (*get_count)(u64);
};

struct perf_ibs_data {
	u32 size;
	union {
		u32 data[0];
		u32 caps;
	};
	u64 regs[8];
};

enum perf_msr_id {
	PERF_MSR_TSC = 0,
	PERF_MSR_APERF = 1,
	PERF_MSR_MPERF = 2,
	PERF_MSR_PPERF = 3,
	PERF_MSR_SMI = 4,
	PERF_MSR_PTSC = 5,
	PERF_MSR_IRPERF = 6,
	PERF_MSR_THERM = 7,
	PERF_MSR_EVENT_MAX = 8,
};

enum lockdep_wait_type {
	LD_WAIT_INV = 0,
	LD_WAIT_FREE = 1,
	LD_WAIT_SPIN = 2,
	LD_WAIT_CONFIG = 2,
	LD_WAIT_SLEEP = 3,
	LD_WAIT_MAX = 4,
};

struct x86_cpu_desc {
	u8 x86_family;
	u8 x86_vendor;
	u8 x86_model;
	u8 x86_stepping;
	u32 x86_microcode_rev;
};

union cpuid10_eax {
	struct {
		unsigned int version_id: 8;
		unsigned int num_counters: 8;
		unsigned int bit_width: 8;
		unsigned int mask_length: 8;
	} split;
	unsigned int full;
};

union cpuid10_ebx {
	struct {
		unsigned int no_unhalted_core_cycles: 1;
		unsigned int no_instructions_retired: 1;
		unsigned int no_unhalted_reference_cycles: 1;
		unsigned int no_llc_reference: 1;
		unsigned int no_llc_misses: 1;
		unsigned int no_branch_instruction_retired: 1;
		unsigned int no_branch_misses_retired: 1;
	} split;
	unsigned int full;
};

union cpuid10_edx {
	struct {
		unsigned int num_counters_fixed: 5;
		unsigned int bit_width_fixed: 8;
		unsigned int reserved: 19;
	} split;
	unsigned int full;
};

enum {
	LBR_FORMAT_32 = 0,
	LBR_FORMAT_LIP = 1,
	LBR_FORMAT_EIP = 2,
	LBR_FORMAT_EIP_FLAGS = 3,
	LBR_FORMAT_EIP_FLAGS2 = 4,
	LBR_FORMAT_INFO = 5,
	LBR_FORMAT_TIME = 6,
	LBR_FORMAT_MAX_KNOWN = 6,
};

union x86_pmu_config {
	struct {
		u64 event: 8;
		u64 umask: 8;
		u64 usr: 1;
		u64 os: 1;
		u64 edge: 1;
		u64 pc: 1;
		u64 interrupt: 1;
		u64 __reserved1: 1;
		u64 en: 1;
		u64 inv: 1;
		u64 cmask: 8;
		u64 event2: 4;
		u64 __reserved2: 4;
		u64 go: 1;
		u64 ho: 1;
	} bits;
	u64 value;
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	PG_uncached = 22,
	PG_hwpoison = 23,
	PG_arch_2 = 24,
	__NR_PAGEFLAGS = 25,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 6,
	PG_isolated = 18,
	PG_reported = 2,
};

struct bts_ctx {
	struct perf_output_handle handle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct debug_store ds_back;
	int state;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BTS_STATE_STOPPED = 0,
	BTS_STATE_INACTIVE = 1,
	BTS_STATE_ACTIVE = 2,
};

struct bts_phys {
	struct page *page;
	long unsigned int size;
	long unsigned int offset;
	long unsigned int displacement;
};

struct bts_buffer {
	size_t real_size;
	unsigned int nr_pages;
	unsigned int nr_bufs;
	unsigned int cur_buf;
	bool snapshot;
	local_t data_size;
	local_t head;
	long unsigned int end;
	void **data_pages;
	struct bts_phys buf[0];
};

struct lbr_entry {
	u64 from;
	u64 to;
	u64 info;
};

struct pebs_basic {
	u64 format_size;
	u64 ip;
	u64 applicable_counters;
	u64 tsc;
};

struct pebs_meminfo {
	u64 address;
	u64 aux;
	u64 latency;
	u64 tsx_tuning;
};

struct pebs_gprs {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 cx;
	u64 dx;
	u64 bx;
	u64 sp;
	u64 bp;
	u64 si;
	u64 di;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_xmm {
	u64 xmm[32];
};

struct x86_perf_regs {
	struct pt_regs regs;
	u64 *xmm_regs;
};

typedef unsigned int insn_attr_t;

typedef unsigned char insn_byte_t;

typedef int insn_value_t;

struct insn_field {
	union {
		insn_value_t value;
		insn_byte_t bytes[4];
	};
	unsigned char got;
	unsigned char nbytes;
};

struct insn {
	struct insn_field prefixes;
	struct insn_field rex_prefix;
	struct insn_field vex_prefix;
	struct insn_field opcode;
	struct insn_field modrm;
	struct insn_field sib;
	struct insn_field displacement;
	union {
		struct insn_field immediate;
		struct insn_field moffset1;
		struct insn_field immediate1;
	};
	union {
		struct insn_field moffset2;
		struct insn_field immediate2;
	};
	int emulate_prefix_size;
	insn_attr_t attr;
	unsigned char opnd_bytes;
	unsigned char addr_bytes;
	unsigned char length;
	unsigned char x86_64;
	const insn_byte_t *kaddr;
	const insn_byte_t *end_kaddr;
	const insn_byte_t *next_byte;
};

enum {
	PERF_TXN_ELISION = 1,
	PERF_TXN_TRANSACTION = 2,
	PERF_TXN_SYNC = 4,
	PERF_TXN_ASYNC = 8,
	PERF_TXN_RETRY = 16,
	PERF_TXN_CONFLICT = 32,
	PERF_TXN_CAPACITY_WRITE = 64,
	PERF_TXN_CAPACITY_READ = 128,
	PERF_TXN_MAX = 256,
	PERF_TXN_ABORT_MASK = 0,
	PERF_TXN_ABORT_SHIFT = 32,
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

union intel_x86_pebs_dse {
	u64 val;
	struct {
		unsigned int ld_dse: 4;
		unsigned int ld_stlb_miss: 1;
		unsigned int ld_locked: 1;
		unsigned int ld_reserved: 26;
	};
	struct {
		unsigned int st_l1d_hit: 1;
		unsigned int st_reserved1: 3;
		unsigned int st_stlb_miss: 1;
		unsigned int st_locked: 1;
		unsigned int st_reserved2: 26;
	};
};

struct pebs_record_core {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_record_nhm {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
};

union hsw_tsx_tuning {
	struct {
		u32 cycles_last_block: 32;
		u32 hle_abort: 1;
		u32 rtm_abort: 1;
		u32 instruction_abort: 1;
		u32 non_instruction_abort: 1;
		u32 retry: 1;
		u32 data_conflict: 1;
		u32 capacity_writes: 1;
		u32 capacity_reads: 1;
	};
	u64 value;
};

struct pebs_record_skl {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
	u64 real_ip;
	u64 tsx_tuning;
	u64 tsc;
};

struct bts_record {
	u64 from;
	u64 to;
	u64 flags;
};

enum {
	PERF_BR_UNKNOWN = 0,
	PERF_BR_COND = 1,
	PERF_BR_UNCOND = 2,
	PERF_BR_IND = 3,
	PERF_BR_CALL = 4,
	PERF_BR_IND_CALL = 5,
	PERF_BR_RET = 6,
	PERF_BR_SYSCALL = 7,
	PERF_BR_SYSRET = 8,
	PERF_BR_COND_CALL = 9,
	PERF_BR_COND_RET = 10,
	PERF_BR_MAX = 11,
};

enum xfeature {
	XFEATURE_FP = 0,
	XFEATURE_SSE = 1,
	XFEATURE_YMM = 2,
	XFEATURE_BNDREGS = 3,
	XFEATURE_BNDCSR = 4,
	XFEATURE_OPMASK = 5,
	XFEATURE_ZMM_Hi256 = 6,
	XFEATURE_Hi16_ZMM = 7,
	XFEATURE_PT_UNIMPLEMENTED_SO_FAR = 8,
	XFEATURE_PKRU = 9,
	XFEATURE_PASID = 10,
	XFEATURE_RSRVD_COMP_11 = 11,
	XFEATURE_RSRVD_COMP_12 = 12,
	XFEATURE_RSRVD_COMP_13 = 13,
	XFEATURE_RSRVD_COMP_14 = 14,
	XFEATURE_LBR = 15,
	XFEATURE_MAX = 16,
};

struct arch_lbr_state {
	u64 lbr_ctl;
	u64 lbr_depth;
	u64 ler_from;
	u64 ler_to;
	u64 ler_info;
	struct lbr_entry entries[0];
};

union cpuid28_eax {
	struct {
		unsigned int lbr_depth_mask: 8;
		unsigned int reserved: 22;
		unsigned int lbr_deep_c_reset: 1;
		unsigned int lbr_lip: 1;
	} split;
	unsigned int full;
};

union cpuid28_ebx {
	struct {
		unsigned int lbr_cpl: 1;
		unsigned int lbr_filter: 1;
		unsigned int lbr_call_stack: 1;
	} split;
	unsigned int full;
};

union cpuid28_ecx {
	struct {
		unsigned int lbr_mispred: 1;
		unsigned int lbr_timed_lbr: 1;
		unsigned int lbr_br_type: 1;
	} split;
	unsigned int full;
};

struct x86_pmu_lbr {
	unsigned int nr;
	unsigned int from;
	unsigned int to;
	unsigned int info;
};

struct x86_perf_task_context_opt {
	int lbr_callstack_users;
	int lbr_stack_state;
	int log_id;
};

struct x86_perf_task_context {
	u64 lbr_sel;
	int tos;
	int valid_lbrs;
	struct x86_perf_task_context_opt opt;
	struct lbr_entry lbr[32];
};

struct x86_perf_task_context_arch_lbr {
	struct x86_perf_task_context_opt opt;
	struct lbr_entry entries[0];
};

struct x86_perf_task_context_arch_lbr_xsave {
	struct x86_perf_task_context_opt opt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct xregs_state xsave;
		struct {
			struct fxregs_state i387;
			struct xstate_header header;
			struct arch_lbr_state lbr;
			long: 64;
			long: 64;
			long: 64;
		};
	};
};

enum {
	X86_BR_NONE = 0,
	X86_BR_USER = 1,
	X86_BR_KERNEL = 2,
	X86_BR_CALL = 4,
	X86_BR_RET = 8,
	X86_BR_SYSCALL = 16,
	X86_BR_SYSRET = 32,
	X86_BR_INT = 64,
	X86_BR_IRET = 128,
	X86_BR_JCC = 256,
	X86_BR_JMP = 512,
	X86_BR_IRQ = 1024,
	X86_BR_IND_CALL = 2048,
	X86_BR_ABORT = 4096,
	X86_BR_IN_TX = 8192,
	X86_BR_NO_TX = 16384,
	X86_BR_ZERO_CALL = 32768,
	X86_BR_CALL_STACK = 65536,
	X86_BR_IND_JMP = 131072,
	X86_BR_TYPE_SAVE = 262144,
};

enum {
	LBR_NONE = 0,
	LBR_VALID = 1,
};

enum {
	ARCH_LBR_BR_TYPE_JCC = 0,
	ARCH_LBR_BR_TYPE_NEAR_IND_JMP = 1,
	ARCH_LBR_BR_TYPE_NEAR_REL_JMP = 2,
	ARCH_LBR_BR_TYPE_NEAR_IND_CALL = 3,
	ARCH_LBR_BR_TYPE_NEAR_REL_CALL = 4,
	ARCH_LBR_BR_TYPE_NEAR_RET = 5,
	ARCH_LBR_BR_TYPE_KNOWN_MAX = 5,
	ARCH_LBR_BR_TYPE_MAP_MAX = 16,
};

enum P4_EVENTS {
	P4_EVENT_TC_DELIVER_MODE = 0,
	P4_EVENT_BPU_FETCH_REQUEST = 1,
	P4_EVENT_ITLB_REFERENCE = 2,
	P4_EVENT_MEMORY_CANCEL = 3,
	P4_EVENT_MEMORY_COMPLETE = 4,
	P4_EVENT_LOAD_PORT_REPLAY = 5,
	P4_EVENT_STORE_PORT_REPLAY = 6,
	P4_EVENT_MOB_LOAD_REPLAY = 7,
	P4_EVENT_PAGE_WALK_TYPE = 8,
	P4_EVENT_BSQ_CACHE_REFERENCE = 9,
	P4_EVENT_IOQ_ALLOCATION = 10,
	P4_EVENT_IOQ_ACTIVE_ENTRIES = 11,
	P4_EVENT_FSB_DATA_ACTIVITY = 12,
	P4_EVENT_BSQ_ALLOCATION = 13,
	P4_EVENT_BSQ_ACTIVE_ENTRIES = 14,
	P4_EVENT_SSE_INPUT_ASSIST = 15,
	P4_EVENT_PACKED_SP_UOP = 16,
	P4_EVENT_PACKED_DP_UOP = 17,
	P4_EVENT_SCALAR_SP_UOP = 18,
	P4_EVENT_SCALAR_DP_UOP = 19,
	P4_EVENT_64BIT_MMX_UOP = 20,
	P4_EVENT_128BIT_MMX_UOP = 21,
	P4_EVENT_X87_FP_UOP = 22,
	P4_EVENT_TC_MISC = 23,
	P4_EVENT_GLOBAL_POWER_EVENTS = 24,
	P4_EVENT_TC_MS_XFER = 25,
	P4_EVENT_UOP_QUEUE_WRITES = 26,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE = 27,
	P4_EVENT_RETIRED_BRANCH_TYPE = 28,
	P4_EVENT_RESOURCE_STALL = 29,
	P4_EVENT_WC_BUFFER = 30,
	P4_EVENT_B2B_CYCLES = 31,
	P4_EVENT_BNR = 32,
	P4_EVENT_SNOOP = 33,
	P4_EVENT_RESPONSE = 34,
	P4_EVENT_FRONT_END_EVENT = 35,
	P4_EVENT_EXECUTION_EVENT = 36,
	P4_EVENT_REPLAY_EVENT = 37,
	P4_EVENT_INSTR_RETIRED = 38,
	P4_EVENT_UOPS_RETIRED = 39,
	P4_EVENT_UOP_TYPE = 40,
	P4_EVENT_BRANCH_RETIRED = 41,
	P4_EVENT_MISPRED_BRANCH_RETIRED = 42,
	P4_EVENT_X87_ASSIST = 43,
	P4_EVENT_MACHINE_CLEAR = 44,
	P4_EVENT_INSTR_COMPLETED = 45,
};

enum P4_EVENT_OPCODES {
	P4_EVENT_TC_DELIVER_MODE_OPCODE = 257,
	P4_EVENT_BPU_FETCH_REQUEST_OPCODE = 768,
	P4_EVENT_ITLB_REFERENCE_OPCODE = 6147,
	P4_EVENT_MEMORY_CANCEL_OPCODE = 517,
	P4_EVENT_MEMORY_COMPLETE_OPCODE = 2050,
	P4_EVENT_LOAD_PORT_REPLAY_OPCODE = 1026,
	P4_EVENT_STORE_PORT_REPLAY_OPCODE = 1282,
	P4_EVENT_MOB_LOAD_REPLAY_OPCODE = 770,
	P4_EVENT_PAGE_WALK_TYPE_OPCODE = 260,
	P4_EVENT_BSQ_CACHE_REFERENCE_OPCODE = 3079,
	P4_EVENT_IOQ_ALLOCATION_OPCODE = 774,
	P4_EVENT_IOQ_ACTIVE_ENTRIES_OPCODE = 6662,
	P4_EVENT_FSB_DATA_ACTIVITY_OPCODE = 5894,
	P4_EVENT_BSQ_ALLOCATION_OPCODE = 1287,
	P4_EVENT_BSQ_ACTIVE_ENTRIES_OPCODE = 1543,
	P4_EVENT_SSE_INPUT_ASSIST_OPCODE = 13313,
	P4_EVENT_PACKED_SP_UOP_OPCODE = 2049,
	P4_EVENT_PACKED_DP_UOP_OPCODE = 3073,
	P4_EVENT_SCALAR_SP_UOP_OPCODE = 2561,
	P4_EVENT_SCALAR_DP_UOP_OPCODE = 3585,
	P4_EVENT_64BIT_MMX_UOP_OPCODE = 513,
	P4_EVENT_128BIT_MMX_UOP_OPCODE = 6657,
	P4_EVENT_X87_FP_UOP_OPCODE = 1025,
	P4_EVENT_TC_MISC_OPCODE = 1537,
	P4_EVENT_GLOBAL_POWER_EVENTS_OPCODE = 4870,
	P4_EVENT_TC_MS_XFER_OPCODE = 1280,
	P4_EVENT_UOP_QUEUE_WRITES_OPCODE = 2304,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE_OPCODE = 1282,
	P4_EVENT_RETIRED_BRANCH_TYPE_OPCODE = 1026,
	P4_EVENT_RESOURCE_STALL_OPCODE = 257,
	P4_EVENT_WC_BUFFER_OPCODE = 1285,
	P4_EVENT_B2B_CYCLES_OPCODE = 5635,
	P4_EVENT_BNR_OPCODE = 2051,
	P4_EVENT_SNOOP_OPCODE = 1539,
	P4_EVENT_RESPONSE_OPCODE = 1027,
	P4_EVENT_FRONT_END_EVENT_OPCODE = 2053,
	P4_EVENT_EXECUTION_EVENT_OPCODE = 3077,
	P4_EVENT_REPLAY_EVENT_OPCODE = 2309,
	P4_EVENT_INSTR_RETIRED_OPCODE = 516,
	P4_EVENT_UOPS_RETIRED_OPCODE = 260,
	P4_EVENT_UOP_TYPE_OPCODE = 514,
	P4_EVENT_BRANCH_RETIRED_OPCODE = 1541,
	P4_EVENT_MISPRED_BRANCH_RETIRED_OPCODE = 772,
	P4_EVENT_X87_ASSIST_OPCODE = 773,
	P4_EVENT_MACHINE_CLEAR_OPCODE = 517,
	P4_EVENT_INSTR_COMPLETED_OPCODE = 1796,
};

enum P4_ESCR_EMASKS {
	P4_EVENT_TC_DELIVER_MODE__DD = 512,
	P4_EVENT_TC_DELIVER_MODE__DB = 1024,
	P4_EVENT_TC_DELIVER_MODE__DI = 2048,
	P4_EVENT_TC_DELIVER_MODE__BD = 4096,
	P4_EVENT_TC_DELIVER_MODE__BB = 8192,
	P4_EVENT_TC_DELIVER_MODE__BI = 16384,
	P4_EVENT_TC_DELIVER_MODE__ID = 32768,
	P4_EVENT_BPU_FETCH_REQUEST__TCMISS = 512,
	P4_EVENT_ITLB_REFERENCE__HIT = 512,
	P4_EVENT_ITLB_REFERENCE__MISS = 1024,
	P4_EVENT_ITLB_REFERENCE__HIT_UK = 2048,
	P4_EVENT_MEMORY_CANCEL__ST_RB_FULL = 2048,
	P4_EVENT_MEMORY_CANCEL__64K_CONF = 4096,
	P4_EVENT_MEMORY_COMPLETE__LSC = 512,
	P4_EVENT_MEMORY_COMPLETE__SSC = 1024,
	P4_EVENT_LOAD_PORT_REPLAY__SPLIT_LD = 1024,
	P4_EVENT_STORE_PORT_REPLAY__SPLIT_ST = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STA = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STD = 4096,
	P4_EVENT_MOB_LOAD_REPLAY__PARTIAL_DATA = 8192,
	P4_EVENT_MOB_LOAD_REPLAY__UNALGN_ADDR = 16384,
	P4_EVENT_PAGE_WALK_TYPE__DTMISS = 512,
	P4_EVENT_PAGE_WALK_TYPE__ITMISS = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITS = 512,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITE = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITM = 2048,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITS = 4096,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITE = 8192,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITM = 16384,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_MISS = 131072,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_MISS = 262144,
	P4_EVENT_BSQ_CACHE_REFERENCE__WR_2ndL_MISS = 524288,
	P4_EVENT_IOQ_ALLOCATION__DEFAULT = 512,
	P4_EVENT_IOQ_ALLOCATION__ALL_READ = 16384,
	P4_EVENT_IOQ_ALLOCATION__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ALLOCATION__MEM_UC = 65536,
	P4_EVENT_IOQ_ALLOCATION__MEM_WC = 131072,
	P4_EVENT_IOQ_ALLOCATION__MEM_WT = 262144,
	P4_EVENT_IOQ_ALLOCATION__MEM_WP = 524288,
	P4_EVENT_IOQ_ALLOCATION__MEM_WB = 1048576,
	P4_EVENT_IOQ_ALLOCATION__OWN = 4194304,
	P4_EVENT_IOQ_ALLOCATION__OTHER = 8388608,
	P4_EVENT_IOQ_ALLOCATION__PREFETCH = 16777216,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__DEFAULT = 512,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_READ = 16384,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_UC = 65536,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WC = 131072,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WT = 262144,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WP = 524288,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WB = 1048576,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OWN = 4194304,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OTHER = 8388608,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__PREFETCH = 16777216,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_DRV = 512,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OWN = 1024,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OTHER = 2048,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_DRV = 4096,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OWN = 8192,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OTHER = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ALLOCATION__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ALLOCATION__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ALLOCATION__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ALLOCATION__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ALLOCATION__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE2 = 4194304,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE2 = 4194304,
	P4_EVENT_SSE_INPUT_ASSIST__ALL = 16777216,
	P4_EVENT_PACKED_SP_UOP__ALL = 16777216,
	P4_EVENT_PACKED_DP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_SP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_DP_UOP__ALL = 16777216,
	P4_EVENT_64BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_128BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_X87_FP_UOP__ALL = 16777216,
	P4_EVENT_TC_MISC__FLUSH = 8192,
	P4_EVENT_GLOBAL_POWER_EVENTS__RUNNING = 512,
	P4_EVENT_TC_MS_XFER__CISC = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_BUILD = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_DELIVER = 1024,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_ROM = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RETIRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RESOURCE_STALL__SBFULL = 16384,
	P4_EVENT_WC_BUFFER__WCB_EVICTS = 512,
	P4_EVENT_WC_BUFFER__WCB_FULL_EVICTS = 1024,
	P4_EVENT_FRONT_END_EVENT__NBOGUS = 512,
	P4_EVENT_FRONT_END_EVENT__BOGUS = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS0 = 512,
	P4_EVENT_EXECUTION_EVENT__NBOGUS1 = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS2 = 2048,
	P4_EVENT_EXECUTION_EVENT__NBOGUS3 = 4096,
	P4_EVENT_EXECUTION_EVENT__BOGUS0 = 8192,
	P4_EVENT_EXECUTION_EVENT__BOGUS1 = 16384,
	P4_EVENT_EXECUTION_EVENT__BOGUS2 = 32768,
	P4_EVENT_EXECUTION_EVENT__BOGUS3 = 65536,
	P4_EVENT_REPLAY_EVENT__NBOGUS = 512,
	P4_EVENT_REPLAY_EVENT__BOGUS = 1024,
	P4_EVENT_INSTR_RETIRED__NBOGUSNTAG = 512,
	P4_EVENT_INSTR_RETIRED__NBOGUSTAG = 1024,
	P4_EVENT_INSTR_RETIRED__BOGUSNTAG = 2048,
	P4_EVENT_INSTR_RETIRED__BOGUSTAG = 4096,
	P4_EVENT_UOPS_RETIRED__NBOGUS = 512,
	P4_EVENT_UOPS_RETIRED__BOGUS = 1024,
	P4_EVENT_UOP_TYPE__TAGLOADS = 1024,
	P4_EVENT_UOP_TYPE__TAGSTORES = 2048,
	P4_EVENT_BRANCH_RETIRED__MMNP = 512,
	P4_EVENT_BRANCH_RETIRED__MMNM = 1024,
	P4_EVENT_BRANCH_RETIRED__MMTP = 2048,
	P4_EVENT_BRANCH_RETIRED__MMTM = 4096,
	P4_EVENT_MISPRED_BRANCH_RETIRED__NBOGUS = 512,
	P4_EVENT_X87_ASSIST__FPSU = 512,
	P4_EVENT_X87_ASSIST__FPSO = 1024,
	P4_EVENT_X87_ASSIST__POAO = 2048,
	P4_EVENT_X87_ASSIST__POAU = 4096,
	P4_EVENT_X87_ASSIST__PREA = 8192,
	P4_EVENT_MACHINE_CLEAR__CLEAR = 512,
	P4_EVENT_MACHINE_CLEAR__MOCLEAR = 1024,
	P4_EVENT_MACHINE_CLEAR__SMCLEAR = 2048,
	P4_EVENT_INSTR_COMPLETED__NBOGUS = 512,
	P4_EVENT_INSTR_COMPLETED__BOGUS = 1024,
};

enum P4_PEBS_METRIC {
	P4_PEBS_METRIC__none = 0,
	P4_PEBS_METRIC__1stl_cache_load_miss_retired = 1,
	P4_PEBS_METRIC__2ndl_cache_load_miss_retired = 2,
	P4_PEBS_METRIC__dtlb_load_miss_retired = 3,
	P4_PEBS_METRIC__dtlb_store_miss_retired = 4,
	P4_PEBS_METRIC__dtlb_all_miss_retired = 5,
	P4_PEBS_METRIC__tagged_mispred_branch = 6,
	P4_PEBS_METRIC__mob_load_replay_retired = 7,
	P4_PEBS_METRIC__split_load_retired = 8,
	P4_PEBS_METRIC__split_store_retired = 9,
	P4_PEBS_METRIC__max = 10,
};

struct p4_event_bind {
	unsigned int opcode;
	unsigned int escr_msr[2];
	unsigned int escr_emask;
	unsigned int shared;
	char cntr[6];
};

struct p4_pebs_bind {
	unsigned int metric_pebs;
	unsigned int metric_vert;
};

struct p4_event_alias {
	u64 original;
	u64 alternative;
};

enum cpuid_regs_idx {
	CPUID_EAX = 0,
	CPUID_EBX = 1,
	CPUID_ECX = 2,
	CPUID_EDX = 3,
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

enum pt_capabilities {
	PT_CAP_max_subleaf = 0,
	PT_CAP_cr3_filtering = 1,
	PT_CAP_psb_cyc = 2,
	PT_CAP_ip_filtering = 3,
	PT_CAP_mtc = 4,
	PT_CAP_ptwrite = 5,
	PT_CAP_power_event_trace = 6,
	PT_CAP_topa_output = 7,
	PT_CAP_topa_multiple_entries = 8,
	PT_CAP_single_range_output = 9,
	PT_CAP_output_subsys = 10,
	PT_CAP_payloads_lip = 11,
	PT_CAP_num_address_ranges = 12,
	PT_CAP_mtc_periods = 13,
	PT_CAP_cycle_thresholds = 14,
	PT_CAP_psb_periods = 15,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct topa_entry {
	u64 end: 1;
	u64 rsvd0: 1;
	u64 intr: 1;
	u64 rsvd1: 1;
	u64 stop: 1;
	u64 rsvd2: 1;
	u64 size: 4;
	u64 rsvd3: 2;
	u64 base: 36;
	u64 rsvd4: 16;
};

struct pt_pmu {
	struct pmu pmu;
	u32 caps[8];
	bool vmx;
	bool branch_en_always_on;
	long unsigned int max_nonturbo_ratio;
	unsigned int tsc_art_num;
	unsigned int tsc_art_den;
};

struct topa;

struct pt_buffer {
	struct list_head tables;
	struct topa *first;
	struct topa *last;
	struct topa *cur;
	unsigned int cur_idx;
	size_t output_off;
	long unsigned int nr_pages;
	local_t data_size;
	local64_t head;
	bool snapshot;
	bool single;
	long int stop_pos;
	long int intr_pos;
	struct topa_entry *stop_te;
	struct topa_entry *intr_te;
	void **data_pages;
};

struct topa {
	struct list_head list;
	u64 offset;
	size_t size;
	int last;
	unsigned int z_count;
};

struct pt_filter {
	long unsigned int msr_a;
	long unsigned int msr_b;
	long unsigned int config;
};

struct pt_filters {
	struct pt_filter filter[4];
	unsigned int nr_filters;
};

struct pt {
	struct perf_output_handle handle;
	struct pt_filters filters;
	int handle_nmi;
	int vmx_on;
	u64 output_base;
	u64 output_mask;
};

struct pt_cap_desc {
	const char *name;
	u32 leaf;
	u8 reg;
	u32 mask;
};

struct pt_address_range {
	long unsigned int msr_a;
	long unsigned int msr_b;
	unsigned int reg_off;
};

struct topa_page {
	struct topa_entry table[507];
	struct topa topa;
};

typedef void (*exitcall_t)();

struct x86_cpu_id {
	__u16 vendor;
	__u16 family;
	__u16 model;
	__u16 steppings;
	__u16 feature;
	kernel_ulong_t driver_data;
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

struct acpi_device;

struct pci_sysdata {
	int domain;
	int node;
	struct acpi_device *companion;
	void *iommu;
	void *fwnode;
};

struct pci_extra_dev {
	struct pci_dev *dev[4];
};

struct intel_uncore_pmu;

struct intel_uncore_ops;

struct uncore_event_desc;

struct freerunning_counters;

struct intel_uncore_type {
	const char *name;
	int num_counters;
	int num_boxes;
	int perf_ctr_bits;
	int fixed_ctr_bits;
	int num_freerunning_types;
	unsigned int perf_ctr;
	unsigned int event_ctl;
	unsigned int event_mask;
	unsigned int event_mask_ext;
	unsigned int fixed_ctr;
	unsigned int fixed_ctl;
	unsigned int box_ctl;
	union {
		unsigned int msr_offset;
		unsigned int mmio_offset;
	};
	unsigned int mmio_map_size;
	unsigned int num_shared_regs: 8;
	unsigned int single_fixed: 1;
	unsigned int pair_ctr_ctl: 1;
	unsigned int *msr_offsets;
	struct event_constraint unconstrainted;
	struct event_constraint *constraints;
	struct intel_uncore_pmu *pmus;
	struct intel_uncore_ops *ops;
	struct uncore_event_desc *event_descs;
	struct freerunning_counters *freerunning;
	const struct attribute_group *attr_groups[4];
	const struct attribute_group **attr_update;
	struct pmu *pmu;
	u64 *topology;
	int (*set_mapping)(struct intel_uncore_type *);
	void (*cleanup_mapping)(struct intel_uncore_type *);
};

struct intel_uncore_box;

struct intel_uncore_pmu {
	struct pmu pmu;
	char name[32];
	int pmu_idx;
	int func_id;
	bool registered;
	atomic_t activeboxes;
	struct intel_uncore_type *type;
	struct intel_uncore_box **boxes;
};

struct intel_uncore_ops {
	void (*init_box)(struct intel_uncore_box *);
	void (*exit_box)(struct intel_uncore_box *);
	void (*disable_box)(struct intel_uncore_box *);
	void (*enable_box)(struct intel_uncore_box *);
	void (*disable_event)(struct intel_uncore_box *, struct perf_event *);
	void (*enable_event)(struct intel_uncore_box *, struct perf_event *);
	u64 (*read_counter)(struct intel_uncore_box *, struct perf_event *);
	int (*hw_config)(struct intel_uncore_box *, struct perf_event *);
	struct event_constraint * (*get_constraint)(struct intel_uncore_box *, struct perf_event *);
	void (*put_constraint)(struct intel_uncore_box *, struct perf_event *);
};

struct uncore_event_desc {
	struct kobj_attribute attr;
	const char *config;
};

struct freerunning_counters {
	unsigned int counter_base;
	unsigned int counter_offset;
	unsigned int box_offset;
	unsigned int num_counters;
	unsigned int bits;
	unsigned int *box_offsets;
};

struct intel_uncore_extra_reg {
	raw_spinlock_t lock;
	u64 config;
	u64 config1;
	u64 config2;
	atomic_t ref;
};

struct intel_uncore_box {
	int pci_phys_id;
	int dieid;
	int n_active;
	int n_events;
	int cpu;
	long unsigned int flags;
	atomic_t refcnt;
	struct perf_event *events[10];
	struct perf_event *event_list[10];
	struct event_constraint *event_constraint[10];
	long unsigned int active_mask[1];
	u64 tags[10];
	struct pci_dev *pci_dev;
	struct intel_uncore_pmu *pmu;
	u64 hrtimer_duration;
	struct hrtimer hrtimer;
	struct list_head list;
	struct list_head active_list;
	void *io_addr;
	struct intel_uncore_extra_reg shared_regs[0];
};

struct pci2phy_map {
	struct list_head list;
	int segment;
	int pbus_to_physid[256];
};

struct intel_uncore_init_fun {
	void (*cpu_init)();
	int (*pci_init)();
	void (*mmio_init)();
};

enum {
	EXTRA_REG_NHMEX_M_FILTER = 0,
	EXTRA_REG_NHMEX_M_DSP = 1,
	EXTRA_REG_NHMEX_M_ISS = 2,
	EXTRA_REG_NHMEX_M_MAP = 3,
	EXTRA_REG_NHMEX_M_MSC_THR = 4,
	EXTRA_REG_NHMEX_M_PGT = 5,
	EXTRA_REG_NHMEX_M_PLD = 6,
	EXTRA_REG_NHMEX_M_ZDP_CTL_FVC = 7,
};

enum {
	SNB_PCI_UNCORE_IMC = 0,
};

enum perf_snb_uncore_imc_freerunning_types {
	SNB_PCI_UNCORE_IMC_DATA_READS = 0,
	SNB_PCI_UNCORE_IMC_DATA_WRITES = 1,
	SNB_PCI_UNCORE_IMC_GT_REQUESTS = 2,
	SNB_PCI_UNCORE_IMC_IA_REQUESTS = 3,
	SNB_PCI_UNCORE_IMC_IO_REQUESTS = 4,
	SNB_PCI_UNCORE_IMC_FREERUNNING_TYPE_MAX = 5,
};

struct imc_uncore_pci_dev {
	__u32 pci_id;
	struct pci_driver *driver;
};

enum perf_tgl_uncore_imc_freerunning_types {
	TGL_MMIO_UNCORE_IMC_DATA_TOTAL = 0,
	TGL_MMIO_UNCORE_IMC_DATA_READ = 1,
	TGL_MMIO_UNCORE_IMC_DATA_WRITE = 2,
	TGL_MMIO_UNCORE_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum {
	SNBEP_PCI_QPI_PORT0_FILTER = 0,
	SNBEP_PCI_QPI_PORT1_FILTER = 1,
	BDX_PCI_QPI_PORT2_FILTER = 2,
	HSWEP_PCI_PCU_3 = 3,
};

enum {
	SNBEP_PCI_UNCORE_HA = 0,
	SNBEP_PCI_UNCORE_IMC = 1,
	SNBEP_PCI_UNCORE_QPI = 2,
	SNBEP_PCI_UNCORE_R2PCIE = 3,
	SNBEP_PCI_UNCORE_R3QPI = 4,
};

enum {
	IVBEP_PCI_UNCORE_HA = 0,
	IVBEP_PCI_UNCORE_IMC = 1,
	IVBEP_PCI_UNCORE_IRP = 2,
	IVBEP_PCI_UNCORE_QPI = 3,
	IVBEP_PCI_UNCORE_R2PCIE = 4,
	IVBEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	KNL_PCI_UNCORE_MC_UCLK = 0,
	KNL_PCI_UNCORE_MC_DCLK = 1,
	KNL_PCI_UNCORE_EDC_UCLK = 2,
	KNL_PCI_UNCORE_EDC_ECLK = 3,
	KNL_PCI_UNCORE_M2PCIE = 4,
	KNL_PCI_UNCORE_IRP = 5,
};

enum {
	HSWEP_PCI_UNCORE_HA = 0,
	HSWEP_PCI_UNCORE_IMC = 1,
	HSWEP_PCI_UNCORE_IRP = 2,
	HSWEP_PCI_UNCORE_QPI = 3,
	HSWEP_PCI_UNCORE_R2PCIE = 4,
	HSWEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	BDX_PCI_UNCORE_HA = 0,
	BDX_PCI_UNCORE_IMC = 1,
	BDX_PCI_UNCORE_IRP = 2,
	BDX_PCI_UNCORE_QPI = 3,
	BDX_PCI_UNCORE_R2PCIE = 4,
	BDX_PCI_UNCORE_R3QPI = 5,
};

enum perf_uncore_iio_freerunning_type_id {
	SKX_IIO_MSR_IOCLK = 0,
	SKX_IIO_MSR_BW = 1,
	SKX_IIO_MSR_UTIL = 2,
	SKX_IIO_FREERUNNING_TYPE_MAX = 3,
};

enum {
	SKX_PCI_UNCORE_IMC = 0,
	SKX_PCI_UNCORE_M2M = 1,
	SKX_PCI_UNCORE_UPI = 2,
	SKX_PCI_UNCORE_M2PCIE = 3,
	SKX_PCI_UNCORE_M3UPI = 4,
};

enum perf_uncore_snr_iio_freerunning_type_id {
	SNR_IIO_MSR_IOCLK = 0,
	SNR_IIO_MSR_BW_IN = 1,
	SNR_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum {
	SNR_PCI_UNCORE_M2M = 0,
	SNR_PCI_UNCORE_PCIE3 = 1,
};

enum perf_uncore_snr_imc_freerunning_type_id {
	SNR_IMC_DCLK = 0,
	SNR_IMC_DDR = 1,
	SNR_IMC_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_icx_iio_freerunning_type_id {
	ICX_IIO_MSR_IOCLK = 0,
	ICX_IIO_MSR_BW_IN = 1,
	ICX_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum {
	ICX_PCI_UNCORE_M2M = 0,
	ICX_PCI_UNCORE_UPI = 1,
	ICX_PCI_UNCORE_M3UPI = 2,
};

enum perf_uncore_icx_imc_freerunning_type_id {
	ICX_IMC_DCLK = 0,
	ICX_IMC_DDR = 1,
	ICX_IMC_DDRT = 2,
	ICX_IMC_FREERUNNING_TYPE_MAX = 3,
};

struct real_mode_header {
	u32 text_start;
	u32 ro_end;
	u32 trampoline_start;
	u32 trampoline_header;
	u32 trampoline_pgd;
	u32 wakeup_start;
	u32 wakeup_header;
	u32 machine_real_restart_asm;
	u32 machine_real_restart_seg;
};

struct trampoline_header {
	u64 start;
	u64 efer;
	u32 cr4;
	u32 flags;
};

struct pkru_state {
	u32 pkru;
	u32 pad;
};

struct x86_hw_tss {
	u32 reserved1;
	u64 sp0;
	u64 sp1;
	u64 sp2;
	u64 reserved2;
	u64 ist[7];
	u32 reserved3;
	u32 reserved4;
	u16 reserved5;
	u16 io_bitmap_base;
} __attribute__((packed));

struct x86_io_bitmap {
	u64 prev_sequence;
	unsigned int prev_max;
	long unsigned int bitmap[1025];
	long unsigned int mapall[1025];
};

struct tss_struct {
	struct x86_hw_tss x86_tss;
	struct x86_io_bitmap io_bitmap;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum show_regs_mode {
	SHOW_REGS_SHORT = 0,
	SHOW_REGS_USER = 1,
	SHOW_REGS_ALL = 2,
};

enum which_selector {
	FS = 0,
	GS = 1,
};

struct sigcontext_64 {
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 di;
	__u64 si;
	__u64 bp;
	__u64 bx;
	__u64 dx;
	__u64 ax;
	__u64 cx;
	__u64 sp;
	__u64 ip;
	__u64 flags;
	__u16 cs;
	__u16 gs;
	__u16 fs;
	__u16 ss;
	__u64 err;
	__u64 trapno;
	__u64 oldmask;
	__u64 cr2;
	__u64 fpstate;
	__u64 reserved1[8];
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct __large_struct {
	long unsigned int buf[100];
};

typedef u32 compat_sigset_word;

typedef struct {
	compat_sigset_word sig[2];
} compat_sigset_t;

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	struct sigcontext_64 uc_mcontext;
	sigset_t uc_sigmask;
};

struct kernel_vm86_regs {
	struct pt_regs pt;
	short unsigned int es;
	short unsigned int __esh;
	short unsigned int ds;
	short unsigned int __dsh;
	short unsigned int fs;
	short unsigned int __fsh;
	short unsigned int gs;
	short unsigned int __gsh;
};

struct rt_sigframe {
	char *pretcode;
	struct ucontext uc;
	struct siginfo info;
};

typedef struct siginfo siginfo_t;

typedef s32 compat_clock_t;

typedef s32 compat_pid_t;

typedef s32 compat_timer_t;

typedef s32 compat_int_t;

typedef u32 __compat_uid32_t;

union compat_sigval {
	compat_int_t sival_int;
	compat_uptr_t sival_ptr;
};

typedef union compat_sigval compat_sigval_t;

struct compat_siginfo {
	int si_signo;
	int si_errno;
	int si_code;
	union {
		int _pad[29];
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
		} _kill;
		struct {
			compat_timer_t _tid;
			int _overrun;
			compat_sigval_t _sigval;
		} _timer;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			compat_sigval_t _sigval;
		} _rt;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			int _status;
			compat_clock_t _utime;
			compat_clock_t _stime;
		} _sigchld;
		struct {
			compat_uptr_t _addr;
			union {
				short int _addr_lsb;
				struct {
					char _dummy_bnd[4];
					compat_uptr_t _lower;
					compat_uptr_t _upper;
				} _addr_bnd;
				struct {
					char _dummy_pkey[4];
					u32 _pkey;
				} _addr_pkey;
			};
		} _sigfault;
		struct {
			compat_long_t _band;
			int _fd;
		} _sigpoll;
		struct {
			compat_uptr_t _call_addr;
			int _syscall;
			unsigned int _arch;
		} _sigsys;
	} _sifields;
};

typedef struct compat_siginfo compat_siginfo_t;

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

typedef u8 kprobe_opcode_t;

struct arch_specific_insn {
	kprobe_opcode_t *insn;
	bool boostable;
	bool if_modifier;
	int tp_len;
};

struct kprobe;

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

typedef int (*kprobe_fault_handler_t)(struct kprobe *, struct pt_regs *, int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_fault_handler_t fault_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

enum die_val {
	DIE_OOPS = 1,
	DIE_INT3 = 2,
	DIE_DEBUG = 3,
	DIE_PANIC = 4,
	DIE_NMI = 5,
	DIE_DIE = 6,
	DIE_KERNELDEBUG = 7,
	DIE_TRAP = 8,
	DIE_GPF = 9,
	DIE_CALL = 10,
	DIE_PAGE_FAULT = 11,
	DIE_NMIUNKNOWN = 12,
};

struct irqentry_state {
	bool exit_rcu;
};

typedef struct irqentry_state irqentry_state_t;

enum kernel_gp_hint {
	GP_NO_HINT = 0,
	GP_NON_CANONICAL = 1,
	GP_CANONICAL = 2,
};

struct bad_iret_stack {
	void *error_entry_ret;
	struct pt_regs regs;
};

enum {
	GATE_INTERRUPT = 14,
	GATE_TRAP = 15,
	GATE_CALL = 12,
	GATE_TASK = 5,
};

struct idt_data {
	unsigned int vector;
	unsigned int segment;
	struct idt_bits bits;
	const void *addr;
};

struct irq_stack {
	char stack[16384];
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	cpumask_var_t pending_mask;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	long: 64;
};

struct msi_msg;

struct irq_chip {
	struct device *parent_device;
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_cpu_online)(struct irq_data *);
	void (*irq_cpu_offline)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

typedef struct irq_desc *vector_irq_t[256];

struct trace_event_raw_x86_irq_vector {
	struct trace_entry ent;
	int vector;
	char __data[0];
};

struct trace_event_raw_vector_config {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int apicdest;
	char __data[0];
};

struct trace_event_raw_vector_mod {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int prev_vector;
	unsigned int prev_cpu;
	char __data[0];
};

struct trace_event_raw_vector_reserve {
	struct trace_entry ent;
	unsigned int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_alloc {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	bool reserved;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_alloc_managed {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_activate {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool can_reserve;
	bool reserve;
	char __data[0];
};

struct trace_event_raw_vector_teardown {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool has_reserved;
	char __data[0];
};

struct trace_event_raw_vector_setup {
	struct trace_entry ent;
	unsigned int irq;
	bool is_legacy;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_free_moved {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int cpu;
	unsigned int vector;
	bool is_managed;
	char __data[0];
};

struct trace_event_data_offsets_x86_irq_vector {};

struct trace_event_data_offsets_vector_config {};

struct trace_event_data_offsets_vector_mod {};

struct trace_event_data_offsets_vector_reserve {};

struct trace_event_data_offsets_vector_alloc {};

struct trace_event_data_offsets_vector_alloc_managed {};

struct trace_event_data_offsets_vector_activate {};

struct trace_event_data_offsets_vector_teardown {};

struct trace_event_data_offsets_vector_setup {};

struct trace_event_data_offsets_vector_free_moved {};

typedef void (*btf_trace_local_timer_entry)(void *, int);

typedef void (*btf_trace_local_timer_exit)(void *, int);

typedef void (*btf_trace_spurious_apic_entry)(void *, int);

typedef void (*btf_trace_spurious_apic_exit)(void *, int);

typedef void (*btf_trace_error_apic_entry)(void *, int);

typedef void (*btf_trace_error_apic_exit)(void *, int);

typedef void (*btf_trace_x86_platform_ipi_entry)(void *, int);

typedef void (*btf_trace_x86_platform_ipi_exit)(void *, int);

typedef void (*btf_trace_irq_work_entry)(void *, int);

typedef void (*btf_trace_irq_work_exit)(void *, int);

typedef void (*btf_trace_reschedule_entry)(void *, int);

typedef void (*btf_trace_reschedule_exit)(void *, int);

typedef void (*btf_trace_call_function_entry)(void *, int);

typedef void (*btf_trace_call_function_exit)(void *, int);

typedef void (*btf_trace_call_function_single_entry)(void *, int);

typedef void (*btf_trace_call_function_single_exit)(void *, int);

typedef void (*btf_trace_threshold_apic_entry)(void *, int);

typedef void (*btf_trace_threshold_apic_exit)(void *, int);

typedef void (*btf_trace_deferred_error_apic_entry)(void *, int);

typedef void (*btf_trace_deferred_error_apic_exit)(void *, int);

typedef void (*btf_trace_thermal_apic_entry)(void *, int);

typedef void (*btf_trace_thermal_apic_exit)(void *, int);

typedef void (*btf_trace_vector_config)(void *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_update)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_clear)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_reserve_managed)(void *, unsigned int, int);

typedef void (*btf_trace_vector_reserve)(void *, unsigned int, int);

typedef void (*btf_trace_vector_alloc)(void *, unsigned int, unsigned int, bool, int);

typedef void (*btf_trace_vector_alloc_managed)(void *, unsigned int, unsigned int, int);

typedef void (*btf_trace_vector_activate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_deactivate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_teardown)(void *, unsigned int, bool, bool);

typedef void (*btf_trace_vector_setup)(void *, unsigned int, bool, int);

typedef void (*btf_trace_vector_free_moved)(void *, unsigned int, unsigned int, unsigned int, bool);

struct cea_exception_stacks {
	char DF_stack_guard[4096];
	char DF_stack[4096];
	char NMI_stack_guard[4096];
	char NMI_stack[4096];
	char DB_stack_guard[4096];
	char DB_stack[4096];
	char MCE_stack_guard[4096];
	char MCE_stack[4096];
	char VC_stack_guard[4096];
	char VC_stack[4096];
	char VC2_stack_guard[4096];
	char VC2_stack[4096];
	char IST_top_guard[4096];
};

struct estack_pages {
	u32 offs;
	u16 size;
	u16 type;
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct list_head wd_list;
	u64 cs_last;
	u64 wd_last;
	struct module *owner;
};

struct x86_init_mpparse {
	void (*setup_ioapic_ids)();
	void (*find_smp_config)();
	void (*get_smp_config)(unsigned int);
};

struct x86_init_resources {
	void (*probe_roms)();
	void (*reserve_resources)();
	char * (*memory_setup)();
};

struct x86_init_irqs {
	void (*pre_vector_init)();
	void (*intr_init)();
	void (*intr_mode_select)();
	void (*intr_mode_init)();
	struct irq_domain * (*create_pci_msi_domain)();
};

struct x86_init_oem {
	void (*arch_setup)();
	void (*banner)();
};

struct x86_init_paging {
	void (*pagetable_init)();
};

struct x86_init_timers {
	void (*setup_percpu_clockev)();
	void (*timer_init)();
	void (*wallclock_init)();
};

struct x86_init_iommu {
	int (*iommu_init)();
};

struct x86_init_pci {
	int (*arch_init)();
	int (*init)();
	void (*init_irq)();
	void (*fixup_irqs)();
};

struct x86_hyper_init {
	void (*init_platform)();
	void (*guest_late_init)();
	bool (*x2apic_available)();
	void (*init_mem_mapping)();
	void (*init_after_bootmem)();
};

struct x86_init_acpi {
	void (*set_root_pointer)(u64);
	u64 (*get_root_pointer)();
	void (*reduced_hw_early_init)();
};

struct x86_init_ops {
	struct x86_init_resources resources;
	struct x86_init_mpparse mpparse;
	struct x86_init_irqs irqs;
	struct x86_init_oem oem;
	struct x86_init_paging paging;
	struct x86_init_timers timers;
	struct x86_init_iommu iommu;
	struct x86_init_pci pci;
	struct x86_hyper_init hyper;
	struct x86_init_acpi acpi;
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

struct msi_msg {
	u32 address_lo;
	u32 address_hi;
	u32 data;
};

struct platform_msi_priv_data;

struct platform_msi_desc {
	struct platform_msi_priv_data *msi_priv_data;
	u16 msi_index;
};

struct fsl_mc_msi_desc {
	u16 msi_index;
};

struct ti_sci_inta_msi_desc {
	u16 dev_index;
};

struct msi_desc {
	struct list_head list;
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	union {
		struct {
			u32 masked;
			struct {
				u8 is_msix: 1;
				u8 multiple: 3;
				u8 multi_cap: 3;
				u8 maskbit: 1;
				u8 is_64: 1;
				u8 is_virtual: 1;
				u16 entry_nr;
				unsigned int default_irq;
			} msi_attrib;
			union {
				u8 mask_pos;
				void *mask_base;
			};
		};
		struct platform_msi_desc platform;
		struct fsl_mc_msi_desc fsl_mc;
		struct ti_sci_inta_msi_desc inta;
	};
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_PCMCIA_CIS = 10,
	LOCKDOWN_TIOCSSERIAL = 11,
	LOCKDOWN_MODULE_PARAMETERS = 12,
	LOCKDOWN_MMIOTRACE = 13,
	LOCKDOWN_DEBUGFS = 14,
	LOCKDOWN_XMON_WR = 15,
	LOCKDOWN_INTEGRITY_MAX = 16,
	LOCKDOWN_KCORE = 17,
	LOCKDOWN_KPROBES = 18,
	LOCKDOWN_BPF_READ = 19,
	LOCKDOWN_PERF = 20,
	LOCKDOWN_TRACEFS = 21,
	LOCKDOWN_XMON_RW = 22,
	LOCKDOWN_CONFIDENTIALITY_MAX = 23,
};

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

struct entry_stack {
	char stack[4096];
};

typedef long unsigned int uintptr_t;

typedef u64 uint64_t;

struct trace_event_raw_nmi_handler {
	struct trace_entry ent;
	void *handler;
	s64 delta_ns;
	int handled;
	char __data[0];
};

struct trace_event_data_offsets_nmi_handler {};

typedef void (*btf_trace_nmi_handler)(void *, void *, s64, int);

struct nmi_desc {
	raw_spinlock_t lock;
	struct list_head head;
};

struct nmi_stats {
	unsigned int normal;
	unsigned int unknown;
	unsigned int external;
	unsigned int swallow;
};

enum nmi_states {
	NMI_NOT_RUNNING = 0,
	NMI_EXECUTING = 1,
	NMI_LATCHED = 2,
};

enum {
	DESC_TSS = 9,
	DESC_LDT = 2,
	DESCTYPE_S = 16,
};

struct ldttss_desc {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 zero0: 3;
	u16 g: 1;
	u16 base2: 8;
	u32 base3;
	u32 zero1;
};

typedef struct ldttss_desc ldt_desc;

struct user_desc {
	unsigned int entry_number;
	unsigned int base_addr;
	unsigned int limit;
	unsigned int seg_32bit: 1;
	unsigned int contents: 2;
	unsigned int read_exec_only: 1;
	unsigned int limit_in_pages: 1;
	unsigned int seg_not_present: 1;
	unsigned int useable: 1;
	unsigned int lm: 1;
};

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_gather {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_font_copy)(struct vc_data *, int);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedir;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[4];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc;
	struct uni_screen *vc_uni_screen;
};

struct edd {
	unsigned int mbr_signature[16];
	struct edd_info edd_info[6];
	unsigned char mbr_signature_nr;
	unsigned char edd_info_nr;
};

struct setup_data {
	__u64 next;
	__u32 type;
	__u32 len;
	__u8 data[0];
};

struct setup_indirect {
	__u32 type;
	__u32 reserved;
	__u64 len;
	__u64 addr;
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

enum e820_type {
	E820_TYPE_RAM = 1,
	E820_TYPE_RESERVED = 2,
	E820_TYPE_ACPI = 3,
	E820_TYPE_NVS = 4,
	E820_TYPE_UNUSABLE = 5,
	E820_TYPE_PMEM = 7,
	E820_TYPE_PRAM = 12,
	E820_TYPE_SOFT_RESERVED = 4026531839,
	E820_TYPE_RESERVED_KERN = 128,
};

struct e820_entry {
	u64 addr;
	u64 size;
	enum e820_type type;
} __attribute__((packed));

struct e820_table {
	__u32 nr_entries;
	struct e820_entry entries[320];
} __attribute__((packed));

struct x86_cpuinit_ops {
	void (*setup_percpu_clockev)();
	void (*early_percpu_clock_init)();
	void (*fixup_cpu_id)(struct cpuinfo_x86 *, int);
};

struct x86_msi_ops {
	void (*restore_msi_irqs)(struct pci_dev *);
};

struct x86_apic_ops {
	unsigned int (*io_apic_read)(unsigned int, unsigned int);
	void (*restore)();
};

struct msi_controller {
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct list_head list;
	int (*setup_irq)(struct msi_controller *, struct pci_dev *, struct msi_desc *);
	int (*setup_irqs)(struct msi_controller *, struct pci_dev *, int, int);
	void (*teardown_irq)(struct msi_controller *, unsigned int);
};

struct legacy_pic {
	int nr_legacy_irqs;
	struct irq_chip *chip;
	void (*mask)(unsigned int);
	void (*unmask)(unsigned int);
	void (*mask_all)();
	void (*restore_mask)();
	void (*init)(int);
	int (*probe)();
	int (*irq_pending)(unsigned int);
	void (*make_irq)(unsigned int);
};

enum jump_label_type {
	JUMP_LABEL_NOP = 0,
	JUMP_LABEL_JMP = 1,
};

union text_poke_insn {
	u8 text[5];
	struct {
		u8 opcode;
		s32 disp;
	} __attribute__((packed));
};

enum {
	JL_STATE_START = 0,
	JL_STATE_NO_UPDATE = 1,
	JL_STATE_UPDATE = 2,
};

typedef short unsigned int __kernel_old_uid_t;

typedef short unsigned int __kernel_old_gid_t;

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef __kernel_old_gid_t old_gid_t;

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	struct cgroup *cgrp;
	struct css_set *cset;
};

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

struct stat64 {
	long long unsigned int st_dev;
	unsigned char __pad0[4];
	unsigned int __st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	long long unsigned int st_rdev;
	unsigned char __pad3[4];
	long long int st_size;
	unsigned int st_blksize;
	long long int st_blocks;
	unsigned int st_atime;
	unsigned int st_atime_nsec;
	unsigned int st_mtime;
	unsigned int st_mtime_nsec;
	unsigned int st_ctime;
	unsigned int st_ctime_nsec;
	long long unsigned int st_ino;
} __attribute__((packed));

struct mmap_arg_struct32 {
	unsigned int addr;
	unsigned int len;
	unsigned int prot;
	unsigned int flags;
	unsigned int fd;
	unsigned int offset;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

enum align_flags {
	ALIGN_VA_32 = 1,
	ALIGN_VA_64 = 2,
};

struct va_alignment {
	int flags;
	long unsigned int mask;
	long unsigned int bits;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
};

struct change_member {
	struct e820_entry *entry;
	long long unsigned int addr;
};

struct iommu_fault_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct iommu_fault_unrecoverable {
	__u32 reason;
	__u32 flags;
	__u32 pasid;
	__u32 perm;
	__u64 addr;
	__u64 fetch_addr;
};

struct iommu_fault_page_request {
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u64 addr;
	__u64 private_data[2];
};

struct iommu_fault {
	__u32 type;
	__u32 padding;
	union {
		struct iommu_fault_unrecoverable event;
		struct iommu_fault_page_request prm;
		__u8 padding2[56];
	};
};

struct iommu_page_response {
	__u32 argsz;
	__u32 version;
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 code;
};

struct iommu_inv_addr_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
	__u64 addr;
	__u64 granule_size;
	__u64 nb_granules;
};

struct iommu_inv_pasid_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
};

struct iommu_cache_invalidate_info {
	__u32 argsz;
	__u32 version;
	__u8 cache;
	__u8 granularity;
	__u8 padding[6];
	union {
		struct iommu_inv_pasid_info pasid_info;
		struct iommu_inv_addr_info addr_info;
	} granu;
};

struct iommu_gpasid_bind_data_vtd {
	__u64 flags;
	__u32 pat;
	__u32 emt;
};

struct iommu_gpasid_bind_data {
	__u32 argsz;
	__u32 version;
	__u32 format;
	__u32 addr_width;
	__u64 flags;
	__u64 gpgd;
	__u64 hpasid;
	__u64 gpasid;
	__u8 padding[8];
	union {
		struct iommu_gpasid_bind_data_vtd vtd;
	} vendor;
};

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain {
	unsigned int type;
	const struct iommu_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	void *iova_cookie;
};

typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
};

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
};

struct iommu_sva {
	struct device *dev;
};

struct iommu_fault_event {
	struct iommu_fault fault;
	struct list_head list;
};

struct iommu_fault_param {
	iommu_dev_fault_handler_t handler;
	void *data;
	struct list_head faults;
	struct mutex lock;
};

struct iommu_fwspec {
	const struct iommu_ops *ops;
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	u32 num_pasid_bits;
	unsigned int num_ids;
	u32 ids[0];
};

struct iommu_table_entry {
	initcall_t detect;
	initcall_t depend;
	void (*early_init)();
	void (*late_init)();
	int flags;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

enum {
	NONE_FORCE_HPET_RESUME = 0,
	OLD_ICH_FORCE_HPET_RESUME = 1,
	ICH_FORCE_HPET_RESUME = 2,
	VT8237_FORCE_HPET_RESUME = 3,
	NVIDIA_FORCE_HPET_RESUME = 4,
	ATI_FORCE_HPET_RESUME = 5,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct x86_cpu {
	struct cpu cpu;
};

typedef int (*cmp_func_t)(const void *, const void *);

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct smp_alt_module {
	struct module *mod;
	char *name;
	const s32 *locks;
	const s32 *locks_end;
	u8 *text;
	u8 *text_end;
	struct list_head next;
};

typedef struct {
	struct mm_struct *mm;
} temp_mm_state_t;

struct text_poke_loc {
	s32 rel_addr;
	s32 rel32;
	u8 opcode;
	const u8 text[5];
	u8 old;
};

struct bp_patching_desc {
	struct text_poke_loc *vec;
	int nr_entries;
	atomic_t refs;
};

struct paravirt_patch_site;

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

typedef unsigned int u_int;

typedef long long unsigned int cycles_t;

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_DELAYED_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_DELAYED = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 15,
	WORK_NO_COLOR = 15,
	WORK_CPU_UNBOUND = 128,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_CANCELING = 16,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 59,
	WORK_OFFQ_POOL_BITS = 31,
	WORK_OFFQ_POOL_NONE = 2147483647,
	WORK_STRUCT_FLAG_MASK = 255,
	WORK_STRUCT_WQ_DATA_MASK = 4294967040,
	WORK_STRUCT_NO_POOL = 4294967264,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

struct plist_head {
	struct list_head node_list;
};

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int restore_freq;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct cyc2ns {
	struct cyc2ns_data data[2];
	seqcount_latch_t seq;
};

struct muldiv {
	u32 multiplier;
	u32 divider;
};

struct freq_desc {
	bool use_msr_plat;
	struct muldiv muldiv[16];
	u32 freqs[16];
	u32 mask;
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct pdev_archdata {};

struct mfd_cell;

struct platform_device_id;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct pnp_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
};

struct pnp_card_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
	struct {
		__u8 id[8];
	} devs[8];
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_table_fadt {
	struct acpi_table_header header;
	u32 facs;
	u32 dsdt;
	u8 model;
	u8 preferred_profile;
	u16 sci_interrupt;
	u32 smi_command;
	u8 acpi_enable;
	u8 acpi_disable;
	u8 s4_bios_request;
	u8 pstate_control;
	u32 pm1a_event_block;
	u32 pm1b_event_block;
	u32 pm1a_control_block;
	u32 pm1b_control_block;
	u32 pm2_control_block;
	u32 pm_timer_block;
	u32 gpe0_block;
	u32 gpe1_block;
	u8 pm1_event_length;
	u8 pm1_control_length;
	u8 pm2_control_length;
	u8 pm_timer_length;
	u8 gpe0_block_length;
	u8 gpe1_block_length;
	u8 gpe1_base;
	u8 cst_control;
	u16 c2_latency;
	u16 c3_latency;
	u16 flush_size;
	u16 flush_stride;
	u8 duty_offset;
	u8 duty_width;
	u8 day_alarm;
	u8 month_alarm;
	u8 century;
	u16 boot_flags;
	u8 reserved;
	u32 flags;
	struct acpi_generic_address reset_register;
	u8 reset_value;
	u16 arm_boot_flags;
	u8 minor_revision;
	u64 Xfacs;
	u64 Xdsdt;
	struct acpi_generic_address xpm1a_event_block;
	struct acpi_generic_address xpm1b_event_block;
	struct acpi_generic_address xpm1a_control_block;
	struct acpi_generic_address xpm1b_control_block;
	struct acpi_generic_address xpm2_control_block;
	struct acpi_generic_address xpm_timer_block;
	struct acpi_generic_address xgpe0_block;
	struct acpi_generic_address xgpe1_block;
	struct acpi_generic_address sleep_control;
	struct acpi_generic_address sleep_status;
	u64 hypervisor_id;
} __attribute__((packed));

struct pnp_protocol;

struct pnp_id;

struct pnp_card {
	struct device dev;
	unsigned char number;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head devices;
	struct pnp_protocol *protocol;
	struct pnp_id *id;
	char name[50];
	unsigned char pnpver;
	unsigned char productver;
	unsigned int serial;
	unsigned char checksum;
	struct proc_dir_entry *procdir;
};

struct pnp_dev;

struct pnp_protocol {
	struct list_head protocol_list;
	char *name;
	int (*get)(struct pnp_dev *);
	int (*set)(struct pnp_dev *);
	int (*disable)(struct pnp_dev *);
	bool (*can_wakeup)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	unsigned char number;
	struct device dev;
	struct list_head cards;
	struct list_head devices;
};

struct pnp_id {
	char id[8];
	struct pnp_id *next;
};

struct pnp_card_driver;

struct pnp_card_link {
	struct pnp_card *card;
	struct pnp_card_driver *driver;
	void *driver_data;
	pm_message_t pm_state;
};

struct pnp_driver {
	const char *name;
	const struct pnp_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
	void (*remove)(struct pnp_dev *);
	void (*shutdown)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	struct device_driver driver;
};

struct pnp_card_driver {
	struct list_head global_list;
	char *name;
	const struct pnp_card_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
	void (*remove)(struct pnp_card_link *);
	int (*suspend)(struct pnp_card_link *, pm_message_t);
	int (*resume)(struct pnp_card_link *);
	struct pnp_driver link;
};

struct pnp_dev {
	struct device dev;
	u64 dma_mask;
	unsigned int number;
	int status;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head card_list;
	struct list_head rdev_list;
	struct pnp_protocol *protocol;
	struct pnp_card *card;
	struct pnp_driver *driver;
	struct pnp_card_link *card_link;
	struct pnp_id *id;
	int active;
	int capabilities;
	unsigned int num_dependent_sets;
	struct list_head resources;
	struct list_head options;
	char name[50];
	int flags;
	struct proc_dir_entry *procent;
	void *data;
};

enum insn_type {
	CALL = 0,
	NOP = 1,
	JMP = 2,
	RET = 3,
};

typedef struct ldttss_desc tss_desc;

enum idle_boot_override {
	IDLE_NO_OVERRIDE = 0,
	IDLE_HALT = 1,
	IDLE_NOMWAIT = 2,
	IDLE_POLL = 3,
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

struct inactive_task_frame {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bx;
	long unsigned int bp;
	long unsigned int ret_addr;
};

struct fork_frame {
	struct inactive_task_frame frame;
	struct pt_regs regs;
};

struct ssb_state {
	struct ssb_state *shared_state;
	raw_spinlock_t lock;
	unsigned int disable_state;
	long unsigned int local_state;
};

struct trace_event_raw_x86_fpu {
	struct trace_entry ent;
	struct fpu *fpu;
	bool load_fpu;
	u64 xfeatures;
	u64 xcomp_bv;
	char __data[0];
};

struct trace_event_data_offsets_x86_fpu {};

typedef void (*btf_trace_x86_fpu_before_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_after_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_before_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_after_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_activated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_deactivated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_init_state)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_dropped)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_src)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_dst)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_xstate_check_failed)(void *, struct fpu *);

struct _fpreg {
	__u16 significand[4];
	__u16 exponent;
};

struct _fpxreg {
	__u16 significand[4];
	__u16 exponent;
	__u16 padding[3];
};

struct user_i387_ia32_struct {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
};

struct membuf {
	void *p;
	size_t left;
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct _fpx_sw_bytes {
	__u32 magic1;
	__u32 extended_size;
	__u64 xfeatures;
	__u32 xstate_size;
	__u32 padding[7];
};

struct _xmmreg {
	__u32 element[4];
};

struct _fpstate_32 {
	__u32 cw;
	__u32 sw;
	__u32 tag;
	__u32 ipoff;
	__u32 cssel;
	__u32 dataoff;
	__u32 datasel;
	struct _fpreg _st[8];
	__u16 status;
	__u16 magic;
	__u32 _fxsr_env[6];
	__u32 mxcsr;
	__u32 reserved;
	struct _fpxreg _fxsr_st[8];
	struct _xmmreg _xmm[8];
	union {
		__u32 padding1[44];
		__u32 padding[44];
	};
	union {
		__u32 padding2[12];
		struct _fpx_sw_bytes sw_reserved;
	};
};

struct ia32_pasid_state {
	u64 pasid;
};

typedef u32 compat_ulong_t;

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

enum x86_regset {
	REGSET_GENERAL = 0,
	REGSET_FP = 1,
	REGSET_XFP = 2,
	REGSET_IOPERM64 = 2,
	REGSET_XSTATE = 3,
	REGSET_TLS = 4,
	REGSET_IOPERM32 = 5,
};

struct pt_regs_offset {
	const char *name;
	int offset;
};

typedef u8 uint8_t;

enum {
	TB_SHUTDOWN_REBOOT = 0,
	TB_SHUTDOWN_S5 = 1,
	TB_SHUTDOWN_S4 = 2,
	TB_SHUTDOWN_S3 = 3,
	TB_SHUTDOWN_HALT = 4,
	TB_SHUTDOWN_WFS = 5,
};

struct tboot_mac_region {
	u64 start;
	u32 size;
} __attribute__((packed));

struct tboot_acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct tboot_acpi_sleep_info {
	struct tboot_acpi_generic_address pm1a_cnt_blk;
	struct tboot_acpi_generic_address pm1b_cnt_blk;
	struct tboot_acpi_generic_address pm1a_evt_blk;
	struct tboot_acpi_generic_address pm1b_evt_blk;
	u16 pm1a_cnt_val;
	u16 pm1b_cnt_val;
	u64 wakeup_vector;
	u32 vector_width;
	u64 kernel_s3_resume_vector;
} __attribute__((packed));

struct tboot {
	u8 uuid[16];
	u32 version;
	u32 log_addr;
	u32 shutdown_entry;
	u32 shutdown_type;
	struct tboot_acpi_sleep_info acpi_sinfo;
	u32 tboot_base;
	u32 tboot_size;
	u8 num_mac_regions;
	struct tboot_mac_region mac_regions[32];
	u8 s3_key[64];
	u8 reserved_align[3];
	u32 num_in_wfs;
} __attribute__((packed));

struct sha1_hash {
	u8 hash[20];
};

struct sinit_mle_data {
	u32 version;
	struct sha1_hash bios_acm_id;
	u32 edx_senter_flags;
	u64 mseg_valid;
	struct sha1_hash sinit_hash;
	struct sha1_hash mle_hash;
	struct sha1_hash stm_hash;
	struct sha1_hash lcp_policy_hash;
	u32 lcp_policy_control;
	u32 rlp_wakeup_addr;
	u32 reserved;
	u32 num_mdrs;
	u32 mdrs_off;
	u32 num_vtd_dmars;
	u32 vtd_dmars_off;
} __attribute__((packed));

typedef bool (*stack_trace_consume_fn)(void *, long unsigned int);

struct stack_frame_user {
	const void *next_fp;
	long unsigned int ret_addr;
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

struct amd_l3_cache {
	unsigned int indices;
	u8 subcaches[4];
};

struct threshold_block {
	unsigned int block;
	unsigned int bank;
	unsigned int cpu;
	u32 address;
	u16 interrupt_enable;
	bool interrupt_capable;
	u16 threshold_limit;
	struct kobject kobj;
	struct list_head miscj;
};

struct threshold_bank {
	struct kobject *kobj;
	struct threshold_block *blocks;
	refcount_t cpus;
	unsigned int shared;
};

struct amd_northbridge {
	struct pci_dev *root;
	struct pci_dev *misc;
	struct pci_dev *link;
	struct amd_l3_cache l3_cache;
	struct threshold_bank *bank4;
};

struct _cache_table {
	unsigned char descriptor;
	char cache_type;
	short int size;
};

enum _cache_type {
	CTYPE_NULL = 0,
	CTYPE_DATA = 1,
	CTYPE_INST = 2,
	CTYPE_UNIFIED = 3,
};

union _cpuid4_leaf_eax {
	struct {
		enum _cache_type type: 5;
		unsigned int level: 3;
		unsigned int is_self_initializing: 1;
		unsigned int is_fully_associative: 1;
		unsigned int reserved: 4;
		unsigned int num_threads_sharing: 12;
		unsigned int num_cores_on_die: 6;
	} split;
	u32 full;
};

union _cpuid4_leaf_ebx {
	struct {
		unsigned int coherency_line_size: 12;
		unsigned int physical_line_partition: 10;
		unsigned int ways_of_associativity: 10;
	} split;
	u32 full;
};

union _cpuid4_leaf_ecx {
	struct {
		unsigned int number_of_sets: 32;
	} split;
	u32 full;
};

struct _cpuid4_info_regs {
	union _cpuid4_leaf_eax eax;
	union _cpuid4_leaf_ebx ebx;
	union _cpuid4_leaf_ecx ecx;
	unsigned int id;
	long unsigned int size;
	struct amd_northbridge *nb;
};

union l1_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 8;
		unsigned int assoc: 8;
		unsigned int size_in_kb: 8;
	};
	unsigned int val;
};

union l2_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int size_in_kb: 16;
	};
	unsigned int val;
};

union l3_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int res: 2;
		unsigned int size_encoded: 14;
	};
	unsigned int val;
};

struct cpuid_bit {
	u16 feature;
	u8 reg;
	u8 bit;
	u32 level;
	u32 sub_leaf;
};

struct fixed_percpu_data {
	char gs_base[40];
	long unsigned int stack_canary;
};

enum cpuid_leafs {
	CPUID_1_EDX = 0,
	CPUID_8000_0001_EDX = 1,
	CPUID_8086_0001_EDX = 2,
	CPUID_LNX_1 = 3,
	CPUID_1_ECX = 4,
	CPUID_C000_0001_EDX = 5,
	CPUID_8000_0001_ECX = 6,
	CPUID_LNX_2 = 7,
	CPUID_LNX_3 = 8,
	CPUID_7_0_EBX = 9,
	CPUID_D_1_EAX = 10,
	CPUID_LNX_4 = 11,
	CPUID_7_1_EAX = 12,
	CPUID_8000_0008_EBX = 13,
	CPUID_6_EAX = 14,
	CPUID_8000_000A_EDX = 15,
	CPUID_7_ECX = 16,
	CPUID_8000_0007_EBX = 17,
	CPUID_7_EDX = 18,
};

struct cpu_dev {
	const char *c_vendor;
	const char *c_ident[2];
	void (*c_early_init)(struct cpuinfo_x86 *);
	void (*c_bsp_init)(struct cpuinfo_x86 *);
	void (*c_init)(struct cpuinfo_x86 *);
	void (*c_identify)(struct cpuinfo_x86 *);
	void (*c_detect_tlb)(struct cpuinfo_x86 *);
	int c_x86_vendor;
};

struct cpuid_dependent_feature {
	u32 feature;
	u32 level;
};

enum spectre_v2_mitigation {
	SPECTRE_V2_NONE = 0,
	SPECTRE_V2_RETPOLINE_GENERIC = 1,
	SPECTRE_V2_RETPOLINE_AMD = 2,
	SPECTRE_V2_IBRS_ENHANCED = 3,
};

enum spectre_v2_user_mitigation {
	SPECTRE_V2_USER_NONE = 0,
	SPECTRE_V2_USER_STRICT = 1,
	SPECTRE_V2_USER_STRICT_PREFERRED = 2,
	SPECTRE_V2_USER_PRCTL = 3,
	SPECTRE_V2_USER_SECCOMP = 4,
};

enum ssb_mitigation {
	SPEC_STORE_BYPASS_NONE = 0,
	SPEC_STORE_BYPASS_DISABLE = 1,
	SPEC_STORE_BYPASS_PRCTL = 2,
	SPEC_STORE_BYPASS_SECCOMP = 3,
};

enum l1tf_mitigations {
	L1TF_MITIGATION_OFF = 0,
	L1TF_MITIGATION_FLUSH_NOWARN = 1,
	L1TF_MITIGATION_FLUSH = 2,
	L1TF_MITIGATION_FLUSH_NOSMT = 3,
	L1TF_MITIGATION_FULL = 4,
	L1TF_MITIGATION_FULL_FORCE = 5,
};

enum mds_mitigations {
	MDS_MITIGATION_OFF = 0,
	MDS_MITIGATION_FULL = 1,
	MDS_MITIGATION_VMWERV = 2,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

enum vmx_l1d_flush_state {
	VMENTER_L1D_FLUSH_AUTO = 0,
	VMENTER_L1D_FLUSH_NEVER = 1,
	VMENTER_L1D_FLUSH_COND = 2,
	VMENTER_L1D_FLUSH_ALWAYS = 3,
	VMENTER_L1D_FLUSH_EPT_DISABLED = 4,
	VMENTER_L1D_FLUSH_NOT_REQUIRED = 5,
};

enum x86_hypervisor_type {
	X86_HYPER_NATIVE = 0,
	X86_HYPER_VMWARE = 1,
	X86_HYPER_MS_HYPERV = 2,
	X86_HYPER_XEN_PV = 3,
	X86_HYPER_XEN_HVM = 4,
	X86_HYPER_KVM = 5,
	X86_HYPER_JAILHOUSE = 6,
	X86_HYPER_ACRN = 7,
};

enum taa_mitigations {
	TAA_MITIGATION_OFF = 0,
	TAA_MITIGATION_UCODE_NEEDED = 1,
	TAA_MITIGATION_VERW = 2,
	TAA_MITIGATION_TSX_DISABLED = 3,
};

enum srbds_mitigations {
	SRBDS_MITIGATION_OFF = 0,
	SRBDS_MITIGATION_UCODE_NEEDED = 1,
	SRBDS_MITIGATION_FULL = 2,
	SRBDS_MITIGATION_TSX_OFF = 3,
	SRBDS_MITIGATION_HYPERVISOR = 4,
};

enum spectre_v1_mitigation {
	SPECTRE_V1_MITIGATION_NONE = 0,
	SPECTRE_V1_MITIGATION_AUTO = 1,
};

enum spectre_v2_mitigation_cmd {
	SPECTRE_V2_CMD_NONE = 0,
	SPECTRE_V2_CMD_AUTO = 1,
	SPECTRE_V2_CMD_FORCE = 2,
	SPECTRE_V2_CMD_RETPOLINE = 3,
	SPECTRE_V2_CMD_RETPOLINE_GENERIC = 4,
	SPECTRE_V2_CMD_RETPOLINE_AMD = 5,
};

enum spectre_v2_user_cmd {
	SPECTRE_V2_USER_CMD_NONE = 0,
	SPECTRE_V2_USER_CMD_AUTO = 1,
	SPECTRE_V2_USER_CMD_FORCE = 2,
	SPECTRE_V2_USER_CMD_PRCTL = 3,
	SPECTRE_V2_USER_CMD_PRCTL_IBPB = 4,
	SPECTRE_V2_USER_CMD_SECCOMP = 5,
	SPECTRE_V2_USER_CMD_SECCOMP_IBPB = 6,
};

enum ssb_mitigation_cmd {
	SPEC_STORE_BYPASS_CMD_NONE = 0,
	SPEC_STORE_BYPASS_CMD_AUTO = 1,
	SPEC_STORE_BYPASS_CMD_ON = 2,
	SPEC_STORE_BYPASS_CMD_PRCTL = 3,
	SPEC_STORE_BYPASS_CMD_SECCOMP = 4,
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

struct aperfmperf_sample {
	unsigned int khz;
	ktime_t time;
	u64 aperf;
	u64 mperf;
};

struct cpuid_dep {
	unsigned int feature;
	unsigned int depends;
};

enum vmx_feature_leafs {
	MISC_FEATURES = 0,
	PRIMARY_CTLS = 1,
	SECONDARY_CTLS = 2,
	NR_VMX_FEATURE_WORDS = 3,
};

struct _tlb_table {
	unsigned char descriptor;
	char tlb_type;
	unsigned int entries;
	char info[128];
};

enum tsx_ctrl_states {
	TSX_CTRL_ENABLE = 0,
	TSX_CTRL_DISABLE = 1,
	TSX_CTRL_NOT_SUPPORTED = 2,
};

enum split_lock_detect_state {
	sld_off = 0,
	sld_warn = 1,
	sld_fatal = 2,
};

struct sku_microcode {
	u8 model;
	u8 stepping;
	u32 microcode;
};

struct cpuid_regs {
	u32 eax;
	u32 ebx;
	u32 ecx;
	u32 edx;
};

enum pconfig_target {
	INVALID_TARGET = 0,
	MKTME_TARGET = 1,
	PCONFIG_TARGET_NR = 2,
};

enum {
	PCONFIG_CPUID_SUBLEAF_INVALID = 0,
	PCONFIG_CPUID_SUBLEAF_TARGETID = 1,
};

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
};

enum mf_flags {
	MF_COUNT_INCREASED = 1,
	MF_ACTION_REQUIRED = 2,
	MF_MUST_KILL = 4,
	MF_SOFT_OFFLINE = 8,
};

struct mce {
	__u64 status;
	__u64 misc;
	__u64 addr;
	__u64 mcgstatus;
	__u64 ip;
	__u64 tsc;
	__u64 time;
	__u8 cpuvendor;
	__u8 inject_flags;
	__u8 severity;
	__u8 pad;
	__u32 cpuid;
	__u8 cs;
	__u8 bank;
	__u8 cpu;
	__u8 finished;
	__u32 extcpu;
	__u32 socketid;
	__u32 apicid;
	__u64 mcgcap;
	__u64 synd;
	__u64 ipid;
	__u64 ppin;
	__u32 microcode;
	__u64 kflags;
};

enum mce_notifier_prios {
	MCE_PRIO_LOWEST = 0,
	MCE_PRIO_MCELOG = 1,
	MCE_PRIO_EDAC = 2,
	MCE_PRIO_NFIT = 3,
	MCE_PRIO_EXTLOG = 4,
	MCE_PRIO_UC = 5,
	MCE_PRIO_EARLY = 6,
	MCE_PRIO_CEC = 7,
};

typedef long unsigned int mce_banks_t[1];

enum mcp_flags {
	MCP_TIMESTAMP = 1,
	MCP_UC = 2,
	MCP_DONTLOG = 4,
};

enum severity_level {
	MCE_NO_SEVERITY = 0,
	MCE_DEFERRED_SEVERITY = 1,
	MCE_UCNA_SEVERITY = 1,
	MCE_KEEP_SEVERITY = 2,
	MCE_SOME_SEVERITY = 3,
	MCE_AO_SEVERITY = 4,
	MCE_UC_SEVERITY = 5,
	MCE_AR_SEVERITY = 6,
	MCE_PANIC_SEVERITY = 7,
};

struct mce_evt_llist {
	struct llist_node llnode;
	struct mce mce;
};

struct mca_config {
	bool dont_log_ce;
	bool cmci_disabled;
	bool ignore_ce;
	bool print_all;
	__u64 lmce_disabled: 1;
	__u64 disabled: 1;
	__u64 ser: 1;
	__u64 recovery: 1;
	__u64 bios_cmci_threshold: 1;
	int: 27;
	__u64 __reserved: 59;
	s8 bootlog;
	int tolerant;
	int monarch_timeout;
	int panic_timeout;
	u32 rip_msr;
};

struct mce_vendor_flags {
	__u64 overflow_recov: 1;
	__u64 succor: 1;
	__u64 smca: 1;
	__u64 amd_threshold: 1;
	__u64 __reserved_0: 60;
};

struct mca_msr_regs {
	u32 (*ctl)(int);
	u32 (*status)(int);
	u32 (*addr)(int);
	u32 (*misc)(int);
};

struct trace_event_raw_mce_record {
	struct trace_entry ent;
	u64 mcgcap;
	u64 mcgstatus;
	u64 status;
	u64 addr;
	u64 misc;
	u64 synd;
	u64 ipid;
	u64 ip;
	u64 tsc;
	u64 walltime;
	u32 cpu;
	u32 cpuid;
	u32 apicid;
	u32 socketid;
	u8 cs;
	u8 bank;
	u8 cpuvendor;
	char __data[0];
};

struct trace_event_data_offsets_mce_record {};

typedef void (*btf_trace_mce_record)(void *, struct mce *);

struct mce_bank {
	u64 ctl;
	bool init;
};

struct mce_bank_dev {
	struct device_attribute attr;
	char attrname[16];
	u8 bank;
};

enum handler_type {
	EX_HANDLER_NONE = 0,
	EX_HANDLER_FAULT = 1,
	EX_HANDLER_UACCESS = 2,
	EX_HANDLER_OTHER = 3,
};

enum context {
	IN_KERNEL = 1,
	IN_USER = 2,
	IN_KERNEL_RECOV = 3,
};

enum ser {
	SER_REQUIRED = 1,
	NO_SER = 2,
};

enum exception {
	EXCP_CONTEXT = 1,
	NO_EXCP = 2,
};

struct severity {
	u64 mask;
	u64 result;
	unsigned char sev;
	unsigned char mcgmask;
	unsigned char mcgres;
	unsigned char ser;
	unsigned char context;
	unsigned char excp;
	unsigned char covered;
	unsigned char cpu_model;
	unsigned char cpu_minstepping;
	unsigned char bank_lo;
	unsigned char bank_hi;
	char *msg;
};

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

enum {
	CMCI_STORM_NONE = 0,
	CMCI_STORM_ACTIVE = 1,
	CMCI_STORM_SUBSIDED = 2,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

enum smca_bank_types {
	SMCA_LS = 0,
	SMCA_LS_V2 = 1,
	SMCA_IF = 2,
	SMCA_L2_CACHE = 3,
	SMCA_DE = 4,
	SMCA_RESERVED = 5,
	SMCA_EX = 6,
	SMCA_FP = 7,
	SMCA_L3_CACHE = 8,
	SMCA_CS = 9,
	SMCA_CS_V2 = 10,
	SMCA_PIE = 11,
	SMCA_UMC = 12,
	SMCA_PB = 13,
	SMCA_PSP = 14,
	SMCA_PSP_V2 = 15,
	SMCA_SMU = 16,
	SMCA_SMU_V2 = 17,
	SMCA_MP5 = 18,
	SMCA_NBIO = 19,
	SMCA_PCIE = 20,
	N_SMCA_BANK_TYPES = 21,
};

struct smca_hwid {
	unsigned int bank_type;
	u32 hwid_mcatype;
	u8 count;
};

struct smca_bank {
	struct smca_hwid *hwid;
	u32 id;
	u8 sysfs_id;
};

struct smca_bank_name {
	const char *name;
	const char *long_name;
};

struct thresh_restart {
	struct threshold_block *b;
	int reset;
	int set_lvt_off;
	int lvt_off;
	u16 old_limit;
};

struct threshold_attr {
	struct attribute attr;
	ssize_t (*show)(struct threshold_block *, char *);
	ssize_t (*store)(struct threshold_block *, const char *, size_t);
};

struct _thermal_state {
	u64 next_check;
	u64 last_interrupt_time;
	struct delayed_work therm_work;
	long unsigned int count;
	long unsigned int last_count;
	long unsigned int max_time_ms;
	long unsigned int total_time_ms;
	bool rate_control_active;
	bool new_event;
	u8 level;
	u8 sample_index;
	u8 sample_count;
	u8 average;
	u8 baseline_temp;
	u8 temp_samples[3];
};

struct thermal_state {
	struct _thermal_state core_throttle;
	struct _thermal_state core_power_limit;
	struct _thermal_state package_throttle;
	struct _thermal_state package_power_limit;
	struct _thermal_state core_thresh0;
	struct _thermal_state core_thresh1;
	struct _thermal_state pkg_thresh0;
	struct _thermal_state pkg_thresh1;
};

typedef __u8 mtrr_type;

struct mtrr_ops {
	u32 vendor;
	u32 use_intel_if;
	void (*set)(unsigned int, long unsigned int, long unsigned int, mtrr_type);
	void (*set_all)();
	void (*get)(unsigned int, long unsigned int *, long unsigned int *, mtrr_type *);
	int (*get_free_region)(long unsigned int, long unsigned int, int);
	int (*validate_add_page)(long unsigned int, long unsigned int, unsigned int);
	int (*have_wrcomb)();
};

struct set_mtrr_data {
	long unsigned int smp_base;
	long unsigned int smp_size;
	unsigned int smp_reg;
	mtrr_type smp_type;
};

struct mtrr_value {
	mtrr_type ltype;
	long unsigned int lbase;
	long unsigned int lsize;
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*proc_compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

struct mtrr_sentry {
	__u64 base;
	__u32 size;
	__u32 type;
};

struct mtrr_gentry {
	__u64 base;
	__u32 size;
	__u32 regnum;
	__u32 type;
	__u32 _pad;
};

typedef u32 compat_uint_t;

struct mtrr_sentry32 {
	compat_ulong_t base;
	compat_uint_t size;
	compat_uint_t type;
};

struct mtrr_gentry32 {
	compat_ulong_t regnum;
	compat_uint_t base;
	compat_uint_t size;
	compat_uint_t type;
};

struct mtrr_var_range {
	__u32 base_lo;
	__u32 base_hi;
	__u32 mask_lo;
	__u32 mask_hi;
};

struct mtrr_state_type {
	struct mtrr_var_range var_ranges[256];
	mtrr_type fixed_ranges[88];
	unsigned char enabled;
	unsigned char have_fixed;
	mtrr_type def_type;
};

struct fixed_range_block {
	int base_msr;
	int ranges;
};

struct var_mtrr_range_state {
	long unsigned int base_pfn;
	long unsigned int size_pfn;
	mtrr_type type;
};

struct mpc_intsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbus;
	unsigned char srcbusirq;
	unsigned char dstapic;
	unsigned char dstirq;
};

enum mp_irq_source_types {
	mp_INT = 0,
	mp_NMI = 1,
	mp_SMI = 2,
	mp_ExtINT = 3,
};

typedef u64 acpi_physical_address;

typedef u32 acpi_status;

typedef void *acpi_handle;

typedef u8 acpi_adr_space_type;

struct acpi_subtable_header {
	u8 type;
	u8 length;
};

struct acpi_table_boot {
	struct acpi_table_header header;
	u8 cmos_index;
	u8 reserved[3];
};

struct acpi_hmat_structure {
	u16 type;
	u16 reserved;
	u32 length;
};

struct acpi_table_hpet {
	struct acpi_table_header header;
	u32 id;
	struct acpi_generic_address address;
	u8 sequence;
	u16 minimum_tick;
	u8 flags;
} __attribute__((packed));

struct acpi_table_madt {
	struct acpi_table_header header;
	u32 address;
	u32 flags;
};

enum acpi_madt_type {
	ACPI_MADT_TYPE_LOCAL_APIC = 0,
	ACPI_MADT_TYPE_IO_APIC = 1,
	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
	ACPI_MADT_TYPE_NMI_SOURCE = 3,
	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
	ACPI_MADT_TYPE_IO_SAPIC = 6,
	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
	ACPI_MADT_TYPE_RESERVED = 16,
};

struct acpi_madt_local_apic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u32 lapic_flags;
};

struct acpi_madt_io_apic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 address;
	u32 global_irq_base;
};

struct acpi_madt_interrupt_override {
	struct acpi_subtable_header header;
	u8 bus;
	u8 source_irq;
	u32 global_irq;
	u16 inti_flags;
} __attribute__((packed));

struct acpi_madt_nmi_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 global_irq;
};

struct acpi_madt_local_apic_nmi {
	struct acpi_subtable_header header;
	u8 processor_id;
	u16 inti_flags;
	u8 lint;
} __attribute__((packed));

struct acpi_madt_local_apic_override {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_madt_local_sapic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u8 eid;
	u8 reserved[3];
	u32 lapic_flags;
	u32 uid;
	char uid_string[1];
} __attribute__((packed));

struct acpi_madt_local_x2apic {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 local_apic_id;
	u32 lapic_flags;
	u32 uid;
};

struct acpi_madt_local_x2apic_nmi {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 uid;
	u8 lint;
	u8 reserved[3];
};

enum acpi_irq_model_id {
	ACPI_IRQ_MODEL_PIC = 0,
	ACPI_IRQ_MODEL_IOAPIC = 1,
	ACPI_IRQ_MODEL_IOSAPIC = 2,
	ACPI_IRQ_MODEL_PLATFORM = 3,
	ACPI_IRQ_MODEL_GIC = 4,
	ACPI_IRQ_MODEL_COUNT = 5,
};

union acpi_subtable_headers {
	struct acpi_subtable_header common;
	struct acpi_hmat_structure hmat;
};

typedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *, const long unsigned int);

struct acpi_subtable_proc {
	int id;
	acpi_tbl_entry_handler handler;
	int count;
};

typedef u32 phys_cpuid_t;

enum irq_alloc_type {
	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
	X86_IRQ_ALLOC_TYPE_HPET = 2,
	X86_IRQ_ALLOC_TYPE_PCI_MSI = 3,
	X86_IRQ_ALLOC_TYPE_PCI_MSIX = 4,
	X86_IRQ_ALLOC_TYPE_DMAR = 5,
	X86_IRQ_ALLOC_TYPE_UV = 6,
	X86_IRQ_ALLOC_TYPE_IOAPIC_GET_PARENT = 7,
	X86_IRQ_ALLOC_TYPE_HPET_GET_PARENT = 8,
};

struct IO_APIC_route_entry;

struct ioapic_alloc_info {
	int pin;
	int node;
	u32 trigger: 1;
	u32 polarity: 1;
	u32 valid: 1;
	struct IO_APIC_route_entry *entry;
};

struct IO_APIC_route_entry {
	__u32 vector: 8;
	__u32 delivery_mode: 3;
	__u32 dest_mode: 1;
	__u32 delivery_status: 1;
	__u32 polarity: 1;
	__u32 irr: 1;
	__u32 trigger: 1;
	__u32 mask: 1;
	__u32 __reserved_2: 15;
	__u32 __reserved_3: 24;
	__u32 dest: 8;
};

struct uv_alloc_info {
	int limit;
	int blade;
	long unsigned int offset;
	char *name;
};

struct irq_alloc_info {
	enum irq_alloc_type type;
	u32 flags;
	u32 devid;
	irq_hw_number_t hwirq;
	const struct cpumask *mask;
	struct msi_desc *desc;
	void *data;
	union {
		struct ioapic_alloc_info ioapic;
		struct uv_alloc_info uv;
	};
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

enum ioapic_domain_type {
	IOAPIC_DOMAIN_INVALID = 0,
	IOAPIC_DOMAIN_LEGACY = 1,
	IOAPIC_DOMAIN_STRICT = 2,
	IOAPIC_DOMAIN_DYNAMIC = 3,
};

struct ioapic_domain_cfg {
	enum ioapic_domain_type type;
	const struct irq_domain_ops *ops;
	struct device_node *dev;
};

struct wakeup_header {
	u16 video_mode;
	u32 pmode_entry;
	u16 pmode_cs;
	u32 pmode_cr0;
	u32 pmode_cr3;
	u32 pmode_cr4;
	u32 pmode_efer_low;
	u32 pmode_efer_high;
	u64 pmode_gdt;
	u32 pmode_misc_en_low;
	u32 pmode_misc_en_high;
	u32 pmode_behavior;
	u32 realmode_flags;
	u32 real_magic;
	u32 signature;
} __attribute__((packed));

struct cpc_reg {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_power_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_processor_cx {
	u8 valid;
	u8 type;
	u32 address;
	u8 entry_method;
	u8 index;
	u32 latency;
	u8 bm_sts_skip;
	char desc[32];
};

struct acpi_processor_flags {
	u8 power: 1;
	u8 performance: 1;
	u8 throttling: 1;
	u8 limit: 1;
	u8 bm_control: 1;
	u8 bm_check: 1;
	u8 has_cst: 1;
	u8 has_lpi: 1;
	u8 power_setup_done: 1;
	u8 bm_rld_set: 1;
	u8 need_hotplug_init: 1;
};

struct cstate_entry {
	struct {
		unsigned int eax;
		unsigned int ecx;
	} states[8];
};

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

struct vmcb_seg {
	u16 selector;
	u16 attrib;
	u32 limit;
	u64 base;
};

struct vmcb_save_area {
	struct vmcb_seg es;
	struct vmcb_seg cs;
	struct vmcb_seg ss;
	struct vmcb_seg ds;
	struct vmcb_seg fs;
	struct vmcb_seg gs;
	struct vmcb_seg gdtr;
	struct vmcb_seg ldtr;
	struct vmcb_seg idtr;
	struct vmcb_seg tr;
	u8 reserved_1[43];
	u8 cpl;
	u8 reserved_2[4];
	u64 efer;
	u8 reserved_3[112];
	u64 cr4;
	u64 cr3;
	u64 cr0;
	u64 dr7;
	u64 dr6;
	u64 rflags;
	u64 rip;
	u8 reserved_4[88];
	u64 rsp;
	u8 reserved_5[24];
	u64 rax;
	u64 star;
	u64 lstar;
	u64 cstar;
	u64 sfmask;
	u64 kernel_gs_base;
	u64 sysenter_cs;
	u64 sysenter_esp;
	u64 sysenter_eip;
	u64 cr2;
	u8 reserved_6[32];
	u64 g_pat;
	u64 dbgctl;
	u64 br_from;
	u64 br_to;
	u64 last_excp_from;
	u64 last_excp_to;
	u8 reserved_7[104];
	u64 reserved_8;
	u64 rcx;
	u64 rdx;
	u64 rbx;
	u64 reserved_9;
	u64 rbp;
	u64 rsi;
	u64 rdi;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u8 reserved_10[16];
	u64 sw_exit_code;
	u64 sw_exit_info_1;
	u64 sw_exit_info_2;
	u64 sw_scratch;
	u8 reserved_11[56];
	u64 xcr0;
	u8 valid_bitmap[16];
	u64 x87_state_gpa;
};

struct ghcb {
	struct vmcb_save_area save;
	u8 reserved_save[1016];
	u8 shared_buffer[2032];
	u8 reserved_1[10];
	u16 protocol_version;
	u32 ghcb_usage;
};

struct machine_ops {
	void (*restart)(char *);
	void (*halt)();
	void (*power_off)();
	void (*shutdown)();
	void (*crash_shutdown)(struct pt_regs *);
	void (*emergency_restart)();
};

typedef void (*nmi_shootdown_cb)(int, struct pt_regs *);

enum intercept_words {
	INTERCEPT_CR = 0,
	INTERCEPT_DR = 1,
	INTERCEPT_EXCEPTION = 2,
	INTERCEPT_WORD3 = 3,
	INTERCEPT_WORD4 = 4,
	INTERCEPT_WORD5 = 5,
	MAX_INTERCEPT = 6,
};

enum allow_write_msrs {
	MSR_WRITES_ON = 0,
	MSR_WRITES_OFF = 1,
	MSR_WRITES_DEFAULT = 2,
};

typedef struct __call_single_data call_single_data_t;

struct cpuid_regs_done {
	struct cpuid_regs regs;
	struct completion done;
};

struct intel_early_ops {
	resource_size_t (*stolen_size)(int, int, int);
	resource_size_t (*stolen_base)(int, int, int, resource_size_t);
};

struct chipset {
	u32 vendor;
	u32 device;
	u32 class;
	u32 class_mask;
	u32 flags;
	void (*f)(int, int, int);
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_SHARE_CPUCAPACITY = 64,
	SD_SHARE_PKG_RESOURCES = 128,
	SD_SERIALIZE = 256,
	SD_ASYM_PACKING = 512,
	SD_PREFER_SIBLING = 1024,
	SD_OVERLAP = 2048,
	SD_NUMA = 4096,
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int next_decay_max_lb_cost;
	u64 avg_scan_cost;
	unsigned int lb_count[3];
	unsigned int lb_failed[3];
	unsigned int lb_balanced[3];
	unsigned int lb_imbalance[3];
	unsigned int lb_gained[3];
	unsigned int lb_hot_gained[3];
	unsigned int lb_nobusyg[3];
	unsigned int lb_nobusyq[3];
	unsigned int alb_count;
	unsigned int alb_failed;
	unsigned int alb_pushed;
	unsigned int sbe_count;
	unsigned int sbe_balanced;
	unsigned int sbe_pushed;
	unsigned int sbf_count;
	unsigned int sbf_balanced;
	unsigned int sbf_pushed;
	unsigned int ttwu_wake_remote;
	unsigned int ttwu_move_affine;
	unsigned int ttwu_move_balance;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sched_group_capacity;

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

enum apic_intr_mode_id {
	APIC_PIC = 0,
	APIC_VIRTUAL_WIRE = 1,
	APIC_VIRTUAL_WIRE_NO_CONFIG = 2,
	APIC_SYMMETRIC_IO = 3,
	APIC_SYMMETRIC_IO_NO_ROUTING = 4,
};

struct tsc_adjust {
	s64 bootval;
	s64 adjusted;
	long unsigned int nextcheck;
	bool warned;
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

struct mpf_intel {
	char signature[4];
	unsigned int physptr;
	unsigned char length;
	unsigned char specification;
	unsigned char checksum;
	unsigned char feature1;
	unsigned char feature2;
	unsigned char feature3;
	unsigned char feature4;
	unsigned char feature5;
};

struct mpc_table {
	char signature[4];
	short unsigned int length;
	char spec;
	char checksum;
	char oem[8];
	char productid[12];
	unsigned int oemptr;
	short unsigned int oemsize;
	short unsigned int oemcount;
	unsigned int lapic;
	unsigned int reserved;
};

struct mpc_cpu {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char cpuflag;
	unsigned int cpufeature;
	unsigned int featureflag;
	unsigned int reserved[2];
};

struct mpc_bus {
	unsigned char type;
	unsigned char busid;
	unsigned char bustype[6];
};

struct mpc_ioapic {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char flags;
	unsigned int apicaddr;
};

struct mpc_lintsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbusid;
	unsigned char srcbusirq;
	unsigned char destapic;
	unsigned char destapiclint;
};

enum page_cache_mode {
	_PAGE_CACHE_MODE_WB = 0,
	_PAGE_CACHE_MODE_WC = 1,
	_PAGE_CACHE_MODE_UC_MINUS = 2,
	_PAGE_CACHE_MODE_UC = 3,
	_PAGE_CACHE_MODE_WT = 4,
	_PAGE_CACHE_MODE_WP = 5,
	_PAGE_CACHE_MODE_NUM = 8,
};

enum {
	IRQ_REMAP_XAPIC_MODE = 0,
	IRQ_REMAP_X2APIC_MODE = 1,
};

union apic_ir {
	long unsigned int map[4];
	u32 regs[8];
};

enum {
	X2APIC_OFF = 0,
	X2APIC_ON = 1,
	X2APIC_DISABLED = 2,
};

enum ioapic_irq_destination_types {
	dest_Fixed = 0,
	dest_LowestPrio = 1,
	dest_SMI = 2,
	dest__reserved_1 = 3,
	dest_NMI = 4,
	dest_INIT = 5,
	dest__reserved_2 = 6,
	dest_ExtINT = 7,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 1073741824,
};

struct irq_cfg {
	unsigned int dest_apicid;
	unsigned int vector;
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

enum {
	X86_IRQ_ALLOC_CONTIGUOUS_VECTORS = 1,
	X86_IRQ_ALLOC_LEGACY = 2,
};

struct apic_chip_data {
	struct irq_cfg hw_irq_cfg;
	unsigned int vector;
	unsigned int prev_vector;
	unsigned int cpu;
	unsigned int prev_cpu;
	unsigned int irq;
	struct hlist_node clist;
	unsigned int move_in_progress: 1;
	unsigned int is_managed: 1;
	unsigned int can_reserve: 1;
	unsigned int has_reserved: 1;
};

struct irq_matrix;

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
};

struct clock_event_device___2;

union IO_APIC_reg_00 {
	u32 raw;
	struct {
		u32 __reserved_2: 14;
		u32 LTS: 1;
		u32 delivery_type: 1;
		u32 __reserved_1: 8;
		u32 ID: 8;
	} bits;
};

union IO_APIC_reg_01 {
	u32 raw;
	struct {
		u32 version: 8;
		u32 __reserved_2: 7;
		u32 PRQ: 1;
		u32 entries: 8;
		u32 __reserved_1: 8;
	} bits;
};

union IO_APIC_reg_02 {
	u32 raw;
	struct {
		u32 __reserved_2: 24;
		u32 arbitration: 4;
		u32 __reserved_1: 4;
	} bits;
};

union IO_APIC_reg_03 {
	u32 raw;
	struct {
		u32 boot_DT: 1;
		u32 __reserved_1: 31;
	} bits;
};

struct IR_IO_APIC_route_entry {
	__u64 vector: 8;
	__u64 zero: 3;
	__u64 index2: 1;
	__u64 delivery_status: 1;
	__u64 polarity: 1;
	__u64 irr: 1;
	__u64 trigger: 1;
	__u64 mask: 1;
	__u64 reserved: 31;
	__u64 format: 1;
	__u64 index: 15;
};

struct irq_pin_list {
	struct list_head list;
	int apic;
	int pin;
};

struct mp_chip_data {
	struct list_head irq_2_pin;
	struct IO_APIC_route_entry entry;
	int trigger;
	int polarity;
	u32 count;
	bool isa_irq;
};

struct mp_ioapic_gsi {
	u32 gsi_base;
	u32 gsi_end;
};

struct ioapic {
	int nr_registers;
	struct IO_APIC_route_entry *saved_registers;
	struct mpc_ioapic mp_config;
	struct mp_ioapic_gsi gsi_config;
	struct ioapic_domain_cfg irqdomain_cfg;
	struct irq_domain *irqdomain;
	struct resource *iomem_res;
};

struct io_apic {
	unsigned int index;
	unsigned int unused[3];
	unsigned int data;
	unsigned int unused2[11];
	unsigned int eoi;
};

union entry_union {
	struct {
		u32 w1;
		u32 w2;
	};
	struct IO_APIC_route_entry entry;
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

typedef struct irq_alloc_info msi_alloc_info_t;

struct msi_domain_info;

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*msi_finish)(msi_alloc_info_t *, int);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*handle_error)(struct irq_domain *, struct msi_desc *, int);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
};

struct msi_domain_info {
	u32 flags;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_MULTI_PCI_MSI = 4,
	MSI_FLAG_PCI_MSIX = 8,
	MSI_FLAG_ACTIVATE_EARLY = 16,
	MSI_FLAG_MUST_REACTIVATE = 32,
	MSI_FLAG_LEVEL_CAPABLE = 64,
};

struct hpet_channel;

struct cluster_mask {
	unsigned int clusterid;
	int node;
	struct cpumask mask;
};

struct dyn_arch_ftrace {};

enum {
	FTRACE_OPS_FL_ENABLED = 1,
	FTRACE_OPS_FL_DYNAMIC = 2,
	FTRACE_OPS_FL_SAVE_REGS = 4,
	FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED = 8,
	FTRACE_OPS_FL_RECURSION_SAFE = 16,
	FTRACE_OPS_FL_STUB = 32,
	FTRACE_OPS_FL_INITIALIZED = 64,
	FTRACE_OPS_FL_DELETED = 128,
	FTRACE_OPS_FL_ADDING = 256,
	FTRACE_OPS_FL_REMOVING = 512,
	FTRACE_OPS_FL_MODIFYING = 1024,
	FTRACE_OPS_FL_ALLOC_TRAMP = 2048,
	FTRACE_OPS_FL_IPMODIFY = 4096,
	FTRACE_OPS_FL_PID = 8192,
	FTRACE_OPS_FL_RCU = 16384,
	FTRACE_OPS_FL_TRACE_ARRAY = 32768,
	FTRACE_OPS_FL_PERMANENT = 65536,
	FTRACE_OPS_FL_DIRECT = 131072,
};

enum {
	FTRACE_FL_ENABLED = 2147483648,
	FTRACE_FL_REGS = 1073741824,
	FTRACE_FL_REGS_EN = 536870912,
	FTRACE_FL_TRAMP = 268435456,
	FTRACE_FL_TRAMP_EN = 134217728,
	FTRACE_FL_IPMODIFY = 67108864,
	FTRACE_FL_DISABLED = 33554432,
	FTRACE_FL_DIRECT = 16777216,
	FTRACE_FL_DIRECT_EN = 8388608,
};

struct dyn_ftrace {
	long unsigned int ip;
	long unsigned int flags;
	struct dyn_arch_ftrace arch;
};

enum {
	FTRACE_UPDATE_IGNORE = 0,
	FTRACE_UPDATE_MAKE_CALL = 1,
	FTRACE_UPDATE_MODIFY_CALL = 2,
	FTRACE_UPDATE_MAKE_NOP = 3,
};

union ftrace_op_code_union {
	char code[7];
	struct {
		char op[3];
		int offset;
	} __attribute__((packed));
};

struct ftrace_rec_iter;

struct kimage_arch {
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	void *elf_headers;
	long unsigned int elf_headers_sz;
	long unsigned int elf_load_addr;
};

typedef long unsigned int kimage_entry_t;

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
};

struct x86_mapping_info {
	void * (*alloc_pgt_page)(void *);
	void *context;
	long unsigned int page_flag;
	long unsigned int offset;
	bool direct_gbpages;
	long unsigned int kernpg_flag;
};

struct init_pgtable_data {
	struct x86_mapping_info *info;
	pgd_t *level4p;
};

typedef void crash_vmclear_fn();

struct prev_kprobe {
	struct kprobe *kp;
	long unsigned int status;
	long unsigned int old_flags;
	long unsigned int saved_flags;
};

struct kprobe_ctlblk {
	long unsigned int kprobe_status;
	long unsigned int kprobe_old_flags;
	long unsigned int kprobe_saved_flags;
	struct prev_kprobe prev_kprobe;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe;

struct kretprobe_instance {
	union {
		struct hlist_node hlist;
		struct callback_head rcu;
	};
	struct kretprobe *rp;
	kprobe_opcode_t *ret_addr;
	struct task_struct *task;
	void *fp;
	char data[0];
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct hlist_head free_instances;
	raw_spinlock_t lock;
};

struct kretprobe_blackpoint {
	const char *name;
	void *addr;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

struct __arch_relative_insn {
	u8 op;
	s32 raddr;
} __attribute__((packed));

struct arch_optimized_insn {
	kprobe_opcode_t copied_insn[4];
	kprobe_opcode_t *insn;
	size_t size;
};

struct optimized_kprobe {
	struct kprobe kp;
	struct list_head list;
	struct arch_optimized_insn optinsn;
};

typedef __u64 Elf64_Off;

typedef __s64 Elf64_Sxword;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	void *data;
	struct console *next;
};

struct hpet_data {
	long unsigned int hd_phys_address;
	void *hd_address;
	short unsigned int hd_nirqs;
	unsigned int hd_state;
	unsigned int hd_irq[32];
};

typedef irqreturn_t (*rtc_irq_handler)(int, void *);

enum hpet_mode {
	HPET_MODE_UNUSED = 0,
	HPET_MODE_LEGACY = 1,
	HPET_MODE_CLOCKEVT = 2,
	HPET_MODE_DEVICE = 3,
};

struct hpet_channel___2 {
	struct clock_event_device evt;
	unsigned int num;
	unsigned int cpu;
	unsigned int irq;
	unsigned int in_use;
	enum hpet_mode mode;
	unsigned int boot_cfg;
	char name[10];
	long: 48;
	long: 64;
	long: 64;
	long: 64;
};

struct hpet_base {
	unsigned int nr_channels;
	unsigned int nr_clockevents;
	unsigned int boot_cfg;
	struct hpet_channel___2 *channels;
};

union hpet_lock {
	struct {
		arch_spinlock_t lock;
		u32 value;
	};
	u64 lockval;
};

struct amd_nb_bus_dev_range {
	u8 bus;
	u8 dev_base;
	u8 dev_limit;
};

struct amd_northbridge_info {
	u16 num;
	u64 flags;
	struct amd_northbridge *nb;
};

struct property_entry;

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

enum swiotlb_force {
	SWIOTLB_NORMAL = 0,
	SWIOTLB_FORCE = 1,
	SWIOTLB_NO_FORCE = 2,
};

struct uprobe_xol_ops;

struct arch_uprobe {
	union {
		u8 insn[16];
		u8 ixol[16];
	};
	const struct uprobe_xol_ops *ops;
	union {
		struct {
			s32 offs;
			u8 ilen;
			u8 opc1;
		} branch;
		struct {
			u8 fixups;
			u8 ilen;
		} defparam;
		struct {
			u8 reg_offset;
			u8 ilen;
		} push;
	};
};

struct uprobe_xol_ops {
	bool (*emulate)(struct arch_uprobe *, struct pt_regs *);
	int (*pre_xol)(struct arch_uprobe *, struct pt_regs *);
	int (*post_xol)(struct arch_uprobe *, struct pt_regs *);
	void (*abort)(struct arch_uprobe *, struct pt_regs *);
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

struct simplefb_platform_data {
	u32 width;
	u32 height;
	u32 stride;
	const char *format;
};

enum {
	M_I17 = 0,
	M_I20 = 1,
	M_I20_SR = 2,
	M_I24 = 3,
	M_I24_8_1 = 4,
	M_I24_10_1 = 5,
	M_I27_11_1 = 6,
	M_MINI = 7,
	M_MINI_3_1 = 8,
	M_MINI_4_1 = 9,
	M_MB = 10,
	M_MB_2 = 11,
	M_MB_3 = 12,
	M_MB_5_1 = 13,
	M_MB_6_1 = 14,
	M_MB_7_1 = 15,
	M_MB_SR = 16,
	M_MBA = 17,
	M_MBA_3 = 18,
	M_MBP = 19,
	M_MBP_2 = 20,
	M_MBP_2_2 = 21,
	M_MBP_SR = 22,
	M_MBP_4 = 23,
	M_MBP_5_1 = 24,
	M_MBP_5_2 = 25,
	M_MBP_5_3 = 26,
	M_MBP_6_1 = 27,
	M_MBP_6_2 = 28,
	M_MBP_7_1 = 29,
	M_MBP_8_2 = 30,
	M_UNKNOWN = 31,
};

struct efifb_dmi_info {
	char *optname;
	long unsigned int base;
	int stride;
	int width;
	int height;
	int flags;
};

enum {
	OVERRIDE_NONE = 0,
	OVERRIDE_BASE = 1,
	OVERRIDE_STRIDE = 2,
	OVERRIDE_HEIGHT = 4,
	OVERRIDE_WIDTH = 8,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

struct __va_list_tag {
	unsigned int gp_offset;
	unsigned int fp_offset;
	void *overflow_arg_area;
	void *reg_save_area;
};

typedef __builtin_va_list __gnuc_va_list;

typedef __gnuc_va_list va_list;

struct va_format {
	const char *fmt;
	va_list *va;
};

enum chipset_type {
	NOT_SUPPORTED = 0,
	SUPPORTED = 1,
};

struct agp_version {
	u16 major;
	u16 minor;
};

struct agp_kern_info {
	struct agp_version version;
	struct pci_dev *device;
	enum chipset_type chipset;
	long unsigned int mode;
	long unsigned int aper_base;
	size_t aper_size;
	int max_memory;
	int current_memory;
	bool cant_use_aperture;
	long unsigned int page_mask;
	const struct vm_operations_struct *vm_ops;
};

struct agp_bridge_data;

struct pci_hostbridge_probe {
	u32 bus;
	u32 slot;
	u32 vendor;
	u32 device;
};

typedef u16 uint16_t;

enum pg_level {
	PG_LEVEL_NONE = 0,
	PG_LEVEL_4K = 1,
	PG_LEVEL_2M = 2,
	PG_LEVEL_1G = 3,
	PG_LEVEL_512G = 4,
	PG_LEVEL_NUM = 5,
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

enum tlb_flush_reason {
	TLB_FLUSH_ON_TASK_SWITCH = 0,
	TLB_REMOTE_SHOOTDOWN = 1,
	TLB_LOCAL_SHOOTDOWN = 2,
	TLB_LOCAL_MM_SHOOTDOWN = 3,
	TLB_REMOTE_SEND_IPI = 4,
	NR_TLB_FLUSH_REASONS = 5,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct trace_event_raw_tlb_flush {
	struct trace_entry ent;
	int reason;
	long unsigned int pages;
	char __data[0];
};

struct trace_event_data_offsets_tlb_flush {};

typedef void (*btf_trace_tlb_flush)(void *, int, long unsigned int);

struct map_range {
	long unsigned int start;
	long unsigned int end;
	unsigned int page_size_mask;
};

struct mem_section_usage {
	long unsigned int subsection_map[1];
	long unsigned int pageblock_flags[0];
};

struct mem_section {
	long unsigned int section_mem_map;
	struct mem_section_usage *usage;
};

enum kcore_type {
	KCORE_TEXT = 0,
	KCORE_VMALLOC = 1,
	KCORE_RAM = 2,
	KCORE_VMEMMAP = 3,
	KCORE_USER = 4,
	KCORE_OTHER = 5,
	KCORE_REMAP = 6,
};

struct kcore_list {
	struct list_head list;
	long unsigned int addr;
	long unsigned int vaddr;
	size_t size;
	int type;
};

struct hstate {
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[64];
	unsigned int nr_huge_pages_node[64];
	unsigned int free_huge_pages_node[64];
	unsigned int surplus_huge_pages_node[64];
	struct cftype cgroup_files_dfl[7];
	struct cftype cgroup_files_legacy[9];
	char name[32];
};

struct trace_event_raw_x86_exceptions {
	struct trace_entry ent;
	long unsigned int address;
	long unsigned int ip;
	long unsigned int error_code;
	char __data[0];
};

struct trace_event_data_offsets_x86_exceptions {};

typedef void (*btf_trace_page_fault_user)(void *, long unsigned int, struct pt_regs *, long unsigned int);

typedef void (*btf_trace_page_fault_kernel)(void *, long unsigned int, struct pt_regs *, long unsigned int);

enum {
	IORES_MAP_SYSTEM_RAM = 1,
	IORES_MAP_ENCRYPTED = 2,
};

struct ioremap_desc {
	unsigned int flags;
};

typedef bool (*ex_handler_t)(const struct exception_table_entry *, struct pt_regs *, int, long unsigned int, long unsigned int);

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct flush_tlb_info {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	u64 new_tlb_gen;
	unsigned int stride_shift;
	bool freed_tables;
};

struct entry_stack_page {
	struct entry_stack stack;
};

struct debug_store_buffers {
	char bts_buffer[65536];
	char pebs_buffer[65536];
};

struct exception_stacks {
	char DF_stack_guard[0];
	char DF_stack[4096];
	char NMI_stack_guard[0];
	char NMI_stack[4096];
	char DB_stack_guard[0];
	char DB_stack[4096];
	char MCE_stack_guard[0];
	char MCE_stack[4096];
	char VC_stack_guard[0];
	char VC_stack[0];
	char VC2_stack_guard[0];
	char VC2_stack[0];
	char IST_top_guard[0];
};

struct cpu_entry_area {
	char gdt[4096];
	struct entry_stack_page entry_stack_page;
	struct tss_struct tss;
	struct cea_exception_stacks estacks;
	struct debug_store cpu_debug_store;
	struct debug_store_buffers cpu_debug_buffers;
};

struct cpa_data {
	long unsigned int *vaddr;
	pgd_t *pgd;
	pgprot_t mask_set;
	pgprot_t mask_clr;
	long unsigned int numpages;
	long unsigned int curpage;
	long unsigned int pfn;
	unsigned int flags;
	unsigned int force_split: 1;
	unsigned int force_static_prot: 1;
	unsigned int force_flush_all: 1;
	struct page **pages;
};

enum cpa_warn {
	CPA_CONFLICT = 0,
	CPA_PROTECT = 1,
	CPA_DETECT = 2,
};

typedef struct {
	u64 val;
} pfn_t;

struct memtype {
	u64 start;
	u64 end;
	u64 subtree_max_end;
	enum page_cache_mode type;
	struct rb_node rb;
};

enum {
	PAT_UC = 0,
	PAT_WC = 1,
	PAT_WT = 4,
	PAT_WP = 5,
	PAT_WB = 6,
	PAT_UC_MINUS = 7,
};

struct pagerange_state {
	long unsigned int cur_pfn;
	int ram;
	int not_ram;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum {
	MEMTYPE_EXACT_MATCH = 0,
	MEMTYPE_END_MATCH = 1,
};

struct numa_memblk {
	u64 start;
	u64 end;
	int nid;
};

struct numa_meminfo {
	int nr_blks;
	struct numa_memblk blk[128];
};

struct acpi_srat_cpu_affinity {
	struct acpi_subtable_header header;
	u8 proximity_domain_lo;
	u8 apic_id;
	u32 flags;
	u8 local_sapic_eid;
	u8 proximity_domain_hi[3];
	u32 clock_domain;
};

struct acpi_srat_x2apic_cpu_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 apic_id;
	u32 flags;
	u32 clock_domain;
	u32 reserved2;
};

enum uv_system_type {
	UV_NONE = 0,
	UV_LEGACY_APIC = 1,
	UV_X2APIC = 2,
};

enum pti_mode {
	PTI_AUTO = 0,
	PTI_FORCE_OFF = 1,
	PTI_FORCE_ON = 2,
};

enum pti_clone_level {
	PTI_CLONE_PMD = 0,
	PTI_CLONE_PTE = 1,
};

struct sigcontext_32 {
	__u16 gs;
	__u16 __gsh;
	__u16 fs;
	__u16 __fsh;
	__u16 es;
	__u16 __esh;
	__u16 ds;
	__u16 __dsh;
	__u32 di;
	__u32 si;
	__u32 bp;
	__u32 sp;
	__u32 bx;
	__u32 dx;
	__u32 cx;
	__u32 ax;
	__u32 trapno;
	__u32 err;
	__u32 ip;
	__u16 cs;
	__u16 __csh;
	__u32 flags;
	__u32 sp_at_signal;
	__u16 ss;
	__u16 __ssh;
	__u32 fpstate;
	__u32 oldmask;
	__u32 cr2;
};

typedef u32 compat_size_t;

struct compat_sigaltstack {
	compat_uptr_t ss_sp;
	int ss_flags;
	compat_size_t ss_size;
};

typedef struct compat_sigaltstack compat_stack_t;

struct ucontext_ia32 {
	unsigned int uc_flags;
	unsigned int uc_link;
	compat_stack_t uc_stack;
	struct sigcontext_32 uc_mcontext;
	compat_sigset_t uc_sigmask;
};

struct sigframe_ia32 {
	u32 pretcode;
	int sig;
	struct sigcontext_32 sc;
	struct _fpstate_32 fpstate_unused;
	unsigned int extramask[1];
	char retcode[8];
};

struct rt_sigframe_ia32 {
	u32 pretcode;
	int sig;
	u32 pinfo;
	u32 puc;
	compat_siginfo_t info;
	struct ucontext_ia32 uc;
	char retcode[8];
};

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
};

struct efi_runtime_work {
	void *arg1;
	void *arg2;
	void *arg3;
	void *arg4;
	void *arg5;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
};

struct efi_scratch {
	u64 phys_stack;
	struct mm_struct *prev_mm;
};

struct efi_setup_data {
	u64 fw_vendor;
	u64 __unused;
	u64 tables;
	u64 smbios;
	u64 reserved[8];
};

typedef struct {
	efi_guid_t guid;
	long unsigned int *ptr;
	const char name[16];
} efi_config_table_type_t;

typedef struct {
	efi_table_hdr_t hdr;
	u64 fw_vendor;
	u32 fw_revision;
	u32 __pad1;
	u64 con_in_handle;
	u64 con_in;
	u64 con_out_handle;
	u64 con_out;
	u64 stderr_handle;
	u64 stderr;
	u64 runtime;
	u64 boottime;
	u32 nr_tables;
	u32 __pad2;
	u64 tables;
} efi_system_table_64_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

typedef struct {
	u32 version;
	u32 length;
	u64 memory_protection_attribute;
} efi_properties_table_t;

union efi_boot_services;

typedef union efi_boot_services efi_boot_services_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		long unsigned int fw_vendor;
		u32 fw_revision;
		long unsigned int con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		long unsigned int con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		long unsigned int stderr_handle;
		long unsigned int stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		long unsigned int nr_tables;
		long unsigned int tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

struct bpf_tramp_progs {
	struct bpf_prog *progs[40];
	int nr_progs;
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

struct bpf_array_aux {
	enum bpf_prog_type type;
	bool jited;
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

struct bpf_binary_header {
	u32 pages;
	int: 32;
	u8 image[0];
};

struct jit_context {
	int cleanup_addr;
};

struct x64_jit_data {
	struct bpf_binary_header *header;
	int *addrs;
	u8 *image;
	int proglen;
	struct jit_context ctx;
};

struct static_key_true {
	struct static_key key;
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

typedef struct pglist_data pg_data_t;

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
};

struct io_identity {
	struct files_struct *files;
	struct mm_struct *mm;
	struct cgroup_subsys_state *blkcg_css;
	const struct cred *creds;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	long unsigned int fsize;
	kuid_t loginuid;
	unsigned int sessionid;
	refcount_t count;
};

struct io_uring_task {
	struct xarray xa;
	struct wait_queue_head wait;
	struct file *last;
	struct percpu_counter inflight;
	struct io_identity __identity;
	struct io_identity *identity;
	atomic_t in_idle;
	bool sqpoll;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

enum page_memcg_data_flags {
	MEMCG_DATA_OBJCGS = 1,
	MEMCG_DATA_KMEM = 2,
	__NR_MEMCG_DATA_FLAGS = 4,
};

typedef struct poll_table_struct poll_table;

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

typedef struct {} mm_segment_t;

struct compat_rusage {
	struct old_timeval32 ru_utime;
	struct old_timeval32 ru_stime;
	compat_long_t ru_maxrss;
	compat_long_t ru_ixrss;
	compat_long_t ru_idrss;
	compat_long_t ru_isrss;
	compat_long_t ru_minflt;
	compat_long_t ru_majflt;
	compat_long_t ru_nswap;
	compat_long_t ru_inblock;
	compat_long_t ru_oublock;
	compat_long_t ru_msgsnd;
	compat_long_t ru_msgrcv;
	compat_long_t ru_nsignals;
	compat_long_t ru_nvcsw;
	compat_long_t ru_nivcsw;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

typedef void (*dr_release_t)(struct device *, void *);

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct user_struct *user;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

typedef long unsigned int old_sigset_t;

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_MCEERR = 4,
	SIL_FAULT_BNDERR = 5,
	SIL_FAULT_PKUERR = 6,
	SIL_CHLD = 7,
	SIL_RT = 8,
	SIL_SYS = 9,
};

struct fd {
	struct file *file;
	unsigned int flags;
};

typedef u32 compat_old_sigset_t;

struct compat_sigaction {
	compat_uptr_t sa_handler;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
	compat_sigset_t sa_mask;
};

struct compat_old_sigaction {
	compat_uptr_t sa_handler;
	compat_old_sigset_t sa_mask;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

typedef __kernel_clock_t clock_t;

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct oldold_utsname {
	char sysname[9];
	char nodename[9];
	char release[9];
	char version[9];
	char machine[9];
};

struct old_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
};

enum uts_proc {
	UTS_PROC_OSTYPE = 0,
	UTS_PROC_OSRELEASE = 1,
	UTS_PROC_VERSION = 2,
	UTS_PROC_HOSTNAME = 3,
	UTS_PROC_DOMAINNAME = 4,
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct compat_tms {
	compat_clock_t tms_utime;
	compat_clock_t tms_stime;
	compat_clock_t tms_cutime;
	compat_clock_t tms_cstime;
};

struct compat_rlimit {
	compat_ulong_t rlim_cur;
	compat_ulong_t rlim_max;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

struct compat_sysinfo {
	s32 uptime;
	u32 loads[3];
	u32 totalram;
	u32 freeram;
	u32 sharedram;
	u32 bufferram;
	u32 totalswap;
	u32 freeswap;
	u16 procs;
	u16 pad;
	u32 totalhigh;
	u32 freehigh;
	u32 mem_unit;
	char _f[8];
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	long: 64;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

typedef unsigned int xa_mark_t;

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct ida {
	struct xarray xa;
};

struct __una_u32 {
	u32 x;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[15];
	int nr_active;
	int max_active;
	struct list_head delayed_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t nr_running;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 300000,
	MAYDAY_INITIAL_TIMEOUT = 10,
	MAYDAY_INTERVAL = 100,
	CREATE_COOLDOWN = 1000,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *workqueue;
	unsigned int req_cpu;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_queue_work {};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

typedef void (*btf_trace_workqueue_queue_work)(void *, unsigned int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

typedef struct {} local_lock_t;

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct sched_param {
	int sched_priority;
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	int (*threadfn)(void *);
	void *data;
	mm_segment_t oldfs;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct pt_regs___2;

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	refcount_t count;
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	atomic_t msg_bytes;
	atomic_t msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct umd_info {
	const char *driver_name;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct path wd;
	struct pid *tgid;
};

struct pin_cookie {};

struct preempt_notifier;

struct preempt_ops {
	void (*sched_in)(struct preempt_notifier *, int);
	void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};

struct preempt_notifier {
	struct hlist_node link;
	struct preempt_ops *ops;
};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[102];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
};

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_h_nr_running;
	u64 exec_clock;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	unsigned int nr_spread_over;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		long: 64;
	} removed;
	long unsigned int tg_load_avg_contrib;
	long int propagate;
	long int prop_runnable_sum;
	long unsigned int h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int runtime_enabled;
	s64 runtime_remaining;
	u64 throttled_clock;
	u64 throttled_clock_task;
	u64 throttled_clock_task_time;
	int throttled;
	int throttle_count;
	struct list_head throttled_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cfs_bandwidth {
	raw_spinlock_t lock;
	ktime_t period;
	u64 quota;
	u64 runtime;
	s64 hierarchical_quota;
	u8 idle;
	u8 period_active;
	u8 slack_started;
	struct hrtimer period_timer;
	struct hrtimer slack_timer;
	struct list_head throttled_cfs_rq;
	int nr_periods;
	int nr_throttled;
	u64 throttled_time;
};

struct task_group {
	struct cgroup_subsys_state css;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	long unsigned int shares;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct cfs_bandwidth cfs_bandwidth;
	long: 64;
	long: 64;
};

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	int id;
	long unsigned int cpumask[0];
};

struct em_perf_state {
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
};

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	long unsigned int cpus[0];
};

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_USER = 1,
	CONTEXT_GUEST = 2,
};

struct kernel_cpustat {
	u64 cpustat[10];
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int success;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 delay;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_process_hang {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_stat_template {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_process_hang {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_wait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_sleep)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_iowait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_blocked)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_hang)(void *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	u64 exit_latency_ns;
	u64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_driver_kobj;

struct cpuidle_state_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	u64 dl_runtime;
	u64 dl_period;
};

typedef int (*tg_visitor)(struct task_group *, void *);

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	long unsigned int rt_nr_migratory;
	long unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
};

struct dl_rq {
	struct rb_root_cached root;
	long unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	long unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

struct rq {
	raw_spinlock_t lock;
	unsigned int nr_running;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
	unsigned int numa_migrate_on;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 32;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	long unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	long: 64;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	struct callback_head *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	long unsigned int calc_load_update;
	long int calc_load_active;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	struct sched_info rq_sched_info;
	long long unsigned int rq_cpu_time;
	unsigned int yld_count;
	unsigned int sched_count;
	unsigned int sched_goidle;
	unsigned int ttwu_count;
	unsigned int ttwu_local;
	struct cpuidle_state *idle_state;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
	unsigned int clock_update_flags;
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_DOUBLE_TICK = 7,
	__SCHED_FEAT_NONTASK_CAPACITY = 8,
	__SCHED_FEAT_TTWU_QUEUE = 9,
	__SCHED_FEAT_SIS_AVG_CPU = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 12,
	__SCHED_FEAT_RT_PUSH_IPI = 13,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 14,
	__SCHED_FEAT_LB_MIN = 15,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 16,
	__SCHED_FEAT_WA_IDLE = 17,
	__SCHED_FEAT_WA_WEIGHT = 18,
	__SCHED_FEAT_WA_BIAS = 19,
	__SCHED_FEAT_UTIL_EST = 20,
	__SCHED_FEAT_UTIL_EST_FASTUP = 21,
	__SCHED_FEAT_NR = 22,
};

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
};

struct migration_swap_arg {
	struct task_struct *src_task;
	struct task_struct *dst_task;
	int src_cpu;
	int dst_cpu;
};

struct cfs_schedulable_data {
	struct task_group *tg;
	u64 period;
	u64 quota;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

struct sched_clock_data {
	u64 tick_raw;
	u64 tick_gtod;
	u64 clock;
};

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

typedef void (*rcu_callback_t)(struct callback_head *);

struct numa_group {
	refcount_t refcount;
	spinlock_t lock;
	int nr_tasks;
	pid_t gid;
	int active_nodes;
	struct callback_head rcu;
	long unsigned int total_faults;
	long unsigned int max_faults_cpu;
	long unsigned int *faults_cpu;
	long unsigned int faults[0];
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum numa_faults_stats {
	NUMA_MEM = 0,
	NUMA_CPU = 1,
	NUMA_MEMBUF = 2,
	NUMA_CPUBUF = 3,
};

enum schedutil_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

enum numa_type {
	node_has_spare = 0,
	node_fully_busy = 1,
	node_overloaded = 2,
};

struct numa_stats {
	long unsigned int load;
	long unsigned int runnable;
	long unsigned int util;
	long unsigned int compute_capacity;
	unsigned int nr_running;
	unsigned int weight;
	enum numa_type node_type;
	int idle_cpu;
};

struct task_numa_env {
	struct task_struct *p;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	struct numa_stats src_stats;
	struct numa_stats dst_stats;
	int imbalance_pct;
	int dist;
	struct task_struct *best_task;
	long int best_imp;
	int best_cpu;
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_asym_packing = 3,
	group_imbalanced = 4,
	group_overloaded = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	long unsigned int group_misfit_task_load;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

typedef struct rt_rq *rt_rq_iter_t;

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct sd_flag_debug {
	unsigned int meta_flags;
	char *name;
};

struct sched_domain_attr {
	int relax_domain_level;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

struct cpuacct_usage {
	u64 usages[2];
};

struct cpuacct {
	struct cgroup_subsys_state css;
	struct cpuacct_usage *cpuusage;
	struct kernel_cpustat *cpustat;
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int bw_dl;
	long unsigned int max;
	long unsigned int saved_idle_calls;
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

enum psi_res {
	PSI_IO = 0,
	PSI_MEM = 1,
	PSI_CPU = 2,
	NR_PSI_RESOURCES = 3,
};

struct psi_window {
	u64 size;
	u64 start_time;
	u64 start_value;
	u64 prev_growth;
};

struct psi_trigger {
	enum psi_states state;
	u64 threshold;
	struct list_head node;
	struct psi_group *group;
	wait_queue_head_t event_wait;
	int event;
	struct psi_window win;
	u64 last_event_time;
	struct kref refcount;
};

enum mutex_trylock_recursive_enum {
	MUTEX_TRYLOCK_FAILED = 0,
	MUTEX_TRYLOCK_SUCCESS = 1,
	MUTEX_TRYLOCK_RECURSIVE = 2,
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	long unsigned int last_rowner;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum writer_wait_state {
	WRITER_NOT_FIRST = 0,
	WRITER_FIRST = 1,
	WRITER_HANDOFF = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked;
	int count;
};

struct qnode {
	struct mcs_spinlock mcs;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct rt_mutex;

struct rt_mutex_waiter {
	struct rb_node tree_entry;
	struct rb_node pi_tree_entry;
	struct task_struct *task;
	struct rt_mutex *lock;
	long unsigned int ip;
	struct pid *deadlock_task_pid;
	struct rt_mutex *deadlock_lock;
	int prio;
	u64 deadline;
};

struct rt_mutex {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
	int save_state;
	const char *name;
	const char *file;
	int line;
	void *magic;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

typedef int suspend_state_t;

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	enum suspend_stat_step failed_steps[2];
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct sysrq_key_op {
	void (* const handler)(int);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool active;
	bool registered;
	u32 cur_idx;
	u32 next_idx;
	u64 cur_seq;
	u64 next_seq;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

enum desc_state {
	desc_miss = 4294967295,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum log_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

struct devkmsg_user {
	u64 seq;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
	struct printk_info info;
	char text_buf[8192];
	struct printk_record record;
};

struct printk_safe_seq_buf {
	atomic_t len;
	atomic_t message_lost;
	struct irq_work work;
	unsigned char buffer[8160];
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQF_MODIFY_MASK = 2096911,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

struct cpumap {
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int managed_allocated;
	bool initialized;
	bool online;
	long unsigned int alloc_map[4];
	long unsigned int managed_map[4];
};

struct irq_matrix___2 {
	unsigned int matrix_bits;
	unsigned int alloc_start;
	unsigned int alloc_end;
	unsigned int alloc_size;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int systembits_inalloc;
	unsigned int total_allocated;
	unsigned int online_maps;
	struct cpumap *maps;
	long unsigned int scratch_map[4];
	long unsigned int system_map[4];
};

struct trace_event_raw_irq_matrix_global {
	struct trace_entry ent;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_global_update {
	struct trace_entry ent;
	int bit;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_cpu {
	struct trace_entry ent;
	int bit;
	unsigned int cpu;
	bool online;
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_data_offsets_irq_matrix_global {};

struct trace_event_data_offsets_irq_matrix_global_update {};

struct trace_event_data_offsets_irq_matrix_cpu {};

typedef void (*btf_trace_irq_matrix_online)(void *, struct irq_matrix___2 *);

typedef void (*btf_trace_irq_matrix_offline)(void *, struct irq_matrix___2 *);

typedef void (*btf_trace_irq_matrix_reserve)(void *, struct irq_matrix___2 *);

typedef void (*btf_trace_irq_matrix_remove_reserved)(void *, struct irq_matrix___2 *);

typedef void (*btf_trace_irq_matrix_assign_system)(void *, int, struct irq_matrix___2 *);

typedef void (*btf_trace_irq_matrix_alloc_reserved)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_reserve_managed)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_remove_managed)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc_managed)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_assign)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_free)(void *, int, unsigned int, struct irq_matrix___2 *, struct cpumap *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)();

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

struct rcu_tasks {
	struct callback_head *cbs_head;
	struct callback_head **cbs_tail;
	struct wait_queue_head cbs_wq;
	raw_spinlock_t cbs_lock;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int n_gps;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	char *name;
	char *kname;
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

typedef long unsigned int ulong;

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long: 32;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	long: 56;
	long: 64;
	long: 64;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool exp_deferred_qs;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
	atomic_t dynticks;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[9];
	struct rcu_node *level[3];
	int ncpus;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 boost;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	raw_spinlock_t ofl_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kvfree_rcu_bulk_data {
	long unsigned int nr_records;
	struct kvfree_rcu_bulk_data *next;
	void *records[0];
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct kvfree_rcu_bulk_data *bkvhead_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	struct kvfree_rcu_bulk_data *bkvhead[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool monitor_todo;
	bool initialized;
	int count;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

enum dma_sync_target {
	SYNC_FOR_CPU = 0,
	SYNC_FOR_DEVICE = 1,
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	enum swiotlb_force swiotlb_force;
	char __data[0];
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
};

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t, enum swiotlb_force);

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
};

struct mmu_notifier;

struct mmu_notifier_range;

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	void (*change_pte)(struct mmu_notifier *, struct mm_struct *, long unsigned int, pte_t);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct mmu_notifier_range {
	struct vm_area_struct *vma;
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *migrate_pgmap_owner;
};

struct kvm_regs {
	__u64 rax;
	__u64 rbx;
	__u64 rcx;
	__u64 rdx;
	__u64 rsi;
	__u64 rdi;
	__u64 rsp;
	__u64 rbp;
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 rip;
	__u64 rflags;
};

struct kvm_segment {
	__u64 base;
	__u32 limit;
	__u16 selector;
	__u8 type;
	__u8 present;
	__u8 dpl;
	__u8 db;
	__u8 s;
	__u8 l;
	__u8 g;
	__u8 avl;
	__u8 unusable;
	__u8 padding;
};

struct kvm_dtable {
	__u64 base;
	__u16 limit;
	__u16 padding[3];
};

struct kvm_sregs {
	struct kvm_segment cs;
	struct kvm_segment ds;
	struct kvm_segment es;
	struct kvm_segment fs;
	struct kvm_segment gs;
	struct kvm_segment ss;
	struct kvm_segment tr;
	struct kvm_segment ldt;
	struct kvm_dtable gdt;
	struct kvm_dtable idt;
	__u64 cr0;
	__u64 cr2;
	__u64 cr3;
	__u64 cr4;
	__u64 cr8;
	__u64 efer;
	__u64 apic_base;
	__u64 interrupt_bitmap[4];
};

struct kvm_cpuid_entry2 {
	__u32 function;
	__u32 index;
	__u32 flags;
	__u32 eax;
	__u32 ebx;
	__u32 ecx;
	__u32 edx;
	__u32 padding[3];
};

struct kvm_debug_exit_arch {
	__u32 exception;
	__u32 pad;
	__u64 pc;
	__u64 dr6;
	__u64 dr7;
};

struct kvm_vcpu_events {
	struct {
		__u8 injected;
		__u8 nr;
		__u8 has_error_code;
		__u8 pending;
		__u32 error_code;
	} exception;
	struct {
		__u8 injected;
		__u8 nr;
		__u8 soft;
		__u8 shadow;
	} interrupt;
	struct {
		__u8 injected;
		__u8 pending;
		__u8 masked;
		__u8 pad;
	} nmi;
	__u32 sipi_vector;
	__u32 flags;
	struct {
		__u8 smm;
		__u8 pending;
		__u8 smm_inside_nmi;
		__u8 latched_init;
	} smi;
	__u8 reserved[27];
	__u8 exception_has_payload;
	__u64 exception_payload;
};

struct kvm_sync_regs {
	struct kvm_regs regs;
	struct kvm_sregs sregs;
	struct kvm_vcpu_events events;
};

struct kvm_pmu_event_filter {
	__u32 action;
	__u32 nevents;
	__u32 fixed_counter_bitmap;
	__u32 flags;
	__u32 pad[4];
	__u64 events[0];
};

struct kvm_hyperv_exit {
	__u32 type;
	__u32 pad1;
	union {
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 evt_page;
			__u64 msg_page;
		} synic;
		struct {
			__u64 input;
			__u64 result;
			__u64 params[2];
		} hcall;
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 status;
			__u64 send_page;
			__u64 recv_page;
			__u64 pending_page;
		} syndbg;
	} u;
};

struct kvm_run {
	__u8 request_interrupt_window;
	__u8 immediate_exit;
	__u8 padding1[6];
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;
	__u64 cr8;
	__u64 apic_base;
	union {
		struct {
			__u64 hardware_exit_reason;
		} hw;
		struct {
			__u64 hardware_entry_failure_reason;
			__u32 cpu;
		} fail_entry;
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		struct {
			__u8 direction;
			__u8 size;
			__u16 port;
			__u32 count;
			__u64 data_offset;
		} io;
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} mmio;
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			__u32 longmode;
			__u32 pad;
		} hypercall;
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		struct {
			__u8 icptcode;
			__u16 ipa;
			__u32 ipb;
		} s390_sieic;
		__u64 s390_reset_flags;
		struct {
			__u64 trans_exc_code;
			__u32 pgm_code;
		} s390_ucontrol;
		struct {
			__u32 dcrn;
			__u32 data;
			__u8 is_write;
		} dcr;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 data[16];
		} internal;
		struct {
			__u64 gprs[32];
		} osi;
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		struct {
			__u16 subchannel_id;
			__u16 subchannel_nr;
			__u32 io_int_parm;
			__u32 io_int_word;
			__u32 ipb;
			__u8 dequeued;
		} s390_tsch;
		struct {
			__u32 epr;
		} epr;
		struct {
			__u32 type;
			__u64 flags;
		} system_event;
		struct {
			__u64 addr;
			__u8 ar;
			__u8 reserved;
			__u8 fc;
			__u8 sel1;
			__u16 sel2;
		} s390_stsi;
		struct {
			__u8 vector;
		} eoi;
		struct kvm_hyperv_exit hyperv;
		struct {
			__u64 esr_iss;
			__u64 fault_ipa;
		} arm_nisv;
		struct {
			__u8 error;
			__u8 pad[7];
			__u32 reason;
			__u32 index;
			__u64 data;
		} msr;
		char padding[256];
	};
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[2048];
	} s;
};

struct kvm_coalesced_mmio {
	__u64 phys_addr;
	__u32 len;
	union {
		__u32 pad;
		__u32 pio;
	};
	__u8 data[8];
};

struct kvm_coalesced_mmio_ring {
	__u32 first;
	__u32 last;
	struct kvm_coalesced_mmio coalesced_mmio[0];
};

struct kvm_xen_hvm_config {
	__u32 flags;
	__u32 msr;
	__u64 blob_addr_32;
	__u64 blob_addr_64;
	__u8 blob_size_32;
	__u8 blob_size_64;
	__u8 pad2[30];
};

typedef long unsigned int gva_t;

typedef u64 gpa_t;

typedef u64 gfn_t;

typedef u64 hpa_t;

typedef u64 hfn_t;

typedef hfn_t kvm_pfn_t;

struct kvm_memory_slot;

struct gfn_to_hva_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int hva;
	long unsigned int len;
	struct kvm_memory_slot *memslot;
};

struct kvm_rmap_head;

struct kvm_lpage_info;

struct kvm_arch_memory_slot {
	struct kvm_rmap_head *rmap[3];
	struct kvm_lpage_info *lpage_info[2];
	short unsigned int *gfn_track[1];
};

struct kvm_memory_slot {
	gfn_t base_gfn;
	long unsigned int npages;
	long unsigned int *dirty_bitmap;
	struct kvm_arch_memory_slot arch;
	long unsigned int userspace_addr;
	u32 flags;
	short int id;
	u16 as_id;
};

struct gfn_to_pfn_cache {
	u64 generation;
	gfn_t gfn;
	kvm_pfn_t pfn;
	bool dirty;
};

struct kvm_mmu_memory_cache {
	int nobjs;
	gfp_t gfp_zero;
	struct kmem_cache *kmem_cache;
	void *objects[40];
};

struct hv_partition_assist_pg {
	u32 tlb_lock_count;
};

union hv_message_flags {
	__u8 asu8;
	struct {
		__u8 msg_pending: 1;
		__u8 reserved: 7;
	};
};

union hv_port_id {
	__u32 asu32;
	struct {
		__u32 id: 24;
		__u32 reserved: 8;
	} u;
};

struct hv_message_header {
	__u32 message_type;
	__u8 payload_size;
	union hv_message_flags message_flags;
	__u8 reserved[2];
	union {
		__u64 sender;
		union hv_port_id port;
	};
};

struct hv_message {
	struct hv_message_header header;
	union {
		__u64 payload[30];
	} u;
};

union hv_stimer_config {
	u64 as_uint64;
	struct {
		u64 enable: 1;
		u64 periodic: 1;
		u64 lazy: 1;
		u64 auto_enable: 1;
		u64 apic_vector: 8;
		u64 direct_mode: 1;
		u64 reserved_z0: 3;
		u64 sintx: 4;
		u64 reserved_z1: 44;
	};
};

enum kvm_page_track_mode {
	KVM_PAGE_TRACK_WRITE = 0,
	KVM_PAGE_TRACK_MAX = 1,
};

struct kvm_page_track_notifier_head {
	struct srcu_struct track_srcu;
	struct hlist_head track_notifier_list;
};

struct kvm_vcpu;

struct kvm;

struct kvm_page_track_notifier_node {
	struct hlist_node node;
	void (*track_write)(struct kvm_vcpu *, gpa_t, const u8 *, int, struct kvm_page_track_notifier_node *);
	void (*track_flush_slot)(struct kvm *, struct kvm_memory_slot *, struct kvm_page_track_notifier_node *);
};

struct kvm_vcpu_stat {
	u64 pf_fixed;
	u64 pf_guest;
	u64 tlb_flush;
	u64 invlpg;
	u64 exits;
	u64 io_exits;
	u64 mmio_exits;
	u64 signal_exits;
	u64 irq_window_exits;
	u64 nmi_window_exits;
	u64 l1d_flush;
	u64 halt_exits;
	u64 halt_successful_poll;
	u64 halt_attempted_poll;
	u64 halt_poll_invalid;
	u64 halt_wakeup;
	u64 request_irq_exits;
	u64 irq_exits;
	u64 host_state_reload;
	u64 fpu_reload;
	u64 insn_emulation;
	u64 insn_emulation_fail;
	u64 hypercalls;
	u64 irq_injections;
	u64 nmi_injections;
	u64 req_event;
	u64 halt_poll_success_ns;
	u64 halt_poll_fail_ns;
};

struct kvm_mmio_fragment {
	gpa_t gpa;
	void *data;
	unsigned int len;
};

struct kvm_lapic;

struct x86_exception;

struct kvm_mmu_page;

union kvm_mmu_page_role {
	u32 word;
	struct {
		unsigned int level: 4;
		unsigned int gpte_is_8_bytes: 1;
		unsigned int quadrant: 2;
		unsigned int direct: 1;
		unsigned int access: 3;
		unsigned int invalid: 1;
		unsigned int nxe: 1;
		unsigned int cr0_wp: 1;
		unsigned int smep_andnot_wp: 1;
		unsigned int smap_andnot_wp: 1;
		unsigned int ad_disabled: 1;
		unsigned int guest_mode: 1;
		char: 6;
		unsigned int smm: 8;
	};
};

union kvm_mmu_extended_role {
	u32 word;
	struct {
		unsigned int valid: 1;
		unsigned int execonly: 1;
		unsigned int cr0_pg: 1;
		unsigned int cr4_pae: 1;
		unsigned int cr4_pse: 1;
		unsigned int cr4_pke: 1;
		unsigned int cr4_smap: 1;
		unsigned int cr4_smep: 1;
		unsigned int maxphyaddr: 6;
	};
};

union kvm_mmu_role {
	u64 as_u64;
	struct {
		union kvm_mmu_page_role base;
		union kvm_mmu_extended_role ext;
	};
};

struct kvm_mmu_root_info {
	gpa_t pgd;
	hpa_t hpa;
};

struct rsvd_bits_validate {
	u64 rsvd_bits_mask[10];
	u64 bad_mt_xwr;
};

struct kvm_mmu {
	long unsigned int (*get_guest_pgd)(struct kvm_vcpu *);
	u64 (*get_pdptr)(struct kvm_vcpu *, int);
	int (*page_fault)(struct kvm_vcpu *, gpa_t, u32, bool);
	void (*inject_page_fault)(struct kvm_vcpu *, struct x86_exception *);
	gpa_t (*gva_to_gpa)(struct kvm_vcpu *, gpa_t, u32, struct x86_exception *);
	gpa_t (*translate_gpa)(struct kvm_vcpu *, gpa_t, u32, struct x86_exception *);
	int (*sync_page)(struct kvm_vcpu *, struct kvm_mmu_page *);
	void (*invlpg)(struct kvm_vcpu *, gva_t, hpa_t);
	void (*update_pte)(struct kvm_vcpu *, struct kvm_mmu_page *, u64 *, const void *);
	hpa_t root_hpa;
	gpa_t root_pgd;
	union kvm_mmu_role mmu_role;
	u8 root_level;
	u8 shadow_root_level;
	u8 ept_ad;
	bool direct_map;
	struct kvm_mmu_root_info prev_roots[3];
	u8 permissions[16];
	u32 pkru_mask;
	u64 *pae_root;
	u64 *lm_root;
	struct rsvd_bits_validate shadow_zero_check;
	struct rsvd_bits_validate guest_rsvd_check;
	u8 last_nonleaf_level;
	bool nx;
	u64 pdptrs[4];
};

struct kvm_pio_request {
	long unsigned int linear_rip;
	long unsigned int count;
	int in;
	int port;
	int size;
};

struct kvm_queued_exception {
	bool pending;
	bool injected;
	bool has_error_code;
	u8 nr;
	u32 error_code;
	long unsigned int payload;
	bool has_payload;
	u8 nested_apf;
};

struct kvm_queued_interrupt {
	bool injected;
	bool soft;
	u8 nr;
};

struct x86_emulate_ctxt;

struct kvm_mtrr_range {
	u64 base;
	u64 mask;
	struct list_head node;
};

struct kvm_mtrr {
	struct kvm_mtrr_range var_ranges[8];
	mtrr_type fixed_ranges[88];
	u64 deftype;
	struct list_head head;
};

enum pmc_type {
	KVM_PMC_GP = 0,
	KVM_PMC_FIXED = 1,
};

struct kvm_pmc {
	enum pmc_type type;
	u8 idx;
	u64 counter;
	u64 eventsel;
	struct perf_event *perf_event;
	struct kvm_vcpu *vcpu;
	u64 current_config;
};

struct kvm_pmu {
	unsigned int nr_arch_gp_counters;
	unsigned int nr_arch_fixed_counters;
	unsigned int available_event_types;
	u64 fixed_ctr_ctrl;
	u64 global_ctrl;
	u64 global_status;
	u64 global_ovf_ctrl;
	u64 counter_bitmask[2];
	u64 global_ctrl_mask;
	u64 global_ovf_ctrl_mask;
	u64 reserved_bits;
	u8 version;
	struct kvm_pmc gp_counters[32];
	struct kvm_pmc fixed_counters[4];
	struct irq_work irq_work;
	long unsigned int reprogram_pmi[1];
	long unsigned int all_valid_pmc_idx[1];
	long unsigned int pmc_in_use[1];
	bool need_cleanup;
	u8 event_count;
};

struct kvm_vcpu_hv_synic {
	u64 version;
	u64 control;
	u64 msg_page;
	u64 evt_page;
	atomic64_t sint[16];
	atomic_t sint_to_gsi[16];
	long unsigned int auto_eoi_bitmap[4];
	long unsigned int vec_bitmap[4];
	bool active;
	bool dont_zero_synic_pages;
};

struct kvm_vcpu_hv_stimer {
	struct hrtimer timer;
	int index;
	union hv_stimer_config config;
	u64 count;
	u64 exp_time;
	struct hv_message msg;
	bool msg_pending;
};

struct kvm_vcpu_hv {
	u32 vp_index;
	u64 hv_vapic;
	s64 runtime_offset;
	struct kvm_vcpu_hv_synic synic;
	struct kvm_hyperv_exit exit;
	struct kvm_vcpu_hv_stimer stimer[4];
	long unsigned int stimer_pending_bitmap[1];
	cpumask_t tlb_flush;
};

struct kvm_vcpu_arch {
	long unsigned int regs[17];
	u32 regs_avail;
	u32 regs_dirty;
	long unsigned int cr0;
	long unsigned int cr0_guest_owned_bits;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	long unsigned int cr4_guest_owned_bits;
	long unsigned int cr4_guest_rsvd_bits;
	long unsigned int cr8;
	u32 host_pkru;
	u32 pkru;
	u32 hflags;
	u64 efer;
	u64 apic_base;
	struct kvm_lapic *apic;
	bool apicv_active;
	bool load_eoi_exitmap_pending;
	long unsigned int ioapic_handled_vectors[4];
	long unsigned int apic_attention;
	int32_t apic_arb_prio;
	int mp_state;
	u64 ia32_misc_enable_msr;
	u64 smbase;
	u64 smi_count;
	bool tpr_access_reporting;
	bool xsaves_enabled;
	u64 ia32_xss;
	u64 microcode_version;
	u64 arch_capabilities;
	u64 perf_capabilities;
	struct kvm_mmu *mmu;
	struct kvm_mmu root_mmu;
	struct kvm_mmu guest_mmu;
	struct kvm_mmu nested_mmu;
	struct kvm_mmu *walk_mmu;
	struct kvm_mmu_memory_cache mmu_pte_list_desc_cache;
	struct kvm_mmu_memory_cache mmu_shadow_page_cache;
	struct kvm_mmu_memory_cache mmu_gfn_array_cache;
	struct kvm_mmu_memory_cache mmu_page_header_cache;
	struct fpu *user_fpu;
	struct fpu *guest_fpu;
	u64 xcr0;
	u64 guest_supported_xcr0;
	struct kvm_pio_request pio;
	void *pio_data;
	u8 event_exit_inst_len;
	struct kvm_queued_exception exception;
	struct kvm_queued_interrupt interrupt;
	int halt_request;
	int cpuid_nent;
	struct kvm_cpuid_entry2 *cpuid_entries;
	int maxphyaddr;
	int max_tdp_level;
	struct x86_emulate_ctxt *emulate_ctxt;
	bool emulate_regs_need_sync_to_vcpu;
	bool emulate_regs_need_sync_from_vcpu;
	int (*complete_userspace_io)(struct kvm_vcpu *);
	gpa_t time;
	struct pvclock_vcpu_time_info hv_clock;
	unsigned int hw_tsc_khz;
	struct gfn_to_hva_cache pv_time;
	bool pv_time_enabled;
	bool pvclock_set_guest_stopped_request;
	struct {
		u8 preempted;
		u64 msr_val;
		u64 last_steal;
		struct gfn_to_pfn_cache cache;
	} st;
	u64 l1_tsc_offset;
	u64 tsc_offset;
	u64 last_guest_tsc;
	u64 last_host_tsc;
	u64 tsc_offset_adjustment;
	u64 this_tsc_nsec;
	u64 this_tsc_write;
	u64 this_tsc_generation;
	bool tsc_catchup;
	bool tsc_always_catchup;
	s8 virtual_tsc_shift;
	u32 virtual_tsc_mult;
	u32 virtual_tsc_khz;
	s64 ia32_tsc_adjust_msr;
	u64 msr_ia32_power_ctl;
	u64 tsc_scaling_ratio;
	atomic_t nmi_queued;
	unsigned int nmi_pending;
	bool nmi_injected;
	bool smi_pending;
	struct kvm_mtrr mtrr_state;
	u64 pat;
	unsigned int switch_db_regs;
	long unsigned int db[4];
	long unsigned int dr6;
	long unsigned int dr7;
	long unsigned int eff_db[4];
	long unsigned int guest_debug_dr7;
	u64 msr_platform_info;
	u64 msr_misc_features_enables;
	u64 mcg_cap;
	u64 mcg_status;
	u64 mcg_ctl;
	u64 mcg_ext_ctl;
	u64 *mce_banks;
	u64 mmio_gva;
	unsigned int mmio_access;
	gfn_t mmio_gfn;
	u64 mmio_gen;
	struct kvm_pmu pmu;
	long unsigned int singlestep_rip;
	struct kvm_vcpu_hv hyperv;
	cpumask_var_t wbinvd_dirty_mask;
	long unsigned int last_retry_eip;
	long unsigned int last_retry_addr;
	struct {
		bool halted;
		gfn_t gfns[64];
		struct gfn_to_hva_cache data;
		u64 msr_en_val;
		u64 msr_int_val;
		u16 vec;
		u32 id;
		bool send_user_only;
		u32 host_apf_flags;
		long unsigned int nested_apf_token;
		bool delivery_as_pf_vmexit;
		bool pageready_pending;
	} apf;
	struct {
		u64 length;
		u64 status;
	} osvw;
	struct {
		u64 msr_val;
		struct gfn_to_hva_cache data;
	} pv_eoi;
	u64 msr_kvm_poll_control;
	bool write_fault_to_shadow_pgtable;
	long unsigned int exit_qualification;
	struct {
		bool pv_unhalted;
	} pv;
	int pending_ioapic_eoi;
	int pending_external_vector;
	bool preempted_in_kernel;
	bool l1tf_flush_l1d;
	unsigned int last_vmentry_cpu;
	u64 msr_hwcr;
	struct {
		u32 features;
		bool enforce;
	} pv_cpuid;
};

struct kvm_vcpu {
	struct kvm *kvm;
	struct preempt_notifier preempt_notifier;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int srcu_idx;
	int mode;
	u64 requests;
	long unsigned int guest_debug;
	int pre_pcpu;
	struct list_head blocked_vcpu_list;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid *pid;
	int sigset_active;
	sigset_t sigset;
	struct kvm_vcpu_stat stat;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	struct {
		u32 queued;
		struct list_head queue;
		struct list_head done;
		spinlock_t lock;
	} async_pf;
	struct {
		bool in_spin_loop;
		bool dy_eligible;
	} spin_loop;
	bool preempted;
	bool ready;
	struct kvm_vcpu_arch arch;
};

struct kvm_vm_stat {
	ulong mmu_shadow_zapped;
	ulong mmu_pte_write;
	ulong mmu_pte_updated;
	ulong mmu_pde_zapped;
	ulong mmu_flooded;
	ulong mmu_recycled;
	ulong mmu_cache_miss;
	ulong mmu_unsync;
	ulong remote_tlb_flush;
	ulong lpages;
	ulong nx_lpage_splits;
	ulong max_mmu_page_hash_collisions;
};

struct iommu_domain___2;

struct kvm_pic;

struct kvm_ioapic;

struct kvm_pit;

struct kvm_hv_syndbg {
	struct {
		u64 control;
		u64 status;
		u64 send_page;
		u64 recv_page;
		u64 pending_page;
	} control;
	u64 options;
};

struct kvm_hv {
	struct mutex hv_lock;
	u64 hv_guest_os_id;
	u64 hv_hypercall;
	u64 hv_tsc_page;
	u64 hv_crash_param[5];
	u64 hv_crash_ctl;
	struct ms_hyperv_tsc_page tsc_ref;
	struct idr conn_to_evt;
	u64 hv_reenlightenment_control;
	u64 hv_tsc_emulation_control;
	u64 hv_tsc_emulation_status;
	atomic_t num_mismatched_vp_indexes;
	struct hv_partition_assist_pg *hv_pa_pg;
	struct kvm_hv_syndbg hv_syndbg;
};

enum kvm_irqchip_mode {
	KVM_IRQCHIP_NONE = 0,
	KVM_IRQCHIP_KERNEL = 1,
	KVM_IRQCHIP_SPLIT = 2,
};

struct msr_bitmap_range {
	u32 flags;
	u32 nmsrs;
	u32 base;
	long unsigned int *bitmap;
};

struct kvm_apic_map;

struct kvm_arch {
	long unsigned int n_used_mmu_pages;
	long unsigned int n_requested_mmu_pages;
	long unsigned int n_max_mmu_pages;
	unsigned int indirect_shadow_pages;
	u8 mmu_valid_gen;
	struct hlist_head mmu_page_hash[4096];
	struct list_head active_mmu_pages;
	struct list_head zapped_obsolete_pages;
	struct list_head lpage_disallowed_mmu_pages;
	struct kvm_page_track_notifier_node mmu_sp_tracker;
	struct kvm_page_track_notifier_head track_notifier_head;
	struct list_head assigned_dev_head;
	struct iommu_domain___2 *iommu_domain;
	bool iommu_noncoherent;
	atomic_t noncoherent_dma_count;
	atomic_t assigned_device_count;
	struct kvm_pic *vpic;
	struct kvm_ioapic *vioapic;
	struct kvm_pit *vpit;
	atomic_t vapics_in_nmi_mode;
	struct mutex apic_map_lock;
	struct kvm_apic_map *apic_map;
	atomic_t apic_map_dirty;
	bool apic_access_page_done;
	long unsigned int apicv_inhibit_reasons;
	gpa_t wall_clock;
	bool mwait_in_guest;
	bool hlt_in_guest;
	bool pause_in_guest;
	bool cstate_in_guest;
	long unsigned int irq_sources_bitmap;
	s64 kvmclock_offset;
	raw_spinlock_t tsc_write_lock;
	u64 last_tsc_nsec;
	u64 last_tsc_write;
	u32 last_tsc_khz;
	u64 cur_tsc_nsec;
	u64 cur_tsc_write;
	u64 cur_tsc_offset;
	u64 cur_tsc_generation;
	int nr_vcpus_matched_tsc;
	spinlock_t pvclock_gtod_sync_lock;
	bool use_master_clock;
	u64 master_kernel_ns;
	u64 master_cycle_now;
	struct delayed_work kvmclock_update_work;
	struct delayed_work kvmclock_sync_work;
	struct kvm_xen_hvm_config xen_hvm_config;
	struct hlist_head mask_notifier_list;
	struct kvm_hv hyperv;
	bool backwards_tsc_observed;
	bool boot_vcpu_runs_old_kvmclock;
	u32 bsp_vcpu_id;
	u64 disabled_quirks;
	enum kvm_irqchip_mode irqchip_mode;
	u8 nr_reserved_ioapic_pins;
	bool disabled_lapic_found;
	bool x2apic_format;
	bool x2apic_broadcast_quirk_disabled;
	bool guest_can_read_msr_platform_info;
	bool exception_payload_enabled;
	u32 user_space_msr_mask;
	struct {
		u8 count;
		bool default_allow: 1;
		struct msr_bitmap_range ranges[16];
	} msr_filter;
	struct kvm_pmu_event_filter *pmu_event_filter;
	struct task_struct *nx_lpage_recovery_thread;
	bool tdp_mmu_enabled;
	struct list_head tdp_mmu_roots;
	struct list_head tdp_mmu_pages;
};

struct kvm_memslots;

struct kvm_io_bus;

struct kvm_irq_routing_table;

struct kvm_stat_data;

struct kvm {
	spinlock_t mmu_lock;
	struct mutex slots_lock;
	struct mm_struct *mm;
	struct kvm_memslots *memslots[2];
	struct kvm_vcpu *vcpus[288];
	atomic_t online_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus *buses[4];
	struct {
		spinlock_t lock;
		struct list_head items;
		struct list_head resampler_list;
		struct mutex resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	refcount_t users_count;
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
	struct mutex irq_lock;
	struct kvm_irq_routing_table *irq_routing;
	struct hlist_head irq_ack_notifier_list;
	struct mmu_notifier mmu_notifier;
	long unsigned int mmu_notifier_seq;
	long int mmu_notifier_count;
	long int tlbs_dirty;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	unsigned int max_halt_poll_ns;
};

enum kvm_reg {
	VCPU_REGS_RAX = 0,
	VCPU_REGS_RCX = 1,
	VCPU_REGS_RDX = 2,
	VCPU_REGS_RBX = 3,
	VCPU_REGS_RSP = 4,
	VCPU_REGS_RBP = 5,
	VCPU_REGS_RSI = 6,
	VCPU_REGS_RDI = 7,
	VCPU_REGS_R8 = 8,
	VCPU_REGS_R9 = 9,
	VCPU_REGS_R10 = 10,
	VCPU_REGS_R11 = 11,
	VCPU_REGS_R12 = 12,
	VCPU_REGS_R13 = 13,
	VCPU_REGS_R14 = 14,
	VCPU_REGS_R15 = 15,
	VCPU_REGS_RIP = 16,
	NR_VCPU_REGS = 17,
	VCPU_EXREG_PDPTR = 17,
	VCPU_EXREG_CR0 = 18,
	VCPU_EXREG_CR3 = 19,
	VCPU_EXREG_CR4 = 20,
	VCPU_EXREG_RFLAGS = 21,
	VCPU_EXREG_SEGMENTS = 22,
	VCPU_EXREG_EXIT_INFO_1 = 23,
	VCPU_EXREG_EXIT_INFO_2 = 24,
};

struct kvm_rmap_head {
	long unsigned int val;
};

struct kvm_lpage_info {
	int disallow_lpage;
};

struct kvm_apic_map {
	struct callback_head rcu;
	u8 mode;
	u32 max_apic_id;
	union {
		struct kvm_lapic *xapic_flat_map[8];
		struct kvm_lapic *xapic_cluster_map[64];
	};
	struct kvm_lapic *phys_map[0];
};

struct kvm_io_device;

struct kvm_io_range {
	gpa_t addr;
	int len;
	struct kvm_io_device *dev;
};

struct kvm_io_bus {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range range[0];
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_NR_BUSES = 4,
};

struct kvm_irq_routing_table {
	int chip[72];
	u32 nr_rt_entries;
	struct hlist_head map[0];
};

struct kvm_memslots {
	u64 generation;
	short int id_to_index[512];
	atomic_t lru_slot;
	int used_slots;
	struct kvm_memory_slot memslots[0];
};

struct kvm_stats_debugfs_item;

struct kvm_stat_data {
	struct kvm *kvm;
	struct kvm_stats_debugfs_item *dbgfs_item;
};

enum kvm_stat_kind {
	KVM_STAT_VM = 0,
	KVM_STAT_VCPU = 1,
};

struct kvm_stats_debugfs_item {
	const char *name;
	int offset;
	enum kvm_stat_kind kind;
	int mode;
};

enum profile_type {
	PROFILE_TASK_EXIT = 0,
	PROFILE_MUNMAP = 1,
};

struct profile_hit {
	u32 pc;
	u32 hits;
};

struct stacktrace_cookie {
	long unsigned int *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_long_t __kernel_old_time_t;

typedef __kernel_suseconds_t suseconds_t;

typedef __u64 timeu64_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	long unsigned int pending_map[9];
	struct hlist_head vectors[576];
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

struct audit_ntp_val {
	long long int oldval;
	long long int newval;
};

struct audit_ntp_data {
	struct audit_ntp_val vals[6];
};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

typedef s64 int64_t;

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

typedef __kernel_timer_t timer_t;

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	int uie_unsupported;
	long int set_offset_nsec;
	bool registered;
	bool nvram_old_abi;
	struct bin_attribute *nvram;
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

struct compat_sigevent {
	compat_sigval_t sigev_value;
	compat_int_t sigev_signo;
	compat_int_t sigev_notify;
	union {
		compat_int_t _pad[13];
		compat_int_t _tid;
		struct {
			compat_uptr_t _function;
			compat_uptr_t _attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef unsigned int uint;

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

struct old_itimerval32 {
	struct old_timeval32 it_interval;
	struct old_timeval32 it_value;
};

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

struct dma_chan {
	int lock;
	const char *device_id;
};

typedef bool (*smp_cond_func_t)(int, void *);

struct call_function_data {
	call_single_data_t *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct modversion_info {
	long unsigned int crc;
	char name[56];
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
	WILL_BE_GPL_ONLY = 2,
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
	bool unused;
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int flags: 8;
	union {
		struct static_key_true dd_key_true;
		struct static_key_false dd_key_false;
	} key;
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug *debug;
	unsigned int num_debug;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct module_signature {
	u8 algo;
	u8 hash;
	u8 id_type;
	u8 signer_len;
	u8 key_id_len;
	u8 __pad[3];
	__be32 sig_len;
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

enum pkey_id_type {
	PKEY_ID_PGP = 0,
	PKEY_ID_X509 = 1,
	PKEY_ID_PKCS7 = 2,
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[128];
	char module_name[56];
	int exported;
	int show_value;
};

typedef __u16 comp_t;

typedef __u32 comp2_t;

struct acct {
	char ac_flag;
	char ac_version;
	__u16 ac_uid16;
	__u16 ac_gid16;
	__u16 ac_tty;
	__u32 ac_btime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_etime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	__u16 ac_ahz;
	__u32 ac_exitcode;
	char ac_comm[17];
	__u8 ac_etime_hi;
	__u16 ac_etime_lo;
	__u32 ac_uid;
	__u32 ac_gid;
};

typedef struct acct acct_t;

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	int active;
	long unsigned int needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
};

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

struct elf_note_section {
	struct elf64_note n_hdr;
	u8 n_data[0];
};

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[27];

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

typedef u32 note_buf_t[92];

struct compat_kexec_segment {
	compat_uptr_t buf;
	compat_size_t bufsz;
	compat_ulong_t mem;
	compat_size_t memsz;
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_TYPES = 7,
};

typedef __kernel_ulong_t __kernel_ino_t;

typedef __kernel_ino_t ino_t;

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	MAX_BPF_LINK_TYPE = 7,
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
	};
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_CPUSET_V2_MODE = 16,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 32,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 64,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int id;
	int level;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_id;
	int dst_level;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int id;
	int level;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_memory_localevents = 1,
	Opt_memory_recursiveprot = 2,
	nr__cgroup2_params = 3,
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
};

struct root_domain___2;

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

struct cpuset {
	struct cgroup_subsys_state css;
	long unsigned int flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t subparts_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int pn;
	int relax_domain_level;
	int nr_subparts_cpus;
	int partition_root_state;
	int use_parent_ecpus;
	int child_ecpus_count;
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

enum subparts_cmd {
	partcmd_enable = 0,
	partcmd_disable = 1,
	partcmd_update = 2,
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_CPU_EXCLUSIVE = 6,
	FILE_MEM_EXCLUSIVE = 7,
	FILE_MEM_HARDWALL = 8,
	FILE_SCHED_LOAD_BALANCE = 9,
	FILE_PARTITION_ROOT = 10,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 11,
	FILE_MEMORY_PRESSURE_ENABLED = 12,
	FILE_MEMORY_PRESSURE = 13,
	FILE_SPREAD_PAGE = 14,
	FILE_SPREAD_SLAB = 15,
} cpuset_filetype_t;

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct key_preparsed_payload {
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

enum audit_state {
	AUDIT_DISABLED = 0,
	AUDIT_BUILD_CONTEXT = 1,
	AUDIT_RECORD_CONTEXT = 2,
};

struct audit_cap_data {
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	union {
		unsigned int fE;
		kernel_cap_t effective;
	};
	kernel_cap_t ambient;
	kuid_t rootid;
};

struct audit_names {
	struct list_head list;
	struct filename *name;
	int name_len;
	bool hidden;
	long unsigned int ino;
	dev_t dev;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	u32 osid;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	unsigned char type;
	bool should_free;
};

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct audit_proctitle {
	int len;
	char *value;
};

struct audit_aux_data;

struct __kernel_sockaddr_storage;

struct audit_tree_refs;

struct audit_context {
	int dummy;
	int in_syscall;
	enum audit_state state;
	enum audit_state current_state;
	unsigned int serial;
	int major;
	struct timespec64 ctime;
	long unsigned int argv[4];
	long int return_code;
	u64 prio;
	int return_valid;
	struct audit_names preallocated_names[5];
	int name_count;
	struct list_head names_list;
	char *filterkey;
	struct path pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct __kernel_sockaddr_storage *sockaddr;
	size_t sockaddr_len;
	pid_t pid;
	pid_t ppid;
	kuid_t uid;
	kuid_t euid;
	kuid_t suid;
	kuid_t fsuid;
	kgid_t gid;
	kgid_t egid;
	kgid_t sgid;
	kgid_t fsgid;
	long unsigned int personality;
	int arch;
	pid_t target_pid;
	kuid_t target_auid;
	kuid_t target_uid;
	unsigned int target_sessionid;
	u32 target_sid;
	char target_comm[16];
	struct audit_tree_refs *trees;
	struct audit_tree_refs *first_trees;
	struct list_head killed_trees;
	int tree_count;
	int type;
	union {
		struct {
			int nargs;
			long int args[6];
		} socketcall;
		struct {
			kuid_t uid;
			kgid_t gid;
			umode_t mode;
			u32 osid;
			int has_perm;
			uid_t perm_uid;
			gid_t perm_gid;
			umode_t perm_mode;
			long unsigned int qbytes;
		} ipc;
		struct {
			mqd_t mqdes;
			struct mq_attr mqstat;
		} mq_getsetattr;
		struct {
			mqd_t mqdes;
			int sigev_signo;
		} mq_notify;
		struct {
			mqd_t mqdes;
			size_t msg_len;
			unsigned int msg_prio;
			struct timespec64 abs_timeout;
		} mq_sendrecv;
		struct {
			int oflag;
			umode_t mode;
			struct mq_attr attr;
		} mq_open;
		struct {
			pid_t pid;
			struct audit_cap_data cap;
		} capset;
		struct {
			int fd;
			int flags;
		} mmap;
		struct {
			int argc;
		} execve;
		struct {
			char *name;
		} module;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

enum audit_nlgrps {
	AUDIT_NLGRP_NONE = 0,
	AUDIT_NLGRP_READLOG = 1,
	__AUDIT_NLGRP_MAX = 2,
};

struct audit_status {
	__u32 mask;
	__u32 enabled;
	__u32 failure;
	__u32 pid;
	__u32 rate_limit;
	__u32 backlog_limit;
	__u32 lost;
	__u32 backlog;
	union {
		__u32 version;
		__u32 feature_bitmap;
	};
	__u32 backlog_wait_time;
	__u32 backlog_wait_time_actual;
};

struct audit_features {
	__u32 vers;
	__u32 mask;
	__u32 features;
	__u32 lock;
};

struct audit_tty_status {
	__u32 enabled;
	__u32 log_passwd;
};

struct audit_sig_info {
	uid_t uid;
	pid_t pid;
	char ctx[0];
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		void *ptr[0];
	};
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

struct audit_netlink_list {
	__u32 portid;
	struct net *net;
	struct sk_buff_head q;
};

struct audit_net {
	struct sock *sk;
};

struct auditd_connection {
	struct pid *pid;
	u32 portid;
	struct net *net;
	struct callback_head rcu;
};

struct audit_ctl_mutex {
	struct mutex lock;
	void *owner;
};

struct audit_buffer {
	struct sk_buff *skb;
	struct audit_context *ctx;
	gfp_t gfp_mask;
};

struct audit_reply {
	__u32 portid;
	struct net *net;
	struct sk_buff *skb;
};

enum {
	Audit_equal = 0,
	Audit_not_equal = 1,
	Audit_bitmask = 2,
	Audit_bittest = 3,
	Audit_lt = 4,
	Audit_gt = 5,
	Audit_le = 6,
	Audit_ge = 7,
	Audit_bad = 8,
};

struct audit_rule_data {
	__u32 flags;
	__u32 action;
	__u32 field_count;
	__u32 mask[64];
	__u32 fields[64];
	__u32 values[64];
	__u32 fieldflags[64];
	__u32 buflen;
	char buf[0];
};

struct audit_field;

struct audit_watch;

struct audit_tree;

struct audit_fsnotify_mark;

struct audit_krule {
	u32 pflags;
	u32 flags;
	u32 listnr;
	u32 action;
	u32 mask[64];
	u32 buflen;
	u32 field_count;
	char *filterkey;
	struct audit_field *fields;
	struct audit_field *arch_f;
	struct audit_field *inode_f;
	struct audit_watch *watch;
	struct audit_tree *tree;
	struct audit_fsnotify_mark *exe;
	struct list_head rlist;
	struct list_head list;
	u64 prio;
};

struct audit_field {
	u32 type;
	union {
		u32 val;
		kuid_t uid;
		kgid_t gid;
		struct {
			char *lsm_str;
			void *lsm_rule;
		};
	};
	u32 op;
};

struct audit_entry {
	struct list_head list;
	struct callback_head rcu;
	struct audit_krule rule;
};

struct audit_buffer___2;

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

enum audit_nfcfgop {
	AUDIT_XT_OP_REGISTER = 0,
	AUDIT_XT_OP_REPLACE = 1,
	AUDIT_XT_OP_UNREGISTER = 2,
	AUDIT_NFT_OP_TABLE_REGISTER = 3,
	AUDIT_NFT_OP_TABLE_UNREGISTER = 4,
	AUDIT_NFT_OP_CHAIN_REGISTER = 5,
	AUDIT_NFT_OP_CHAIN_UNREGISTER = 6,
	AUDIT_NFT_OP_RULE_REGISTER = 7,
	AUDIT_NFT_OP_RULE_UNREGISTER = 8,
	AUDIT_NFT_OP_SET_REGISTER = 9,
	AUDIT_NFT_OP_SET_UNREGISTER = 10,
	AUDIT_NFT_OP_SETELEM_REGISTER = 11,
	AUDIT_NFT_OP_SETELEM_UNREGISTER = 12,
	AUDIT_NFT_OP_GEN_REGISTER = 13,
	AUDIT_NFT_OP_OBJ_REGISTER = 14,
	AUDIT_NFT_OP_OBJ_UNREGISTER = 15,
	AUDIT_NFT_OP_OBJ_RESET = 16,
	AUDIT_NFT_OP_FLOWTABLE_REGISTER = 17,
	AUDIT_NFT_OP_FLOWTABLE_UNREGISTER = 18,
	AUDIT_NFT_OP_INVALID = 19,
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_CHILD = 1,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 2,
	FSNOTIFY_OBJ_TYPE_SB = 3,
	FSNOTIFY_OBJ_TYPE_COUNT = 4,
	FSNOTIFY_OBJ_TYPE_DETACHED = 4,
};

struct audit_aux_data {
	struct audit_aux_data *next;
	int type;
};

struct audit_chunk;

struct audit_tree_refs {
	struct audit_tree_refs *next;
	struct audit_chunk *c[31];
};

struct audit_aux_data_pids {
	struct audit_aux_data d;
	pid_t target_pid[16];
	kuid_t target_auid[16];
	kuid_t target_uid[16];
	unsigned int target_sessionid[16];
	u32 target_sid[16];
	char target_comm[256];
	int pid_count;
};

struct audit_aux_data_bprm_fcaps {
	struct audit_aux_data d;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	struct audit_cap_data old_pcap;
	struct audit_cap_data new_pcap;
};

struct audit_nfcfgop_tab {
	enum audit_nfcfgop op;
	const char *s;
};

struct audit_parent;

struct audit_watch {
	refcount_t count;
	dev_t dev;
	char *path;
	long unsigned int ino;
	struct audit_parent *parent;
	struct list_head wlist;
	struct list_head rules;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	struct mutex mark_mutex;
	atomic_t num_marks;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[4];
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignored_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
	long unsigned int objectid;
};

struct audit_parent {
	struct list_head watches;
	struct fsnotify_mark mark;
};

struct audit_fsnotify_mark {
	dev_t dev;
	long unsigned int ino;
	char *path;
	struct fsnotify_mark mark;
	struct audit_krule *rule;
};

struct audit_chunk___2;

struct audit_tree {
	refcount_t count;
	int goner;
	struct audit_chunk___2 *root;
	struct list_head chunks;
	struct list_head rules;
	struct list_head list;
	struct list_head same_root;
	struct callback_head head;
	char pathname[0];
};

struct node {
	struct list_head list;
	struct audit_tree *owner;
	unsigned int index;
};

struct audit_chunk___2 {
	struct list_head hash;
	long unsigned int key;
	struct fsnotify_mark *mark;
	struct list_head trees;
	int count;
	atomic_long_t refs;
	struct callback_head head;
	struct node owners[0];
};

struct audit_tree_mark {
	struct fsnotify_mark mark;
	struct audit_chunk___2 *chunk;
};

enum {
	HASH_SIZE = 128,
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

struct fault_attr {
	long unsigned int probability;
	long unsigned int interval;
	atomic_t times;
	atomic_t space;
	long unsigned int verbose;
	bool task_filter;
	long unsigned int stacktrace_depth;
	long unsigned int require_start;
	long unsigned int require_end;
	long unsigned int reject_start;
	long unsigned int reject_end;
	long unsigned int count;
	struct ratelimit_state ratelimit_state;
	struct dentry *dname;
};

struct fei_attr {
	struct list_head list;
	struct kprobe kp;
	long unsigned int retval;
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct ctl_path {
	const char *procname;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	int ret;
	struct completion completion;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct rchan;

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	long: 32;
	long: 64;
};

struct rchan_callbacks;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf **buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	void (*buf_mapped)(struct rchan_buf *, struct file *);
	void (*buf_unmapped)(struct rchan_buf *, struct file *);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

enum {
	TASKSTATS_TYPE_UNSPEC = 0,
	TASKSTATS_TYPE_PID = 1,
	TASKSTATS_TYPE_TGID = 2,
	TASKSTATS_TYPE_STATS = 3,
	TASKSTATS_TYPE_AGGR_PID = 4,
	TASKSTATS_TYPE_AGGR_TGID = 5,
	TASKSTATS_TYPE_NULL = 6,
	__TASKSTATS_TYPE_MAX = 7,
};

enum {
	TASKSTATS_CMD_ATTR_UNSPEC = 0,
	TASKSTATS_CMD_ATTR_PID = 1,
	TASKSTATS_CMD_ATTR_TGID = 2,
	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK = 3,
	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 4,
	__TASKSTATS_CMD_ATTR_MAX = 5,
};

enum {
	CGROUPSTATS_CMD_UNSPEC = 3,
	CGROUPSTATS_CMD_GET = 4,
	CGROUPSTATS_CMD_NEW = 5,
	__CGROUPSTATS_CMD_MAX = 6,
};

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,
	CGROUPSTATS_TYPE_CGROUP_STATS = 1,
	__CGROUPSTATS_TYPE_MAX = 2,
};

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD = 1,
	__CGROUPSTATS_CMD_ATTR_MAX = 2,
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	__NLA_TYPE_MAX = 18,
};

struct genl_multicast_group {
	char name[16];
};

struct genl_ops;

struct genl_info;

struct genl_small_ops;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	unsigned int mcgrp_offset;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_mcgrps;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct listener {
	struct list_head list;
	pid_t pid;
	char valid;
};

struct listener_list {
	struct rw_semaphore sem;
	struct list_head list;
};

enum actions {
	REGISTER = 0,
	DEREGISTER = 1,
	CPU_DONT_CARE = 2,
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

struct ftrace_hash {
	long unsigned int size_bits;
	struct hlist_head *buckets;
	long unsigned int count;
	long unsigned int flags;
	struct callback_head rcu;
};

struct ftrace_func_entry {
	struct hlist_node hlist;
	long unsigned int ip;
	long unsigned int direct;
};

enum ftrace_bug_type {
	FTRACE_BUG_UNKNOWN = 0,
	FTRACE_BUG_INIT = 1,
	FTRACE_BUG_NOP = 2,
	FTRACE_BUG_CALL = 3,
	FTRACE_BUG_UPDATE = 4,
};

enum {
	FTRACE_UPDATE_CALLS = 1,
	FTRACE_DISABLE_CALLS = 2,
	FTRACE_UPDATE_TRACE_FUNC = 4,
	FTRACE_START_FUNC_RET = 8,
	FTRACE_STOP_FUNC_RET = 16,
	FTRACE_MAY_SLEEP = 32,
};

enum {
	FTRACE_ITER_FILTER = 1,
	FTRACE_ITER_NOTRACE = 2,
	FTRACE_ITER_PRINTALL = 4,
	FTRACE_ITER_DO_PROBES = 8,
	FTRACE_ITER_PROBE = 16,
	FTRACE_ITER_MOD = 32,
	FTRACE_ITER_ENABLED = 64,
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

struct trace_pid_list;

struct trace_options;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file *enter_syscall_files[441];
	struct trace_event_file *exit_syscall_files[441];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	struct ftrace_ops *ops;
	struct trace_pid_list *function_pids;
	struct trace_pid_list *function_no_pids;
	struct list_head func_probes;
	struct list_head mod_trace;
	struct list_head mod_notrace;
	int function_enabled;
	int time_stamp_abs_ref;
	struct list_head hist_vars;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	int ftrace_ignore_pid;
	bool ignore_pid;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_pid_list {
	int pid_max;
	long unsigned int *pids;
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

enum {
	TRACE_FTRACE_BIT = 0,
	TRACE_FTRACE_NMI_BIT = 1,
	TRACE_FTRACE_IRQ_BIT = 2,
	TRACE_FTRACE_SIRQ_BIT = 3,
	TRACE_INTERNAL_BIT = 4,
	TRACE_INTERNAL_NMI_BIT = 5,
	TRACE_INTERNAL_IRQ_BIT = 6,
	TRACE_INTERNAL_SIRQ_BIT = 7,
	TRACE_BRANCH_BIT = 8,
	TRACE_IRQ_BIT = 9,
	TRACE_GRAPH_BIT = 10,
	TRACE_GRAPH_DEPTH_START_BIT = 11,
	TRACE_GRAPH_DEPTH_END_BIT = 12,
	TRACE_GRAPH_NOTRACE_BIT = 13,
	TRACE_TRANSITION_BIT = 14,
};

struct ftrace_mod_load {
	struct list_head list;
	char *func;
	char *module;
	int enable;
};

enum {
	FTRACE_HASH_FL_MOD = 1,
};

struct ftrace_func_command {
	struct list_head list;
	char *name;
	int (*func)(struct trace_array *, struct ftrace_hash *, char *, char *, char *, int);
};

struct ftrace_probe_ops {
	void (*func)(long unsigned int, long unsigned int, struct trace_array *, struct ftrace_probe_ops *, void *);
	int (*init)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *, void **);
	void (*free)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *);
	int (*print)(struct seq_file *, long unsigned int, struct ftrace_probe_ops *, void *);
};

typedef int (*ftrace_mapper_func)(void *);

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 22,
	TRACE_ITER_FUNCTION_BIT = 23,
	TRACE_ITER_FUNC_FORK_BIT = 24,
	TRACE_ITER_DISPLAY_GRAPH_BIT = 25,
	TRACE_ITER_STACKTRACE_BIT = 26,
	TRACE_ITER_LAST_BIT = 27,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum {
	FTRACE_MODIFY_ENABLE_FL = 1,
	FTRACE_MODIFY_MAY_SLEEP_FL = 2,
};

struct ftrace_func_probe {
	struct ftrace_probe_ops *probe_ops;
	struct ftrace_ops ops;
	struct trace_array *tr;
	struct list_head list;
	void *data;
	int ref;
};

struct ftrace_page {
	struct ftrace_page *next;
	struct dyn_ftrace *records;
	int index;
	int size;
};

struct ftrace_rec_iter___2 {
	struct ftrace_page *pg;
	int index;
};

struct ftrace_iterator {
	loff_t pos;
	loff_t func_pos;
	loff_t mod_pos;
	struct ftrace_page *pg;
	struct dyn_ftrace *func;
	struct ftrace_func_probe *probe;
	struct ftrace_func_entry *probe_entry;
	struct trace_parser parser;
	struct ftrace_hash *hash;
	struct ftrace_ops *ops;
	struct trace_array *tr;
	struct list_head *mod_list;
	int pidx;
	int idx;
	unsigned int flags;
};

struct ftrace_glob {
	char *search;
	unsigned int len;
	int type;
};

struct ftrace_func_map {
	struct ftrace_func_entry entry;
	void *data;
};

struct ftrace_func_mapper {
	struct ftrace_hash hash;
};

struct ftrace_direct_func {
	struct list_head next;
	long unsigned int addr;
	int count;
};

enum graph_filter_type {
	GRAPH_FILTER_NOTRACE = 0,
	GRAPH_FILTER_FUNCTION = 1,
};

struct ftrace_graph_data {
	struct ftrace_hash *hash;
	struct ftrace_func_entry *entry;
	int idx;
	enum graph_filter_type type;
	struct ftrace_hash *new_hash;
	const struct seq_operations *seq_ops;
	struct trace_parser parser;
};

struct ftrace_mod_func {
	struct list_head list;
	char *name;
	long unsigned int ip;
	unsigned int size;
};

struct ftrace_mod_map {
	struct callback_head rcu;
	struct list_head list;
	struct module *mod;
	long unsigned int start_addr;
	long unsigned int end_addr;
	struct list_head funcs;
	unsigned int num_funcs;
};

struct ftrace_init_func {
	struct list_head list;
	long unsigned int ip;
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

struct ring_buffer_per_cpu;

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct trace_buffer___2 {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer___2 *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 read_stamp;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_RAW_DATA = 16,
	__TRACE_LAST_TYPE = 17,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_PAUSE_ON_TRACE = 4194304,
	TRACE_ITER_FUNCTION = 8388608,
	TRACE_ITER_FUNC_FORK = 16777216,
	TRACE_ITER_DISPLAY_GRAPH = 33554432,
	TRACE_ITER_STACKTRACE = 67108864,
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
};

struct err_info {
	const char **errs;
	u8 type;
	u8 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char cmd[256];
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

enum {
	TRACE_FUNC_OPT_STACK = 1,
};

struct ftrace_func_mapper___2;

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

struct ftrace_graph_ent {
	long unsigned int func;
	int depth;
} __attribute__((packed));

struct ftrace_graph_ret {
	long unsigned int func;
	long unsigned int overrun;
	long long unsigned int calltime;
	long long unsigned int rettime;
	int depth;
} __attribute__((packed));

typedef void (*trace_func_graph_ret_t)(struct ftrace_graph_ret *);

typedef int (*trace_func_graph_ent_t)(struct ftrace_graph_ent *);

struct fgraph_ops {
	trace_func_graph_ent_t entryfunc;
	trace_func_graph_ret_t retfunc;
};

struct ftrace_graph_ent_entry {
	struct trace_entry ent;
	struct ftrace_graph_ent graph_ent;
} __attribute__((packed));

struct ftrace_graph_ret_entry {
	struct trace_entry ent;
	struct ftrace_graph_ret ret;
} __attribute__((packed));

struct fgraph_cpu_data {
	pid_t last_pid;
	int depth;
	int depth_irq;
	int ignore;
	long unsigned int enter_funcs[50];
};

struct fgraph_data {
	struct fgraph_cpu_data *cpu_data;
	struct ftrace_graph_ent_entry ent;
	struct ftrace_graph_ret_entry ret;
	int failed;
	int cpu;
} __attribute__((packed));

enum {
	FLAGS_FILL_FULL = 268435456,
	FLAGS_FILL_START = 536870912,
	FLAGS_FILL_END = 805306368,
};

typedef __u32 blk_mq_req_flags_t;

enum req_opf {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_SAME = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_SCSI_IN = 32,
	REQ_OP_SCSI_OUT = 33,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_CGROUP_PUNT = 22,
	__REQ_NOUNMAP = 23,
	__REQ_HIPRI = 24,
	__REQ_DRV = 25,
	__REQ_SWAP = 26,
	__REQ_NR_BITS = 27,
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	long unsigned int rq_dispatched[2];
	long unsigned int rq_merged;
	long unsigned int rq_completed[2];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	struct sbitmap_word *map;
};

struct blk_mq_tags;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	long unsigned int dispatched[7];
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	atomic_t elevator_queued;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	long unsigned int poll_considered;
	long unsigned int poll_invoked;
	long unsigned int poll_success;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	struct srcu_struct srcu[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	unsigned int cmd_flags;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_trace {
	int trace_state;
	struct rchan *rchan;
	long unsigned int *sequence;
	unsigned char *msg_data;
	u16 act_mask;
	u64 start_lba;
	u64 end_lba;
	u32 pid;
	u32 dev;
	struct dentry *dir;
	struct dentry *dropped_file;
	struct dentry *msg_file;
	struct list_head running_list;
	atomic_t dropped;
};

struct blk_flush_queue {
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	struct lock_class_key key;
	spinlock_t mq_flush_lock;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int *alloc_hint;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	bool round_robin;
	unsigned int min_shallow_depth;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	atomic_t active_queues_shared_sbitmap;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct blk_mq_tags **tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
};

typedef u64 compat_u64;

enum blktrace_cat {
	BLK_TC_READ = 1,
	BLK_TC_WRITE = 2,
	BLK_TC_FLUSH = 4,
	BLK_TC_SYNC = 8,
	BLK_TC_SYNCIO = 8,
	BLK_TC_QUEUE = 16,
	BLK_TC_REQUEUE = 32,
	BLK_TC_ISSUE = 64,
	BLK_TC_COMPLETE = 128,
	BLK_TC_FS = 256,
	BLK_TC_PC = 512,
	BLK_TC_NOTIFY = 1024,
	BLK_TC_AHEAD = 2048,
	BLK_TC_META = 4096,
	BLK_TC_DISCARD = 8192,
	BLK_TC_DRV_DATA = 16384,
	BLK_TC_FUA = 32768,
	BLK_TC_END = 32768,
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

enum blktrace_notify {
	__BLK_TN_PROCESS = 0,
	__BLK_TN_TIMESTAMP = 1,
	__BLK_TN_MESSAGE = 2,
	__BLK_TN_CGROUP = 256,
};

struct blk_io_trace {
	__u32 magic;
	__u32 sequence;
	__u64 time;
	__u64 sector;
	__u32 bytes;
	__u32 action;
	__u32 pid;
	__u32 device;
	__u32 cpu;
	__u16 error;
	__u16 pdu_len;
};

struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

enum {
	Blktrace_setup = 1,
	Blktrace_running = 2,
	Blktrace_stopped = 3,
};

struct blk_user_trace_setup {
	char name[32];
	__u16 act_mask;
	__u32 buf_size;
	__u32 buf_nr;
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

struct compat_blk_user_trace_setup {
	char name[32];
	u16 act_mask;
	short: 16;
	u32 buf_size;
	u32 buf_nr;
	compat_u64 start_lba;
	compat_u64 end_lba;
	u32 pid;
} __attribute__((packed));

struct sbitmap_word {
	long unsigned int depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	spinlock_t swap_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	long: 64;
	long: 64;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue *bitmap_tags;
	struct sbitmap_queue *breserved_tags;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

typedef void blk_log_action_t(struct trace_iterator *, const char *, bool);

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

struct event_probe_data {
	struct trace_event_file *file;
	long unsigned int count;
	int ref;
	bool enable;
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	long unsigned int args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long int ret;
};

struct syscall_tp_t {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int ret;
};

struct syscall_tp_t___2 {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int args[6];
};

typedef long unsigned int perf_trace_t[256];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

typedef int (*filter_pred_fn_t)(struct filter_pred *, void *);

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_pred {
	filter_pred_fn_t fn;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct function_filter_data {
	struct ftrace_ops *ops;
	int first_filter;
	int first_notrace;
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*func)(struct event_trigger_data *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_ops *, struct event_trigger_data *);
	void (*free)(struct event_trigger_ops *, struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_ops *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*func)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_bpf_per_cpu_ptr = 153,
	BPF_FUNC_bpf_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	__BPF_FUNC_MAX_ID = 162,
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_UNINIT_MAP_VALUE = 4,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 5,
	ARG_PTR_TO_MEM = 6,
	ARG_PTR_TO_MEM_OR_NULL = 7,
	ARG_PTR_TO_UNINIT_MEM = 8,
	ARG_CONST_SIZE = 9,
	ARG_CONST_SIZE_OR_ZERO = 10,
	ARG_PTR_TO_CTX = 11,
	ARG_PTR_TO_CTX_OR_NULL = 12,
	ARG_ANYTHING = 13,
	ARG_PTR_TO_SPIN_LOCK = 14,
	ARG_PTR_TO_SOCK_COMMON = 15,
	ARG_PTR_TO_INT = 16,
	ARG_PTR_TO_LONG = 17,
	ARG_PTR_TO_SOCKET = 18,
	ARG_PTR_TO_SOCKET_OR_NULL = 19,
	ARG_PTR_TO_BTF_ID = 20,
	ARG_PTR_TO_ALLOC_MEM = 21,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 22,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 23,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 24,
	ARG_PTR_TO_PERCPU_BTF_ID = 25,
	__BPF_ARG_TYPE_MAX = 26,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 3,
	RET_PTR_TO_SOCKET_OR_NULL = 4,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 5,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 6,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 7,
	RET_PTR_TO_BTF_ID_OR_NULL = 8,
	RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL = 9,
	RET_PTR_TO_MEM_OR_BTF_ID = 10,
	RET_PTR_TO_BTF_ID = 11,
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf *, const struct btf_type *, int, int, enum bpf_access_type, u32 *);
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef struct pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

typedef u64 (*btf_bpf_override_return)(struct pt_regs *, long unsigned int);

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

struct bpf_seq_printf_buf {
	char buf[768];
};

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_get_current_task_btf)();

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(int, const char **);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct dynevent_arg {
	const char *str;
	char separator;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_MOD_BF = 17,
	FETCH_OP_LP_ARRAY = 18,
	FETCH_OP_END = 19,
	FETCH_NOP_SYMBOL = 20,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	int is_signed;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_BAD_ADDR_SUFFIX = 11,
	TP_ERR_NO_GROUP_NAME = 12,
	TP_ERR_GROUP_TOO_LONG = 13,
	TP_ERR_BAD_GROUP_NAME = 14,
	TP_ERR_NO_EVENT_NAME = 15,
	TP_ERR_EVENT_TOO_LONG = 16,
	TP_ERR_BAD_EVENT_NAME = 17,
	TP_ERR_RETVAL_ON_PROBE = 18,
	TP_ERR_BAD_STACK_NUM = 19,
	TP_ERR_BAD_ARG_NUM = 20,
	TP_ERR_BAD_VAR = 21,
	TP_ERR_BAD_REG_NAME = 22,
	TP_ERR_BAD_MEM_ADDR = 23,
	TP_ERR_BAD_IMM = 24,
	TP_ERR_IMMSTR_NO_CLOSE = 25,
	TP_ERR_FILE_ON_KPROBE = 26,
	TP_ERR_BAD_FILE_OFFS = 27,
	TP_ERR_SYM_ON_UPROBE = 28,
	TP_ERR_TOO_MANY_OPS = 29,
	TP_ERR_DEREF_NEED_BRACE = 30,
	TP_ERR_BAD_DEREF_OFFS = 31,
	TP_ERR_DEREF_OPEN_BRACE = 32,
	TP_ERR_COMM_CANT_DEREF = 33,
	TP_ERR_BAD_FETCH_ARG = 34,
	TP_ERR_ARRAY_NO_CLOSE = 35,
	TP_ERR_BAD_ARRAY_SUFFIX = 36,
	TP_ERR_BAD_ARRAY_NUM = 37,
	TP_ERR_ARRAY_TOO_BIG = 38,
	TP_ERR_BAD_TYPE = 39,
	TP_ERR_BAD_STRING = 40,
	TP_ERR_BAD_BITFIELD = 41,
	TP_ERR_ARG_NAME_TOO_LONG = 42,
	TP_ERR_NO_ARG_NAME = 43,
	TP_ERR_BAD_ARG_NAME = 44,
	TP_ERR_USED_ARG_NAME = 45,
	TP_ERR_ARG_TOO_LONG = 46,
	TP_ERR_NO_ARG_BODY = 47,
	TP_ERR_BAD_INSN_BNDRY = 48,
	TP_ERR_FAIL_REG_PROBE = 49,
	TP_ERR_DIFF_PROBE_TYPE = 50,
	TP_ERR_DIFF_ARG_TYPE = 51,
	TP_ERR_SAME_PROBE = 52,
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef int (*dynevent_check_arg_fn_t)(void *);

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int nhit;
	struct trace_probe tp;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct rhash_lock_head {};

struct zero_copy_allocator;

struct page_pool;

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
		struct zero_copy_allocator *zc_alloc;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_tracing_link {
	struct bpf_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	u32 used_map_cnt;
	u32 id_gen;
	bool allow_ptr_leaks;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct bpf_map *map_ptr;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		u32 mem_size;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
	};
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
};

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
	};
	u64 map_key_state;
	int ctx_field_size;
	int sanitize_stack_off;
	u32 seen;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	MAX_BTF_SOCK_TYPE = 13,
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum {
	AT_PKT_END = 4294967295,
	BEYOND_PKT_END = 4294967294,
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

struct idpair {
	u32 old;
	u32 cur;
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct bpf_preload_info {
	char link_name[16];
	int link_id;
};

struct bpf_preload_ops {
	struct umd_info info;
	int (*preload)(struct bpf_preload_info *);
	int (*finish)();
	struct module *owner;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_ktime_get_coarse_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long int *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, long unsigned int *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 56;
	u8 target_private[0];
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct files_struct *files;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket {
	struct hlist_nulls_head head;
	union {
		raw_spinlock_t raw_lock;
		spinlock_t lock;
	};
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bucket *buckets;
	void *elems;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	atomic_t count;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct bpf_htab *htab;
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		struct callback_head rcu;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	int: 32;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	long: 64;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
	long: 64;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	int: 32;
	char elements[0];
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t spinlock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

struct lsm_blob_sizes {
	int lbs_cred;
	int lbs_file;
	int lbs_inode;
	int lbs_ipc;
	int lbs_msg_msg;
	int lbs_task;
};

struct bpf_storage_blob {
	struct bpf_local_storage *storage;
};

typedef u64 (*btf_bpf_inode_storage_get)(struct bpf_map *, struct inode *, void *, u64);

typedef u64 (*btf_bpf_inode_storage_delete)(struct bpf_map *, struct inode *);

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_var {
	__u32 linkage;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__u32 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sk_lookup {
	union {
		struct bpf_sock *sk;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__u32 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	void *data;
	void *data_end;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	unsigned int count;
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	long: 64;
	struct inet_listen_hashbucket listening_hash[32];
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	u64 tmp_reg;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	s32 retval;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	bool no_reuseport;
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	s32 delivered;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy;
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, struct __va_list_tag *);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
	void *BPF_PROG_TYPE_LSM_prog;
	void *BPF_PROG_TYPE_LSM_kern;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
	__ctx_convertBPF_PROG_TYPE_LSM = 28,
	__ctx_convert_unused = 29,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	u32 image_off;
	struct bpf_ksym ksym;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	unsigned int count;
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_hwtstamps {
	ktime_t hwtstamp;
};

struct skb_shared_info {
	__u8 __unused;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	void *destructor_arg;
	skb_frag_t frags[17];
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	atomic_t refcnt;
	struct callback_head rcu;
	struct work_struct kthread_stop_wq;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

typedef struct elf32_note Elf32_Nhdr;

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	long: 64;
};

struct stack_map_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

struct bpf_prog_list {
	struct list_head node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
	u16 mru;
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_prog **progs;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

enum {
	BPF_F_BPRM_SECUREEXEC = 1,
};

typedef u64 (*btf_bpf_bprm_opts_set)(struct linux_binprm *, u64);

typedef u64 (*btf_bpf_ima_inode_hash)(struct inode *, void *, u32);

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_MAX = 16,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_MAX = 21,
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

typedef struct {
	char *from;
	char *to;
} substring_t;

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_cgroup_event {
	char *path;
	int path_size;
	struct {
		struct perf_event_header header;
		u64 id;
		char path[0];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 0,
	TYPE_MAX = 1,
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	unsigned int *tsk_pinned;
	unsigned int flexible;
};

struct bp_busy_slots {
	unsigned int pinned;
	unsigned int flexible;
};

typedef u8 uprobe_opcode_t;

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	long unsigned int *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page *pages[2];
	long unsigned int vaddr;
};

typedef long unsigned int vm_flags_t;

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct page_vma_mapped_walk {
	struct page *page;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
	bool alloc_contig;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct map_info {
	struct map_info *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

struct user_return_notifier {
	void (*on_user_return)(struct user_return_notifier *);
	struct hlist_node link;
};

struct static_key_mod {
	struct static_key_mod *next;
	struct jump_entry *entries;
	struct module *mod;
};

struct static_key_deferred {
	struct static_key key;
	long unsigned int timeout;
	struct delayed_work work;
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = 4294967295,
	RSEQ_CPU_ID_REGISTRATION_FAILED = 4294967294,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rseq_ip_fixup {};

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

struct pkcs7_message;

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
};

typedef int __kernel_rwf_t;

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

struct vm_event_state {
	long unsigned int event[96];
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_THP_SUPPORT = 6,
};

struct wait_page_key {
	struct page *page;
	int bit_nr;
	int page_match;
};

enum iter_type {
	ITER_IOVEC = 4,
	ITER_KVEC = 8,
	ITER_BVEC = 16,
	ITER_PIPE = 32,
	ITER_DISCARD = 64,
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page *pages[15];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct page *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct page *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects max;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	unsigned int remote_node_defrag_ratio;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[64];
};

struct kmem_cache_cpu {
	void **freelist;
	long unsigned int tid;
	struct page *page;
	struct page *partial;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum wb_congested_state {
	WB_async_congested = 0,
	WB_sync_congested = 1,
};

enum {
	XA_CHECK_SCHED = 4096,
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum {
	BLK_RW_ASYNC = 0,
	BLK_RW_SYNC = 1,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);

struct dirty_throttle_control {
	struct wb_domain *dom;
	struct dirty_throttle_control *gdtc;
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

typedef void compound_page_dtor(struct page *);

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	int lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct page *, int);

typedef void (*btf_trace_mm_lru_activate)(void *, struct page *);

struct lru_rotate {
	local_lock_t lock;
	struct pagevec pvec;
};

struct lru_pvecs {
	local_lock_t lock;
	struct pagevec lru_add;
	struct pagevec lru_deactivate_file;
	struct pagevec lru_deactivate;
	struct pagevec lru_lazyfree;
	struct pagevec activate_page;
};

typedef struct {
	long unsigned int val;
} swp_entry_t;

enum lruvec_flags {
	LRUVEC_CONGESTED = 0,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

enum ttu_flags {
	TTU_MIGRATION = 1,
	TTU_MUNLOCK = 2,
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_IGNORE_ACCESS = 16,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
	TTU_SPLIT_FREEZE = 256,
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	gfp_t gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	isolate_mode_t isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_writepage {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_inactive_list_is_low {
	struct trace_entry ent;
	int nid;
	int reclaim_idx;
	long unsigned int total_inactive;
	long unsigned int inactive;
	long unsigned int total_active;
	long unsigned int active;
	long unsigned int ratio;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_writepage {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_inactive_list_is_low {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_writepage)(void *, struct page *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_inactive_list_is_low)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum page_references {
	PAGEREF_RECLAIM = 0,
	PAGEREF_RECLAIM_CLEAN = 1,
	PAGEREF_KEEP = 2,
	PAGEREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

enum transparent_hugepage_flag {
	TRANSPARENT_HUGEPAGE_FLAG = 0,
	TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 1,
	TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG = 2,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG = 3,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG = 4,
	TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 5,
	TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 6,
	TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 7,
};

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct constant_table {
	const char *name;
	int value;
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_MAX = 5,
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_CACHE = 1,
	SGP_NOHUGE = 2,
	SGP_HUGE = 3,
	SGP_WRITE = 4,
	SGP_FALLOC = 5,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);

typedef void (*pcpu_fc_free_fn_t)(void *, size_t);

typedef void (*pcpu_fc_populate_pte_fn_t)(long unsigned int);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, bool, bool, size_t, size_t, void *, int, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

enum pcpu_chunk_type {
	PCPU_CHUNK_ROOT = 0,
	PCPU_CHUNK_MEMCG = 1,
	PCPU_NR_CHUNK_TYPES = 2,
	PCPU_FAIL_ALLOC = 2,
};

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	int start_offset;
	int end_offset;
	struct obj_cgroup **obj_cgroups;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

struct trace_event_raw_kmem_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_kmem_alloc_node {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kmem_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	gfp_t gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_alloc {};

struct trace_event_data_offsets_kmem_alloc_node {};

struct trace_event_data_offsets_kmem_free {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmalloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int, long int);

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name[3];
	unsigned int size;
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct node___2 {
	struct device dev;
	struct list_head access_list;
};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	gfp_t gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, long unsigned int, int, struct list_head *);

typedef void (*btf_trace_mm_compaction_begin)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

typedef unsigned int pgtbl_mod_mask;

struct zap_details {
	struct address_space *check_mapping;
	long unsigned int first_index;
	long unsigned int last_index;
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_VALID = 8192,
	SWP_SCANNING = 16384,
};

struct copy_subpage_arg {
	struct page *dst;
	struct page *src;
	struct vm_area_struct *vma;
};

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_data_offsets_vm_unmapped_area {};

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

struct rmap_walk_control {
	void *arg;
	bool (*rmap_one)(struct page *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct page *);
	struct anon_vma * (*anon_lock)(struct page *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct page_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
		struct llist_node purge_list;
	};
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct vmap_pfn_data {
	long unsigned int *pfns;
	pgprot_t prot;
	unsigned int idx;
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
};

struct mminit_pfnnid_cache {
	long unsigned int last_start;
	long unsigned int last_end;
	int last_nid;
};

typedef int fpi_t;

struct pcpu_drain {
	struct zone *zone;
	struct work_struct work;
};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_WORKINGSET = 3,
	BIO_QUIET = 4,
	BIO_CHAIN = 5,
	BIO_REFFED = 6,
	BIO_THROTTLED = 7,
	BIO_TRACE_COMPLETION = 8,
	BIO_CGROUP_ACCT = 9,
	BIO_TRACKED = 10,
	BIO_FLAG_LAST = 11,
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t *ptes;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
	struct page_counter *reservation_counter;
	long unsigned int pages_per_hpage;
	struct cgroup_subsys_state *css;
};

struct file_region {
	struct list_head link;
	long int from;
	long int to;
	struct page_counter *reservation_counter;
	struct cgroup_subsys_state *css;
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

enum hugetlb_memory_event {
	HUGETLB_MAX = 0,
	HUGETLB_NR_MEMORY_EVENTS = 1,
};

struct hugetlb_cgroup {
	struct cgroup_subsys_state css;
	struct page_counter hugepage[2];
	struct page_counter rsvd_hugepage[2];
	atomic_long_t events[2];
	atomic_long_t events_local[2];
	struct cgroup_file events_file[2];
	struct cgroup_file events_local_file[2];
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
};

struct node_hstate {
	struct kobject *hugepages_kobj;
	struct kobject *hstate_kobjs[2];
};

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

struct sp_node {
	struct rb_node nd;
	long unsigned int start;
	long unsigned int end;
	struct mempolicy *policy;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

struct queue_pages {
	struct list_head *pagelist;
	long unsigned int flags;
	nodemask_t *nmask;
	long unsigned int start;
	long unsigned int end;
	struct vm_area_struct *first;
};

struct mmu_notifier_subscriptions {
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	long unsigned int invalidate_seq;
	long unsigned int active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

struct mmu_interval_notifier;

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, long unsigned int);
};

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	long unsigned int invalidate_seq;
};

struct rmap_item;

struct mm_slot {
	struct hlist_node link;
	struct list_head mm_list;
	struct rmap_item *rmap_list;
	struct mm_struct *mm;
};

struct stable_node;

struct rmap_item {
	struct rmap_item *rmap_list;
	union {
		struct anon_vma *anon_vma;
		int nid;
	};
	struct mm_struct *mm;
	long unsigned int address;
	unsigned int oldchecksum;
	union {
		struct rb_node node;
		struct {
			struct stable_node *head;
			struct hlist_node hlist;
		};
	};
};

struct ksm_scan {
	struct mm_slot *mm_slot;
	long unsigned int address;
	struct rmap_item **rmap_list;
	long unsigned int seqnr;
};

struct stable_node {
	union {
		struct rb_node node;
		struct {
			struct list_head *head;
			struct {
				struct hlist_node hlist_dup;
				struct list_head list;
			};
		};
	};
	struct hlist_head hlist;
	union {
		long unsigned int kpfn;
		long unsigned int chain_prune_time;
	};
	int rmap_hlist_len;
	int nid;
};

enum get_ksm_page_flags {
	GET_KSM_PAGE_NOLOCK = 0,
	GET_KSM_PAGE_LOCK = 1,
	GET_KSM_PAGE_TRYLOCK = 2,
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

struct track {
	long unsigned int addr;
	long unsigned int addrs[16];
	int cpu;
	int pid;
	long unsigned int when;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

struct detached_freelist {
	struct page *page;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct location {
	long unsigned int count;
	long unsigned int addr;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[2];
	nodemask_t nodes;
};

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FULL = 2,
	M_FREE = 3,
};

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page *b_page;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

typedef struct page *new_page_t(struct page *, long unsigned int);

typedef void free_page_t(struct page *, long unsigned int);

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

enum scan_result {
	SCAN_FAIL = 0,
	SCAN_SUCCEED = 1,
	SCAN_PMD_NULL = 2,
	SCAN_EXCEED_NONE_PTE = 3,
	SCAN_EXCEED_SWAP_PTE = 4,
	SCAN_EXCEED_SHARED_PTE = 5,
	SCAN_PTE_NON_PRESENT = 6,
	SCAN_PTE_UFFD_WP = 7,
	SCAN_PAGE_RO = 8,
	SCAN_LACK_REFERENCED_PAGE = 9,
	SCAN_PAGE_NULL = 10,
	SCAN_SCAN_ABORT = 11,
	SCAN_PAGE_COUNT = 12,
	SCAN_PAGE_LRU = 13,
	SCAN_PAGE_LOCK = 14,
	SCAN_PAGE_ANON = 15,
	SCAN_PAGE_COMPOUND = 16,
	SCAN_ANY_PROCESS = 17,
	SCAN_VMA_NULL = 18,
	SCAN_VMA_CHECK = 19,
	SCAN_ADDRESS_RANGE = 20,
	SCAN_SWAP_CACHE_PAGE = 21,
	SCAN_DEL_PAGE_LRU = 22,
	SCAN_ALLOC_HUGE_PAGE_FAIL = 23,
	SCAN_CGROUP_CHARGE_FAIL = 24,
	SCAN_TRUNCATED = 25,
	SCAN_PAGE_HAS_PRIVATE = 26,
};

struct trace_event_raw_mm_khugepaged_scan_pmd {
	struct trace_entry ent;
	struct mm_struct *mm;
	long unsigned int pfn;
	bool writable;
	int referenced;
	int none_or_zero;
	int status;
	int unmapped;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page {
	struct trace_entry ent;
	struct mm_struct *mm;
	int isolated;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_isolate {
	struct trace_entry ent;
	long unsigned int pfn;
	int none_or_zero;
	int referenced;
	bool writable;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_swapin {
	struct trace_entry ent;
	struct mm_struct *mm;
	int swapped_in;
	int referenced;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_mm_khugepaged_scan_pmd {};

struct trace_event_data_offsets_mm_collapse_huge_page {};

struct trace_event_data_offsets_mm_collapse_huge_page_isolate {};

struct trace_event_data_offsets_mm_collapse_huge_page_swapin {};

typedef void (*btf_trace_mm_khugepaged_scan_pmd)(void *, struct mm_struct *, struct page *, bool, int, int, int, int);

typedef void (*btf_trace_mm_collapse_huge_page)(void *, struct mm_struct *, int, int);

typedef void (*btf_trace_mm_collapse_huge_page_isolate)(void *, struct page *, int, int, bool, int);

typedef void (*btf_trace_mm_collapse_huge_page_swapin)(void *, struct mm_struct *, int, int, int);

struct mm_slot___2 {
	struct hlist_node hash;
	struct list_head mm_node;
	struct mm_struct *mm;
	int nr_pte_mapped_thp;
	long unsigned int pte_mapped_thp[8];
};

struct khugepaged_scan {
	struct list_head mm_head;
	struct mm_slot___2 *mm_slot;
	long unsigned int address;
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

struct mem_cgroup_tree_per_node {
	struct rb_root rb_root;
	struct rb_node *rb_rightmost;
	spinlock_t lock;
};

struct mem_cgroup_tree {
	struct mem_cgroup_tree_per_node *rb_tree_per_node[64];
};

struct mem_cgroup_eventfd_list {
	struct list_head list;
	struct eventfd_ctx *eventfd;
};

struct mem_cgroup_event {
	struct mem_cgroup *memcg;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	int (*register_event)(struct mem_cgroup *, struct eventfd_ctx *, const char *);
	void (*unregister_event)(struct mem_cgroup *, struct eventfd_ctx *);
	poll_table pt;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct work_struct remove;
};

struct move_charge_struct {
	spinlock_t lock;
	struct mm_struct *mm;
	struct mem_cgroup *from;
	struct mem_cgroup *to;
	long unsigned int flags;
	long unsigned int precharge;
	long unsigned int moved_charge;
	long unsigned int moved_swap;
	struct task_struct *moving_task;
	wait_queue_head_t waitq;
};

enum res_type {
	_MEM = 0,
	_MEMSWAP = 1,
	_OOM_TYPE = 2,
	_KMEM = 3,
	_TCP = 4,
};

struct memory_stat {
	const char *name;
	unsigned int ratio;
	unsigned int idx;
};

struct oom_wait_info {
	struct mem_cgroup *memcg;
	wait_queue_entry_t wait;
};

enum oom_status {
	OOM_SUCCESS = 0,
	OOM_FAILED = 1,
	OOM_ASYNC = 2,
	OOM_SKIPPED = 3,
};

struct memcg_stock_pcp {
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct obj_cgroup *cached_objcg;
	unsigned int nr_bytes;
	struct work_struct work;
	long unsigned int flags;
};

enum {
	RES_USAGE = 0,
	RES_LIMIT = 1,
	RES_MAX_USAGE = 2,
	RES_FAILCNT = 3,
	RES_SOFT_LIMIT = 4,
};

union mc_target {
	struct page *page;
	swp_entry_t ent;
};

enum mc_target_type {
	MC_TARGET_NONE = 0,
	MC_TARGET_PAGE = 1,
	MC_TARGET_SWAP = 2,
	MC_TARGET_DEVICE = 3,
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	long unsigned int nr_pages;
	long unsigned int pgpgout;
	long unsigned int nr_kmem;
	struct page *dummy_page;
};

struct numa_stat {
	const char *name;
	unsigned int lru_mask;
};

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

struct swap_cgroup_ctrl {
	struct page **map;
	long unsigned int length;
	spinlock_t lock;
};

struct swap_cgroup {
	short unsigned int id;
};

enum {
	RES_USAGE___2 = 0,
	RES_RSVD_USAGE = 1,
	RES_LIMIT___2 = 2,
	RES_RSVD_LIMIT = 3,
	RES_MAX_USAGE___2 = 4,
	RES_RSVD_MAX_USAGE = 5,
	RES_FAILCNT___2 = 6,
	RES_RSVD_FAILCNT = 7,
};

enum mf_result {
	MF_IGNORED = 0,
	MF_FAILED = 1,
	MF_DELAYED = 2,
	MF_RECOVERED = 3,
};

enum mf_action_page_type {
	MF_MSG_KERNEL = 0,
	MF_MSG_KERNEL_HIGH_ORDER = 1,
	MF_MSG_SLAB = 2,
	MF_MSG_DIFFERENT_COMPOUND = 3,
	MF_MSG_POISONED_HUGE = 4,
	MF_MSG_HUGE = 5,
	MF_MSG_FREE_HUGE = 6,
	MF_MSG_NON_PMD_HUGE = 7,
	MF_MSG_UNMAP_FAILED = 8,
	MF_MSG_DIRTY_SWAPCACHE = 9,
	MF_MSG_CLEAN_SWAPCACHE = 10,
	MF_MSG_DIRTY_MLOCKED_LRU = 11,
	MF_MSG_CLEAN_MLOCKED_LRU = 12,
	MF_MSG_DIRTY_UNEVICTABLE_LRU = 13,
	MF_MSG_CLEAN_UNEVICTABLE_LRU = 14,
	MF_MSG_DIRTY_LRU = 15,
	MF_MSG_CLEAN_LRU = 16,
	MF_MSG_TRUNCATED_LRU = 17,
	MF_MSG_BUDDY = 18,
	MF_MSG_BUDDY_2ND = 19,
	MF_MSG_DAX = 20,
	MF_MSG_UNSPLIT_THP = 21,
	MF_MSG_UNKNOWN = 22,
};

typedef long unsigned int dax_entry_t;

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct to_kill {
	struct list_head nd;
	struct task_struct *tsk;
	long unsigned int addr;
	short int size_shift;
};

struct page_state {
	long unsigned int mask;
	long unsigned int res;
	enum mf_action_page_type type;
	int (*action)(struct page *, long unsigned int);
};

struct memory_failure_entry {
	long unsigned int pfn;
	int flags;
};

struct memory_failure_cpu {
	struct {
		union {
			struct __kfifo kfifo;
			struct memory_failure_entry *type;
			const struct memory_failure_entry *const_type;
			char (*rectype)[0];
			struct memory_failure_entry *ptr;
			const struct memory_failure_entry *ptr_const;
		};
		struct memory_failure_entry buf[16];
	} fifo;
	spinlock_t lock;
	struct work_struct work;
};

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

struct cma {
	long unsigned int base_pfn;
	long unsigned int count;
	long unsigned int *bitmap;
	unsigned int order_per_bit;
	struct mutex lock;
	char name[64];
};

struct trace_event_raw_cma_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	const struct page *page;
	unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	long unsigned int pfn;
	const struct page *page;
	unsigned int count;
	char __data[0];
};

struct trace_event_data_offsets_cma_alloc {};

struct trace_event_data_offsets_cma_release {};

typedef void (*btf_trace_cma_alloc)(void *, long unsigned int, const struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_cma_release)(void *, long unsigned int, const struct page *, unsigned int);

struct balloon_dev_info {
	long unsigned int isolated_pages;
	spinlock_t pages_lock;
	struct list_head pages;
	int (*migratepage)(struct balloon_dev_info *, struct page *, struct page *, enum migrate_mode);
	struct inode *inode;
};

enum hmm_pfn_flags {
	HMM_PFN_VALID = 0,
	HMM_PFN_WRITE = 0,
	HMM_PFN_ERROR = 0,
	HMM_PFN_ORDER_SHIFT = 56,
	HMM_PFN_REQ_FAULT = 0,
	HMM_PFN_REQ_WRITE = 0,
	HMM_PFN_FLAGS = 0,
};

struct hmm_range {
	struct mmu_interval_notifier *notifier;
	long unsigned int notifier_seq;
	long unsigned int start;
	long unsigned int end;
	long unsigned int *hmm_pfns;
	long unsigned int default_flags;
	long unsigned int pfn_flags_mask;
	void *dev_private_owner;
};

struct hmm_vma_walk {
	struct hmm_range *range;
	long unsigned int last;
};

enum {
	HMM_NEED_FAULT = 1,
	HMM_NEED_WRITE_FAULT = 2,
	HMM_NEED_ALL_BITS = 3,
};

struct hugetlbfs_inode_info {
	struct shared_policy policy;
	struct inode vfs_inode;
	unsigned int seals;
};

struct page_reporting_dev_info {
	int (*report)(struct page_reporting_dev_info *, struct scatterlist *, unsigned int);
	struct delayed_work work;
	atomic_t state;
};

enum {
	PAGE_REPORTING_IDLE = 0,
	PAGE_REPORTING_REQUESTED = 1,
	PAGE_REPORTING_ACTIVE = 2,
};

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
};

typedef s32 compat_off_t;

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

typedef __kernel_rwf_t rwf_t;

typedef s64 compat_loff_t;

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

struct kobj_map;

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	__kernel_ulong_t st_dev;
	__kernel_ulong_t st_ino;
	__kernel_ulong_t st_nlink;
	unsigned int st_mode;
	unsigned int st_uid;
	unsigned int st_gid;
	unsigned int __pad0;
	__kernel_ulong_t st_rdev;
	__kernel_long_t st_size;
	__kernel_long_t st_blksize;
	__kernel_long_t st_blocks;
	__kernel_ulong_t st_atime;
	__kernel_ulong_t st_atime_nsec;
	__kernel_ulong_t st_mtime;
	__kernel_ulong_t st_mtime_nsec;
	__kernel_ulong_t st_ctime;
	__kernel_ulong_t st_ctime_nsec;
	__kernel_long_t __unused[3];
};

struct __old_kernel_stat {
	short unsigned int st_dev;
	short unsigned int st_ino;
	short unsigned int st_mode;
	short unsigned int st_nlink;
	short unsigned int st_uid;
	short unsigned int st_gid;
	short unsigned int st_rdev;
	unsigned int st_size;
	unsigned int st_atime;
	unsigned int st_mtime;
	unsigned int st_ctime;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u64 __spare2;
	__u64 __spare3[12];
};

struct mount;

struct mnt_namespace {
	atomic_t count;
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

typedef u32 compat_ino_t;

typedef u16 __compat_uid_t;

typedef u16 __compat_gid_t;

typedef u16 compat_mode_t;

typedef u16 compat_dev_t;

typedef u16 compat_nlink_t;

struct compat_stat {
	compat_dev_t st_dev;
	u16 __pad1;
	compat_ino_t st_ino;
	compat_mode_t st_mode;
	compat_nlink_t st_nlink;
	__compat_uid_t st_uid;
	__compat_gid_t st_gid;
	compat_dev_t st_rdev;
	u16 __pad2;
	u32 st_size;
	u32 st_blksize;
	u32 st_blocks;
	u32 st_atime;
	u32 st_atime_nsec;
	u32 st_mtime;
	u32 st_mtime_nsec;
	u32 st_ctime;
	u32 st_ctime_nsec;
	u32 __unused4;
	u32 __unused5;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	bool is_compat;
	union {
		const char * const *native;
		const compat_uptr_t *compat;
	} ptr;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[32];
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	kuid_t dir_uid;
	umode_t dir_mode;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct compat_flock {
	short int l_type;
	short int l_whence;
	compat_off_t l_start;
	compat_off_t l_len;
	compat_pid_t l_pid;
};

struct compat_flock64 {
	short int l_type;
	short int l_whence;
	compat_loff_t l_start;
	compat_loff_t l_len;
	compat_pid_t l_pid;
} __attribute__((packed));

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct space_resv_32 {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
} __attribute__((packed));

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct old_linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_offset;
	short unsigned int d_namlen;
	char d_name[1];
};

struct readdir_callback {
	struct dir_context ctx;
	struct old_linux_dirent *dirent;
	int result;
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct compat_old_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_offset;
	short unsigned int d_namlen;
	char d_name[1];
};

struct compat_readdir_callback {
	struct dir_context ctx;
	struct compat_old_linux_dirent *dirent;
	int result;
};

struct compat_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct compat_getdents_callback {
	struct dir_context ctx;
	struct compat_linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

struct compat_sel_arg_struct {
	compat_ulong_t n;
	compat_uptr_t inp;
	compat_uptr_t outp;
	compat_uptr_t exp;
	compat_uptr_t tvp;
};

struct compat_sigset_argpack {
	compat_uptr_t p;
	compat_size_t size;
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_page_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_inode_foreign_history {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t cgroup_ino;
	unsigned int history;
	char __data[0];
};

struct trace_event_raw_inode_switch_wbs {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t old_cgroup_ino;
	ino_t new_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_track_foreign_dirty {
	struct trace_entry ent;
	char name[32];
	u64 bdi_id;
	ino_t ino;
	unsigned int memcg_id;
	ino_t cgroup_ino;
	ino_t page_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_flush_foreign {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	unsigned int frn_bdi_id;
	unsigned int frn_memcg_id;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_congest_waited_template {
	struct trace_entry ent;
	unsigned int usec_timeout;
	unsigned int usec_delayed;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_page_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_inode_foreign_history {};

struct trace_event_data_offsets_inode_switch_wbs {};

struct trace_event_data_offsets_track_foreign_dirty {};

struct trace_event_data_offsets_flush_foreign {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_congest_waited_template {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_page)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_wait_on_page_writeback)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);

typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);

typedef void (*btf_trace_track_foreign_dirty)(void *, struct page *, struct bdi_writeback *);

typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_congestion_wait)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_wait_iff_congested)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct inode_switch_wbs_context {
	struct inode *inode;
	struct bdi_writeback *new_wb;
	struct callback_head callback_head;
	struct work_struct work;
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

struct utimbuf {
	__kernel_old_time_t actime;
	__kernel_old_time_t modtime;
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	__kernel_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

typedef s32 compat_daddr_t;

typedef __kernel_fsid_t compat_fsid_t;

struct compat_statfs {
	int f_type;
	int f_bsize;
	int f_blocks;
	int f_bfree;
	int f_bavail;
	int f_files;
	int f_ffree;
	compat_fsid_t f_fsid;
	int f_namelen;
	int f_frsize;
	int f_flags;
	int f_spare[4];
};

struct compat_ustat {
	compat_daddr_t f_tfree;
	compat_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct compat_statfs64 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
} __attribute__((packed));

typedef struct ns_common *ns_get_path_helper_t(void *);

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

struct dax_device;

struct iomap_page_ops;

struct iomap___2 {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int, struct iomap___2 *);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *, struct iomap___2 *);
};

struct decrypt_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	bool multi_bio: 1;
	bool should_dirty: 1;
	bool is_sync: 1;
	struct bio bio;
};

struct bd_holder_disk {
	struct list_head list;
	struct gendisk *disk;
	int refcnt;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dio {
	int flags;
	int op;
	int op_flags;
	blk_qc_t bio_cookie;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct page *page;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	unsigned int use_writepage;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct epoll_event {
	__poll_t events;
	__u64 data;
} __attribute__((packed));

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct nested_call_node {
	struct list_head llink;
	void *cookie;
	void *ctx;
};

struct nested_calls {
	struct list_head tasks_call_list;
	spinlock_t lock;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	int nwait;
	struct list_head pwqlist;
	struct eventpoll *ep;
	struct list_head fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	unsigned int napi_id;
};

struct eppoll_entry {
	struct list_head llink;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct ep_send_events_data {
	int maxevents;
	struct epoll_event *events;
	int res;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx___2 {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef u32 compat_aio_context_t;

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool done;
	bool cancelled;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct __compat_aio_sigset {
	compat_uptr_t sigmask;
	compat_size_t sigsetsize;
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

typedef s32 compat_ssize_t;

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 secid;
	u32 consumed;
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	bool eventfd;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	int fd;
	char __data[0];
};

struct io_wq_work;

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	int rw;
	void *req;
	struct io_wq_work *work;
	unsigned int flags;
	char __data[0];
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work {
	struct io_wq_work_node list;
	struct io_identity *identity;
	unsigned int flags;
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *req;
	void *link;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	u64 user_data;
	long int res;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_sqe {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	bool force_nonblock;
	bool sq_thread;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	int events;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_wake {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_run {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	char __data[0];
};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_queue_async_work {};

struct trace_event_data_offsets_io_uring_defer {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_fail_link {};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_submit_sqe {};

struct trace_event_data_offsets_io_uring_poll_arm {};

struct trace_event_data_offsets_io_uring_poll_wake {};

struct trace_event_data_offsets_io_uring_task_add {};

struct trace_event_data_offsets_io_uring_task_run {};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, bool, long int);

typedef void (*btf_trace_io_uring_file_get)(void *, void *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, void *, int, void *, struct io_wq_work *, unsigned int);

typedef void (*btf_trace_io_uring_defer)(void *, void *, void *, long long unsigned int);

typedef void (*btf_trace_io_uring_link)(void *, void *, void *, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, void *, void *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, u64, long int);

typedef void (*btf_trace_io_uring_submit_sqe)(void *, void *, u8, u64, bool, bool);

typedef void (*btf_trace_io_uring_poll_arm)(void *, void *, u8, u64, int, int);

typedef void (*btf_trace_io_uring_poll_wake)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_add)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_run)(void *, void *, u8, u64);

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
	};
	__u64 user_data;
	union {
		struct {
			union {
				__u16 buf_index;
				__u16 buf_group;
			};
			__u16 personality;
			__s32 splice_fd_in;
		};
		__u64 __pad2[3];
	};
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
};

enum {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_LAST = 34,
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
};

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 resv2;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_LAST = 13,
};

struct io_uring_files_update {
	__u32 offset;
	__u32 resv;
	__u64 fds;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_NO_CANCEL = 8,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_WORK_FILES = 32,
	IO_WQ_WORK_FS = 64,
	IO_WQ_WORK_MM = 128,
	IO_WQ_WORK_CREDS = 256,
	IO_WQ_WORK_BLKCG = 512,
	IO_WQ_WORK_FSIZE = 1024,
	IO_WQ_HASH_SHIFT = 24,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

typedef void free_work_fn(struct io_wq_work *);

typedef struct io_wq_work *io_wq_work_fn(struct io_wq_work *);

struct io_wq_data {
	struct user_struct *user;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_uring {
	u32 head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 tail;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	u32 sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

struct io_mapped_ubuf {
	u64 ubuf;
	size_t len;
	struct bio_vec *bvec;
	unsigned int nr_bvecs;
	long unsigned int acct_pages;
};

struct fixed_file_table {
	struct file **files;
};

struct fixed_file_data;

struct fixed_file_ref_node {
	struct percpu_ref refs;
	struct list_head node;
	struct list_head file_list;
	struct fixed_file_data *file_data;
	struct llist_node llist;
};

struct io_ring_ctx;

struct fixed_file_data {
	struct fixed_file_table *table;
	struct io_ring_ctx *ctx;
	struct fixed_file_ref_node *node;
	struct percpu_ref refs;
	struct completion done;
	struct list_head ref_list;
	spinlock_t lock;
};

struct io_wq;

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_sq_data;

struct io_kiocb;

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		unsigned int flags;
		unsigned int compat: 1;
		unsigned int limit_mem: 1;
		unsigned int cq_overflow_flushed: 1;
		unsigned int drain_next: 1;
		unsigned int eventfd_async: 1;
		unsigned int restricted: 1;
		u32 *sq_array;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		unsigned int sq_mask;
		unsigned int sq_thread_idle;
		unsigned int cached_sq_dropped;
		unsigned int cached_cq_overflow;
		long unsigned int sq_check_overflow;
		struct list_head defer_list;
		struct list_head timeout_list;
		struct list_head cq_overflow_list;
		wait_queue_head_t inflight_wait;
		struct io_uring_sqe *sq_sqes;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct io_rings *rings;
	struct io_wq *io_wq;
	struct task_struct *sqo_task;
	struct mm_struct *mm_account;
	struct cgroup_subsys_state *sqo_blkcg_css;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct wait_queue_entry sqo_wait_entry;
	struct list_head sqd_list;
	struct fixed_file_data *file_data;
	unsigned int nr_user_files;
	unsigned int nr_user_bufs;
	struct io_mapped_ubuf *user_bufs;
	struct user_struct *user;
	const struct cred *creds;
	kuid_t loginuid;
	unsigned int sessionid;
	struct completion ref_comp;
	struct completion sq_thread_comp;
	struct io_kiocb *fallback_req;
	struct socket *ring_sock;
	struct idr io_buffer_idr;
	struct idr personality_idr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		unsigned int cq_mask;
		atomic_t cq_timeouts;
		long unsigned int cq_check_overflow;
		struct wait_queue_head cq_wait;
		struct fasync_struct *cq_fasync;
		struct eventfd_ctx *cq_ev_fd;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		wait_queue_head_t wait;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t completion_lock;
		struct list_head iopoll_list;
		struct hlist_head *cancel_hash;
		unsigned int cancel_hash_bits;
		bool poll_multi_file;
		spinlock_t inflight_lock;
		struct list_head inflight_list;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work file_put_work;
	struct llist_head file_put_llist;
	struct work_struct exit_work;
	struct io_restriction restrictions;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__s32 len;
	__u16 bid;
};

struct io_sq_data {
	refcount_t refs;
	struct mutex lock;
	struct list_head ctx_list;
	struct list_head ctx_new_list;
	struct mutex ctx_lock;
	struct task_struct *thread;
	struct wait_queue_head wait;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u64 len;
};

struct io_poll_iocb {
	struct file *file;
	union {
		struct wait_queue_head *head;
		u64 addr;
	};
	__poll_t events;
	bool done;
	bool canceled;
	struct wait_queue_entry wait;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	long unsigned int nofile;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_cancel {
	struct file *file;
	u64 addr;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	struct list_head list;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
};

struct io_sr_msg {
	struct file *file;
	union {
		struct user_msghdr *umsg;
		void *buf;
	};
	int msg_flags;
	int bgid;
	size_t len;
	struct io_buffer *kbuf;
};

struct io_open {
	struct file *file;
	int dfd;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
};

struct io_close {
	struct file *file;
	struct file *put_file;
	int fd;
};

struct io_files_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
} __attribute__((packed));

struct io_splice {
	struct file *file_out;
	struct file *file_in;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	unsigned int flags;
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__s32 len;
	__u32 bgid;
	__u16 nbufs;
	__u16 bid;
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	const char *filename;
	struct statx *buffer;
};

struct io_completion {
	struct file *file;
	struct list_head list;
	int cflags;
};

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_rw rw;
		struct io_poll_iocb poll;
		struct io_accept accept;
		struct io_sync sync;
		struct io_cancel cancel;
		struct io_timeout timeout;
		struct io_timeout_rem timeout_rem;
		struct io_connect connect;
		struct io_sr_msg sr_msg;
		struct io_open open;
		struct io_close close;
		struct io_files_update files_update;
		struct io_fadvise fadvise;
		struct io_madvise madvise;
		struct io_epoll epoll;
		struct io_splice splice;
		struct io_provide_buf pbuf;
		struct io_statx statx;
		struct io_completion compl;
	};
	void *async_data;
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	u32 result;
	struct io_ring_ctx *ctx;
	unsigned int flags;
	refcount_t refs;
	struct task_struct *task;
	u64 user_data;
	struct list_head link_list;
	struct list_head inflight_entry;
	struct percpu_ref *fixed_file_refs;
	struct callback_head task_work;
	struct hlist_node hash_node;
	struct async_poll *apoll;
	struct io_wq_work work;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

struct io_async_msghdr {
	struct iovec fast_iov[8];
	struct iovec *iov;
	struct sockaddr *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_rw {
	struct iovec fast_iov[8];
	const struct iovec *free_iovec;
	struct iov_iter iter;
	size_t bytes_done;
	struct wait_page_queue wpq;
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_LINK_HEAD_BIT = 6,
	REQ_F_FAIL_LINK_BIT = 7,
	REQ_F_INFLIGHT_BIT = 8,
	REQ_F_CUR_POS_BIT = 9,
	REQ_F_NOWAIT_BIT = 10,
	REQ_F_LINK_TIMEOUT_BIT = 11,
	REQ_F_ISREG_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_BUFFER_SELECTED_BIT = 15,
	REQ_F_NO_FILE_TABLE_BIT = 16,
	REQ_F_WORK_INITIALIZED_BIT = 17,
	REQ_F_LTIMEOUT_ACTIVE_BIT = 18,
	__REQ_F_LAST_BIT = 19,
};

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_LINK_HEAD = 64,
	REQ_F_FAIL_LINK = 128,
	REQ_F_INFLIGHT = 256,
	REQ_F_CUR_POS = 512,
	REQ_F_NOWAIT = 1024,
	REQ_F_LINK_TIMEOUT = 2048,
	REQ_F_ISREG = 4096,
	REQ_F_NEED_CLEANUP = 8192,
	REQ_F_POLLED = 16384,
	REQ_F_BUFFER_SELECTED = 32768,
	REQ_F_NO_FILE_TABLE = 65536,
	REQ_F_WORK_INITIALIZED = 131072,
	REQ_F_LTIMEOUT_ACTIVE = 262144,
};

struct async_poll {
	struct io_poll_iocb poll;
	struct io_poll_iocb *double_poll;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_comp_state {
	unsigned int nr;
	struct list_head list;
	struct io_ring_ctx *ctx;
};

struct io_submit_state {
	struct blk_plug plug;
	void *reqs[8];
	unsigned int free_reqs;
	struct io_comp_state comp;
	struct file *file;
	unsigned int fd;
	unsigned int has_refs;
	unsigned int ios_left;
};

struct io_op_def {
	unsigned int needs_file: 1;
	unsigned int needs_file_no_error: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int not_supported: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int buffer_select: 1;
	unsigned int needs_async_data: 1;
	short unsigned int async_size;
	unsigned int work_flags;
};

enum io_mem_account {
	ACCT_LOCKED = 0,
	ACCT_PINNED = 1,
};

struct req_batch {
	void *reqs[8];
	int to_free;
	struct task_struct *task;
	int task_refs;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int error;
};

enum sq_ret {
	SQT_IDLE = 1,
	SQT_SPIN = 2,
	SQT_DID_WORK = 4,
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int to_wait;
	unsigned int nr_timeouts;
};

struct io_file_put {
	struct list_head list;
	struct file *file;
};

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

typedef bool work_cancel_fn(struct io_wq_work *, void *);

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_FIXED = 8,
	IO_WORKER_F_BOUND = 16,
};

enum {
	IO_WQ_BIT_EXIT = 0,
	IO_WQ_BIT_CANCEL = 1,
	IO_WQ_BIT_ERROR = 2,
};

enum {
	IO_WQE_FLAG_STALLED = 1,
};

struct io_wqe;

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wqe *wqe;
	struct io_wq_work *cur_work;
	spinlock_t lock;
	struct callback_head rcu;
	struct mm_struct *mm;
	struct cgroup_subsys_state *blkcg_css;
	const struct cred *cur_creds;
	const struct cred *saved_creds;
	struct files_struct *restore_files;
	struct nsproxy *restore_nsproxy;
	struct fs_struct *restore_fs;
};

struct io_wqe_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	atomic_t nr_running;
};

struct io_wq___2;

struct io_wqe {
	struct {
		raw_spinlock_t lock;
		struct io_wq_work_list work_list;
		long unsigned int hash_map;
		unsigned int flags;
		long: 32;
		long: 64;
	};
	int node;
	struct io_wqe_acct acct[2];
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct io_wq___2 *wq;
	struct io_wq_work *hash_tail[64];
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
};

struct io_wq___2 {
	struct io_wqe **wqes;
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct task_struct *manager;
	struct user_struct *user;
	refcount_t refs;
	struct completion done;
	struct hlist_node cpuhp_node;
	refcount_t use_refs;
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

enum {
	VERBOSE_STATUS = 1,
};

enum {
	Enabled = 0,
	Magic = 1,
};

typedef struct {
	struct list_head list;
	long unsigned int flags;
	int offset;
	int size;
	char *magic;
	char *mask;
	const char *interpreter;
	char *name;
	struct dentry *dentry;
	struct file *interp_file;
} Node;

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
};

struct arch_elf_state {};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct user_regs_struct {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	long unsigned int cs;
	long unsigned int flags;
	long unsigned int sp;
	long unsigned int ss;
	long unsigned int fs_base;
	long unsigned int gs_base;
	long unsigned int ds;
	long unsigned int es;
	long unsigned int fs;
	long unsigned int gs;
};

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

typedef struct user_regs_struct compat_elf_gregset_t;

struct compat_elf_siginfo {
	compat_int_t si_signo;
	compat_int_t si_code;
	compat_int_t si_errno;
};

struct compat_elf_prstatus {
	struct compat_elf_siginfo pr_info;
	short int pr_cursig;
	compat_ulong_t pr_sigpend;
	compat_ulong_t pr_sighold;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	struct old_timeval32 pr_utime;
	struct old_timeval32 pr_stime;
	struct old_timeval32 pr_cutime;
	struct old_timeval32 pr_cstime;
	compat_elf_gregset_t pr_reg;
	compat_int_t pr_fpvalid;
};

struct compat_elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	compat_ulong_t pr_flag;
	__compat_uid_t pr_uid;
	__compat_gid_t pr_gid;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct elf_thread_core_info___2 {
	struct elf_thread_core_info___2 *next;
	struct task_struct *task;
	struct compat_elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info___2 {
	struct elf_thread_core_info___2 *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	compat_siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	u32 e_referenced: 1;
	u32 e_reusable: 1;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

struct nfsacl_encode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
	int typeflag;
	kuid_t uid;
	kgid_t gid;
};

struct nfsacl_simple_acl {
	struct posix_acl acl;
	struct posix_acl_entry ace[4];
};

struct nfsacl_decode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	short unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	int owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct nfs4_state;

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
};

struct rpc_rqst;

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct rpc_xprt;

struct rpc_task;

struct rpc_cred;

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_call_ops;

struct rpc_clnt;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	int tk_rpc_status;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
	unsigned char tk_rebind_retry: 2;
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_switch;

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_auth;

struct rpc_stat;

struct rpc_iostats;

struct rpc_program;

struct rpc_clnt {
	atomic_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
};

struct rpc_xprt_ops;

struct svc_xprt;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	struct svc_xprt *bc_xprt;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

typedef u32 rpc_authflavor_t;

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_auth_create_args;

struct rpcsec_gss_info;

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	void (*prepare_request)(struct rpc_rqst *);
	int (*send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct callback_head xps_rcu;
};

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct rpc_version;

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = 4294967295,
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 len;
	char *label;
};

typedef struct {
	char data[8];
} nfs4_verifier;

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	__u32 xattr_support;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs4_change_info {
	u32 atomic;
	u64 before;
	u64 after;
};

struct nfs4_slot;

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_open_context;

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	long unsigned int flags;
	int error;
	struct list_head list;
	struct nfs4_threshold *mdsthreshold;
	struct callback_head callback_head;
};

struct nlm_host;

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct pnfs_layoutdriver_type;

struct nfs_client;

struct nfs_iostats;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	atomic_long_t writeback;
	int flags;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	struct nfs_fsid fsid;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	struct ida openowner_id;
	struct ida lockowner_id;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
};

struct idmap;

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_rpc_ops;

struct nfs_subversion;

struct nfs4_minor_version_ops;

struct nfs4_slot_table;

struct nfs4_session;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	const char *cl_principal;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			u32 *bitmask;
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	__u64 prev_cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct pnfs_ds_commit_info {};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_page;

struct pnfs_layout_segment;

struct nfs_pgio_completion_ops;

struct nfs_rw_ops;

struct nfs_io_completion;

struct nfs_direct_req;

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
};

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)();
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct nfs_commit_data;

struct nfs_commit_info;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	struct nfs_fattr dir_attr;
	long int timeout;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
};

struct nlmclnt_operations;

struct nfs_access_entry;

struct nfs_client_initdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*access)(struct inode *, struct nfs_access_entry *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct page *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct dentry *, const struct cred *, u64, struct page **, unsigned int, bool);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	const struct cred *cred;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_client_initdata {
	long unsigned int init_flags;
	const char *hostname;
	const struct sockaddr *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
};

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_mig_recovery_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs4_state_owner;

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs4_ssc_client_ops;

struct nfs_ssc_client_ops;

struct nfs_ssc_client_ops_tbl {
	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
	const struct nfs_ssc_client_ops *ssc_nfs_ops;
};

struct nfs4_ssc_client_ops {
	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
	void (*sco_close)(struct file *);
};

struct nfs_ssc_client_ops {
	void (*sco_sb_deactive)(struct super_block *);
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct inode *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	struct nfs_seqid_counter so_seqid;
	seqcount_spinlock_t so_reclaim_seqcount;
	struct mutex so_delegreturn_mutex;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	long unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_apply {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	loff_t length;
	unsigned int flags;
	const void *ops;
	void *actor;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_apply {};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_releasepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_invalidatepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_apply_dstmap)(void *, struct inode *, struct iomap___2 *);

typedef void (*btf_trace_iomap_apply_srcmap)(void *, struct inode *, struct iomap___2 *);

typedef void (*btf_trace_iomap_apply)(void *, struct inode *, loff_t, loff_t, unsigned int, const void *, void *, long unsigned int);

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap___2 *, struct iomap___2 *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap___2 *);
};

typedef loff_t (*iomap_actor_t)(struct inode *, loff_t, loff_t, void *, struct iomap___2 *, struct iomap___2 *);

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	void *io_private;
	struct bio *io_bio;
	struct bio io_inline_bio;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_page)(struct page *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap___2 iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

struct iomap_page {
	atomic_t read_bytes_pending;
	atomic_t write_bytes_pending;
	spinlock_t uptodate_lock;
	long unsigned int uptodate[0];
};

struct iomap_readpage_ctx {
	struct page *cur_page;
	bool cur_page_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

enum {
	IOMAP_WRITE_F_UNSHARE = 1,
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	blk_qc_t (*submit_io)(struct inode *, struct iomap___2 *, struct bio *, loff_t);
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct request_queue *last_queue;
			blk_qc_t cookie;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct fiemap_ctx {
	struct fiemap_extent_info *fi;
	struct iomap___2 prev;
};

struct iomap_swapfile_info {
	struct iomap___2 iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

typedef __kernel_uid32_t qid_t;

enum {
	DQF_INFO_DIRTY_B = 17,
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct qtree_fmt_operations {
	void (*mem2disk_dqblk)(void *, struct dquot *);
	void (*disk2mem_dqblk)(struct dquot *, void *);
	int (*is_id)(void *, struct dquot *);
};

struct qtree_mem_dqinfo {
	struct super_block *dqi_sb;
	int dqi_type;
	unsigned int dqi_blocks;
	unsigned int dqi_free_blk;
	unsigned int dqi_free_entry;
	unsigned int dqi_blocksize_bits;
	unsigned int dqi_entry_size;
	unsigned int dqi_usable_bs;
	unsigned int dqi_qtree_depth;
	const struct qtree_fmt_operations *dqi_ops;
};

struct v2_disk_dqheader {
	__le32 dqh_magic;
	__le32 dqh_version;
};

struct v2r0_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_ihardlimit;
	__le32 dqb_isoftlimit;
	__le32 dqb_curinodes;
	__le32 dqb_bhardlimit;
	__le32 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v2r1_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_pad;
	__le64 dqb_ihardlimit;
	__le64 dqb_isoftlimit;
	__le64 dqb_curinodes;
	__le64 dqb_bhardlimit;
	__le64 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v2_disk_dqinfo {
	__le32 dqi_bgrace;
	__le32 dqi_igrace;
	__le32 dqi_flags;
	__le32 dqi_blocks;
	__le32 dqi_free_blk;
	__le32 dqi_free_entry;
};

struct qt_disk_dqdbheader {
	__le32 dqdh_next_free;
	__le32 dqdh_prev_free;
	__le16 dqdh_entries;
	__le16 dqdh_pad1;
	__le32 dqdh_pad2;
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u64 qs_pad2[8];
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
} __attribute__((packed));

struct compat_fs_qfilestat {
	compat_u64 dqb_bhardlimit;
	compat_u64 qfs_nblks;
	compat_uint_t qfs_nextents;
} __attribute__((packed));

struct compat_fs_quota_stat {
	__s8 qs_version;
	char: 8;
	__u16 qs_flags;
	__s8 qs_pad;
	int: 24;
	struct compat_fs_qfilestat qs_uquota;
	struct compat_fs_qfilestat qs_gquota;
	compat_uint_t qs_incoredqs;
	compat_int_t qs_btimelimit;
	compat_int_t qs_itimelimit;
	compat_int_t qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
} __attribute__((packed));

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *tail_vma;
	struct mempolicy *task_mempolicy;
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_locked;
	u64 swap_pss;
	bool check_shmem_swap;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

struct clear_refs_private {
	enum clear_refs_types type;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct numa_maps {
	long unsigned int pages;
	long unsigned int anon;
	long unsigned int active;
	long unsigned int writeback;
	long unsigned int mapcount_max;
	long unsigned int dirty;
	long unsigned int swapcache;
	long unsigned int node[64];
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct seq_net_private {
	struct net *net;
};

struct bpf_iter_aux_info___2;

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
};

struct kernfs_open_node {
	atomic_t refcnt;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

struct dcookie_struct {
	struct path path;
	struct list_head hash_list;
};

struct dcookie_user {
	struct list_head next;
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_checkpoint_io_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	void *__crt_ctx[0];
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_shash {
	unsigned int descsize;
	struct crypto_tfm base;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__u32 s_padding[41];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

struct fscrypt_dummy_policy {};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	struct list_head i_orphan;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct rw_semaphore i_mmap_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_reserved[95];
	__le32 s_checksum;
};

struct mb_cache___2;

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct journal_s *s_journal;
	struct list_head s_orphan;
	struct mutex s_orphan_lock;
	long unsigned int s_ext4_flags;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *s_journal_bdev;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	long unsigned int s_stripe;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	spinlock_t s_bal_lock;
	long unsigned int s_mb_buddies_generated;
	long long unsigned int s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	atomic_t s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache___2 *s_ea_block_cache;
	struct mb_cache___2 *s_ea_inode_cache;
	spinlock_t s_es_lock;
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	atomic_t s_fc_subtid;
	atomic_t s_fc_ineligible_updates;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	u64 s_fc_avg_commit_time;
	struct ext4_fc_replay_state s_fc_replay_state;
	long: 64;
	long: 64;
	long: 64;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	ext4_grpblk_t bb_largest_free_order;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_FC_REASON_OK = 0,
	EXT4_FC_REASON_INELIGIBLE = 1,
	EXT4_FC_REASON_ALREADY_COMMITTED = 2,
	EXT4_FC_REASON_FC_START_FAILED = 3,
	EXT4_FC_REASON_FC_FAILED = 4,
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_COMMIT_FAILED = 9,
	EXT4_FC_REASON_MAX = 10,
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	atomic_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_MAY_INLINE_DATA = 7,
	EXT4_STATE_EXT_PRECACHED = 8,
	EXT4_STATE_LUSTRE_EA_INODE = 9,
	EXT4_STATE_VERITY_IN_PROGRESS = 10,
	EXT4_STATE_FC_COMMITTING = 11,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FS_ABORTED = 1,
	EXT4_MF_FC_INELIGIBLE = 2,
	EXT4_MF_FC_COMMITTING = 3,
};

struct fsverity_info;

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

typedef unsigned int __kernel_mode_t;

typedef __kernel_mode_t mode_t;

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
} ext4_iget_flags;

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
};

struct fscrypt_info;

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct compat_ext4_new_group_input {
	u32 group;
	compat_u64 block_bitmap;
	compat_u64 inode_bitmap;
	compat_u64 inode_table;
	u32 blocks_count;
	u16 reserved_blocks;
	u16 unused;
} __attribute__((packed));

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	__u16 ac_groups_scanned;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u16 ac_flags;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct mmpd_data {
	struct buffer_head *bh;
	struct super_block *sb;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidatepage_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_put_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	ext4_fsblk_t start;
	char __data[0];
};

struct trace_event_raw_ext4_ext_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_find_delalloc_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	int reverse;
	int found;
	ext4_lblk_t found_blk;
	char __data[0];
};

struct trace_event_raw_ext4_get_reserved_cluster_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	struct ext4_sb_info *sbi;
	int count;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_create {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_link {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_unlink {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidatepage_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4_direct_IO_enter {};

struct trace_event_data_offsets_ext4_direct_IO_exit {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_put_in_cache {};

struct trace_event_data_offsets_ext4_ext_in_cache {};

struct trace_event_data_offsets_ext4_find_delalloc_range {};

struct trace_event_data_offsets_ext4_get_reserved_cluster_alloc {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_create {};

struct trace_event_data_offsets_ext4_fc_track_link {};

struct trace_event_data_offsets_ext4_fc_track_unlink {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_direct_IO_enter)(void *, struct inode *, loff_t, long unsigned int, int);

typedef void (*btf_trace_ext4_direct_IO_exit)(void *, struct inode *, loff_t, long unsigned int, int, int);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_put_in_cache)(void *, struct inode *, ext4_lblk_t, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_in_cache)(void *, struct inode *, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_find_delalloc_range)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, int, ext4_lblk_t);

typedef void (*btf_trace_ext4_get_reserved_cluster_alloc)(void *, struct inode *, ext4_lblk_t, unsigned int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, struct inode *, long int, long int, int);

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32 = 10,
	Opt_debug = 11,
	Opt_removed = 12,
	Opt_user_xattr = 13,
	Opt_nouser_xattr = 14,
	Opt_acl = 15,
	Opt_noacl = 16,
	Opt_auto_da_alloc = 17,
	Opt_noauto_da_alloc = 18,
	Opt_noload = 19,
	Opt_commit = 20,
	Opt_min_batch_time = 21,
	Opt_max_batch_time = 22,
	Opt_journal_dev = 23,
	Opt_journal_path = 24,
	Opt_journal_checksum = 25,
	Opt_journal_async_commit = 26,
	Opt_abort = 27,
	Opt_data_journal = 28,
	Opt_data_ordered = 29,
	Opt_data_writeback = 30,
	Opt_data_err_abort = 31,
	Opt_data_err_ignore = 32,
	Opt_test_dummy_encryption = 33,
	Opt_inlinecrypt = 34,
	Opt_usrjquota = 35,
	Opt_grpjquota = 36,
	Opt_offusrjquota = 37,
	Opt_offgrpjquota = 38,
	Opt_jqfmt_vfsold = 39,
	Opt_jqfmt_vfsv0 = 40,
	Opt_jqfmt_vfsv1 = 41,
	Opt_quota = 42,
	Opt_noquota = 43,
	Opt_barrier = 44,
	Opt_nobarrier = 45,
	Opt_err___2 = 46,
	Opt_usrquota = 47,
	Opt_grpquota = 48,
	Opt_prjquota = 49,
	Opt_i_version = 50,
	Opt_dax = 51,
	Opt_dax_always = 52,
	Opt_dax_inode = 53,
	Opt_dax_never = 54,
	Opt_stripe = 55,
	Opt_delalloc = 56,
	Opt_nodelalloc = 57,
	Opt_warn_on_error = 58,
	Opt_nowarn_on_error = 59,
	Opt_mblk_io_submit = 60,
	Opt_lazytime = 61,
	Opt_nolazytime = 62,
	Opt_debug_want_extra_isize = 63,
	Opt_nomblk_io_submit = 64,
	Opt_block_validity = 65,
	Opt_noblock_validity = 66,
	Opt_inode_readahead_blks = 67,
	Opt_journal_ioprio = 68,
	Opt_dioread_nolock = 69,
	Opt_dioread_lock = 70,
	Opt_discard = 71,
	Opt_nodiscard = 72,
	Opt_init_itable = 73,
	Opt_noinit_itable = 74,
	Opt_max_dir_size_kb = 75,
	Opt_nojournal_checksum = 76,
	Opt_nombcache = 77,
	Opt_prefetch_block_bitmaps = 78,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_inode_readahead = 5,
	attr_trigger_test_error = 6,
	attr_first_error_time = 7,
	attr_last_error_time = 8,
	attr_feature = 9,
	attr_pointer_ui = 10,
	attr_pointer_ul = 11,
	attr_pointer_u64 = 12,
	attr_pointer_u8 = 13,
	attr_pointer_string = 14,
	attr_pointer_atomic = 15,
	attr_journal_task = 16,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	u8 fc_dname[0];
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct qstr fcd_name;
	unsigned char fcd_iname[32];
	struct list_head fcd_list;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	int head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	int write_op;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, long unsigned int, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, long unsigned int, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum hugetlb_param {
	Opt_gid___4 = 0,
	Opt_min_size = 1,
	Opt_mode___4 = 2,
	Opt_nr_inodes___2 = 3,
	Opt_pagesize = 4,
	Opt_size___2 = 5,
	Opt_uid___3 = 6,
};

struct iso_directory_record {
	__u8 length[1];
	__u8 ext_attr_length[1];
	__u8 extent[8];
	__u8 size[8];
	__u8 date[7];
	__u8 flags[1];
	__u8 file_unit_size[1];
	__u8 interleave[1];
	__u8 volume_sequence_number[4];
	__u8 name_len[1];
	char name[0];
};

struct iso_inode_info {
	long unsigned int i_iget5_block;
	long unsigned int i_iget5_offset;
	unsigned int i_first_extent;
	unsigned char i_file_format;
	unsigned char i_format_parm[3];
	long unsigned int i_next_section_block;
	long unsigned int i_next_section_offset;
	off_t i_section_size;
	struct inode vfs_inode;
};

struct nls_table;

struct isofs_sb_info {
	long unsigned int s_ninodes;
	long unsigned int s_nzones;
	long unsigned int s_firstdatazone;
	long unsigned int s_log_zone_size;
	long unsigned int s_max_size;
	int s_rock_offset;
	s32 s_sbsector;
	unsigned char s_joliet_level;
	unsigned char s_mapping;
	unsigned char s_check;
	unsigned char s_session;
	unsigned int s_high_sierra: 1;
	unsigned int s_rock: 2;
	unsigned int s_utf8: 1;
	unsigned int s_cruft: 1;
	unsigned int s_nocompress: 1;
	unsigned int s_hide: 1;
	unsigned int s_showassoc: 1;
	unsigned int s_overriderockperm: 1;
	unsigned int s_uid_set: 1;
	unsigned int s_gid_set: 1;
	umode_t s_fmode;
	umode_t s_dmode;
	kgid_t s_gid;
	kuid_t s_uid;
	struct nls_table *s_nls_iocharset;
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

struct cdrom_msf0 {
	__u8 minute;
	__u8 second;
	__u8 frame;
};

union cdrom_addr {
	struct cdrom_msf0 msf;
	int lba;
};

struct cdrom_tocentry {
	__u8 cdte_track;
	__u8 cdte_adr: 4;
	__u8 cdte_ctrl: 4;
	__u8 cdte_format;
	union cdrom_addr cdte_addr;
	__u8 cdte_datamode;
};

struct cdrom_multisession {
	union cdrom_addr addr;
	__u8 xa_flag;
	__u8 addr_format;
};

struct cdrom_mcn {
	__u8 medium_catalog_number[14];
};

struct packet_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct scsi_sense_hdr *sshdr;
	unsigned char data_direction;
	int quiet;
	int timeout;
	void *reserved[1];
};

struct cdrom_device_ops;

struct cdrom_device_info {
	const struct cdrom_device_ops *ops;
	struct list_head list;
	struct gendisk *disk;
	void *handle;
	int mask;
	int speed;
	int capacity;
	unsigned int options: 30;
	unsigned int mc_flags: 2;
	unsigned int vfs_events;
	unsigned int ioctl_events;
	int use_count;
	char name[20];
	__u8 sanyo_slot: 2;
	__u8 keeplocked: 1;
	__u8 reserved: 5;
	int cdda_method;
	__u8 last_sense;
	__u8 media_written;
	short unsigned int mmc3_profile;
	int for_data;
	int (*exit)(struct cdrom_device_info *);
	int mrw_mode_page;
};

struct cdrom_device_ops {
	int (*open)(struct cdrom_device_info *, int);
	void (*release)(struct cdrom_device_info *);
	int (*drive_status)(struct cdrom_device_info *, int);
	unsigned int (*check_events)(struct cdrom_device_info *, unsigned int, int);
	int (*tray_move)(struct cdrom_device_info *, int);
	int (*lock_door)(struct cdrom_device_info *, int);
	int (*select_speed)(struct cdrom_device_info *, int);
	int (*select_disc)(struct cdrom_device_info *, int);
	int (*get_last_session)(struct cdrom_device_info *, struct cdrom_multisession *);
	int (*get_mcn)(struct cdrom_device_info *, struct cdrom_mcn *);
	int (*reset)(struct cdrom_device_info *);
	int (*audio_ioctl)(struct cdrom_device_info *, unsigned int, void *);
	const int capability;
	int (*generic_packet)(struct cdrom_device_info *, struct packet_command *);
};

struct iso_volume_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2041];
};

struct iso_primary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct iso_supplementary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 flags[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 escape[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct hs_volume_descriptor {
	__u8 foo[8];
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2033];
};

struct hs_primary_descriptor {
	__u8 foo[8];
	__u8 type[1];
	__u8 id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 unused4[28];
	__u8 root_directory_record[34];
};

enum isofs_file_format {
	isofs_file_normal = 0,
	isofs_file_sparse = 1,
	isofs_file_compressed = 2,
};

struct iso9660_options {
	unsigned int rock: 1;
	unsigned int joliet: 1;
	unsigned int cruft: 1;
	unsigned int hide: 1;
	unsigned int showassoc: 1;
	unsigned int nocompress: 1;
	unsigned int overriderockperm: 1;
	unsigned int uid_set: 1;
	unsigned int gid_set: 1;
	unsigned int utf8: 1;
	unsigned char map;
	unsigned char check;
	unsigned int blocksize;
	umode_t fmode;
	umode_t dmode;
	kgid_t gid;
	kuid_t uid;
	char *iocharset;
	s32 session;
	s32 sbsector;
};

enum {
	Opt_block = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_cruft = 3,
	Opt_gid___5 = 4,
	Opt_ignore = 5,
	Opt_iocharset = 6,
	Opt_map_a = 7,
	Opt_map_n = 8,
	Opt_map_o = 9,
	Opt_mode___5 = 10,
	Opt_nojoliet = 11,
	Opt_norock = 12,
	Opt_sb___2 = 13,
	Opt_session = 14,
	Opt_uid___4 = 15,
	Opt_unhide = 16,
	Opt_utf8 = 17,
	Opt_err___3 = 18,
	Opt_nocompress = 19,
	Opt_hide = 20,
	Opt_showassoc = 21,
	Opt_dmode = 22,
	Opt_overriderockperm = 23,
};

struct isofs_iget5_callback_data {
	long unsigned int block;
	long unsigned int offset;
};

struct SU_SP_s {
	__u8 magic[2];
	__u8 skip;
};

struct SU_CE_s {
	__u8 extent[8];
	__u8 offset[8];
	__u8 size[8];
};

struct SU_ER_s {
	__u8 len_id;
	__u8 len_des;
	__u8 len_src;
	__u8 ext_ver;
	__u8 data[0];
};

struct RR_RR_s {
	__u8 flags[1];
};

struct RR_PX_s {
	__u8 mode[8];
	__u8 n_links[8];
	__u8 uid[8];
	__u8 gid[8];
};

struct RR_PN_s {
	__u8 dev_high[8];
	__u8 dev_low[8];
};

struct SL_component {
	__u8 flags;
	__u8 len;
	__u8 text[0];
};

struct RR_SL_s {
	__u8 flags;
	struct SL_component link;
};

struct RR_NM_s {
	__u8 flags;
	char name[0];
};

struct RR_CL_s {
	__u8 location[8];
};

struct RR_PL_s {
	__u8 location[8];
};

struct stamp {
	__u8 time[7];
};

struct RR_TF_s {
	__u8 flags;
	struct stamp times[0];
};

struct RR_ZF_s {
	__u8 algorithm[2];
	__u8 parms[2];
	__u8 real_size[8];
};

struct rock_ridge {
	__u8 signature[2];
	__u8 len;
	__u8 version;
	union {
		struct SU_SP_s SP;
		struct SU_CE_s CE;
		struct SU_ER_s ER;
		struct RR_RR_s RR;
		struct RR_PX_s PX;
		struct RR_PN_s PN;
		struct RR_SL_s SL;
		struct RR_NM_s NM;
		struct RR_CL_s CL;
		struct RR_PL_s PL;
		struct RR_TF_s TF;
		struct RR_ZF_s ZF;
	} u;
};

struct rock_state {
	void *buffer;
	unsigned char *chr;
	int len;
	int cont_size;
	int cont_extent;
	int cont_offset;
	int cont_loops;
	struct inode *inode;
};

struct isofs_fid {
	u32 block;
	u16 offset;
	u16 parent_offset;
	u32 generation;
	u32 parent_block;
	u32 parent_generation;
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

struct in_addr {
	__be32 s_addr;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	short unsigned int flags;
	signed char priority;
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = 2147483654,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = 2147483904,
	XPRT_TRANSPORT_LOCAL = 257,
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_serv;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct list_head xpt_ready;
	long unsigned int xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct svc_program;

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_version;

struct svc_rqst;

struct svc_process_info;

struct svc_program {
	struct svc_program *pg_next;
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	struct svc_stat *pg_stats;
	int (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char *, size_t);
	ssize_t (*downcall)(struct file *, const char *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_iostats {
	spinlock_t om_lock;
	long unsigned int om_ops;
	long unsigned int om_ntrans;
	long unsigned int om_timeouts;
	long long unsigned int om_bytes_sent;
	long long unsigned int om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	long unsigned int om_error_status;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	long unsigned int flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
};

struct gss_api_mech;

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct auth_domain;

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct auth_ops;

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct pnfs_layout_range {
	u32 iomode;
	u64 offset;
	u64 length;
};

struct pnfs_layout_hdr;

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	long unsigned int pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

struct nfs_page {
	struct list_head wb_list;
	struct page *wb_page;
	struct nfs_lock_context *wb_lock_context;
	long unsigned int wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	long unsigned int wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	short unsigned int wb_nio;
};

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler **xattr;
	struct list_head list;
};

struct nfs_iostats {
	long long unsigned int bytes[8];
	long unsigned int events[27];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct cache_deferred_req;

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	int thread_wait;
};

struct svc_cacherep;

struct svc_pool;

struct svc_procedure;

struct svc_deferred_req;

struct svc_rqst {
	struct list_head rq_all;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	size_t rq_xprt_hlen;
	struct xdr_buf rq_arg;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	long unsigned int rq_flags;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	void *rq_auth_data;
	int rq_auth_slack;
	int rq_reserved;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct svc_cacherep *rq_cacherep;
	struct task_struct *rq_task;
	spinlock_t rq_lock;
	struct net *rq_bc_net;
	void **rq_lease_breaker;
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	short unsigned int protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	long unsigned int flags;
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)();
	void (*flush)();
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	int (*accept)(struct svc_rqst *, __be32 *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	int (*set_client)(struct svc_rqst *);
};

struct svc_pool_stats {
	atomic_long_t packets;
	long unsigned int sockets_queued;
	atomic_long_t threads_woken;
	atomic_long_t threads_timedout;
};

struct svc_pool {
	unsigned int sp_id;
	spinlock_t sp_lock;
	struct list_head sp_sockets;
	unsigned int sp_nrthreads;
	struct list_head sp_all_threads;
	struct svc_pool_stats sp_stats;
	long unsigned int sp_flags;
	long: 64;
	long: 64;
};

struct svc_serv_ops {
	void (*svo_shutdown)(struct svc_serv *, struct net *);
	int (*svo_function)(void *);
	void (*svo_enqueue_xprt)(struct svc_xprt *);
	int (*svo_setup)(struct svc_serv *, struct svc_pool *, int);
	struct module *svo_module;
};

struct svc_serv {
	struct svc_program *sv_program;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	unsigned int sv_nrthreads;
	unsigned int sv_maxconn;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	struct svc_pool *sv_pools;
	const struct svc_serv_ops *sv_ops;
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	int (*pc_decode)(struct svc_rqst *, __be32 *);
	int (*pc_encode)(struct svc_rqst *, __be32 *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	struct cache_deferred_req handle;
	size_t xprt_hlen;
	int argslen;
	__be32 args[0];
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *, __be32 *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	unsigned int *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *, __be32 *);
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_read_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_rqst)(struct svc_rqst *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_secure_port)(struct svc_rqst *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	short unsigned int protofamily;
	short unsigned int mountfamily;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		short unsigned int protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		short unsigned int protocol;
		short unsigned int nconnect;
		short unsigned int export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	short unsigned int nfs_callback_tcpport;
	short unsigned int nfs_callback_tcpport6;
	int cb_users[1];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct proc_dir_entry *proc_nfsfs;
};

struct nfs_netns_client {
	struct kobject kobject;
	struct net *net;
	const char *identifier;
};

struct nfs_open_dir_context {
	struct list_head list;
	const struct cred *cred;
	long unsigned int attr_gencount;
	__u64 dir_cookie;
	__u64 dup_cookie;
	signed char duped;
};

struct nfs4_cached_acl;

struct nfs_delegation;

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	long unsigned int flags;
	long unsigned int cache_validity;
	long unsigned int read_cache_jiffies;
	long unsigned int attrtimeo;
	long unsigned int attrtimeo_timestamp;
	long unsigned int attr_gencount;
	long unsigned int cache_change_attribute;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	__be32 cookieverf[2];
	atomic_long_t nrequests;
	struct nfs_mds_commit_info commit_info;
	struct list_head open_files;
	struct rw_semaphore rmdir_sem;
	struct mutex commit_mutex;
	long unsigned int page_index;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	__u64 write_io;
	__u64 read_io;
	struct inode vfs_inode;
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	long unsigned int pagemod_limit;
	__u64 change_attr;
	long unsigned int flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	struct qstr string;
	unsigned char d_type;
};

struct nfs_cache_array {
	int size;
	int eof_index;
	u64 last_cookie;
	struct nfs_cache_array_entry array[0];
};

typedef struct {
	struct file *file;
	struct page *page;
	struct dir_context *ctx;
	long unsigned int page_index;
	u64 *dir_cookie;
	u64 last_cookie;
	loff_t current_index;
	loff_t prev_index;
	long unsigned int dir_verifier;
	long unsigned int timestamp;
	long unsigned int gencount;
	unsigned int cache_entry_index;
	bool plus;
	bool eof;
} nfs_readdir_descriptor_t;

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	long unsigned int generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	long unsigned int used_slots[16];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	long unsigned int generation;
	struct completion complete;
	long unsigned int slot_tbl_state;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	long unsigned int session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct nfs_mount_request {
	struct sockaddr *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	short unsigned int protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t bytes_left;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_CLEAN = 2,
	PG_COMMIT_TO_DS = 3,
	PG_INODE_REF = 4,
	PG_HEADLOCK = 5,
	PG_TEARDOWN = 6,
	PG_UNLOCKPAGE = 7,
	PG_UPTODATE = 8,
	PG_WB_END = 9,
	PG_REMOVE = 10,
	PG_CONTENDED1 = 11,
	PG_CONTENDED2 = 12,
};

struct nfs_pageio_descriptor;

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	long unsigned int pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	short unsigned int pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs_readdesc {
	struct nfs_pageio_descriptor *pgio;
	struct nfs_open_context *ctx;
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum mountstat {
	MNT_OK = 0,
	MNT_EPERM = 1,
	MNT_ENOENT = 2,
	MNT_EACCES = 13,
	MNT_EINVAL = 22,
};

enum mountstat3 {
	MNT3_OK = 0,
	MNT3ERR_PERM = 1,
	MNT3ERR_NOENT = 2,
	MNT3ERR_IO = 5,
	MNT3ERR_ACCES = 13,
	MNT3ERR_NOTDIR = 20,
	MNT3ERR_INVAL = 22,
	MNT3ERR_NAMETOOLONG = 63,
	MNT3ERR_NOTSUPP = 10004,
	MNT3ERR_SERVERFAULT = 10006,
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_OPNOTSUPP = 45,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	long unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 old_dir;
	u32 __data_loc_old_name;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	enum nfs3_stable_how stable;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int status;
	enum nfs3_stable_how stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	const void *req;
	long unsigned int index;
	unsigned int offset;
	unsigned int pgbase;
	unsigned int bytes;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int status;
	enum nfs3_stable_how stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_xdr_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	long unsigned int error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct trace_event_data_offsets_nfs_xdr_status {
	u32 program;
	u32 procedure;
};

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_page_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_page_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_rename)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_write_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

struct nfs2_fh {
	char data[32];
};

struct nfs3_fh {
	short unsigned int size;
	unsigned char data[64];
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___2 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_fg = 12,
	Opt_fscache = 13,
	Opt_fscache_flag = 14,
	Opt_hard = 15,
	Opt_intr = 16,
	Opt_local_lock = 17,
	Opt_lock = 18,
	Opt_lookupcache = 19,
	Opt_migration = 20,
	Opt_minorversion = 21,
	Opt_mountaddr = 22,
	Opt_mounthost = 23,
	Opt_mountport = 24,
	Opt_mountproto = 25,
	Opt_mountvers = 26,
	Opt_namelen = 27,
	Opt_nconnect = 28,
	Opt_port = 29,
	Opt_posix = 30,
	Opt_proto = 31,
	Opt_rdirplus = 32,
	Opt_rdma = 33,
	Opt_resvport = 34,
	Opt_retrans = 35,
	Opt_retry = 36,
	Opt_rsize = 37,
	Opt_sec = 38,
	Opt_sharecache = 39,
	Opt_sloppy = 40,
	Opt_soft = 41,
	Opt_softerr = 42,
	Opt_softreval = 43,
	Opt_source = 44,
	Opt_tcp = 45,
	Opt_timeo = 46,
	Opt_udp = 47,
	Opt_v = 48,
	Opt_vers = 49,
	Opt_wsize = 50,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	struct timespec64 guardtime;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

struct nfs3_getaclargs {
	struct nfs_fh *fh;
	int mask;
	struct page **pages;
};

struct nfs3_setaclargs {
	struct inode *inode;
	int mask;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
	size_t len;
	unsigned int npages;
	struct page **pages;
};

struct nfs3_getaclres {
	struct nfs_fattr *fattr;
	int mask;
	unsigned int acl_access_count;
	unsigned int acl_default_count;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

struct nlm_host___2;

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host___2 *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nsm_handle;

struct nlm_host___2 {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	short unsigned int h_proto;
	short unsigned int h_reclaiming: 1;
	short unsigned int h_server: 1;
	short unsigned int h_noresvport: 1;
	short unsigned int h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	long unsigned int h_nextrebind;
	long unsigned int h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

struct nsm_private {
	unsigned char data[16];
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	struct file_lock fl;
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_args {
	struct nlm_cookie cookie;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nlm_block;

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host___2 *a_host;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_file;

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host___2 *b_host;
	long unsigned int b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

struct nlm_share;

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file;
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host___2 *b_host;
	struct file_lock *b_lock;
	short unsigned int b_reclaim;
	__be32 b_status;
};

struct nlm_wait___2;

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct lockd_net {
	unsigned int nlmsvc_users;
	long unsigned int next_gc;
	long unsigned int nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const short unsigned int protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

struct ipv4_devconf {
	void *sysctl;
	int data[32];
	long unsigned int state[1];
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	unsigned char mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **);
	void (*fclose)(struct file *);
};

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host___2 *);

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host___2 *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_res {
	u32 status;
	u32 state;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

typedef unsigned int autofs_wqt_t;

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	struct inode *inode;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

enum {
	Opt_err___4 = 0,
	Opt_fd = 1,
	Opt_uid___5 = 2,
	Opt_gid___6 = 3,
	Opt_pgrp = 4,
	Opt_minproto = 5,
	Opt_maxproto = 6,
	Opt_indirect = 7,
	Opt_direct = 8,
	Opt_offset = 9,
	Opt_strictexpire = 10,
	Opt_ignore___2 = 11,
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

struct p9_qid {
	u8 type;
	u32 version;
	u64 path;
};

struct p9_wstat {
	u16 size;
	u16 type;
	u32 dev;
	struct p9_qid qid;
	u32 mode;
	u32 atime;
	u32 mtime;
	u64 length;
	const char *name;
	const char *uid;
	const char *gid;
	const char *muid;
	char *extension;
	kuid_t n_uid;
	kgid_t n_gid;
	kuid_t n_muid;
};

struct p9_stat_dotl {
	u64 st_result_mask;
	struct p9_qid qid;
	u32 st_mode;
	kuid_t st_uid;
	kgid_t st_gid;
	u64 st_nlink;
	u64 st_rdev;
	u64 st_size;
	u64 st_blksize;
	u64 st_blocks;
	u64 st_atime_sec;
	u64 st_atime_nsec;
	u64 st_mtime_sec;
	u64 st_mtime_nsec;
	u64 st_ctime_sec;
	u64 st_ctime_nsec;
	u64 st_btime_sec;
	u64 st_btime_nsec;
	u64 st_gen;
	u64 st_data_version;
};

struct p9_rstatfs {
	u32 type;
	u32 bsize;
	u64 blocks;
	u64 bfree;
	u64 bavail;
	u64 files;
	u64 ffree;
	u64 fsid;
	u32 namelen;
};

enum p9_trans_status {
	Connected = 0,
	BeginDisconnect = 1,
	Disconnected = 2,
	Hung = 3,
};

struct p9_trans_module;

struct p9_client {
	spinlock_t lock;
	unsigned int msize;
	unsigned char proto_version;
	struct p9_trans_module *trans_mod;
	enum p9_trans_status status;
	void *trans;
	struct kmem_cache *fcall_cache;
	union {
		struct {
			int rfd;
			int wfd;
		} fd;
		struct {
			u16 port;
			bool privport;
		} tcp;
	} trans_opts;
	struct idr fids;
	struct idr reqs;
	char name[65];
};

struct p9_fid {
	struct p9_client *clnt;
	u32 fid;
	int mode;
	struct p9_qid qid;
	u32 iounit;
	kuid_t uid;
	void *rdir;
	struct hlist_node dlist;
};

enum p9_session_flags {
	V9FS_PROTO_2000U = 1,
	V9FS_PROTO_2000L = 2,
	V9FS_ACCESS_SINGLE = 4,
	V9FS_ACCESS_USER = 8,
	V9FS_ACCESS_CLIENT = 16,
	V9FS_POSIX_ACL = 32,
};

enum p9_cache_modes {
	CACHE_NONE = 0,
	CACHE_MMAP = 1,
	CACHE_LOOSE = 2,
	CACHE_FSCACHE = 3,
	nr__p9_cache_modes = 4,
};

struct v9fs_session_info {
	unsigned char flags;
	unsigned char nodev;
	short unsigned int debug;
	unsigned int afid;
	unsigned int cache;
	char *uname;
	char *aname;
	unsigned int maxdata;
	kuid_t dfltuid;
	kgid_t dfltgid;
	kuid_t uid;
	struct p9_client *clnt;
	struct list_head slist;
	struct rw_semaphore rename_sem;
	long int session_lock_timeout;
};

struct v9fs_inode {
	struct p9_qid qid;
	unsigned int cache_validity;
	struct p9_fid *writeback_fid;
	struct mutex v_mutex;
	struct inode vfs_inode;
};

enum p9_open_mode_t {
	P9_OREAD = 0,
	P9_OWRITE = 1,
	P9_ORDWR = 2,
	P9_OEXEC = 3,
	P9_OTRUNC = 16,
	P9_OREXEC = 32,
	P9_ORCLOSE = 64,
	P9_OAPPEND = 128,
	P9_OEXCL = 4096,
};

enum p9_perm_t {
	P9_DMDIR = 2147483648,
	P9_DMAPPEND = 1073741824,
	P9_DMEXCL = 536870912,
	P9_DMMOUNT = 268435456,
	P9_DMAUTH = 134217728,
	P9_DMTMP = 67108864,
	P9_DMSYMLINK = 33554432,
	P9_DMLINK = 16777216,
	P9_DMDEVICE = 8388608,
	P9_DMNAMEDPIPE = 2097152,
	P9_DMSOCKET = 1048576,
	P9_DMSETUID = 524288,
	P9_DMSETGID = 262144,
	P9_DMSETVTX = 65536,
};

struct p9_iattr_dotl {
	u32 valid;
	u32 mode;
	kuid_t uid;
	kgid_t gid;
	u64 size;
	u64 atime_sec;
	u64 atime_nsec;
	u64 mtime_sec;
	u64 mtime_nsec;
};

struct dotl_openflag_map {
	int open_flag;
	int dotl_flag;
};

struct dotl_iattr_map {
	int iattr_valid;
	int p9_iattr_valid;
};

struct p9_flock {
	u8 type;
	u32 flags;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_getlock {
	u8 type;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_dirent {
	struct p9_qid qid;
	u64 d_off;
	unsigned char d_type;
	char d_name[256];
};

struct p9_rdir {
	int head;
	int tail;
	uint8_t buf[0];
};

struct p9_fcall {
	u32 size;
	u8 id;
	u16 tag;
	size_t offset;
	size_t capacity;
	struct kmem_cache *cache;
	u8 *sdata;
};

struct p9_req_t {
	int status;
	int t_err;
	struct kref refcount;
	wait_queue_head_t wq;
	struct p9_fcall tc;
	struct p9_fcall rc;
	struct list_head req_list;
};

struct p9_trans_module {
	struct list_head list;
	char *name;
	int maxsize;
	int def;
	struct module *owner;
	int (*create)(struct p9_client *, const char *, char *);
	void (*close)(struct p9_client *);
	int (*request)(struct p9_client *, struct p9_req_t *);
	int (*cancel)(struct p9_client *, struct p9_req_t *);
	int (*cancelled)(struct p9_client *, struct p9_req_t *);
	int (*zc_request)(struct p9_client *, struct p9_req_t *, struct iov_iter *, struct iov_iter *, int, int, int);
	int (*show_options)(struct seq_file *, struct p9_client *);
};

enum {
	Opt_debug___2 = 0,
	Opt_dfltuid = 1,
	Opt_dfltgid = 2,
	Opt_afid = 3,
	Opt_uname = 4,
	Opt_remotename = 5,
	Opt_cache = 6,
	Opt_cachetag = 7,
	Opt_nodevmap = 8,
	Opt_cache_loose = 9,
	Opt_fscache___2 = 10,
	Opt_mmap = 11,
	Opt_access = 12,
	Opt_posixacl = 13,
	Opt_locktimeout = 14,
	Opt_err___5 = 15,
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum {
	Opt_uid___6 = 0,
	Opt_gid___7 = 1,
	Opt_mode___6 = 2,
	Opt_err___6 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

struct btrfs_ioctl_vol_args {
	__s64 fd;
	char name[4088];
};

struct btrfs_scrub_progress {
	__u64 data_extents_scrubbed;
	__u64 tree_extents_scrubbed;
	__u64 data_bytes_scrubbed;
	__u64 tree_bytes_scrubbed;
	__u64 read_errors;
	__u64 csum_errors;
	__u64 verify_errors;
	__u64 no_csum;
	__u64 csum_discards;
	__u64 super_errors;
	__u64 malloc_errors;
	__u64 uncorrectable_errors;
	__u64 corrected_errors;
	__u64 last_physical;
	__u64 unverified_errors;
};

struct btrfs_balance_args {
	__u64 profiles;
	union {
		__u64 usage;
		struct {
			__u32 usage_min;
			__u32 usage_max;
		};
	};
	__u64 devid;
	__u64 pstart;
	__u64 pend;
	__u64 vstart;
	__u64 vend;
	__u64 target;
	__u64 flags;
	union {
		__u64 limit;
		struct {
			__u32 limit_min;
			__u32 limit_max;
		};
	};
	__u32 stripes_min;
	__u32 stripes_max;
	__u64 unused[6];
};

struct btrfs_balance_progress {
	__u64 expected;
	__u64 considered;
	__u64 completed;
};

enum btrfs_dev_stat_values {
	BTRFS_DEV_STAT_WRITE_ERRS = 0,
	BTRFS_DEV_STAT_READ_ERRS = 1,
	BTRFS_DEV_STAT_FLUSH_ERRS = 2,
	BTRFS_DEV_STAT_CORRUPTION_ERRS = 3,
	BTRFS_DEV_STAT_GENERATION_ERRS = 4,
	BTRFS_DEV_STAT_VALUES_MAX = 5,
};

struct btrfs_disk_key {
	__le64 objectid;
	__u8 type;
	__le64 offset;
} __attribute__((packed));

struct btrfs_key {
	__u64 objectid;
	__u8 type;
	__u64 offset;
} __attribute__((packed));

struct btrfs_dev_item {
	__le64 devid;
	__le64 total_bytes;
	__le64 bytes_used;
	__le32 io_align;
	__le32 io_width;
	__le32 sector_size;
	__le64 type;
	__le64 generation;
	__le64 start_offset;
	__le32 dev_group;
	__u8 seek_speed;
	__u8 bandwidth;
	__u8 uuid[16];
	__u8 fsid[16];
} __attribute__((packed));

struct btrfs_inode_ref {
	__le64 index;
	__le16 name_len;
} __attribute__((packed));

struct btrfs_timespec {
	__le64 sec;
	__le32 nsec;
} __attribute__((packed));

struct btrfs_inode_item {
	__le64 generation;
	__le64 transid;
	__le64 size;
	__le64 nbytes;
	__le64 block_group;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le64 rdev;
	__le64 flags;
	__le64 sequence;
	__le64 reserved[4];
	struct btrfs_timespec atime;
	struct btrfs_timespec ctime;
	struct btrfs_timespec mtime;
	struct btrfs_timespec otime;
} __attribute__((packed));

struct btrfs_dir_item {
	struct btrfs_disk_key location;
	__le64 transid;
	__le16 data_len;
	__le16 name_len;
	__u8 type;
} __attribute__((packed));

struct btrfs_root_item {
	struct btrfs_inode_item inode;
	__le64 generation;
	__le64 root_dirid;
	__le64 bytenr;
	__le64 byte_limit;
	__le64 bytes_used;
	__le64 last_snapshot;
	__le64 flags;
	__le32 refs;
	struct btrfs_disk_key drop_progress;
	__u8 drop_level;
	__u8 level;
	__le64 generation_v2;
	__u8 uuid[16];
	__u8 parent_uuid[16];
	__u8 received_uuid[16];
	__le64 ctransid;
	__le64 otransid;
	__le64 stransid;
	__le64 rtransid;
	struct btrfs_timespec ctime;
	struct btrfs_timespec otime;
	struct btrfs_timespec stime;
	struct btrfs_timespec rtime;
	__le64 reserved[8];
} __attribute__((packed));

struct btrfs_root_ref {
	__le64 dirid;
	__le64 sequence;
	__le16 name_len;
} __attribute__((packed));

enum {
	BTRFS_FILE_EXTENT_INLINE = 0,
	BTRFS_FILE_EXTENT_REG = 1,
	BTRFS_FILE_EXTENT_PREALLOC = 2,
	BTRFS_NR_FILE_EXTENT_TYPES = 3,
};

struct btrfs_file_extent_item {
	__le64 generation;
	__le64 ram_bytes;
	__u8 compression;
	__u8 encryption;
	__le16 other_encoding;
	__u8 type;
	__le64 disk_bytenr;
	__le64 disk_num_bytes;
	__le64 offset;
	__le64 num_bytes;
} __attribute__((packed));

enum btrfs_raid_types {
	BTRFS_RAID_RAID10 = 0,
	BTRFS_RAID_RAID1 = 1,
	BTRFS_RAID_DUP = 2,
	BTRFS_RAID_RAID0 = 3,
	BTRFS_RAID_SINGLE = 4,
	BTRFS_RAID_RAID5 = 5,
	BTRFS_RAID_RAID6 = 6,
	BTRFS_RAID_RAID1C3 = 7,
	BTRFS_RAID_RAID1C4 = 8,
	BTRFS_NR_RAID_TYPES = 9,
};

enum {
	IO_TREE_FS_PINNED_EXTENTS = 0,
	IO_TREE_FS_EXCLUDED_EXTENTS = 1,
	IO_TREE_BTREE_INODE_IO = 2,
	IO_TREE_INODE_IO = 3,
	IO_TREE_INODE_IO_FAILURE = 4,
	IO_TREE_RELOC_BLOCKS = 5,
	IO_TREE_TRANS_DIRTY_PAGES = 6,
	IO_TREE_ROOT_DIRTY_LOG_PAGES = 7,
	IO_TREE_INODE_FILE_EXTENT = 8,
	IO_TREE_LOG_CSUM_RANGE = 9,
	IO_TREE_SELFTEST = 10,
	IO_TREE_DEVICE_ALLOC_STATE = 11,
};

struct btrfs_fs_info;

struct extent_io_tree {
	struct rb_root state;
	struct btrfs_fs_info *fs_info;
	void *private_data;
	u64 dirty_bytes;
	bool track_uptodate;
	u8 owner;
	spinlock_t lock;
};

struct extent_map_tree {
	struct rb_root_cached map;
	struct list_head modified_extents;
	rwlock_t lock;
};

struct btrfs_space_info;

struct btrfs_block_rsv {
	u64 size;
	u64 reserved;
	struct btrfs_space_info *space_info;
	spinlock_t lock;
	short unsigned int full;
	short unsigned int type;
	short unsigned int failfast;
	u64 qgroup_rsv_size;
	u64 qgroup_rsv_reserved;
};

struct btrfs_block_group;

struct btrfs_free_cluster {
	spinlock_t lock;
	spinlock_t refill_lock;
	struct rb_root root;
	u64 max_size;
	u64 window_start;
	bool fragmented;
	struct btrfs_block_group *block_group;
	struct list_head block_group_list;
};

struct btrfs_discard_ctl {
	struct workqueue_struct *discard_workers;
	struct delayed_work work;
	spinlock_t lock;
	struct btrfs_block_group *block_group;
	struct list_head discard_list[3];
	u64 prev_discard;
	atomic_t discardable_extents;
	atomic64_t discardable_bytes;
	u64 max_discard_size;
	long unsigned int delay;
	u32 iops_limit;
	u32 kbps_limit;
	u64 discard_extent_bytes;
	u64 discard_bitmap_bytes;
	atomic64_t discard_bytes_saved;
};

struct btrfs_work;

typedef void (*btrfs_func_t)(struct btrfs_work *);

struct __btrfs_workqueue;

struct btrfs_work {
	btrfs_func_t func;
	btrfs_func_t ordered_func;
	btrfs_func_t ordered_free;
	struct work_struct normal_work;
	struct list_head ordered_list;
	struct __btrfs_workqueue *wq;
	long unsigned int flags;
};

struct btrfs_device;

struct btrfs_dev_replace {
	u64 replace_state;
	time64_t time_started;
	time64_t time_stopped;
	atomic64_t num_write_errors;
	atomic64_t num_uncorrectable_read_errors;
	u64 cursor_left;
	u64 committed_cursor_left;
	u64 cursor_left_last_write_of_item;
	u64 cursor_right;
	u64 cont_reading_from_srcdev_mode;
	int is_valid;
	int item_needs_writeback;
	struct btrfs_device *srcdev;
	struct btrfs_device *tgtdev;
	struct mutex lock_finishing_cancel_unmount;
	struct rw_semaphore rwsem;
	struct btrfs_scrub_progress scrub_progress;
	struct percpu_counter bio_counter;
	wait_queue_head_t replace_wait;
};

struct btrfs_root;

struct btrfs_transaction;

struct btrfs_super_block;

struct btrfs_stripe_hash_table;

struct btrfs_workqueue;

struct btrfs_fs_devices;

struct reloc_control;

struct btrfs_balance_control;

struct ulist;

struct btrfs_delayed_root;

struct btrfs_fs_info {
	u8 chunk_tree_uuid[16];
	long unsigned int flags;
	struct btrfs_root *extent_root;
	struct btrfs_root *tree_root;
	struct btrfs_root *chunk_root;
	struct btrfs_root *dev_root;
	struct btrfs_root *fs_root;
	struct btrfs_root *csum_root;
	struct btrfs_root *quota_root;
	struct btrfs_root *uuid_root;
	struct btrfs_root *free_space_root;
	struct btrfs_root *data_reloc_root;
	struct btrfs_root *log_root_tree;
	spinlock_t fs_roots_radix_lock;
	struct xarray fs_roots_radix;
	spinlock_t block_group_cache_lock;
	u64 first_logical_byte;
	struct rb_root block_group_cache_tree;
	atomic64_t free_chunk_space;
	struct extent_io_tree excluded_extents;
	struct extent_map_tree mapping_tree;
	struct btrfs_block_rsv global_block_rsv;
	struct btrfs_block_rsv trans_block_rsv;
	struct btrfs_block_rsv chunk_block_rsv;
	struct btrfs_block_rsv delayed_block_rsv;
	struct btrfs_block_rsv delayed_refs_rsv;
	struct btrfs_block_rsv empty_block_rsv;
	u64 generation;
	u64 last_trans_committed;
	u64 avg_delayed_ref_runtime;
	u64 last_trans_log_full_commit;
	long unsigned int mount_opt;
	long unsigned int pending_changes;
	long unsigned int compress_type: 4;
	unsigned int compress_level;
	u32 commit_interval;
	u64 max_inline;
	struct btrfs_transaction *running_transaction;
	wait_queue_head_t transaction_throttle;
	wait_queue_head_t transaction_wait;
	wait_queue_head_t transaction_blocked_wait;
	wait_queue_head_t async_submit_wait;
	spinlock_t super_lock;
	struct btrfs_super_block *super_copy;
	struct btrfs_super_block *super_for_commit;
	struct super_block *sb;
	struct inode *btree_inode;
	struct mutex tree_log_mutex;
	struct mutex transaction_kthread_mutex;
	struct mutex cleaner_mutex;
	struct mutex chunk_mutex;
	struct mutex ro_block_group_mutex;
	struct btrfs_stripe_hash_table *stripe_hash_table;
	struct mutex ordered_operations_mutex;
	struct rw_semaphore commit_root_sem;
	struct rw_semaphore cleanup_work_sem;
	struct rw_semaphore subvol_sem;
	spinlock_t trans_lock;
	struct mutex reloc_mutex;
	struct list_head trans_list;
	struct list_head dead_roots;
	struct list_head caching_block_groups;
	spinlock_t delayed_iput_lock;
	struct list_head delayed_iputs;
	atomic_t nr_delayed_iputs;
	wait_queue_head_t delayed_iputs_wait;
	atomic64_t tree_mod_seq;
	rwlock_t tree_mod_log_lock;
	struct rb_root tree_mod_log;
	struct list_head tree_mod_seq_list;
	atomic_t async_delalloc_pages;
	spinlock_t ordered_root_lock;
	struct list_head ordered_roots;
	struct mutex delalloc_root_mutex;
	spinlock_t delalloc_root_lock;
	struct list_head delalloc_roots;
	struct btrfs_workqueue *workers;
	struct btrfs_workqueue *delalloc_workers;
	struct btrfs_workqueue *flush_workers;
	struct btrfs_workqueue *endio_workers;
	struct btrfs_workqueue *endio_meta_workers;
	struct btrfs_workqueue *endio_raid56_workers;
	struct btrfs_workqueue *rmw_workers;
	struct btrfs_workqueue *endio_meta_write_workers;
	struct btrfs_workqueue *endio_write_workers;
	struct btrfs_workqueue *endio_freespace_worker;
	struct btrfs_workqueue *caching_workers;
	struct btrfs_workqueue *readahead_workers;
	struct btrfs_workqueue *fixup_workers;
	struct btrfs_workqueue *delayed_workers;
	struct task_struct *transaction_kthread;
	struct task_struct *cleaner_kthread;
	u32 thread_pool_size;
	struct kobject *space_info_kobj;
	struct kobject *qgroups_kobj;
	u64 total_pinned;
	struct percpu_counter dirty_metadata_bytes;
	struct percpu_counter delalloc_bytes;
	struct percpu_counter dio_bytes;
	s32 dirty_metadata_batch;
	s32 delalloc_batch;
	struct list_head dirty_cowonly_roots;
	struct btrfs_fs_devices *fs_devices;
	struct list_head space_info;
	struct btrfs_space_info *data_sinfo;
	struct reloc_control *reloc_ctl;
	struct btrfs_free_cluster data_alloc_cluster;
	struct btrfs_free_cluster meta_alloc_cluster;
	spinlock_t defrag_inodes_lock;
	struct rb_root defrag_inodes;
	atomic_t defrag_running;
	seqlock_t profiles_lock;
	u64 avail_data_alloc_bits;
	u64 avail_metadata_alloc_bits;
	u64 avail_system_alloc_bits;
	spinlock_t balance_lock;
	struct mutex balance_mutex;
	atomic_t balance_pause_req;
	atomic_t balance_cancel_req;
	struct btrfs_balance_control *balance_ctl;
	wait_queue_head_t balance_wait_q;
	u32 data_chunk_allocations;
	u32 metadata_ratio;
	void *bdev_holder;
	struct mutex scrub_lock;
	atomic_t scrubs_running;
	atomic_t scrub_pause_req;
	atomic_t scrubs_paused;
	atomic_t scrub_cancel_req;
	wait_queue_head_t scrub_pause_wait;
	refcount_t scrub_workers_refcnt;
	struct btrfs_workqueue *scrub_workers;
	struct btrfs_workqueue *scrub_wr_completion_workers;
	struct btrfs_workqueue *scrub_parity_workers;
	struct btrfs_discard_ctl discard_ctl;
	u64 qgroup_flags;
	struct rb_root qgroup_tree;
	spinlock_t qgroup_lock;
	struct ulist *qgroup_ulist;
	struct mutex qgroup_ioctl_lock;
	struct list_head dirty_qgroups;
	u64 qgroup_seq;
	struct mutex qgroup_rescan_lock;
	struct btrfs_key qgroup_rescan_progress;
	struct btrfs_workqueue *qgroup_rescan_workers;
	struct completion qgroup_rescan_completion;
	struct btrfs_work qgroup_rescan_work;
	bool qgroup_rescan_running;
	long unsigned int fs_state;
	struct btrfs_delayed_root *delayed_root;
	spinlock_t reada_lock;
	struct xarray reada_tree;
	atomic_t reada_works_cnt;
	spinlock_t buffer_lock;
	struct xarray buffer_radix;
	int backup_root_index;
	struct btrfs_dev_replace dev_replace;
	struct semaphore uuid_tree_rescan_sem;
	struct work_struct async_reclaim_work;
	struct work_struct async_data_reclaim_work;
	spinlock_t unused_bgs_lock;
	struct list_head unused_bgs;
	struct mutex unused_bg_unpin_mutex;
	struct mutex delete_unused_bgs_mutex;
	u32 nodesize;
	u32 sectorsize;
	u32 stripesize;
	spinlock_t swapfile_pins_lock;
	struct rb_root swapfile_pins;
	struct crypto_shash *csum_shash;
	int send_in_progress;
	long unsigned int exclusive_operation;
};

struct io_failure_record;

struct extent_state {
	u64 start;
	u64 end;
	struct rb_node rb_node;
	wait_queue_head_t wq;
	refcount_t refs;
	unsigned int state;
	struct io_failure_record *failrec;
};

struct io_failure_record {
	struct page *page;
	u64 start;
	u64 len;
	u64 logical;
	long unsigned int bio_flags;
	int this_mirror;
	int failed_mirror;
	int in_validation;
};

struct ulist {
	long unsigned int nnodes;
	struct list_head nodes;
	struct rb_root root;
};

struct extent_buffer {
	u64 start;
	long unsigned int len;
	long unsigned int bflags;
	struct btrfs_fs_info *fs_info;
	spinlock_t refs_lock;
	atomic_t refs;
	atomic_t io_pages;
	int read_mirror;
	struct callback_head callback_head;
	pid_t lock_owner;
	int blocking_writers;
	atomic_t blocking_readers;
	bool lock_recursed;
	short int log_index;
	rwlock_t lock;
	wait_queue_head_t write_lock_wq;
	wait_queue_head_t read_lock_wq;
	struct page *pages[16];
};

struct map_lookup;

struct extent_map {
	struct rb_node rb_node;
	u64 start;
	u64 len;
	u64 mod_start;
	u64 mod_len;
	u64 orig_start;
	u64 orig_block_len;
	u64 ram_bytes;
	u64 block_start;
	u64 block_len;
	u64 generation;
	long unsigned int flags;
	struct map_lookup *map_lookup;
	refcount_t refs;
	unsigned int compress_type;
	struct list_head list;
};

struct btrfs_ordered_inode_tree {
	spinlock_t lock;
	struct rb_root tree;
	struct rb_node *last;
};

struct btrfs_delayed_node;

struct btrfs_inode {
	struct btrfs_root *root;
	struct btrfs_key location;
	spinlock_t lock;
	struct extent_map_tree extent_tree;
	struct extent_io_tree io_tree;
	struct extent_io_tree io_failure_tree;
	struct extent_io_tree file_extent_tree;
	struct mutex log_mutex;
	struct btrfs_ordered_inode_tree ordered_tree;
	struct list_head delalloc_inodes;
	struct rb_node rb_node;
	long unsigned int runtime_flags;
	atomic_t sync_writers;
	u64 generation;
	u64 last_trans;
	u64 logged_trans;
	int last_sub_trans;
	int last_log_commit;
	u64 delalloc_bytes;
	u64 new_delalloc_bytes;
	u64 defrag_bytes;
	u64 disk_i_size;
	u64 index_cnt;
	u64 dir_index;
	u64 last_unlink_trans;
	u64 last_reflink_trans;
	u64 csum_bytes;
	u32 flags;
	unsigned int outstanding_extents;
	struct btrfs_block_rsv block_rsv;
	unsigned int prop_compress;
	unsigned int defrag_compress;
	struct btrfs_delayed_node *delayed_node;
	struct timespec64 i_otime;
	struct list_head delayed_iput;
	struct rw_semaphore dio_sem;
	struct inode vfs_inode;
};

enum {
	EXTENT_FLAG_PINNED = 0,
	EXTENT_FLAG_COMPRESSED = 1,
	EXTENT_FLAG_PREALLOC = 2,
	EXTENT_FLAG_LOGGING = 3,
	EXTENT_FLAG_FILLING = 4,
	EXTENT_FLAG_FS_MAPPING = 5,
};

struct btrfs_bio_stripe {
	struct btrfs_device *dev;
	u64 physical;
	u64 length;
};

struct map_lookup {
	u64 type;
	int io_align;
	int io_width;
	u64 stripe_len;
	int num_stripes;
	int sub_stripes;
	int verified_stripes;
	struct btrfs_bio_stripe stripes[0];
};

struct __btrfs_workqueue {
	struct workqueue_struct *normal_wq;
	struct btrfs_fs_info *fs_info;
	struct list_head ordered_list;
	spinlock_t list_lock;
	atomic_t pending;
	int limit_active;
	int current_active;
	int thresh;
	unsigned int count;
	spinlock_t thres_lock;
};

struct btrfs_space_info {
	spinlock_t lock;
	u64 total_bytes;
	u64 bytes_used;
	u64 bytes_pinned;
	u64 bytes_reserved;
	u64 bytes_may_use;
	u64 bytes_readonly;
	u64 max_extent_size;
	unsigned int full: 1;
	unsigned int chunk_alloc: 1;
	unsigned int flush: 1;
	unsigned int force_alloc;
	u64 disk_used;
	u64 disk_total;
	u64 flags;
	struct percpu_counter total_bytes_pinned;
	struct list_head list;
	struct list_head ro_bgs;
	struct list_head priority_tickets;
	struct list_head tickets;
	u64 reclaim_size;
	u64 tickets_id;
	struct rw_semaphore groups_sem;
	struct list_head block_groups[9];
	struct kobject kobj;
	struct kobject *block_group_kobjs[9];
};

enum btrfs_lock_nesting {
	BTRFS_NESTING_NORMAL = 0,
	BTRFS_NESTING_COW = 1,
	BTRFS_NESTING_LEFT = 2,
	BTRFS_NESTING_RIGHT = 3,
	BTRFS_NESTING_LEFT_COW = 4,
	BTRFS_NESTING_RIGHT_COW = 5,
	BTRFS_NESTING_SPLIT = 6,
	BTRFS_NESTING_NEW_ROOT = 7,
	BTRFS_NESTING_MAX = 8,
};

struct btrfs_drew_lock {
	atomic_t readers;
	struct percpu_counter writers;
	wait_queue_head_t pending_writers;
	wait_queue_head_t pending_readers;
};

enum {
	BTRFS_FS_STATE_ERROR = 0,
	BTRFS_FS_STATE_REMOUNTING = 1,
	BTRFS_FS_STATE_TRANS_ABORTED = 2,
	BTRFS_FS_STATE_DEV_REPLACING = 3,
	BTRFS_FS_STATE_DUMMY_FS_INFO = 4,
};

struct btrfs_header {
	u8 csum[32];
	u8 fsid[16];
	__le64 bytenr;
	__le64 flags;
	u8 chunk_tree_uuid[16];
	__le64 generation;
	__le64 owner;
	__le32 nritems;
	u8 level;
} __attribute__((packed));

struct btrfs_root_backup {
	__le64 tree_root;
	__le64 tree_root_gen;
	__le64 chunk_root;
	__le64 chunk_root_gen;
	__le64 extent_root;
	__le64 extent_root_gen;
	__le64 fs_root;
	__le64 fs_root_gen;
	__le64 dev_root;
	__le64 dev_root_gen;
	__le64 csum_root;
	__le64 csum_root_gen;
	__le64 total_bytes;
	__le64 bytes_used;
	__le64 num_devices;
	__le64 unused_64[4];
	u8 tree_root_level;
	u8 chunk_root_level;
	u8 extent_root_level;
	u8 fs_root_level;
	u8 dev_root_level;
	u8 csum_root_level;
	u8 unused_8[10];
};

struct btrfs_super_block {
	u8 csum[32];
	u8 fsid[16];
	__le64 bytenr;
	__le64 flags;
	__le64 magic;
	__le64 generation;
	__le64 root;
	__le64 chunk_root;
	__le64 log_root;
	__le64 log_root_transid;
	__le64 total_bytes;
	__le64 bytes_used;
	__le64 root_dir_objectid;
	__le64 num_devices;
	__le32 sectorsize;
	__le32 nodesize;
	__le32 __unused_leafsize;
	__le32 stripesize;
	__le32 sys_chunk_array_size;
	__le64 chunk_root_generation;
	__le64 compat_flags;
	__le64 compat_ro_flags;
	__le64 incompat_flags;
	__le16 csum_type;
	u8 root_level;
	u8 chunk_root_level;
	u8 log_root_level;
	struct btrfs_dev_item dev_item;
	char label[256];
	__le64 cache_generation;
	__le64 uuid_tree_generation;
	u8 metadata_uuid[16];
	__le64 reserved[28];
	u8 sys_chunk_array[2048];
	struct btrfs_root_backup super_roots[4];
} __attribute__((packed));

struct btrfs_item {
	struct btrfs_disk_key key;
	__le32 offset;
	__le32 size;
} __attribute__((packed));

struct btrfs_path {
	struct extent_buffer *nodes[8];
	int slots[8];
	u8 locks[8];
	u8 reada;
	u8 lowest_level;
	unsigned int search_for_split: 1;
	unsigned int keep_locks: 1;
	unsigned int skip_locking: 1;
	unsigned int leave_spinning: 1;
	unsigned int search_commit_root: 1;
	unsigned int need_commit_sem: 1;
	unsigned int skip_release_on_error: 1;
	unsigned int recurse: 1;
};

struct rcu_string;

struct scrub_ctx;

struct reada_zone;

struct btrfs_device {
	struct list_head dev_list;
	struct list_head dev_alloc_list;
	struct list_head post_commit_list;
	struct btrfs_fs_devices *fs_devices;
	struct btrfs_fs_info *fs_info;
	struct rcu_string *name;
	u64 generation;
	struct block_device *bdev;
	fmode_t mode;
	long unsigned int dev_state;
	blk_status_t last_flush_error;
	u64 devid;
	u64 total_bytes;
	u64 disk_total_bytes;
	u64 bytes_used;
	u32 io_align;
	u32 io_width;
	u64 type;
	u32 sector_size;
	u8 uuid[16];
	u64 commit_total_bytes;
	u64 commit_bytes_used;
	struct bio *flush_bio;
	struct completion flush_wait;
	struct scrub_ctx *scrub_ctx;
	atomic_t reada_in_flight;
	u64 reada_next;
	struct reada_zone *reada_curr_zone;
	struct xarray reada_zones;
	struct xarray reada_extents;
	int dev_stats_valid;
	atomic_t dev_stats_ccnt;
	atomic_t dev_stat_values[5];
	struct extent_io_tree alloc_state;
	struct completion kobj_unregister;
	struct kobject devid_kobj;
};

enum btrfs_discard_state {
	BTRFS_DISCARD_EXTENTS = 0,
	BTRFS_DISCARD_BITMAPS = 1,
	BTRFS_DISCARD_RESET_CURSOR = 2,
};

struct btrfs_io_ctl {
	void *cur;
	void *orig;
	struct page *page;
	struct page **pages;
	struct btrfs_fs_info *fs_info;
	struct inode *inode;
	long unsigned int size;
	int index;
	int num_pages;
	int entries;
	int bitmaps;
	unsigned int check_crcs: 1;
};

struct btrfs_full_stripe_locks_tree {
	struct rb_root root;
	struct mutex lock;
};

struct btrfs_caching_control;

struct btrfs_free_space_ctl;

struct btrfs_block_group {
	struct btrfs_fs_info *fs_info;
	struct inode *inode;
	spinlock_t lock;
	u64 start;
	u64 length;
	u64 pinned;
	u64 reserved;
	u64 used;
	u64 delalloc_bytes;
	u64 bytes_super;
	u64 flags;
	u64 cache_generation;
	u32 bitmap_high_thresh;
	u32 bitmap_low_thresh;
	struct rw_semaphore data_rwsem;
	long unsigned int full_stripe_len;
	unsigned int ro;
	unsigned int iref: 1;
	unsigned int has_caching_ctl: 1;
	unsigned int removed: 1;
	int disk_cache_state;
	int cached;
	struct btrfs_caching_control *caching_ctl;
	u64 last_byte_to_unpin;
	struct btrfs_space_info *space_info;
	struct btrfs_free_space_ctl *free_space_ctl;
	struct rb_node cache_node;
	struct list_head list;
	refcount_t refs;
	struct list_head cluster_list;
	struct list_head bg_list;
	struct list_head ro_list;
	atomic_t frozen;
	struct list_head discard_list;
	int discard_index;
	u64 discard_eligible_time;
	u64 discard_cursor;
	enum btrfs_discard_state discard_state;
	struct list_head dirty_list;
	struct list_head io_list;
	struct btrfs_io_ctl io_ctl;
	atomic_t reservations;
	atomic_t nocow_writers;
	struct mutex free_space_lock;
	int needs_free_space;
	struct btrfs_full_stripe_locks_tree full_stripe_locks_root;
};

enum btrfs_caching_type {
	BTRFS_CACHE_NO = 0,
	BTRFS_CACHE_STARTED = 1,
	BTRFS_CACHE_FAST = 2,
	BTRFS_CACHE_FINISHED = 3,
	BTRFS_CACHE_ERROR = 4,
};

enum {
	BTRFS_FS_BARRIER = 0,
	BTRFS_FS_CLOSING_START = 1,
	BTRFS_FS_CLOSING_DONE = 2,
	BTRFS_FS_LOG_RECOVERING = 3,
	BTRFS_FS_OPEN = 4,
	BTRFS_FS_QUOTA_ENABLED = 5,
	BTRFS_FS_UPDATE_UUID_TREE_GEN = 6,
	BTRFS_FS_CREATING_FREE_SPACE_TREE = 7,
	BTRFS_FS_BTREE_ERR = 8,
	BTRFS_FS_LOG1_ERR = 9,
	BTRFS_FS_LOG2_ERR = 10,
	BTRFS_FS_QUOTA_OVERRIDE = 11,
	BTRFS_FS_FROZEN = 12,
	BTRFS_FS_BALANCE_RUNNING = 13,
	BTRFS_FS_CLEANER_RUNNING = 14,
	BTRFS_FS_CSUM_IMPL_FAST = 15,
	BTRFS_FS_DISCARD_RUNNING = 16,
};

struct btrfs_qgroup_swapped_blocks {
	spinlock_t lock;
	bool swapped;
	struct rb_root blocks[8];
};

struct btrfs_root {
	struct extent_buffer *node;
	struct extent_buffer *commit_root;
	struct btrfs_root *log_root;
	struct btrfs_root *reloc_root;
	long unsigned int state;
	struct btrfs_root_item root_item;
	struct btrfs_key root_key;
	struct btrfs_fs_info *fs_info;
	struct extent_io_tree dirty_log_pages;
	struct mutex objectid_mutex;
	spinlock_t accounting_lock;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_free_space_ctl *free_ino_ctl;
	enum btrfs_caching_type ino_cache_state;
	int: 32;
	spinlock_t ino_cache_lock;
	wait_queue_head_t ino_cache_wait;
	struct btrfs_free_space_ctl *free_ino_pinned;
	u64 ino_cache_progress;
	struct inode *ino_cache_inode;
	struct mutex log_mutex;
	wait_queue_head_t log_writer_wait;
	wait_queue_head_t log_commit_wait[2];
	struct list_head log_ctxs[2];
	atomic_t log_writers;
	atomic_t log_commit[2];
	atomic_t log_batch;
	int log_transid;
	int log_transid_committed;
	int last_log_commit;
	pid_t log_start_pid;
	u64 last_trans;
	u32 type;
	int: 32;
	u64 highest_objectid;
	struct btrfs_key defrag_progress;
	struct btrfs_key defrag_max;
	long: 48;
	struct list_head dirty_list;
	struct list_head root_list;
	spinlock_t log_extents_lock[2];
	struct list_head logged_list[2];
	int orphan_cleanup_state;
	int: 32;
	spinlock_t inode_lock;
	struct rb_root inode_tree;
	struct xarray delayed_nodes_tree;
	dev_t anon_dev;
	int: 32;
	spinlock_t root_item_lock;
	refcount_t refs;
	int: 32;
	struct mutex delalloc_mutex;
	spinlock_t delalloc_lock;
	struct list_head delalloc_inodes;
	struct list_head delalloc_root;
	u64 nr_delalloc_inodes;
	struct mutex ordered_extent_mutex;
	spinlock_t ordered_extent_lock;
	struct list_head ordered_extents;
	struct list_head ordered_root;
	u64 nr_ordered_extents;
	struct list_head reloc_dirty_list;
	int send_in_progress;
	int dedupe_in_progress;
	struct btrfs_drew_lock snapshot_lock;
	atomic_t snapshot_force_cow;
	int: 32;
	spinlock_t qgroup_meta_rsv_lock;
	u64 qgroup_meta_rsv_pertrans;
	u64 qgroup_meta_rsv_prealloc;
	wait_queue_head_t qgroup_flush_wait;
	atomic_t nr_swapfiles;
	int: 32;
	struct btrfs_qgroup_swapped_blocks swapped_blocks;
	struct extent_io_tree log_csum_range;
} __attribute__((packed));

enum btrfs_trans_state {
	TRANS_STATE_RUNNING = 0,
	TRANS_STATE_COMMIT_START = 1,
	TRANS_STATE_COMMIT_DOING = 2,
	TRANS_STATE_UNBLOCKED = 3,
	TRANS_STATE_COMPLETED = 4,
	TRANS_STATE_MAX = 5,
};

struct btrfs_delayed_ref_root {
	struct rb_root_cached href_root;
	struct rb_root dirty_extent_root;
	spinlock_t lock;
	atomic_t num_entries;
	long unsigned int num_heads;
	long unsigned int num_heads_ready;
	u64 pending_csums;
	int flushing;
	u64 run_delayed_start;
	u64 qgroup_to_skip;
};

struct btrfs_transaction {
	u64 transid;
	atomic_t num_extwriters;
	atomic_t num_writers;
	refcount_t use_count;
	long unsigned int flags;
	enum btrfs_trans_state state;
	int aborted;
	struct list_head list;
	struct extent_io_tree dirty_pages;
	time64_t start_time;
	wait_queue_head_t writer_wait;
	wait_queue_head_t commit_wait;
	struct list_head pending_snapshots;
	struct list_head dev_update_list;
	struct list_head switch_commits;
	struct list_head dirty_bgs;
	struct list_head io_bgs;
	struct list_head dropped_roots;
	struct extent_io_tree pinned_extents;
	struct mutex cache_write_mutex;
	spinlock_t dirty_bgs_lock;
	struct list_head deleted_bgs;
	spinlock_t dropped_roots_lock;
	struct btrfs_delayed_ref_root delayed_refs;
	struct btrfs_fs_info *fs_info;
	atomic_t pending_ordered;
	wait_queue_head_t pending_wait;
};

enum btrfs_chunk_allocation_policy {
	BTRFS_CHUNK_ALLOC_REGULAR = 0,
};

struct btrfs_fs_devices {
	u8 fsid[16];
	u8 metadata_uuid[16];
	bool fsid_change;
	struct list_head fs_list;
	u64 num_devices;
	u64 open_devices;
	u64 rw_devices;
	u64 missing_devices;
	u64 total_rw_bytes;
	u64 total_devices;
	u64 latest_generation;
	struct block_device *latest_bdev;
	struct mutex device_list_mutex;
	struct list_head devices;
	struct list_head alloc_list;
	struct list_head seed_list;
	bool seeding;
	int opened;
	bool rotating;
	struct btrfs_fs_info *fs_info;
	struct kobject fsid_kobj;
	struct kobject *devices_kobj;
	struct kobject *devinfo_kobj;
	struct completion kobj_unregister;
	enum btrfs_chunk_allocation_policy chunk_alloc_policy;
};

struct btrfs_balance_control {
	struct btrfs_balance_args data;
	struct btrfs_balance_args meta;
	struct btrfs_balance_args sys;
	u64 flags;
	struct btrfs_balance_progress stat;
};

struct btrfs_delayed_root {
	spinlock_t lock;
	struct list_head node_list;
	struct list_head prepare_list;
	atomic_t items;
	atomic_t items_seq;
	int nodes;
	wait_queue_head_t wait;
};

struct btrfs_free_space_op;

struct btrfs_free_space_ctl {
	spinlock_t tree_lock;
	struct rb_root free_space_offset;
	u64 free_space;
	int extents_thresh;
	int free_extents;
	int total_bitmaps;
	int unit;
	u64 start;
	s32 discardable_extents[2];
	s64 discardable_bytes[2];
	const struct btrfs_free_space_op *op;
	void *private;
	struct mutex cache_writeout_mutex;
	struct list_head trimming_ranges;
};

enum btrfs_reserve_flush_enum {
	BTRFS_RESERVE_NO_FLUSH = 0,
	BTRFS_RESERVE_FLUSH_LIMIT = 1,
	BTRFS_RESERVE_FLUSH_EVICT = 2,
	BTRFS_RESERVE_FLUSH_DATA = 3,
	BTRFS_RESERVE_FLUSH_FREE_SPACE_INODE = 4,
	BTRFS_RESERVE_FLUSH_ALL = 5,
	BTRFS_RESERVE_FLUSH_ALL_STEAL = 6,
};

enum btrfs_flush_state {
	FLUSH_DELAYED_ITEMS_NR = 1,
	FLUSH_DELAYED_ITEMS = 2,
	FLUSH_DELAYED_REFS_NR = 3,
	FLUSH_DELAYED_REFS = 4,
	FLUSH_DELALLOC = 5,
	FLUSH_DELALLOC_WAIT = 6,
	ALLOC_CHUNK = 7,
	ALLOC_CHUNK_FORCE = 8,
	RUN_DELAYED_IPUTS = 9,
	COMMIT_TRANS = 10,
};

struct btrfs_delayed_node {
	u64 inode_id;
	u64 bytes_reserved;
	struct btrfs_root *root;
	struct list_head n_list;
	struct list_head p_list;
	struct rb_root_cached ins_root;
	struct rb_root_cached del_root;
	struct mutex mutex;
	struct btrfs_inode_item inode_item;
	refcount_t refs;
	u64 index_cnt;
	long unsigned int flags;
	int count;
};

enum {
	BTRFS_ORDERED_IO_DONE = 0,
	BTRFS_ORDERED_COMPLETE = 1,
	BTRFS_ORDERED_NOCOW = 2,
	BTRFS_ORDERED_COMPRESSED = 3,
	BTRFS_ORDERED_PREALLOC = 4,
	BTRFS_ORDERED_DIRECT = 5,
	BTRFS_ORDERED_IOERR = 6,
	BTRFS_ORDERED_TRUNCATED = 7,
	BTRFS_ORDERED_REGULAR = 8,
	BTRFS_ORDERED_LOGGED = 9,
	BTRFS_ORDERED_LOGGED_CSUM = 10,
	BTRFS_ORDERED_PENDING = 11,
};

struct btrfs_ordered_extent {
	u64 file_offset;
	u64 disk_bytenr;
	u64 num_bytes;
	u64 disk_num_bytes;
	u64 bytes_left;
	u64 outstanding_isize;
	u64 truncated_len;
	long unsigned int flags;
	int compress_type;
	int qgroup_rsv;
	refcount_t refs;
	struct inode *inode;
	struct list_head list;
	struct list_head log_list;
	wait_queue_head_t wait;
	struct rb_node rb_node;
	struct list_head root_extent_list;
	struct btrfs_work work;
	struct completion completion;
	struct btrfs_work flush_work;
	struct list_head work_list;
};

struct btrfs_delayed_ref_node {
	struct rb_node ref_node;
	struct list_head add_list;
	u64 bytenr;
	u64 num_bytes;
	u64 seq;
	refcount_t refs;
	int ref_mod;
	unsigned int action: 8;
	unsigned int type: 8;
	unsigned int is_head: 1;
	unsigned int in_tree: 1;
};

struct btrfs_delayed_extent_op {
	struct btrfs_disk_key key;
	u8 level;
	bool update_key;
	bool update_flags;
	bool is_data;
	u64 flags_to_set;
};

struct btrfs_delayed_ref_head {
	u64 bytenr;
	u64 num_bytes;
	refcount_t refs;
	struct mutex mutex;
	spinlock_t lock;
	struct rb_root_cached ref_tree;
	struct list_head ref_add_list;
	struct rb_node href_node;
	struct btrfs_delayed_extent_op *extent_op;
	int total_ref_mod;
	int ref_mod;
	unsigned int must_insert_reserved: 1;
	unsigned int is_data: 1;
	unsigned int is_system: 1;
	unsigned int processing: 1;
};

struct btrfs_delayed_tree_ref {
	struct btrfs_delayed_ref_node node;
	u64 root;
	u64 parent;
	int level;
};

struct btrfs_delayed_data_ref {
	struct btrfs_delayed_ref_node node;
	u64 root;
	u64 parent;
	u64 objectid;
	u64 offset;
};

struct btrfs_trans_handle {
	u64 transid;
	u64 bytes_reserved;
	u64 chunk_bytes_reserved;
	long unsigned int delayed_ref_updates;
	struct btrfs_transaction *transaction;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_block_rsv *orig_rsv;
	refcount_t use_count;
	unsigned int type;
	short int aborted;
	bool adding_csums;
	bool allocating_chunk;
	bool can_flush_pending_bgs;
	bool reloc_reserved;
	bool dirty;
	struct btrfs_root *root;
	struct btrfs_fs_info *fs_info;
	struct list_head new_bgs;
};

struct rcu_string {
	struct callback_head rcu;
	char str[0];
};

struct btrfs_device_info {
	struct btrfs_device *dev;
	u64 dev_offset;
	u64 max_avail;
	u64 total_avail;
};

struct btrfs_raid_attr {
	u8 sub_stripes;
	u8 dev_stripes;
	u8 devs_max;
	u8 devs_min;
	u8 tolerated_failures;
	u8 devs_increment;
	u8 ncopies;
	u8 nparity;
	u8 mindev_error;
	const char raid_name[8];
	u64 bg_flag;
};

enum btrfs_compression_type {
	BTRFS_COMPRESS_NONE = 0,
	BTRFS_COMPRESS_ZLIB = 1,
	BTRFS_COMPRESS_LZO = 2,
	BTRFS_COMPRESS_ZSTD = 3,
	BTRFS_NR_COMPRESS_TYPES = 4,
};

enum btrfs_trim_state {
	BTRFS_TRIM_STATE_UNTRIMMED = 0,
	BTRFS_TRIM_STATE_TRIMMED = 1,
	BTRFS_TRIM_STATE_TRIMMING = 2,
};

struct btrfs_free_space {
	struct rb_node offset_index;
	u64 offset;
	u64 bytes;
	u64 max_extent_size;
	long unsigned int *bitmap;
	struct list_head list;
	enum btrfs_trim_state trim_state;
	s32 bitmap_extents;
};

struct btrfs_free_space_op {
	void (*recalc_thresholds)(struct btrfs_free_space_ctl *);
	bool (*use_bitmap)(struct btrfs_free_space_ctl *, struct btrfs_free_space *);
};

struct extent_inode_elem;

struct prelim_ref {
	struct rb_node rbnode;
	u64 root_id;
	struct btrfs_key key_for_search;
	int level;
	int count;
	struct extent_inode_elem *inode_list;
	u64 parent;
	u64 wanted_disk_byte;
};

struct btrfs_caching_control {
	struct list_head list;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct btrfs_work work;
	struct btrfs_block_group *block_group;
	u64 progress;
	refcount_t count;
};

struct btrfs_qgroup_extent_record {
	struct rb_node node;
	u64 bytenr;
	u64 num_bytes;
	u32 data_rsv;
	u64 data_rsv_refroot;
	struct ulist *old_roots;
};

enum btrfs_qgroup_rsv_type {
	BTRFS_QGROUP_RSV_DATA = 0,
	BTRFS_QGROUP_RSV_META_PERTRANS = 1,
	BTRFS_QGROUP_RSV_META_PREALLOC = 2,
	BTRFS_QGROUP_RSV_LAST = 3,
};

struct btrfs_qgroup_rsv {
	u64 values[3];
};

struct btrfs_qgroup {
	u64 qgroupid;
	u64 rfer;
	u64 rfer_cmpr;
	u64 excl;
	u64 excl_cmpr;
	u64 lim_flags;
	u64 max_rfer;
	u64 max_excl;
	u64 rsv_rfer;
	u64 rsv_excl;
	struct btrfs_qgroup_rsv rsv;
	struct list_head groups;
	struct list_head members;
	struct list_head dirty;
	struct rb_node node;
	u64 old_refcnt;
	u64 new_refcnt;
	struct kobject kobj;
};

struct trace_event_raw_btrfs_transaction_commit {
	struct trace_entry ent;
	u8 fsid[16];
	u64 generation;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs__inode {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 blocks;
	u64 disk_i_size;
	u64 generation;
	u64 last_trans;
	u64 logged_trans;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_get_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 ino;
	u64 start;
	u64 len;
	u64 orig_start;
	u64 block_start;
	u64 block_len;
	long unsigned int flags;
	int refs;
	unsigned int compress_type;
	char __data[0];
};

struct trace_event_raw_btrfs_handle_em_exist {
	struct trace_entry ent;
	u8 fsid[16];
	u64 e_start;
	u64 e_len;
	u64 map_start;
	u64 map_len;
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_btrfs__file_extent_item_regular {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_obj;
	u64 ino;
	loff_t isize;
	u64 disk_isize;
	u64 num_bytes;
	u64 ram_bytes;
	u64 disk_bytenr;
	u64 disk_num_bytes;
	u64 extent_offset;
	u8 extent_type;
	u8 compression;
	u64 extent_start;
	u64 extent_end;
	char __data[0];
};

struct trace_event_raw_btrfs__file_extent_item_inline {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_obj;
	u64 ino;
	loff_t isize;
	u64 disk_isize;
	u8 extent_type;
	u8 compression;
	u64 extent_start;
	u64 extent_end;
	char __data[0];
};

struct trace_event_raw_btrfs__ordered_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 file_offset;
	u64 start;
	u64 len;
	u64 disk_len;
	u64 bytes_left;
	long unsigned int flags;
	int compress_type;
	int refs;
	u64 root_objectid;
	u64 truncated_len;
	char __data[0];
};

struct trace_event_raw_btrfs__writepage {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	long unsigned int index;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	char for_kupdate;
	char for_reclaim;
	char range_cyclic;
	long unsigned int writeback_index;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_writepage_end_io_hook {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	long unsigned int index;
	u64 start;
	u64 end;
	int uptodate;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_sync_file {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 parent;
	int datasync;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_sync_fs {
	struct trace_entry ent;
	u8 fsid[16];
	int wait;
	char __data[0];
};

struct trace_event_raw_btrfs_add_block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 offset;
	u64 size;
	u64 flags;
	u64 bytes_used;
	u64 bytes_super;
	int create;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_tree_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	u64 parent;
	u64 ref_root;
	int level;
	int type;
	u64 seq;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_data_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	u64 parent;
	u64 ref_root;
	u64 owner;
	u64 offset;
	int type;
	u64 seq;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_ref_head {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	int is_data;
	char __data[0];
};

struct trace_event_raw_btrfs__chunk {
	struct trace_entry ent;
	u8 fsid[16];
	int num_stripes;
	u64 type;
	int sub_stripes;
	u64 offset;
	u64 size;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_cow_block {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 buf_start;
	int refs;
	u64 cow_start;
	int buf_level;
	int cow_level;
	char __data[0];
};

struct trace_event_raw_btrfs_space_reservation {
	struct trace_entry ent;
	u8 fsid[16];
	u32 __data_loc_type;
	u64 val;
	u64 bytes;
	int reserve;
	char __data[0];
};

struct trace_event_raw_btrfs_trigger_flush {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 bytes;
	int flush;
	u32 __data_loc_reason;
	char __data[0];
};

struct trace_event_raw_btrfs_flush_space {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 num_bytes;
	int state;
	int ret;
	char __data[0];
};

struct trace_event_raw_btrfs__reserved_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_find_free_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 num_bytes;
	u64 empty_size;
	u64 data;
	char __data[0];
};

struct trace_event_raw_btrfs__reserve_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_btrfs_find_cluster {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 bytes;
	u64 empty_size;
	u64 min_bytes;
	char __data[0];
};

struct trace_event_raw_btrfs_failed_cluster_setup {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_setup_cluster {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 max_size;
	u64 size;
	int bitmap;
	char __data[0];
};

struct trace_event_raw_alloc_extent_state {
	struct trace_entry ent;
	const struct extent_state *state;
	gfp_t mask;
	const void *ip;
	char __data[0];
};

struct trace_event_raw_free_extent_state {
	struct trace_entry ent;
	const struct extent_state *state;
	const void *ip;
	char __data[0];
};

struct trace_event_raw_btrfs__work {
	struct trace_entry ent;
	u8 fsid[16];
	const void *work;
	const void *wq;
	const void *func;
	const void *ordered_func;
	const void *ordered_free;
	const void *normal_work;
	char __data[0];
};

struct trace_event_raw_btrfs__work__done {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wtag;
	char __data[0];
};

struct trace_event_raw_btrfs__workqueue {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wq;
	u32 __data_loc_name;
	int high;
	char __data[0];
};

struct trace_event_raw_btrfs__workqueue_done {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wq;
	char __data[0];
};

struct trace_event_raw_btrfs__qgroup_rsv_data {
	struct trace_entry ent;
	u8 fsid[16];
	u64 rootid;
	u64 ino;
	u64 start;
	u64 len;
	u64 reserved;
	int op;
	char __data[0];
};

struct trace_event_raw_btrfs_qgroup_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	char __data[0];
};

struct trace_event_raw_qgroup_num_dirty_extents {
	struct trace_entry ent;
	u8 fsid[16];
	u64 transid;
	u64 num_dirty_extents;
	char __data[0];
};

struct trace_event_raw_btrfs_qgroup_account_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 transid;
	u64 bytenr;
	u64 num_bytes;
	u64 nr_old_roots;
	u64 nr_new_roots;
	char __data[0];
};

struct trace_event_raw_qgroup_update_counters {
	struct trace_entry ent;
	u8 fsid[16];
	u64 qgid;
	u64 old_rfer;
	u64 old_excl;
	u64 cur_old_count;
	u64 cur_new_count;
	char __data[0];
};

struct trace_event_raw_qgroup_update_reserve {
	struct trace_entry ent;
	u8 fsid[16];
	u64 qgid;
	u64 cur_reserved;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_reserve {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_convert {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_free_all_pertrans {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_btrfs__prelim_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_id;
	u64 objectid;
	u8 type;
	u64 offset;
	int level;
	int old_count;
	u64 parent;
	u64 bytenr;
	int mod_count;
	u64 tree_size;
	char __data[0];
};

struct trace_event_raw_btrfs_inode_mod_outstanding_extents {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 ino;
	int mod;
	char __data[0];
};

struct trace_event_raw_btrfs__block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 len;
	u64 used;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_btrfs_set_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int set_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_clear_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int clear_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_convert_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int set_bits;
	unsigned int clear_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_sleep_tree_lock {
	struct trace_entry ent;
	u8 fsid[16];
	u64 block;
	u64 generation;
	u64 start_ns;
	u64 end_ns;
	u64 diff_ns;
	u64 owner;
	int is_log_tree;
	char __data[0];
};

struct trace_event_raw_btrfs_locking_events {
	struct trace_entry ent;
	u8 fsid[16];
	u64 block;
	u64 generation;
	u64 owner;
	int is_log_tree;
	char __data[0];
};

struct trace_event_raw_btrfs__space_info_update {
	struct trace_entry ent;
	u8 fsid[16];
	u64 type;
	u64 old;
	s64 diff;
	char __data[0];
};

struct trace_event_data_offsets_btrfs_transaction_commit {};

struct trace_event_data_offsets_btrfs__inode {};

struct trace_event_data_offsets_btrfs_get_extent {};

struct trace_event_data_offsets_btrfs_handle_em_exist {};

struct trace_event_data_offsets_btrfs__file_extent_item_regular {};

struct trace_event_data_offsets_btrfs__file_extent_item_inline {};

struct trace_event_data_offsets_btrfs__ordered_extent {};

struct trace_event_data_offsets_btrfs__writepage {};

struct trace_event_data_offsets_btrfs_writepage_end_io_hook {};

struct trace_event_data_offsets_btrfs_sync_file {};

struct trace_event_data_offsets_btrfs_sync_fs {};

struct trace_event_data_offsets_btrfs_add_block_group {};

struct trace_event_data_offsets_btrfs_delayed_tree_ref {};

struct trace_event_data_offsets_btrfs_delayed_data_ref {};

struct trace_event_data_offsets_btrfs_delayed_ref_head {};

struct trace_event_data_offsets_btrfs__chunk {};

struct trace_event_data_offsets_btrfs_cow_block {};

struct trace_event_data_offsets_btrfs_space_reservation {
	u32 type;
};

struct trace_event_data_offsets_btrfs_trigger_flush {
	u32 reason;
};

struct trace_event_data_offsets_btrfs_flush_space {};

struct trace_event_data_offsets_btrfs__reserved_extent {};

struct trace_event_data_offsets_find_free_extent {};

struct trace_event_data_offsets_btrfs__reserve_extent {};

struct trace_event_data_offsets_btrfs_find_cluster {};

struct trace_event_data_offsets_btrfs_failed_cluster_setup {};

struct trace_event_data_offsets_btrfs_setup_cluster {};

struct trace_event_data_offsets_alloc_extent_state {};

struct trace_event_data_offsets_free_extent_state {};

struct trace_event_data_offsets_btrfs__work {};

struct trace_event_data_offsets_btrfs__work__done {};

struct trace_event_data_offsets_btrfs__workqueue {
	u32 name;
};

struct trace_event_data_offsets_btrfs__workqueue_done {};

struct trace_event_data_offsets_btrfs__qgroup_rsv_data {};

struct trace_event_data_offsets_btrfs_qgroup_extent {};

struct trace_event_data_offsets_qgroup_num_dirty_extents {};

struct trace_event_data_offsets_btrfs_qgroup_account_extent {};

struct trace_event_data_offsets_qgroup_update_counters {};

struct trace_event_data_offsets_qgroup_update_reserve {};

struct trace_event_data_offsets_qgroup_meta_reserve {};

struct trace_event_data_offsets_qgroup_meta_convert {};

struct trace_event_data_offsets_qgroup_meta_free_all_pertrans {};

struct trace_event_data_offsets_btrfs__prelim_ref {};

struct trace_event_data_offsets_btrfs_inode_mod_outstanding_extents {};

struct trace_event_data_offsets_btrfs__block_group {};

struct trace_event_data_offsets_btrfs_set_extent_bit {};

struct trace_event_data_offsets_btrfs_clear_extent_bit {};

struct trace_event_data_offsets_btrfs_convert_extent_bit {};

struct trace_event_data_offsets_btrfs_sleep_tree_lock {};

struct trace_event_data_offsets_btrfs_locking_events {};

struct trace_event_data_offsets_btrfs__space_info_update {};

typedef void (*btf_trace_btrfs_transaction_commit)(void *, const struct btrfs_root *);

typedef void (*btf_trace_btrfs_inode_new)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_inode_request)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_inode_evict)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_get_extent)(void *, const struct btrfs_root *, const struct btrfs_inode *, const struct extent_map *);

typedef void (*btf_trace_btrfs_handle_em_exist)(void *, const struct btrfs_fs_info *, const struct extent_map *, const struct extent_map *, u64, u64);

typedef void (*btf_trace_btrfs_get_extent_show_fi_regular)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, u64);

typedef void (*btf_trace_btrfs_truncate_show_fi_regular)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, u64);

typedef void (*btf_trace_btrfs_get_extent_show_fi_inline)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, int, u64);

typedef void (*btf_trace_btrfs_truncate_show_fi_inline)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, int, u64);

typedef void (*btf_trace_btrfs_ordered_extent_add)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_remove)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_start)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_put)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace___extent_writepage)(void *, const struct page *, const struct inode *, const struct writeback_control *);

typedef void (*btf_trace_btrfs_writepage_end_io_hook)(void *, const struct page *, u64, u64, int);

typedef void (*btf_trace_btrfs_sync_file)(void *, const struct file *, int);

typedef void (*btf_trace_btrfs_sync_fs)(void *, const struct btrfs_fs_info *, int);

typedef void (*btf_trace_btrfs_add_block_group)(void *, const struct btrfs_fs_info *, const struct btrfs_block_group *, int);

typedef void (*btf_trace_add_delayed_tree_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_tree_ref *, int);

typedef void (*btf_trace_run_delayed_tree_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_tree_ref *, int);

typedef void (*btf_trace_add_delayed_data_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_data_ref *, int);

typedef void (*btf_trace_run_delayed_data_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *, const struct btrfs_delayed_data_ref *, int);

typedef void (*btf_trace_add_delayed_ref_head)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_head *, int);

typedef void (*btf_trace_run_delayed_ref_head)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_head *, int);

typedef void (*btf_trace_btrfs_chunk_alloc)(void *, const struct btrfs_fs_info *, const struct map_lookup *, u64, u64);

typedef void (*btf_trace_btrfs_chunk_free)(void *, const struct btrfs_fs_info *, const struct map_lookup *, u64, u64);

typedef void (*btf_trace_btrfs_cow_block)(void *, const struct btrfs_root *, const struct extent_buffer *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_space_reservation)(void *, const struct btrfs_fs_info *, const char *, u64, u64, int);

typedef void (*btf_trace_btrfs_trigger_flush)(void *, const struct btrfs_fs_info *, u64, u64, int, const char *);

typedef void (*btf_trace_btrfs_flush_space)(void *, const struct btrfs_fs_info *, u64, u64, int, int);

typedef void (*btf_trace_btrfs_reserved_extent_alloc)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_btrfs_reserved_extent_free)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_find_free_extent)(void *, const struct btrfs_root *, u64, u64, u64);

typedef void (*btf_trace_btrfs_reserve_extent)(void *, const struct btrfs_block_group *, u64, u64);

typedef void (*btf_trace_btrfs_reserve_extent_cluster)(void *, const struct btrfs_block_group *, u64, u64);

typedef void (*btf_trace_btrfs_find_cluster)(void *, const struct btrfs_block_group *, u64, u64, u64, u64);

typedef void (*btf_trace_btrfs_failed_cluster_setup)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_setup_cluster)(void *, const struct btrfs_block_group *, const struct btrfs_free_cluster *, u64, int);

typedef void (*btf_trace_alloc_extent_state)(void *, const struct extent_state *, gfp_t, long unsigned int);

typedef void (*btf_trace_free_extent_state)(void *, const struct extent_state *, long unsigned int);

typedef void (*btf_trace_btrfs_work_queued)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_work_sched)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_all_work_done)(void *, const struct btrfs_fs_info *, const void *);

typedef void (*btf_trace_btrfs_ordered_sched)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_workqueue_alloc)(void *, const struct __btrfs_workqueue *, const char *, int);

typedef void (*btf_trace_btrfs_workqueue_destroy)(void *, const struct __btrfs_workqueue *);

typedef void (*btf_trace_btrfs_qgroup_reserve_data)(void *, const struct inode *, u64, u64, u64, int);

typedef void (*btf_trace_btrfs_qgroup_release_data)(void *, const struct inode *, u64, u64, u64, int);

typedef void (*btf_trace_btrfs_qgroup_account_extents)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup_extent_record *);

typedef void (*btf_trace_btrfs_qgroup_trace_extent)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup_extent_record *);

typedef void (*btf_trace_qgroup_num_dirty_extents)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_btrfs_qgroup_account_extent)(void *, const struct btrfs_fs_info *, u64, u64, u64, u64, u64);

typedef void (*btf_trace_qgroup_update_counters)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup *, u64, u64);

typedef void (*btf_trace_qgroup_update_reserve)(void *, struct btrfs_fs_info *, struct btrfs_qgroup *, s64, int);

typedef void (*btf_trace_qgroup_meta_reserve)(void *, struct btrfs_root *, s64, int);

typedef void (*btf_trace_qgroup_meta_convert)(void *, struct btrfs_root *, s64);

typedef void (*btf_trace_qgroup_meta_free_all_pertrans)(void *, struct btrfs_root *);

typedef void (*btf_trace_btrfs_prelim_ref_merge)(void *, const struct btrfs_fs_info *, const struct prelim_ref *, const struct prelim_ref *, u64);

typedef void (*btf_trace_btrfs_prelim_ref_insert)(void *, const struct btrfs_fs_info *, const struct prelim_ref *, const struct prelim_ref *, u64);

typedef void (*btf_trace_btrfs_inode_mod_outstanding_extents)(void *, const struct btrfs_root *, u64, int);

typedef void (*btf_trace_btrfs_remove_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_add_unused_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_skip_unused_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_set_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int);

typedef void (*btf_trace_btrfs_clear_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int);

typedef void (*btf_trace_btrfs_convert_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int, unsigned int);

typedef void (*btf_trace_btrfs_tree_read_lock)(void *, const struct extent_buffer *, u64);

typedef void (*btf_trace_btrfs_tree_lock)(void *, const struct extent_buffer *, u64);

typedef void (*btf_trace_btrfs_tree_unlock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_unlock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_unlock_blocking)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_set_lock_blocking_read)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_set_lock_blocking_write)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_try_tree_read_lock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_try_tree_write_lock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_lock_atomic)(void *, const struct extent_buffer *);

typedef void (*btf_trace_update_bytes_may_use)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

typedef void (*btf_trace_update_bytes_pinned)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

enum {
	Opt_acl___3 = 0,
	Opt_noacl___2 = 1,
	Opt_clear_cache = 2,
	Opt_commit_interval = 3,
	Opt_compress = 4,
	Opt_compress_force = 5,
	Opt_compress_force_type = 6,
	Opt_compress_type = 7,
	Opt_degraded = 8,
	Opt_device = 9,
	Opt_fatal_errors = 10,
	Opt_flushoncommit = 11,
	Opt_noflushoncommit = 12,
	Opt_inode_cache = 13,
	Opt_noinode_cache = 14,
	Opt_max_inline = 15,
	Opt_barrier___2 = 16,
	Opt_nobarrier___2 = 17,
	Opt_datacow = 18,
	Opt_nodatacow = 19,
	Opt_datasum = 20,
	Opt_nodatasum = 21,
	Opt_defrag = 22,
	Opt_nodefrag = 23,
	Opt_discard___2 = 24,
	Opt_nodiscard___2 = 25,
	Opt_discard_mode = 26,
	Opt_norecovery = 27,
	Opt_ratio = 28,
	Opt_rescan_uuid_tree = 29,
	Opt_skip_balance = 30,
	Opt_space_cache = 31,
	Opt_no_space_cache = 32,
	Opt_space_cache_version = 33,
	Opt_ssd = 34,
	Opt_nossd = 35,
	Opt_ssd_spread = 36,
	Opt_nossd_spread = 37,
	Opt_subvol = 38,
	Opt_subvol_empty = 39,
	Opt_subvolid = 40,
	Opt_thread_pool = 41,
	Opt_treelog = 42,
	Opt_notreelog = 43,
	Opt_user_subvol_rm_allowed = 44,
	Opt_rescue = 45,
	Opt_usebackuproot = 46,
	Opt_nologreplay = 47,
	Opt_recovery = 48,
	Opt_check_integrity = 49,
	Opt_check_integrity_including_extent_data = 50,
	Opt_check_integrity_print_mask = 51,
	Opt_enospc_debug = 52,
	Opt_noenospc_debug = 53,
	Opt_err___7 = 54,
};

enum btrfs_csum_type {
	BTRFS_CSUM_TYPE_CRC32 = 0,
	BTRFS_CSUM_TYPE_XXHASH = 1,
	BTRFS_CSUM_TYPE_SHA256 = 2,
	BTRFS_CSUM_TYPE_BLAKE2 = 3,
};

enum {
	EXTENT_BUFFER_UPTODATE = 0,
	EXTENT_BUFFER_DIRTY = 1,
	EXTENT_BUFFER_CORRUPT = 2,
	EXTENT_BUFFER_READAHEAD = 3,
	EXTENT_BUFFER_TREE_REF = 4,
	EXTENT_BUFFER_STALE = 5,
	EXTENT_BUFFER_WRITEBACK = 6,
	EXTENT_BUFFER_READ_ERR = 7,
	EXTENT_BUFFER_UNMAPPED = 8,
	EXTENT_BUFFER_IN_TREE = 9,
	EXTENT_BUFFER_WRITE_ERR = 10,
};

struct btrfs_key_ptr {
	struct btrfs_disk_key key;
	__le64 blockptr;
	__le64 generation;
} __attribute__((packed));

enum {
	READA_NONE = 0,
	READA_BACK = 1,
	READA_FORWARD = 2,
};

struct seq_list {
	struct list_head list;
	u64 seq;
};

enum {
	BTRFS_ROOT_IN_TRANS_SETUP = 0,
	BTRFS_ROOT_SHAREABLE = 1,
	BTRFS_ROOT_TRACK_DIRTY = 2,
	BTRFS_ROOT_IN_RADIX = 3,
	BTRFS_ROOT_ORPHAN_ITEM_INSERTED = 4,
	BTRFS_ROOT_DEFRAG_RUNNING = 5,
	BTRFS_ROOT_FORCE_COW = 6,
	BTRFS_ROOT_MULTI_LOG_TASKS = 7,
	BTRFS_ROOT_DIRTY = 8,
	BTRFS_ROOT_DELETING = 9,
	BTRFS_ROOT_DEAD_RELOC_TREE = 10,
	BTRFS_ROOT_DEAD_TREE = 11,
	BTRFS_ROOT_HAS_LOG_TREE = 12,
	BTRFS_ROOT_QGROUP_FLUSHING = 13,
};

struct btrfs_map_token {
	struct extent_buffer *eb;
	char *kaddr;
	long unsigned int offset;
};

struct btrfs_csums {
	u16 size;
	const char name[10];
	const char driver[12];
};

enum mod_log_op {
	MOD_LOG_KEY_REPLACE = 0,
	MOD_LOG_KEY_ADD = 1,
	MOD_LOG_KEY_REMOVE = 2,
	MOD_LOG_KEY_REMOVE_WHILE_FREEING = 3,
	MOD_LOG_KEY_REMOVE_WHILE_MOVING = 4,
	MOD_LOG_MOVE_KEYS = 5,
	MOD_LOG_ROOT_REPLACE = 6,
};

struct tree_mod_root {
	u64 logical;
	u8 level;
};

struct tree_mod_elem {
	struct rb_node node;
	u64 logical;
	u64 seq;
	enum mod_log_op op;
	int slot;
	u64 generation;
	struct btrfs_disk_key key;
	u64 blockptr;
	struct {
		int dst_slot;
		int nr_items;
	} move;
	struct tree_mod_root old_root;
};

struct btrfs_extent_item {
	__le64 refs;
	__le64 generation;
	__le64 flags;
};

struct btrfs_tree_block_info {
	struct btrfs_disk_key key;
	__u8 level;
} __attribute__((packed));

struct btrfs_extent_data_ref {
	__le64 root;
	__le64 objectid;
	__le64 offset;
	__le32 count;
} __attribute__((packed));

struct btrfs_shared_data_ref {
	__le32 count;
};

struct btrfs_extent_inline_ref {
	__u8 type;
	__le64 offset;
} __attribute__((packed));

enum btrfs_inline_ref_type {
	BTRFS_REF_TYPE_INVALID = 0,
	BTRFS_REF_TYPE_BLOCK = 1,
	BTRFS_REF_TYPE_DATA = 2,
	BTRFS_REF_TYPE_ANY = 3,
};

enum btrfs_ref_type {
	BTRFS_REF_NOT_SET = 0,
	BTRFS_REF_DATA = 1,
	BTRFS_REF_METADATA = 2,
	BTRFS_REF_LAST = 3,
};

struct btrfs_data_ref {
	u64 ref_root;
	u64 ino;
	u64 offset;
};

struct btrfs_tree_ref {
	int level;
	u64 root;
};

struct btrfs_ref {
	enum btrfs_ref_type type;
	int action;
	bool skip_qgroup;
	u64 real_root;
	u64 bytenr;
	u64 len;
	u64 parent;
	union {
		struct btrfs_data_ref data_ref;
		struct btrfs_tree_ref tree_ref;
	};
};

struct btrfs_bio {
	refcount_t refs;
	atomic_t stripes_pending;
	struct btrfs_fs_info *fs_info;
	u64 map_type;
	bio_end_io_t *end_io;
	struct bio *orig_bio;
	void *private;
	atomic_t error;
	int max_errors;
	int num_stripes;
	int mirror_num;
	int num_tgtdevs;
	int *tgtdev_map;
	u64 *raid_map;
	struct btrfs_bio_stripe stripes[0];
};

enum btrfs_map_op {
	BTRFS_MAP_READ = 0,
	BTRFS_MAP_WRITE = 1,
	BTRFS_MAP_DISCARD = 2,
	BTRFS_MAP_GET_READ_MIRRORS = 3,
};

enum btrfs_chunk_alloc_enum {
	CHUNK_ALLOC_NO_FORCE = 0,
	CHUNK_ALLOC_LIMITED = 1,
	CHUNK_ALLOC_FORCE = 2,
};

enum btrfs_loop_type {
	LOOP_CACHING_NOWAIT = 0,
	LOOP_CACHING_WAIT = 1,
	LOOP_ALLOC_CHUNK = 2,
	LOOP_NO_EMPTY_SIZE = 3,
};

enum btrfs_extent_allocation_policy {
	BTRFS_EXTENT_ALLOC_CLUSTERED = 0,
};

struct find_free_extent_ctl {
	u64 num_bytes;
	u64 empty_size;
	u64 flags;
	int delalloc;
	u64 search_start;
	u64 empty_cluster;
	struct btrfs_free_cluster *last_ptr;
	bool use_cluster;
	bool have_caching_bg;
	bool orig_have_caching_bg;
	int index;
	int loop;
	bool retry_clustered;
	bool retry_unclustered;
	int cached;
	u64 max_extent_size;
	u64 total_free_space;
	u64 found_offset;
	u64 hint_byte;
	enum btrfs_extent_allocation_policy policy;
};

struct walk_control {
	u64 refs[8];
	u64 flags[8];
	struct btrfs_key update_progress;
	struct btrfs_key drop_progress;
	short: 16;
	int drop_level;
	int stage;
	int level;
	int shared_level;
	int update_ref;
	int keep_locks;
	int reada_slot;
	int reada_count;
	int restarted;
} __attribute__((packed));

struct btrfs_stripe {
	__le64 devid;
	__le64 offset;
	__u8 dev_uuid[16];
};

struct btrfs_chunk {
	__le64 length;
	__le64 owner;
	__le64 stripe_len;
	__le64 type;
	__le32 io_align;
	__le32 io_width;
	__le32 sector_size;
	__le16 num_stripes;
	__le16 sub_stripes;
	struct btrfs_stripe stripe;
};

struct btrfs_dev_extent {
	__le64 chunk_tree;
	__le64 chunk_objectid;
	__le64 chunk_offset;
	__le64 length;
	__u8 chunk_tree_uuid[16];
};

struct btrfs_block_group_item {
	__le64 used;
	__le64 chunk_objectid;
	__le64 flags;
};

struct root_name_map {
	u64 id;
	char name[16];
};

struct btrfs_csum_item {
	__u8 csum;
};

struct btrfs_ordered_sum {
	u64 bytenr;
	int len;
	struct list_head list;
	u8 sums[0];
};

struct btrfs_io_bio {
	unsigned int mirror_num;
	struct btrfs_device *device;
	u64 logical;
	u8 *csum;
	u8 csum_inline[64];
	struct bvec_iter iter;
	struct bio bio;
};

struct btrfs_inode_extref {
	__le64 parent_objectid;
	__le64 index;
	__le16 name_len;
	__u8 name[0];
} __attribute__((packed));

struct extent_changeset {
	unsigned int bytes_changed;
	struct ulist range_changed;
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	unsigned int descsize;
	int: 32;
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

typedef blk_status_t extent_submit_bio_start_t(void *, struct bio *, u64);

enum {
	BTRFS_BLOCK_RSV_GLOBAL = 0,
	BTRFS_BLOCK_RSV_DELALLOC = 1,
	BTRFS_BLOCK_RSV_TRANS = 2,
	BTRFS_BLOCK_RSV_CHUNK = 3,
	BTRFS_BLOCK_RSV_DELOPS = 4,
	BTRFS_BLOCK_RSV_DELREFS = 5,
	BTRFS_BLOCK_RSV_EMPTY = 6,
	BTRFS_BLOCK_RSV_TEMP = 7,
};

enum btrfs_wq_endio_type {
	BTRFS_WQ_ENDIO_DATA = 0,
	BTRFS_WQ_ENDIO_METADATA = 1,
	BTRFS_WQ_ENDIO_FREE_SPACE = 2,
	BTRFS_WQ_ENDIO_RAID56 = 3,
};

enum {
	BTRFS_INODE_FLUSH_ON_CLOSE = 0,
	BTRFS_INODE_DUMMY = 1,
	BTRFS_INODE_IN_DEFRAG = 2,
	BTRFS_INODE_HAS_ASYNC_EXTENT = 3,
	BTRFS_INODE_NEEDS_FULL_SYNC = 4,
	BTRFS_INODE_COPY_EVERYTHING = 5,
	BTRFS_INODE_IN_DELALLOC_LIST = 6,
	BTRFS_INODE_HAS_PROPS = 7,
	BTRFS_INODE_SNAPSHOT_FLUSH = 8,
};

enum btrfs_disk_cache_state {
	BTRFS_DC_WRITTEN = 0,
	BTRFS_DC_ERROR = 1,
	BTRFS_DC_CLEAR = 2,
	BTRFS_DC_SETUP = 3,
};

struct btrfs_end_io_wq {
	struct bio *bio;
	bio_end_io_t *end_io;
	void *private;
	struct btrfs_fs_info *info;
	blk_status_t status;
	enum btrfs_wq_endio_type metadata;
	struct btrfs_work work;
};

struct async_submit_bio {
	void *private_data;
	struct bio *bio;
	extent_submit_bio_start_t *submit_bio_start;
	int mirror_num;
	u64 bio_offset;
	struct btrfs_work work;
	blk_status_t status;
};

struct btrfs_qgroup_limit {
	__u64 flags;
	__u64 max_rfer;
	__u64 max_excl;
	__u64 rsv_rfer;
	__u64 rsv_excl;
};

struct btrfs_qgroup_inherit {
	__u64 flags;
	__u64 num_qgroups;
	__u64 num_ref_copies;
	__u64 num_excl_copies;
	struct btrfs_qgroup_limit lim;
	__u64 qgroups[0];
};

struct btrfs_pending_snapshot {
	struct dentry *dentry;
	struct inode *dir;
	struct btrfs_root *root;
	struct btrfs_root_item *root_item;
	struct btrfs_root *snap;
	struct btrfs_qgroup_inherit *inherit;
	struct btrfs_path *path;
	struct btrfs_block_rsv block_rsv;
	int error;
	dev_t anon_dev;
	bool readonly;
	struct list_head list;
};

struct btrfs_async_commit {
	struct btrfs_trans_handle *newtrans;
	struct work_struct work;
};

enum btrfs_orphan_cleanup_state {
	ORPHAN_CLEANUP_STARTED = 1,
	ORPHAN_CLEANUP_DONE = 2,
};

struct btrfs_swapfile_pin {
	struct rb_node node;
	void *ptr;
	struct inode *inode;
	bool is_block_group;
};

enum btrfs_exclusive_operation {
	BTRFS_EXCLOP_NONE = 0,
	BTRFS_EXCLOP_BALANCE = 1,
	BTRFS_EXCLOP_DEV_ADD = 2,
	BTRFS_EXCLOP_DEV_REMOVE = 3,
	BTRFS_EXCLOP_DEV_REPLACE = 4,
	BTRFS_EXCLOP_RESIZE = 5,
	BTRFS_EXCLOP_SWAP_ACTIVATE = 6,
};

struct btrfs_replace_extent_info {
	u64 disk_offset;
	u64 disk_len;
	u64 data_offset;
	u64 data_len;
	u64 file_offset;
	char *extent_buf;
	bool is_new_extent;
	int qgroup_reserved;
	int insertions;
};

struct btrfs_file_private {
	void *filldir_buf;
};

struct btrfs_dio_private {
	struct inode *inode;
	u64 logical_offset;
	u64 disk_bytenr;
	u64 bytes;
	refcount_t refs;
	struct bio *dio_bio;
	u8 csums[0];
};

struct btrfs_io_geometry {
	u64 len;
	u64 offset;
	u64 stripe_len;
	u64 stripe_nr;
	u64 stripe_offset;
	u64 raid56_stripe_offset;
};

struct btrfs_iget_args {
	u64 ino;
	struct btrfs_root *root;
};

struct btrfs_dio_data {
	u64 reserve;
	loff_t length;
	ssize_t submitted;
	struct extent_changeset *data_reserved;
	bool sync;
};

struct async_extent {
	u64 start;
	u64 ram_size;
	u64 compressed_size;
	struct page **pages;
	long unsigned int nr_pages;
	int compress_type;
	struct list_head list;
};

struct async_chunk {
	struct inode *inode;
	struct page *locked_page;
	u64 start;
	u64 end;
	unsigned int write_flags;
	struct list_head extents;
	struct cgroup_subsys_state *blkcg_css;
	struct btrfs_work work;
	atomic_t *pending;
};

struct async_cow {
	atomic_t num_chunks;
	struct async_chunk chunks[0];
};

struct btrfs_writepage_fixup {
	struct page *page;
	struct inode *inode;
	struct btrfs_work work;
};

struct dir_entry___2 {
	u64 ino;
	u64 offset;
	unsigned int type;
	int name_len;
};

struct btrfs_delalloc_work {
	struct inode *inode;
	struct completion completion;
	struct list_head list;
	struct btrfs_work work;
};

struct btrfs_swap_info {
	u64 start;
	u64 block_start;
	u64 block_len;
	u64 lowest_ppage;
	u64 highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

struct btrfs_ioctl_defrag_range_args {
	__u64 start;
	__u64 len;
	__u64 flags;
	__u32 extent_thresh;
	__u32 compress_type;
	__u32 unused[4];
};

struct btrfs_log_ctx {
	int log_ret;
	int log_transid;
	bool log_new_dentries;
	bool logging_new_name;
	struct inode *inode;
	struct list_head list;
	struct list_head ordered_extents;
};

struct inode_defrag {
	struct rb_node rb_node;
	u64 ino;
	u64 transid;
	u64 root;
	u64 last_offset;
	int cycled;
};

struct falloc_range {
	struct list_head list;
	u64 start;
	u64 len;
};

enum {
	RANGE_BOUNDARY_WRITTEN_EXTENT = 0,
	RANGE_BOUNDARY_PREALLOC_EXTENT = 1,
	RANGE_BOUNDARY_HOLE = 2,
};

enum btrfs_feature_set {
	FEAT_COMPAT = 0,
	FEAT_COMPAT_RO = 1,
	FEAT_INCOMPAT = 2,
	FEAT_MAX = 3,
};

struct btrfs_feature_attr {
	struct kobj_attribute kobj_attr;
	enum btrfs_feature_set feature_set;
	u64 feature_bit;
};

struct raid_kobject {
	u64 flags;
	struct kobject kobj;
};

typedef blk_status_t submit_bio_hook_t(struct inode *, struct bio *, int, long unsigned int);

struct tree_entry {
	u64 start;
	u64 end;
	struct rb_node rb_node;
};

struct extent_page_data {
	struct bio *bio;
	unsigned int extent_locked: 1;
	unsigned int sync_io: 1;
};

struct fiemap_cache {
	u64 offset;
	u64 phys;
	u64 len;
	u32 flags;
	bool cached;
};

struct btrfs_ioctl_balance_args {
	__u64 flags;
	__u64 state;
	struct btrfs_balance_args data;
	struct btrfs_balance_args meta;
	struct btrfs_balance_args sys;
	struct btrfs_balance_progress stat;
	__u64 unused[72];
};

struct btrfs_ioctl_get_dev_stats {
	__u64 devid;
	__u64 nr_items;
	__u64 flags;
	__u64 values[5];
	__u64 unused[121];
};

enum btrfs_err_code {
	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET = 1,
	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET = 2,
	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET = 3,
	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET = 4,
	BTRFS_ERROR_DEV_TGT_REPLACE = 5,
	BTRFS_ERROR_DEV_MISSING_NOT_FOUND = 6,
	BTRFS_ERROR_DEV_ONLY_WRITABLE = 7,
	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS = 8,
	BTRFS_ERROR_DEV_RAID1C3_MIN_NOT_MET = 9,
	BTRFS_ERROR_DEV_RAID1C4_MIN_NOT_MET = 10,
};

struct btrfs_disk_balance_args {
	__le64 profiles;
	union {
		__le64 usage;
		struct {
			__le32 usage_min;
			__le32 usage_max;
		};
	};
	__le64 devid;
	__le64 pstart;
	__le64 pend;
	__le64 vstart;
	__le64 vend;
	__le64 target;
	__le64 flags;
	union {
		__le64 limit;
		struct {
			__le32 limit_min;
			__le32 limit_max;
		};
	};
	__le32 stripes_min;
	__le32 stripes_max;
	__le64 unused[6];
};

struct btrfs_balance_item {
	__le64 flags;
	struct btrfs_disk_balance_args data;
	struct btrfs_disk_balance_args meta;
	struct btrfs_disk_balance_args sys;
	__le64 unused[4];
};

struct btrfs_dev_stats_item {
	__le64 values[5];
};

struct alloc_chunk_ctl {
	u64 start;
	u64 type;
	int num_stripes;
	int sub_stripes;
	int dev_stripes;
	int devs_max;
	int devs_min;
	int devs_increment;
	int ncopies;
	int nparity;
	u64 max_stripe_size;
	u64 max_chunk_size;
	u64 dev_extent_min;
	u64 stripe_size;
	u64 chunk_size;
	int ndevs;
};

struct btrfs_workqueue {
	struct __btrfs_workqueue *normal;
	struct __btrfs_workqueue *high;
};

enum {
	WORK_DONE_BIT = 0,
	WORK_ORDER_DONE_BIT = 1,
	WORK_HIGH_PRIO_BIT = 2,
};

struct btrfs_ioctl_qgroup_limit_args {
	__u64 qgroupid;
	struct btrfs_qgroup_limit lim;
};

struct btrfs_ioctl_vol_args_v2 {
	__s64 fd;
	__u64 transid;
	__u64 flags;
	union {
		struct {
			__u64 size;
			struct btrfs_qgroup_inherit *qgroup_inherit;
		};
		__u64 unused[4];
	};
	union {
		char name[4040];
		__u64 devid;
		__u64 subvolid;
	};
};

struct btrfs_ioctl_scrub_args {
	__u64 devid;
	__u64 start;
	__u64 end;
	__u64 flags;
	struct btrfs_scrub_progress progress;
	__u64 unused[109];
};

struct btrfs_ioctl_dev_replace_start_params {
	__u64 srcdevid;
	__u64 cont_reading_from_srcdev_mode;
	__u8 srcdev_name[1025];
	__u8 tgtdev_name[1025];
};

struct btrfs_ioctl_dev_replace_status_params {
	__u64 replace_state;
	__u64 progress_1000;
	__u64 time_started;
	__u64 time_stopped;
	__u64 num_write_errors;
	__u64 num_uncorrectable_read_errors;
};

struct btrfs_ioctl_dev_replace_args {
	__u64 cmd;
	__u64 result;
	union {
		struct btrfs_ioctl_dev_replace_start_params start;
		struct btrfs_ioctl_dev_replace_status_params status;
	};
	__u64 spare[64];
};

struct btrfs_ioctl_dev_info_args {
	__u64 devid;
	__u8 uuid[16];
	__u64 bytes_used;
	__u64 total_bytes;
	__u64 unused[379];
	__u8 path[1024];
};

struct btrfs_ioctl_fs_info_args {
	__u64 max_id;
	__u64 num_devices;
	__u8 fsid[16];
	__u32 nodesize;
	__u32 sectorsize;
	__u32 clone_alignment;
	__u16 csum_type;
	__u16 csum_size;
	__u64 flags;
	__u64 generation;
	__u8 metadata_uuid[16];
	__u8 reserved[944];
};

struct btrfs_ioctl_feature_flags {
	__u64 compat_flags;
	__u64 compat_ro_flags;
	__u64 incompat_flags;
};

struct btrfs_ioctl_ino_lookup_args {
	__u64 treeid;
	__u64 objectid;
	char name[4080];
};

struct btrfs_ioctl_ino_lookup_user_args {
	__u64 dirid;
	__u64 treeid;
	char name[256];
	char path[3824];
};

struct btrfs_ioctl_search_key {
	__u64 tree_id;
	__u64 min_objectid;
	__u64 max_objectid;
	__u64 min_offset;
	__u64 max_offset;
	__u64 min_transid;
	__u64 max_transid;
	__u32 min_type;
	__u32 max_type;
	__u32 nr_items;
	__u32 unused;
	__u64 unused1;
	__u64 unused2;
	__u64 unused3;
	__u64 unused4;
};

struct btrfs_ioctl_search_header {
	__u64 transid;
	__u64 objectid;
	__u64 offset;
	__u32 type;
	__u32 len;
};

struct btrfs_ioctl_search_args {
	struct btrfs_ioctl_search_key key;
	char buf[3992];
};

struct btrfs_ioctl_search_args_v2 {
	struct btrfs_ioctl_search_key key;
	__u64 buf_size;
	__u64 buf[0];
};

struct btrfs_ioctl_space_info {
	__u64 flags;
	__u64 total_bytes;
	__u64 used_bytes;
};

struct btrfs_ioctl_space_args {
	__u64 space_slots;
	__u64 total_spaces;
	struct btrfs_ioctl_space_info spaces[0];
};

struct btrfs_data_container {
	__u32 bytes_left;
	__u32 bytes_missing;
	__u32 elem_cnt;
	__u32 elem_missed;
	__u64 val[0];
};

struct btrfs_ioctl_ino_path_args {
	__u64 inum;
	__u64 size;
	__u64 reserved[4];
	__u64 fspath;
};

struct btrfs_ioctl_logical_ino_args {
	__u64 logical;
	__u64 size;
	__u64 reserved[3];
	__u64 flags;
	__u64 inodes;
};

struct btrfs_ioctl_quota_ctl_args {
	__u64 cmd;
	__u64 status;
};

struct btrfs_ioctl_quota_rescan_args {
	__u64 flags;
	__u64 progress;
	__u64 reserved[6];
};

struct btrfs_ioctl_qgroup_assign_args {
	__u64 assign;
	__u64 src;
	__u64 dst;
};

struct btrfs_ioctl_qgroup_create_args {
	__u64 create;
	__u64 qgroupid;
};

struct btrfs_ioctl_timespec {
	__u64 sec;
	__u32 nsec;
};

struct btrfs_ioctl_received_subvol_args {
	char uuid[16];
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec stime;
	struct btrfs_ioctl_timespec rtime;
	__u64 flags;
	__u64 reserved[16];
};

struct btrfs_ioctl_send_args {
	__s64 send_fd;
	__u64 clone_sources_count;
	__u64 *clone_sources;
	__u64 parent_root;
	__u64 flags;
	__u64 reserved[4];
};

struct btrfs_ioctl_get_subvol_info_args {
	__u64 treeid;
	char name[256];
	__u64 parent_id;
	__u64 dirid;
	__u64 generation;
	__u64 flags;
	__u8 uuid[16];
	__u8 parent_uuid[16];
	__u8 received_uuid[16];
	__u64 ctransid;
	__u64 otransid;
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec ctime;
	struct btrfs_ioctl_timespec otime;
	struct btrfs_ioctl_timespec stime;
	struct btrfs_ioctl_timespec rtime;
	__u64 reserved[8];
};

struct btrfs_ioctl_get_subvol_rootref_args {
	__u64 min_treeid;
	struct {
		__u64 treeid;
		__u64 dirid;
	} rootref[255];
	__u8 num_items;
	__u8 align[7];
};

struct inode_fs_paths {
	struct btrfs_path *btrfs_path;
	struct btrfs_root *fs_root;
	struct btrfs_data_container *fspath;
};

struct btrfs_ioctl_timespec_32 {
	__u64 sec;
	__u32 nsec;
} __attribute__((packed));

struct btrfs_ioctl_received_subvol_args_32 {
	char uuid[16];
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec_32 stime;
	struct btrfs_ioctl_timespec_32 rtime;
	__u64 flags;
	__u64 reserved[16];
} __attribute__((packed));

struct btrfs_ioctl_send_args_32 {
	__s64 send_fd;
	__u64 clone_sources_count;
	compat_uptr_t clone_sources;
	__u64 parent_root;
	__u64 flags;
	__u64 reserved[4];
} __attribute__((packed));

struct btrfs_trans_handle___2;

struct btrfs_fid {
	u64 objectid;
	u64 root_objectid;
	u32 gen;
	u64 parent_objectid;
	u32 parent_gen;
	u64 parent_root_objectid;
} __attribute__((packed));

struct btrfs_dir_log_item {
	__le64 end;
};

enum {
	LOG_INODE_ALL = 0,
	LOG_INODE_EXISTS = 1,
	LOG_OTHER_INODE = 2,
	LOG_OTHER_INODE_ALL = 3,
};

enum {
	LOG_WALK_PIN_ONLY = 0,
	LOG_WALK_REPLAY_INODES = 1,
	LOG_WALK_REPLAY_DIR_INDEX = 2,
	LOG_WALK_REPLAY_ALL = 3,
};

struct walk_control___2 {
	int free;
	int write;
	int wait;
	int pin;
	int stage;
	bool ignore_cur_inode;
	struct btrfs_root *replay_dest;
	struct btrfs_trans_handle *trans;
	int (*process_func)(struct btrfs_root *, struct extent_buffer *, struct walk_control___2 *, u64, int);
};

struct btrfs_ino_list {
	u64 ino;
	u64 parent;
	struct list_head list;
};

struct btrfs_dir_list {
	u64 ino;
	struct list_head list;
};

struct btrfs_free_space_entry {
	__le64 offset;
	__le64 bytes;
	__u8 type;
} __attribute__((packed));

struct btrfs_free_space_header {
	struct btrfs_disk_key location;
	__le64 generation;
	__le64 num_entries;
	__le64 num_bitmaps;
} __attribute__((packed));

struct btrfs_trim_range {
	u64 start;
	u64 bytes;
	struct list_head list;
};

struct compressed_bio {
	refcount_t pending_bios;
	struct page **compressed_pages;
	struct inode *inode;
	u64 start;
	long unsigned int len;
	long unsigned int compressed_len;
	int compress_type;
	long unsigned int nr_pages;
	int errors;
	int mirror_num;
	struct bio *orig_bio;
	u8 sums[0];
};

struct workspace_manager {
	struct list_head idle_ws;
	spinlock_t ws_lock;
	int free_ws;
	atomic_t total_ws;
	wait_queue_head_t ws_wait;
};

struct btrfs_compress_op {
	struct workspace_manager *workspace_manager;
	unsigned int max_level;
	unsigned int default_level;
};

struct workspace {
	z_stream strm;
	char *buf;
	unsigned int buf_size;
	struct list_head list;
	int level;
};

struct workspace___2 {
	void *mem;
	void *buf;
	void *cbuf;
	struct list_head list;
};

typedef enum {
	ZSTD_fast = 0,
	ZSTD_dfast = 1,
	ZSTD_greedy = 2,
	ZSTD_lazy = 3,
	ZSTD_lazy2 = 4,
	ZSTD_btlazy2 = 5,
	ZSTD_btopt = 6,
	ZSTD_btopt2 = 7,
} ZSTD_strategy;

typedef struct {
	unsigned int windowLog;
	unsigned int chainLog;
	unsigned int hashLog;
	unsigned int searchLog;
	unsigned int searchLength;
	unsigned int targetLength;
	ZSTD_strategy strategy;
} ZSTD_compressionParameters;

typedef struct {
	unsigned int contentSizeFlag;
	unsigned int checksumFlag;
	unsigned int noDictIDFlag;
} ZSTD_frameParameters;

typedef struct {
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
} ZSTD_parameters;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

struct ZSTD_CStream_s;

typedef struct ZSTD_CStream_s ZSTD_CStream;

struct ZSTD_DStream_s;

typedef struct ZSTD_DStream_s ZSTD_DStream;

struct workspace___3 {
	void *mem;
	size_t size;
	char *buf;
	unsigned int level;
	unsigned int req_level;
	long unsigned int last_used;
	struct list_head list;
	struct list_head lru_list;
	ZSTD_inBuffer in_buf;
	ZSTD_outBuffer out_buf;
};

struct zstd_workspace_manager {
	const struct btrfs_compress_op *ops;
	spinlock_t lock;
	struct list_head lru_list;
	struct list_head idle_ws[15];
	long unsigned int active_map;
	wait_queue_head_t wait;
	struct timer_list timer;
};

struct bucket_item {
	u32 count;
};

struct heuristic_ws {
	u8 *sample;
	u32 sample_size;
	struct bucket_item *bucket;
	struct bucket_item *bucket_b;
	struct list_head list;
};

struct ulist_iterator {
	struct list_head *cur_list;
};

struct ulist_node {
	u64 val;
	u64 aux;
	struct list_head list;
	struct rb_node rb_node;
};

struct btrfs_backref_node;

struct btrfs_backref_cache {
	struct rb_root rb_root;
	struct btrfs_backref_node *path[8];
	struct list_head pending[8];
	struct list_head leaves;
	struct list_head changed;
	struct list_head detached;
	u64 last_trans;
	int nr_nodes;
	int nr_edges;
	struct list_head pending_edge;
	struct list_head useless_node;
	struct btrfs_fs_info *fs_info;
	unsigned int is_reloc;
};

struct file_extent_cluster {
	u64 start;
	u64 end;
	u64 boundary[128];
	unsigned int nr;
};

struct mapping_tree {
	struct rb_root rb_root;
	spinlock_t lock;
};

struct reloc_control {
	struct btrfs_block_group *block_group;
	struct btrfs_root *extent_root;
	struct inode *data_inode;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_backref_cache backref_cache;
	struct file_extent_cluster cluster;
	struct extent_io_tree processed_blocks;
	struct mapping_tree reloc_root_tree;
	struct list_head reloc_roots;
	struct list_head dirty_subvol_roots;
	u64 merging_rsv_size;
	u64 nodes_relocated;
	u64 reserved_bytes;
	u64 search_start;
	u64 extents_found;
	unsigned int stage: 8;
	unsigned int create_reloc_tree: 1;
	unsigned int merge_reloc_tree: 1;
	unsigned int found_file_extent: 1;
};

struct btrfs_backref_iter {
	u64 bytenr;
	struct btrfs_path *path;
	struct btrfs_fs_info *fs_info;
	struct btrfs_key cur_key;
	u32 item_ptr;
	u32 cur_ptr;
	u32 end_ptr;
};

struct btrfs_backref_node {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	u64 new_bytenr;
	u64 owner;
	struct list_head list;
	struct list_head upper;
	struct list_head lower;
	struct btrfs_root *root;
	struct extent_buffer *eb;
	unsigned int level: 8;
	unsigned int cowonly: 1;
	unsigned int lowest: 1;
	unsigned int locked: 1;
	unsigned int processed: 1;
	unsigned int checked: 1;
	unsigned int pending: 1;
	unsigned int detached: 1;
	unsigned int is_reloc_root: 1;
};

struct btrfs_backref_edge {
	struct list_head list[2];
	struct btrfs_backref_node *node[2];
};

struct rb_simple_node {
	struct rb_node rb_node;
	u64 bytenr;
};

struct mapping_node {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	void *data;
};

struct tree_block {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	struct btrfs_key key;
	unsigned int level: 8;
	unsigned int key_ready: 1;
};

struct btrfs_delayed_item {
	struct rb_node rb_node;
	struct btrfs_key key;
	struct list_head tree_list;
	struct list_head readdir_list;
	u64 bytes_reserved;
	struct btrfs_delayed_node *delayed_node;
	refcount_t refs;
	int ins_or_del;
	u32 data_len;
	char data[0];
};

struct btrfs_async_delayed_work {
	struct btrfs_delayed_root *delayed_root;
	int nr;
	struct btrfs_work work;
};

struct reada_control {
	struct btrfs_fs_info *fs_info;
	struct btrfs_key key_start;
	struct btrfs_key key_end;
	short: 16;
	atomic_t elems;
	struct kref refcnt;
	int: 32;
	wait_queue_head_t wait;
} __attribute__((packed));

struct scrub_bio;

struct scrub_ctx {
	struct scrub_bio *bios[64];
	struct btrfs_fs_info *fs_info;
	int first_free;
	int curr;
	atomic_t bios_in_flight;
	atomic_t workers_pending;
	spinlock_t list_lock;
	wait_queue_head_t list_wait;
	u16 csum_size;
	struct list_head csum_list;
	atomic_t cancel_req;
	int readonly;
	int pages_per_rd_bio;
	int is_dev_replace;
	struct scrub_bio *wr_curr_bio;
	struct mutex wr_lock;
	int pages_per_wr_bio;
	struct btrfs_device *wr_tgtdev;
	bool flush_all_writes;
	struct btrfs_scrub_progress stat;
	spinlock_t stat_lock;
	refcount_t refs;
};

struct scrub_recover {
	refcount_t refs;
	struct btrfs_bio *bbio;
	u64 map_length;
};

struct scrub_block;

struct scrub_page {
	struct scrub_block *sblock;
	struct page *page;
	struct btrfs_device *dev;
	struct list_head list;
	u64 flags;
	u64 generation;
	u64 logical;
	u64 physical;
	u64 physical_for_dev_replace;
	atomic_t refs;
	struct {
		unsigned int mirror_num: 8;
		unsigned int have_csum: 1;
		unsigned int io_error: 1;
	};
	u8 csum[32];
	struct scrub_recover *recover;
};

struct scrub_parity;

struct scrub_block {
	struct scrub_page *pagev[16];
	int page_count;
	atomic_t outstanding_pages;
	refcount_t refs;
	struct scrub_ctx *sctx;
	struct scrub_parity *sparity;
	struct {
		unsigned int header_error: 1;
		unsigned int checksum_error: 1;
		unsigned int no_io_error_seen: 1;
		unsigned int generation_error: 1;
		unsigned int data_corrected: 1;
	};
	struct btrfs_work work;
};

struct scrub_bio {
	int index;
	struct scrub_ctx *sctx;
	struct btrfs_device *dev;
	struct bio *bio;
	blk_status_t status;
	u64 logical;
	u64 physical;
	struct scrub_page *pagev[32];
	int page_count;
	int next_free;
	struct btrfs_work work;
};

struct scrub_parity {
	struct scrub_ctx *sctx;
	struct btrfs_device *scrub_dev;
	u64 logic_start;
	u64 logic_end;
	int nsectors;
	u64 stripe_len;
	refcount_t refs;
	struct list_head spages;
	struct btrfs_work work;
	long unsigned int *dbitmap;
	long unsigned int *ebitmap;
	long unsigned int bitmap[0];
};

struct scrub_warning {
	struct btrfs_path *path;
	u64 extent_item_size;
	const char *errstr;
	u64 physical;
	u64 logical;
	struct btrfs_device *dev;
};

struct full_stripe_lock {
	struct rb_node node;
	u64 logical;
	u64 refs;
	struct mutex mutex;
};

struct btrfs_raid_bio;

struct reada_zone {
	u64 start;
	u64 end;
	u64 elems;
	struct list_head list;
	spinlock_t lock;
	int locked;
	struct btrfs_device *device;
	struct btrfs_device *devs[5];
	int ndevs;
	struct kref refcnt;
};

struct reada_extctl {
	struct list_head list;
	struct reada_control *rc;
	u64 generation;
};

struct reada_extent {
	u64 logical;
	struct btrfs_key top;
	struct list_head extctl;
	int refcnt;
	spinlock_t lock;
	struct reada_zone *zones[5];
	int nzones;
	int scheduled;
};

struct reada_machine_work {
	struct btrfs_work work;
	struct btrfs_fs_info *fs_info;
};

typedef int iterate_extent_inodes_t(u64, u64, u64, void *);

struct extent_inode_elem {
	u64 inum;
	u64 offset;
	struct extent_inode_elem *next;
};

struct preftree {
	struct rb_root_cached root;
	unsigned int count;
};

struct preftrees {
	struct preftree direct;
	struct preftree indirect;
	struct preftree indirect_missing_keys;
};

struct share_check {
	u64 root_objectid;
	u64 inum;
	int share_count;
};

typedef int iterate_irefs_t(u64, u32, long unsigned int, struct extent_buffer *, void *);

struct btrfs_qgroup_status_item {
	__le64 version;
	__le64 generation;
	__le64 flags;
	__le64 rescan;
};

struct btrfs_qgroup_info_item {
	__le64 generation;
	__le64 rfer;
	__le64 rfer_cmpr;
	__le64 excl;
	__le64 excl_cmpr;
};

struct btrfs_qgroup_limit_item {
	__le64 flags;
	__le64 max_rfer;
	__le64 max_excl;
	__le64 rsv_rfer;
	__le64 rsv_excl;
};

struct btrfs_qgroup_swapped_block {
	struct rb_node node;
	int level;
	bool trace_leaf;
	u64 subvol_bytenr;
	u64 subvol_generation;
	u64 reloc_bytenr;
	u64 reloc_generation;
	u64 last_snapshot;
	struct btrfs_key first_key;
};

struct btrfs_qgroup_list {
	struct list_head next_group;
	struct list_head next_member;
	struct btrfs_qgroup *group;
	struct btrfs_qgroup *member;
};

struct btrfs_stream_header {
	char magic[13];
	__le32 version;
} __attribute__((packed));

struct btrfs_cmd_header {
	__le32 len;
	__le16 cmd;
	__le32 crc;
} __attribute__((packed));

struct btrfs_tlv_header {
	__le16 tlv_type;
	__le16 tlv_len;
};

enum btrfs_send_cmd {
	BTRFS_SEND_C_UNSPEC = 0,
	BTRFS_SEND_C_SUBVOL = 1,
	BTRFS_SEND_C_SNAPSHOT = 2,
	BTRFS_SEND_C_MKFILE = 3,
	BTRFS_SEND_C_MKDIR = 4,
	BTRFS_SEND_C_MKNOD = 5,
	BTRFS_SEND_C_MKFIFO = 6,
	BTRFS_SEND_C_MKSOCK = 7,
	BTRFS_SEND_C_SYMLINK = 8,
	BTRFS_SEND_C_RENAME = 9,
	BTRFS_SEND_C_LINK = 10,
	BTRFS_SEND_C_UNLINK = 11,
	BTRFS_SEND_C_RMDIR = 12,
	BTRFS_SEND_C_SET_XATTR = 13,
	BTRFS_SEND_C_REMOVE_XATTR = 14,
	BTRFS_SEND_C_WRITE = 15,
	BTRFS_SEND_C_CLONE = 16,
	BTRFS_SEND_C_TRUNCATE = 17,
	BTRFS_SEND_C_CHMOD = 18,
	BTRFS_SEND_C_CHOWN = 19,
	BTRFS_SEND_C_UTIMES = 20,
	BTRFS_SEND_C_END = 21,
	BTRFS_SEND_C_UPDATE_EXTENT = 22,
	__BTRFS_SEND_C_MAX = 23,
};

enum {
	BTRFS_SEND_A_UNSPEC = 0,
	BTRFS_SEND_A_UUID = 1,
	BTRFS_SEND_A_CTRANSID = 2,
	BTRFS_SEND_A_INO = 3,
	BTRFS_SEND_A_SIZE = 4,
	BTRFS_SEND_A_MODE = 5,
	BTRFS_SEND_A_UID = 6,
	BTRFS_SEND_A_GID = 7,
	BTRFS_SEND_A_RDEV = 8,
	BTRFS_SEND_A_CTIME = 9,
	BTRFS_SEND_A_MTIME = 10,
	BTRFS_SEND_A_ATIME = 11,
	BTRFS_SEND_A_OTIME = 12,
	BTRFS_SEND_A_XATTR_NAME = 13,
	BTRFS_SEND_A_XATTR_DATA = 14,
	BTRFS_SEND_A_PATH = 15,
	BTRFS_SEND_A_PATH_TO = 16,
	BTRFS_SEND_A_PATH_LINK = 17,
	BTRFS_SEND_A_FILE_OFFSET = 18,
	BTRFS_SEND_A_DATA = 19,
	BTRFS_SEND_A_CLONE_UUID = 20,
	BTRFS_SEND_A_CLONE_CTRANSID = 21,
	BTRFS_SEND_A_CLONE_PATH = 22,
	BTRFS_SEND_A_CLONE_OFFSET = 23,
	BTRFS_SEND_A_CLONE_LEN = 24,
	__BTRFS_SEND_A_MAX = 25,
};

struct fs_path {
	union {
		struct {
			char *start;
			char *end;
			char *buf;
			short unsigned int buf_len: 15;
			short unsigned int reversed: 1;
			char inline_buf[0];
		};
		char pad[256];
	};
};

struct clone_root {
	struct btrfs_root *root;
	u64 ino;
	u64 offset;
	u64 found_refs;
};

struct send_ctx {
	struct file *send_filp;
	loff_t send_off;
	char *send_buf;
	u32 send_size;
	u32 send_max_size;
	u64 total_send_size;
	u64 cmd_send_size[23];
	u64 flags;
	struct btrfs_root *send_root;
	struct btrfs_root *parent_root;
	struct clone_root *clone_roots;
	int clone_roots_cnt;
	struct btrfs_path *left_path;
	struct btrfs_path *right_path;
	struct btrfs_key *cmp_key;
	u64 cur_ino;
	u64 cur_inode_gen;
	int cur_inode_new;
	int cur_inode_new_gen;
	int cur_inode_deleted;
	u64 cur_inode_size;
	u64 cur_inode_mode;
	u64 cur_inode_rdev;
	u64 cur_inode_last_extent;
	u64 cur_inode_next_write_offset;
	bool ignore_cur_inode;
	u64 send_progress;
	struct list_head new_refs;
	struct list_head deleted_refs;
	struct xarray name_cache;
	struct list_head name_cache_list;
	int name_cache_size;
	struct file_ra_state ra;
	struct rb_root pending_dir_moves;
	struct rb_root waiting_dir_moves;
	struct rb_root orphan_dirs;
};

struct pending_dir_move {
	struct rb_node node;
	struct list_head list;
	u64 parent_ino;
	u64 ino;
	u64 gen;
	struct list_head update_refs;
};

struct waiting_dir_move {
	struct rb_node node;
	u64 ino;
	u64 rmdir_ino;
	bool orphanized;
};

struct orphan_dir_info {
	struct rb_node node;
	u64 ino;
	u64 gen;
	u64 last_dir_index_offset;
};

struct name_cache_entry {
	struct list_head list;
	struct list_head radix_list;
	u64 ino;
	u64 gen;
	u64 parent_ino;
	u64 parent_gen;
	int ret;
	int need_later_update;
	int name_len;
	char name[0];
};

enum btrfs_compare_tree_result {
	BTRFS_COMPARE_TREE_NEW = 0,
	BTRFS_COMPARE_TREE_DELETED = 1,
	BTRFS_COMPARE_TREE_CHANGED = 2,
	BTRFS_COMPARE_TREE_SAME = 3,
};

typedef int (*iterate_inode_ref_t)(int, u64, int, struct fs_path *, void *);

typedef int (*iterate_dir_item_t)(int, struct btrfs_key *, const char *, int, const char *, int, u8, void *);

struct backref_ctx {
	struct send_ctx *sctx;
	u64 found;
	u64 cur_objectid;
	u64 cur_offset;
	u64 extent_len;
	u64 data_offset;
	int found_itself;
};

enum inode_state {
	inode_state_no_change = 0,
	inode_state_will_create = 1,
	inode_state_did_create = 2,
	inode_state_will_delete = 3,
	inode_state_did_delete = 4,
};

struct recorded_ref {
	struct list_head list;
	char *name;
	struct fs_path *full_path;
	u64 dir;
	u64 dir_gen;
	int name_len;
};

struct find_ref_ctx {
	u64 dir;
	u64 dir_gen;
	struct btrfs_root *root;
	struct fs_path *name;
	int found_idx;
};

struct find_xattr_ctx {
	const char *name;
	int name_len;
	int found_idx;
	char *found_data;
	int found_data_len;
};

struct parent_paths_ctx {
	struct list_head *refs;
	struct send_ctx *sctx;
};

struct btrfs_dev_replace_item {
	__le64 src_devid;
	__le64 cursor_left;
	__le64 cursor_right;
	__le64 cont_reading_from_srcdev_mode;
	__le64 replace_state;
	__le64 time_started;
	__le64 time_stopped;
	__le64 num_write_errors;
	__le64 num_uncorrectable_read_errors;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

struct raid6_calls {
	void (*gen_syndrome)(int, size_t, void **);
	void (*xor_syndrome)(int, int, int, size_t, void **);
	int (*valid)();
	const char *name;
	int prefer;
};

struct btrfs_stripe_hash {
	struct list_head hash_list;
	spinlock_t lock;
};

struct btrfs_stripe_hash_table {
	struct list_head stripe_cache;
	spinlock_t cache_lock;
	int cache_size;
	struct btrfs_stripe_hash table[0];
};

enum btrfs_rbio_ops {
	BTRFS_RBIO_WRITE = 0,
	BTRFS_RBIO_READ_REBUILD = 1,
	BTRFS_RBIO_PARITY_SCRUB = 2,
	BTRFS_RBIO_REBUILD_MISSING = 3,
};

struct btrfs_raid_bio___2 {
	struct btrfs_fs_info *fs_info;
	struct btrfs_bio *bbio;
	struct list_head hash_list;
	struct list_head stripe_cache;
	struct btrfs_work work;
	struct bio_list bio_list;
	spinlock_t bio_list_lock;
	struct list_head plug_list;
	long unsigned int flags;
	int stripe_len;
	int nr_data;
	int real_stripes;
	int stripe_npages;
	enum btrfs_rbio_ops operation;
	int faila;
	int failb;
	int scrubp;
	int nr_pages;
	int bio_list_bytes;
	int generic_bio_cnt;
	refcount_t refs;
	atomic_t stripes_pending;
	atomic_t error;
	struct page **stripe_pages;
	struct page **bio_pages;
	long unsigned int *dbitmap;
	void **finish_pointers;
	long unsigned int *finish_pbitmap;
};

struct btrfs_plug_cb {
	struct blk_plug_cb cb;
	struct btrfs_fs_info *info;
	struct list_head rbio_list;
	struct btrfs_work work;
};

struct prop_handler {
	struct hlist_node node;
	const char *xattr_name;
	int (*validate)(const char *, size_t);
	int (*apply)(struct inode *, const char *, size_t);
	const char * (*extract)(struct inode *);
	int inheritable;
};

struct btrfs_free_space_info {
	__le32 extent_count;
	__le32 flags;
};

struct reserve_ticket {
	u64 bytes;
	int error;
	bool steal;
	struct list_head list;
	wait_queue_head_t wait;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

typedef s32 compat_key_t;

typedef u32 __compat_gid32_t;

struct compat_ipc64_perm {
	compat_key_t key;
	__compat_uid32_t uid;
	__compat_gid32_t gid;
	__compat_uid32_t cuid;
	__compat_gid32_t cgid;
	short unsigned int mode;
	short unsigned int __pad1;
	short unsigned int seq;
	short unsigned int __pad2;
	compat_ulong_t unused1;
	compat_ulong_t unused2;
};

struct compat_ipc_perm {
	key_t key;
	__compat_uid_t uid;
	__compat_gid_t gid;
	__compat_uid_t cuid;
	__compat_gid_t cgid;
	compat_mode_t mode;
	short unsigned int seq;
};

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef int __kernel_ipc_pid_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long int msg_stime;
	long int msg_rtime;
	long int msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

typedef u16 compat_ipc_pid_t;

struct compat_msqid64_ds {
	struct compat_ipc64_perm msg_perm;
	compat_ulong_t msg_stime;
	compat_ulong_t msg_stime_high;
	compat_ulong_t msg_rtime;
	compat_ulong_t msg_rtime_high;
	compat_ulong_t msg_ctime;
	compat_ulong_t msg_ctime_high;
	compat_ulong_t msg_cbytes;
	compat_ulong_t msg_qnum;
	compat_ulong_t msg_qbytes;
	compat_pid_t msg_lspid;
	compat_pid_t msg_lrpid;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct compat_msqid_ds {
	struct compat_ipc_perm msg_perm;
	compat_uptr_t msg_first;
	compat_uptr_t msg_last;
	old_time32_t msg_stime;
	old_time32_t msg_rtime;
	old_time32_t msg_ctime;
	compat_ulong_t msg_lcbytes;
	compat_ulong_t msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	compat_ipc_pid_t msg_lspid;
	compat_ipc_pid_t msg_lrpid;
};

struct compat_msgbuf {
	compat_long_t mtype;
	char mtext[1];
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	__kernel_long_t sem_otime;
	__kernel_ulong_t __unused1;
	__kernel_long_t sem_ctime;
	__kernel_ulong_t __unused2;
	__kernel_ulong_t sem_nsems;
	__kernel_ulong_t __unused3;
	__kernel_ulong_t __unused4;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct compat_semid64_ds {
	struct compat_ipc64_perm sem_perm;
	compat_ulong_t sem_otime;
	compat_ulong_t sem_otime_high;
	compat_ulong_t sem_ctime;
	compat_ulong_t sem_ctime_high;
	compat_ulong_t sem_nsems;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct compat_semid_ds {
	struct compat_ipc_perm sem_perm;
	old_time32_t sem_otime;
	old_time32_t sem_ctime;
	compat_uptr_t sem_base;
	compat_uptr_t sem_pending;
	compat_uptr_t sem_pending_last;
	compat_uptr_t undo;
	short unsigned int sem_nsems;
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	size_t shm_segsz;
	long int shm_atime;
	long int shm_dtime;
	long int shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct compat_shmid64_ds {
	struct compat_ipc64_perm shm_perm;
	compat_size_t shm_segsz;
	compat_ulong_t shm_atime;
	compat_ulong_t shm_atime_high;
	compat_ulong_t shm_dtime;
	compat_ulong_t shm_dtime_high;
	compat_ulong_t shm_ctime;
	compat_ulong_t shm_ctime_high;
	compat_pid_t shm_cpid;
	compat_pid_t shm_lpid;
	compat_ulong_t shm_nattch;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct user_struct *mlock_user;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

struct compat_shmid_ds {
	struct compat_ipc_perm shm_perm;
	int shm_segsz;
	old_time32_t shm_atime;
	old_time32_t shm_dtime;
	old_time32_t shm_ctime;
	compat_ipc_pid_t shm_cpid;
	compat_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	compat_uptr_t shm_unused2;
	compat_uptr_t shm_unused3;
};

struct compat_shminfo64 {
	compat_ulong_t shmmax;
	compat_ulong_t shmmin;
	compat_ulong_t shmmni;
	compat_ulong_t shmseg;
	compat_ulong_t shmall;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct compat_shm_info {
	compat_int_t used_ids;
	compat_ulong_t shm_tot;
	compat_ulong_t shm_rss;
	compat_ulong_t shm_swp;
	compat_ulong_t swap_attempts;
	compat_ulong_t swap_successes;
};

struct compat_ipc_kludge {
	compat_uptr_t msgp;
	compat_long_t msgtyp;
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct user_struct *user;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

struct compat_mq_attr {
	compat_long_t mq_flags;
	compat_long_t mq_maxmsg;
	compat_long_t mq_msgsize;
	compat_long_t mq_curmsgs;
	compat_long_t __reserved[4];
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

struct assoc_array_edit;

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit___2 {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 48;
	char data[0];
};

enum {
	Opt_err___8 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct sctp_endpoint;

union security_list_options {
	int (*binder_set_context_mgr)(struct task_struct *);
	int (*binder_transaction)(struct task_struct *, struct task_struct *);
	int (*binder_transfer_binder)(struct task_struct *, struct task_struct *);
	int (*binder_transfer_file)(struct task_struct *, struct task_struct *, struct file *);
	int (*ptrace_access_check)(struct task_struct *, unsigned int);
	int (*ptrace_traceme)(struct task_struct *);
	int (*capget)(struct task_struct *, kernel_cap_t *, kernel_cap_t *, kernel_cap_t *);
	int (*capset)(struct cred *, const struct cred *, const kernel_cap_t *, const kernel_cap_t *, const kernel_cap_t *);
	int (*capable)(const struct cred *, struct user_namespace *, int, unsigned int);
	int (*quotactl)(int, int, int, struct super_block *);
	int (*quota_on)(struct dentry *);
	int (*syslog)(int);
	int (*settime)(const struct timespec64 *, const struct timezone *);
	int (*vm_enough_memory)(struct mm_struct *, long int);
	int (*bprm_creds_for_exec)(struct linux_binprm *);
	int (*bprm_creds_from_file)(struct linux_binprm *, struct file *);
	int (*bprm_check_security)(struct linux_binprm *);
	void (*bprm_committing_creds)(struct linux_binprm *);
	void (*bprm_committed_creds)(struct linux_binprm *);
	int (*fs_context_dup)(struct fs_context *, struct fs_context *);
	int (*fs_context_parse_param)(struct fs_context *, struct fs_parameter *);
	int (*sb_alloc_security)(struct super_block *);
	void (*sb_free_security)(struct super_block *);
	void (*sb_free_mnt_opts)(void *);
	int (*sb_eat_lsm_opts)(char *, void **);
	int (*sb_remount)(struct super_block *, void *);
	int (*sb_kern_mount)(struct super_block *);
	int (*sb_show_options)(struct seq_file *, struct super_block *);
	int (*sb_statfs)(struct dentry *);
	int (*sb_mount)(const char *, const struct path *, const char *, long unsigned int, void *);
	int (*sb_umount)(struct vfsmount *, int);
	int (*sb_pivotroot)(const struct path *, const struct path *);
	int (*sb_set_mnt_opts)(struct super_block *, void *, long unsigned int, long unsigned int *);
	int (*sb_clone_mnt_opts)(const struct super_block *, struct super_block *, long unsigned int, long unsigned int *);
	int (*sb_add_mnt_opt)(const char *, const char *, int, void **);
	int (*move_mount)(const struct path *, const struct path *);
	int (*dentry_init_security)(struct dentry *, int, const struct qstr *, void **, u32 *);
	int (*dentry_create_files_as)(struct dentry *, int, struct qstr *, const struct cred *, struct cred *);
	int (*path_notify)(const struct path *, u64, unsigned int);
	int (*inode_alloc_security)(struct inode *);
	void (*inode_free_security)(struct inode *);
	int (*inode_init_security)(struct inode *, struct inode *, const struct qstr *, const char **, void **, size_t *);
	int (*inode_create)(struct inode *, struct dentry *, umode_t);
	int (*inode_link)(struct dentry *, struct inode *, struct dentry *);
	int (*inode_unlink)(struct inode *, struct dentry *);
	int (*inode_symlink)(struct inode *, struct dentry *, const char *);
	int (*inode_mkdir)(struct inode *, struct dentry *, umode_t);
	int (*inode_rmdir)(struct inode *, struct dentry *);
	int (*inode_mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*inode_rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
	int (*inode_readlink)(struct dentry *);
	int (*inode_follow_link)(struct dentry *, struct inode *, bool);
	int (*inode_permission)(struct inode *, int);
	int (*inode_setattr)(struct dentry *, struct iattr *);
	int (*inode_getattr)(const struct path *);
	int (*inode_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	void (*inode_post_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	int (*inode_getxattr)(struct dentry *, const char *);
	int (*inode_listxattr)(struct dentry *);
	int (*inode_removexattr)(struct dentry *, const char *);
	int (*inode_need_killpriv)(struct dentry *);
	int (*inode_killpriv)(struct dentry *);
	int (*inode_getsecurity)(struct inode *, const char *, void **, bool);
	int (*inode_setsecurity)(struct inode *, const char *, const void *, size_t, int);
	int (*inode_listsecurity)(struct inode *, char *, size_t);
	void (*inode_getsecid)(struct inode *, u32 *);
	int (*inode_copy_up)(struct dentry *, struct cred **);
	int (*inode_copy_up_xattr)(const char *);
	int (*kernfs_init_security)(struct kernfs_node *, struct kernfs_node *);
	int (*file_permission)(struct file *, int);
	int (*file_alloc_security)(struct file *);
	void (*file_free_security)(struct file *);
	int (*file_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap_addr)(long unsigned int);
	int (*mmap_file)(struct file *, long unsigned int, long unsigned int, long unsigned int);
	int (*file_mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int);
	int (*file_lock)(struct file *, unsigned int);
	int (*file_fcntl)(struct file *, unsigned int, long unsigned int);
	void (*file_set_fowner)(struct file *);
	int (*file_send_sigiotask)(struct task_struct *, struct fown_struct *, int);
	int (*file_receive)(struct file *);
	int (*file_open)(struct file *);
	int (*task_alloc)(struct task_struct *, long unsigned int);
	void (*task_free)(struct task_struct *);
	int (*cred_alloc_blank)(struct cred *, gfp_t);
	void (*cred_free)(struct cred *);
	int (*cred_prepare)(struct cred *, const struct cred *, gfp_t);
	void (*cred_transfer)(struct cred *, const struct cred *);
	void (*cred_getsecid)(const struct cred *, u32 *);
	int (*kernel_act_as)(struct cred *, u32);
	int (*kernel_create_files_as)(struct cred *, struct inode *);
	int (*kernel_module_request)(char *);
	int (*kernel_load_data)(enum kernel_load_data_id, bool);
	int (*kernel_post_load_data)(char *, loff_t, enum kernel_load_data_id, char *);
	int (*kernel_read_file)(struct file *, enum kernel_read_file_id, bool);
	int (*kernel_post_read_file)(struct file *, char *, loff_t, enum kernel_read_file_id);
	int (*task_fix_setuid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgid)(struct cred *, const struct cred *, int);
	int (*task_setpgid)(struct task_struct *, pid_t);
	int (*task_getpgid)(struct task_struct *);
	int (*task_getsid)(struct task_struct *);
	void (*task_getsecid)(struct task_struct *, u32 *);
	int (*task_setnice)(struct task_struct *, int);
	int (*task_setioprio)(struct task_struct *, int);
	int (*task_getioprio)(struct task_struct *);
	int (*task_prlimit)(const struct cred *, const struct cred *, unsigned int);
	int (*task_setrlimit)(struct task_struct *, unsigned int, struct rlimit *);
	int (*task_setscheduler)(struct task_struct *);
	int (*task_getscheduler)(struct task_struct *);
	int (*task_movememory)(struct task_struct *);
	int (*task_kill)(struct task_struct *, struct kernel_siginfo *, int, const struct cred *);
	int (*task_prctl)(int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	void (*task_to_inode)(struct task_struct *, struct inode *);
	int (*ipc_permission)(struct kern_ipc_perm *, short int);
	void (*ipc_getsecid)(struct kern_ipc_perm *, u32 *);
	int (*msg_msg_alloc_security)(struct msg_msg *);
	void (*msg_msg_free_security)(struct msg_msg *);
	int (*msg_queue_alloc_security)(struct kern_ipc_perm *);
	void (*msg_queue_free_security)(struct kern_ipc_perm *);
	int (*msg_queue_associate)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgctl)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgsnd)(struct kern_ipc_perm *, struct msg_msg *, int);
	int (*msg_queue_msgrcv)(struct kern_ipc_perm *, struct msg_msg *, struct task_struct *, long int, int);
	int (*shm_alloc_security)(struct kern_ipc_perm *);
	void (*shm_free_security)(struct kern_ipc_perm *);
	int (*shm_associate)(struct kern_ipc_perm *, int);
	int (*shm_shmctl)(struct kern_ipc_perm *, int);
	int (*shm_shmat)(struct kern_ipc_perm *, char *, int);
	int (*sem_alloc_security)(struct kern_ipc_perm *);
	void (*sem_free_security)(struct kern_ipc_perm *);
	int (*sem_associate)(struct kern_ipc_perm *, int);
	int (*sem_semctl)(struct kern_ipc_perm *, int);
	int (*sem_semop)(struct kern_ipc_perm *, struct sembuf *, unsigned int, int);
	int (*netlink_send)(struct sock *, struct sk_buff *);
	void (*d_instantiate)(struct dentry *, struct inode *);
	int (*getprocattr)(struct task_struct *, char *, char **);
	int (*setprocattr)(const char *, void *, size_t);
	int (*ismaclabel)(const char *);
	int (*secid_to_secctx)(u32, char **, u32 *);
	int (*secctx_to_secid)(const char *, u32, u32 *);
	void (*release_secctx)(char *, u32);
	void (*inode_invalidate_secctx)(struct inode *);
	int (*inode_notifysecctx)(struct inode *, void *, u32);
	int (*inode_setsecctx)(struct dentry *, void *, u32);
	int (*inode_getsecctx)(struct inode *, void **, u32 *);
	int (*unix_stream_connect)(struct sock *, struct sock *, struct sock *);
	int (*unix_may_send)(struct socket *, struct socket *);
	int (*socket_create)(int, int, int, int);
	int (*socket_post_create)(struct socket *, int, int, int, int);
	int (*socket_socketpair)(struct socket *, struct socket *);
	int (*socket_bind)(struct socket *, struct sockaddr *, int);
	int (*socket_connect)(struct socket *, struct sockaddr *, int);
	int (*socket_listen)(struct socket *, int);
	int (*socket_accept)(struct socket *, struct socket *);
	int (*socket_sendmsg)(struct socket *, struct msghdr *, int);
	int (*socket_recvmsg)(struct socket *, struct msghdr *, int, int);
	int (*socket_getsockname)(struct socket *);
	int (*socket_getpeername)(struct socket *);
	int (*socket_getsockopt)(struct socket *, int, int);
	int (*socket_setsockopt)(struct socket *, int, int);
	int (*socket_shutdown)(struct socket *, int);
	int (*socket_sock_rcv_skb)(struct sock *, struct sk_buff *);
	int (*socket_getpeersec_stream)(struct socket *, char *, int *, unsigned int);
	int (*socket_getpeersec_dgram)(struct socket *, struct sk_buff *, u32 *);
	int (*sk_alloc_security)(struct sock *, int, gfp_t);
	void (*sk_free_security)(struct sock *);
	void (*sk_clone_security)(const struct sock *, struct sock *);
	void (*sk_getsecid)(struct sock *, u32 *);
	void (*sock_graft)(struct sock *, struct socket *);
	int (*inet_conn_request)(struct sock *, struct sk_buff *, struct request_sock *);
	void (*inet_csk_clone)(struct sock *, const struct request_sock *);
	void (*inet_conn_established)(struct sock *, struct sk_buff *);
	int (*secmark_relabel_packet)(u32);
	void (*secmark_refcount_inc)();
	void (*secmark_refcount_dec)();
	void (*req_classify_flow)(const struct request_sock *, struct flowi *);
	int (*tun_dev_alloc_security)(void **);
	void (*tun_dev_free_security)(void *);
	int (*tun_dev_create)();
	int (*tun_dev_attach_queue)(void *);
	int (*tun_dev_attach)(struct sock *, void *);
	int (*tun_dev_open)(void *);
	int (*sctp_assoc_request)(struct sctp_endpoint *, struct sk_buff *);
	int (*sctp_bind_connect)(struct sock *, int, struct sockaddr *, int);
	void (*sctp_sk_clone)(struct sctp_endpoint *, struct sock *, struct sock *);
	int (*key_alloc)(struct key *, const struct cred *, long unsigned int);
	void (*key_free)(struct key *);
	int (*key_permission)(key_ref_t, const struct cred *, enum key_need_perm);
	int (*key_getsecurity)(struct key *, char **);
	int (*audit_rule_init)(u32, u32, char *, void **);
	int (*audit_rule_known)(struct audit_krule *);
	int (*audit_rule_match)(u32, u32, u32, void *);
	void (*audit_rule_free)(void *);
	int (*bpf)(int, union bpf_attr *, unsigned int);
	int (*bpf_map)(struct bpf_map *, fmode_t);
	int (*bpf_prog)(struct bpf_prog *);
	int (*bpf_map_alloc_security)(struct bpf_map *);
	void (*bpf_map_free_security)(struct bpf_map *);
	int (*bpf_prog_alloc_security)(struct bpf_prog_aux *);
	void (*bpf_prog_free_security)(struct bpf_prog_aux *);
	int (*locked_down)(enum lockdown_reason);
	int (*perf_event_open)(struct perf_event_attr *, int);
	int (*perf_event_alloc)(struct perf_event *);
	void (*perf_event_free)(struct perf_event *);
	int (*perf_event_read)(struct perf_event *);
	int (*perf_event_write)(struct perf_event *);
};

struct security_hook_heads {
	struct hlist_head binder_set_context_mgr;
	struct hlist_head binder_transaction;
	struct hlist_head binder_transfer_binder;
	struct hlist_head binder_transfer_file;
	struct hlist_head ptrace_access_check;
	struct hlist_head ptrace_traceme;
	struct hlist_head capget;
	struct hlist_head capset;
	struct hlist_head capable;
	struct hlist_head quotactl;
	struct hlist_head quota_on;
	struct hlist_head syslog;
	struct hlist_head settime;
	struct hlist_head vm_enough_memory;
	struct hlist_head bprm_creds_for_exec;
	struct hlist_head bprm_creds_from_file;
	struct hlist_head bprm_check_security;
	struct hlist_head bprm_committing_creds;
	struct hlist_head bprm_committed_creds;
	struct hlist_head fs_context_dup;
	struct hlist_head fs_context_parse_param;
	struct hlist_head sb_alloc_security;
	struct hlist_head sb_free_security;
	struct hlist_head sb_free_mnt_opts;
	struct hlist_head sb_eat_lsm_opts;
	struct hlist_head sb_remount;
	struct hlist_head sb_kern_mount;
	struct hlist_head sb_show_options;
	struct hlist_head sb_statfs;
	struct hlist_head sb_mount;
	struct hlist_head sb_umount;
	struct hlist_head sb_pivotroot;
	struct hlist_head sb_set_mnt_opts;
	struct hlist_head sb_clone_mnt_opts;
	struct hlist_head sb_add_mnt_opt;
	struct hlist_head move_mount;
	struct hlist_head dentry_init_security;
	struct hlist_head dentry_create_files_as;
	struct hlist_head path_notify;
	struct hlist_head inode_alloc_security;
	struct hlist_head inode_free_security;
	struct hlist_head inode_init_security;
	struct hlist_head inode_create;
	struct hlist_head inode_link;
	struct hlist_head inode_unlink;
	struct hlist_head inode_symlink;
	struct hlist_head inode_mkdir;
	struct hlist_head inode_rmdir;
	struct hlist_head inode_mknod;
	struct hlist_head inode_rename;
	struct hlist_head inode_readlink;
	struct hlist_head inode_follow_link;
	struct hlist_head inode_permission;
	struct hlist_head inode_setattr;
	struct hlist_head inode_getattr;
	struct hlist_head inode_setxattr;
	struct hlist_head inode_post_setxattr;
	struct hlist_head inode_getxattr;
	struct hlist_head inode_listxattr;
	struct hlist_head inode_removexattr;
	struct hlist_head inode_need_killpriv;
	struct hlist_head inode_killpriv;
	struct hlist_head inode_getsecurity;
	struct hlist_head inode_setsecurity;
	struct hlist_head inode_listsecurity;
	struct hlist_head inode_getsecid;
	struct hlist_head inode_copy_up;
	struct hlist_head inode_copy_up_xattr;
	struct hlist_head kernfs_init_security;
	struct hlist_head file_permission;
	struct hlist_head file_alloc_security;
	struct hlist_head file_free_security;
	struct hlist_head file_ioctl;
	struct hlist_head mmap_addr;
	struct hlist_head mmap_file;
	struct hlist_head file_mprotect;
	struct hlist_head file_lock;
	struct hlist_head file_fcntl;
	struct hlist_head file_set_fowner;
	struct hlist_head file_send_sigiotask;
	struct hlist_head file_receive;
	struct hlist_head file_open;
	struct hlist_head task_alloc;
	struct hlist_head task_free;
	struct hlist_head cred_alloc_blank;
	struct hlist_head cred_free;
	struct hlist_head cred_prepare;
	struct hlist_head cred_transfer;
	struct hlist_head cred_getsecid;
	struct hlist_head kernel_act_as;
	struct hlist_head kernel_create_files_as;
	struct hlist_head kernel_module_request;
	struct hlist_head kernel_load_data;
	struct hlist_head kernel_post_load_data;
	struct hlist_head kernel_read_file;
	struct hlist_head kernel_post_read_file;
	struct hlist_head task_fix_setuid;
	struct hlist_head task_fix_setgid;
	struct hlist_head task_setpgid;
	struct hlist_head task_getpgid;
	struct hlist_head task_getsid;
	struct hlist_head task_getsecid;
	struct hlist_head task_setnice;
	struct hlist_head task_setioprio;
	struct hlist_head task_getioprio;
	struct hlist_head task_prlimit;
	struct hlist_head task_setrlimit;
	struct hlist_head task_setscheduler;
	struct hlist_head task_getscheduler;
	struct hlist_head task_movememory;
	struct hlist_head task_kill;
	struct hlist_head task_prctl;
	struct hlist_head task_to_inode;
	struct hlist_head ipc_permission;
	struct hlist_head ipc_getsecid;
	struct hlist_head msg_msg_alloc_security;
	struct hlist_head msg_msg_free_security;
	struct hlist_head msg_queue_alloc_security;
	struct hlist_head msg_queue_free_security;
	struct hlist_head msg_queue_associate;
	struct hlist_head msg_queue_msgctl;
	struct hlist_head msg_queue_msgsnd;
	struct hlist_head msg_queue_msgrcv;
	struct hlist_head shm_alloc_security;
	struct hlist_head shm_free_security;
	struct hlist_head shm_associate;
	struct hlist_head shm_shmctl;
	struct hlist_head shm_shmat;
	struct hlist_head sem_alloc_security;
	struct hlist_head sem_free_security;
	struct hlist_head sem_associate;
	struct hlist_head sem_semctl;
	struct hlist_head sem_semop;
	struct hlist_head netlink_send;
	struct hlist_head d_instantiate;
	struct hlist_head getprocattr;
	struct hlist_head setprocattr;
	struct hlist_head ismaclabel;
	struct hlist_head secid_to_secctx;
	struct hlist_head secctx_to_secid;
	struct hlist_head release_secctx;
	struct hlist_head inode_invalidate_secctx;
	struct hlist_head inode_notifysecctx;
	struct hlist_head inode_setsecctx;
	struct hlist_head inode_getsecctx;
	struct hlist_head unix_stream_connect;
	struct hlist_head unix_may_send;
	struct hlist_head socket_create;
	struct hlist_head socket_post_create;
	struct hlist_head socket_socketpair;
	struct hlist_head socket_bind;
	struct hlist_head socket_connect;
	struct hlist_head socket_listen;
	struct hlist_head socket_accept;
	struct hlist_head socket_sendmsg;
	struct hlist_head socket_recvmsg;
	struct hlist_head socket_getsockname;
	struct hlist_head socket_getpeername;
	struct hlist_head socket_getsockopt;
	struct hlist_head socket_setsockopt;
	struct hlist_head socket_shutdown;
	struct hlist_head socket_sock_rcv_skb;
	struct hlist_head socket_getpeersec_stream;
	struct hlist_head socket_getpeersec_dgram;
	struct hlist_head sk_alloc_security;
	struct hlist_head sk_free_security;
	struct hlist_head sk_clone_security;
	struct hlist_head sk_getsecid;
	struct hlist_head sock_graft;
	struct hlist_head inet_conn_request;
	struct hlist_head inet_csk_clone;
	struct hlist_head inet_conn_established;
	struct hlist_head secmark_relabel_packet;
	struct hlist_head secmark_refcount_inc;
	struct hlist_head secmark_refcount_dec;
	struct hlist_head req_classify_flow;
	struct hlist_head tun_dev_alloc_security;
	struct hlist_head tun_dev_free_security;
	struct hlist_head tun_dev_create;
	struct hlist_head tun_dev_attach_queue;
	struct hlist_head tun_dev_attach;
	struct hlist_head tun_dev_open;
	struct hlist_head sctp_assoc_request;
	struct hlist_head sctp_bind_connect;
	struct hlist_head sctp_sk_clone;
	struct hlist_head key_alloc;
	struct hlist_head key_free;
	struct hlist_head key_permission;
	struct hlist_head key_getsecurity;
	struct hlist_head audit_rule_init;
	struct hlist_head audit_rule_known;
	struct hlist_head audit_rule_match;
	struct hlist_head audit_rule_free;
	struct hlist_head bpf;
	struct hlist_head bpf_map;
	struct hlist_head bpf_prog;
	struct hlist_head bpf_map_alloc_security;
	struct hlist_head bpf_map_free_security;
	struct hlist_head bpf_prog_alloc_security;
	struct hlist_head bpf_prog_free_security;
	struct hlist_head locked_down;
	struct hlist_head perf_event_open;
	struct hlist_head perf_event_alloc;
	struct hlist_head perf_event_free;
	struct hlist_head perf_event_read;
	struct hlist_head perf_event_write;
};

struct security_hook_list {
	struct hlist_node list;
	struct hlist_head *head;
	union security_list_options hook;
	char *lsm;
};

enum lsm_order {
	LSM_ORDER_FIRST = 4294967295,
	LSM_ORDER_MUTABLE = 0,
};

struct lsm_info {
	const char *name;
	enum lsm_order order;
	long unsigned int flags;
	int *enabled;
	int (*init)();
	struct lsm_blob_sizes *blobs;
};

enum lsm_event {
	LSM_POLICY_CHANGE = 0,
};

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct lsm_network_audit {
	int netif;
	struct sock *sk;
	u16 family;
	__be16 dport;
	__be16 sport;
	union {
		struct {
			__be32 daddr;
			__be32 saddr;
		} v4;
		struct {
			struct in6_addr daddr;
			struct in6_addr saddr;
		} v6;
	} fam;
};

struct lsm_ioctlop_audit {
	struct path path;
	u16 cmd;
};

struct lsm_ibpkey_audit {
	u64 subnet_prefix;
	u16 pkey;
};

struct lsm_ibendport_audit {
	char dev_name[64];
	u8 port;
};

struct selinux_state;

struct selinux_audit_data {
	u32 ssid;
	u32 tsid;
	u16 tclass;
	u32 requested;
	u32 audited;
	u32 denied;
	int result;
	struct selinux_state *state;
};

struct common_audit_data {
	char type;
	union {
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		struct {
			key_serial_t key;
			char *key_desc;
		} key_struct;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
		int reason;
	} u;
	union {
		struct selinux_audit_data *selinux_audit_data;
	};
};

enum {
	POLICYDB_CAPABILITY_NETPEER = 0,
	POLICYDB_CAPABILITY_OPENPERM = 1,
	POLICYDB_CAPABILITY_EXTSOCKCLASS = 2,
	POLICYDB_CAPABILITY_ALWAYSNETWORK = 3,
	POLICYDB_CAPABILITY_CGROUPSECLABEL = 4,
	POLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION = 5,
	POLICYDB_CAPABILITY_GENFS_SECLABEL_SYMLINKS = 6,
	__POLICYDB_CAPABILITY_MAX = 7,
};

struct selinux_avc;

struct selinux_policy;

struct selinux_state {
	bool disabled;
	bool enforcing;
	bool checkreqprot;
	bool initialized;
	bool policycap[7];
	struct page *status_page;
	struct mutex status_lock;
	struct selinux_avc *avc;
	struct selinux_policy *policy;
	struct mutex policy_mutex;
};

struct avc_cache {
	struct hlist_head slots[512];
	spinlock_t slots_lock[512];
	atomic_t lru_hint;
	atomic_t active_nodes;
	u32 latest_notif;
};

struct selinux_avc {
	unsigned int avc_cache_threshold;
	struct avc_cache avc_cache;
};

struct av_decision {
	u32 allowed;
	u32 auditallow;
	u32 auditdeny;
	u32 seqno;
	u32 flags;
};

struct extended_perms_data {
	u32 p[8];
};

struct extended_perms_decision {
	u8 used;
	u8 driver;
	struct extended_perms_data *allowed;
	struct extended_perms_data *auditallow;
	struct extended_perms_data *dontaudit;
};

struct extended_perms {
	u16 len;
	struct extended_perms_data drivers;
};

struct avc_cache_stats {
	unsigned int lookups;
	unsigned int misses;
	unsigned int allocations;
	unsigned int reclaims;
	unsigned int frees;
};

struct security_class_mapping {
	const char *name;
	const char *perms[33];
};

struct trace_event_raw_selinux_audited {
	struct trace_entry ent;
	u32 requested;
	u32 denied;
	u32 audited;
	int result;
	u32 __data_loc_scontext;
	u32 __data_loc_tcontext;
	u32 __data_loc_tclass;
	char __data[0];
};

struct trace_event_data_offsets_selinux_audited {
	u32 scontext;
	u32 tcontext;
	u32 tclass;
};

typedef void (*btf_trace_selinux_audited)(void *, struct selinux_audit_data *, char *, char *, const char *);

struct avc_xperms_node;

struct avc_entry {
	u32 ssid;
	u32 tsid;
	u16 tclass;
	struct av_decision avd;
	struct avc_xperms_node *xp_node;
};

struct avc_xperms_node {
	struct extended_perms xp;
	struct list_head xpd_head;
};

struct avc_node {
	struct avc_entry ae;
	struct hlist_node list;
	struct callback_head rhead;
};

struct avc_xperms_decision_node {
	struct extended_perms_decision xpd;
	struct list_head xpd_list;
};

struct avc_callback_node {
	int (*callback)(u32);
	u32 events;
	struct avc_callback_node *next;
};

typedef __u16 __sum16;

enum sctp_endpoint_type {
	SCTP_EP_TYPE_SOCKET = 0,
	SCTP_EP_TYPE_ASSOCIATION = 1,
};

struct sctp_chunk;

struct sctp_inq {
	struct list_head in_chunk_list;
	struct sctp_chunk *in_progress;
	struct work_struct immediate;
};

struct sctp_bind_addr {
	__u16 port;
	struct list_head address_list;
};

struct sctp_ep_common {
	struct hlist_node node;
	int hashent;
	enum sctp_endpoint_type type;
	refcount_t refcnt;
	bool dead;
	struct sock *sk;
	struct net *net;
	struct sctp_inq inqueue;
	struct sctp_bind_addr bind_addr;
};

struct sctp_hmac_algo_param;

struct sctp_chunks_param;

struct sctp_endpoint {
	struct sctp_ep_common base;
	struct list_head asocs;
	__u8 secret_key[32];
	__u8 *digest;
	__u32 sndbuf_policy;
	__u32 rcvbuf_policy;
	struct crypto_shash **auth_hmacs;
	struct sctp_hmac_algo_param *auth_hmacs_list;
	struct sctp_chunks_param *auth_chunk_list;
	struct list_head endpoint_shared_keys;
	__u16 active_key_id;
	__u8 ecn_enable: 1;
	__u8 auth_enable: 1;
	__u8 intl_enable: 1;
	__u8 prsctp_enable: 1;
	__u8 asconf_enable: 1;
	__u8 reconf_enable: 1;
	__u8 strreset_enable;
	u32 secid;
	u32 peer_secid;
};

struct nf_hook_state;

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct nf_hook_state {
	unsigned int hook;
	u_int8_t pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u_int8_t pf;
	unsigned int hooknum;
	int priority;
};

enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = 2147483648,
	NF_IP_PRI_RAW_BEFORE_DEFRAG = 4294966846,
	NF_IP_PRI_CONNTRACK_DEFRAG = 4294966896,
	NF_IP_PRI_RAW = 4294966996,
	NF_IP_PRI_SELINUX_FIRST = 4294967071,
	NF_IP_PRI_CONNTRACK = 4294967096,
	NF_IP_PRI_MANGLE = 4294967146,
	NF_IP_PRI_NAT_DST = 4294967196,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_HELPER = 300,
	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
	NF_IP_PRI_LAST = 2147483647,
};

enum nf_ip6_hook_priorities {
	NF_IP6_PRI_FIRST = 2147483648,
	NF_IP6_PRI_RAW_BEFORE_DEFRAG = 4294966846,
	NF_IP6_PRI_CONNTRACK_DEFRAG = 4294966896,
	NF_IP6_PRI_RAW = 4294966996,
	NF_IP6_PRI_SELINUX_FIRST = 4294967071,
	NF_IP6_PRI_CONNTRACK = 4294967096,
	NF_IP6_PRI_MANGLE = 4294967146,
	NF_IP6_PRI_NAT_DST = 4294967196,
	NF_IP6_PRI_FILTER = 0,
	NF_IP6_PRI_SECURITY = 50,
	NF_IP6_PRI_NAT_SRC = 100,
	NF_IP6_PRI_SELINUX_LAST = 225,
	NF_IP6_PRI_CONNTRACK_HELPER = 300,
	NF_IP6_PRI_LAST = 2147483647,
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	__be16 inet_sport;
	__u16 inet_id;
	struct ip_options_rcu *inet_opt;
	int rx_dst_ifindex;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	const struct in6_addr *saddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 recverr_rfc4884: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	__u32 rx_dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	__be32 saddr;
	__be32 daddr;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	struct in6_addr saddr;
	struct in6_addr daddr;
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 dsthao;
	__u16 frag_max_size;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	rwlock_t sflock;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct netlbl_lsm_cache {
	refcount_t refcount;
	void (*free)(const void *);
	void *data;
};

struct netlbl_lsm_catmap {
	u32 startbit;
	u64 bitmap[4];
	struct netlbl_lsm_catmap *next;
};

struct netlbl_lsm_secattr {
	u32 flags;
	u32 type;
	char *domain;
	struct netlbl_lsm_cache *cache;
	struct {
		struct {
			struct netlbl_lsm_catmap *cat;
			u32 lvl;
		} mls;
		u32 secid;
	} attr;
};

struct dccp_hdr {
	__be16 dccph_sport;
	__be16 dccph_dport;
	__u8 dccph_doff;
	__u8 dccph_cscov: 4;
	__u8 dccph_ccval: 4;
	__sum16 dccph_checksum;
	__u8 dccph_x: 1;
	__u8 dccph_type: 4;
	__u8 dccph_reserved: 3;
	__u8 dccph_seq2;
	__be16 dccph_seq;
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

typedef __s32 sctp_assoc_t;

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

struct sctp_initmsg {
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u16 sinit_max_attempts;
	__u16 sinit_max_init_timeo;
};

struct sctp_sndrcvinfo {
	__u16 sinfo_stream;
	__u16 sinfo_ssn;
	__u16 sinfo_flags;
	__u32 sinfo_ppid;
	__u32 sinfo_context;
	__u32 sinfo_timetolive;
	__u32 sinfo_tsn;
	__u32 sinfo_cumtsn;
	sctp_assoc_t sinfo_assoc_id;
};

struct sctp_rtoinfo {
	sctp_assoc_t srto_assoc_id;
	__u32 srto_initial;
	__u32 srto_max;
	__u32 srto_min;
};

struct sctp_assocparams {
	sctp_assoc_t sasoc_assoc_id;
	__u16 sasoc_asocmaxrxt;
	__u16 sasoc_number_peer_destinations;
	__u32 sasoc_peer_rwnd;
	__u32 sasoc_local_rwnd;
	__u32 sasoc_cookie_life;
};

struct sctp_paddrparams {
	sctp_assoc_t spp_assoc_id;
	struct __kernel_sockaddr_storage spp_address;
	__u32 spp_hbinterval;
	__u16 spp_pathmaxrxt;
	__u32 spp_pathmtu;
	__u32 spp_sackdelay;
	__u32 spp_flags;
	__u32 spp_ipv6_flowlabel;
	__u8 spp_dscp;
	char: 8;
} __attribute__((packed));

struct sctphdr {
	__be16 source;
	__be16 dest;
	__be32 vtag;
	__le32 checksum;
};

struct sctp_chunkhdr {
	__u8 type;
	__u8 flags;
	__be16 length;
};

enum sctp_cid {
	SCTP_CID_DATA = 0,
	SCTP_CID_INIT = 1,
	SCTP_CID_INIT_ACK = 2,
	SCTP_CID_SACK = 3,
	SCTP_CID_HEARTBEAT = 4,
	SCTP_CID_HEARTBEAT_ACK = 5,
	SCTP_CID_ABORT = 6,
	SCTP_CID_SHUTDOWN = 7,
	SCTP_CID_SHUTDOWN_ACK = 8,
	SCTP_CID_ERROR = 9,
	SCTP_CID_COOKIE_ECHO = 10,
	SCTP_CID_COOKIE_ACK = 11,
	SCTP_CID_ECN_ECNE = 12,
	SCTP_CID_ECN_CWR = 13,
	SCTP_CID_SHUTDOWN_COMPLETE = 14,
	SCTP_CID_AUTH = 15,
	SCTP_CID_I_DATA = 64,
	SCTP_CID_FWD_TSN = 192,
	SCTP_CID_ASCONF = 193,
	SCTP_CID_I_FWD_TSN = 194,
	SCTP_CID_ASCONF_ACK = 128,
	SCTP_CID_RECONF = 130,
};

struct sctp_paramhdr {
	__be16 type;
	__be16 length;
};

enum sctp_param {
	SCTP_PARAM_HEARTBEAT_INFO = 256,
	SCTP_PARAM_IPV4_ADDRESS = 1280,
	SCTP_PARAM_IPV6_ADDRESS = 1536,
	SCTP_PARAM_STATE_COOKIE = 1792,
	SCTP_PARAM_UNRECOGNIZED_PARAMETERS = 2048,
	SCTP_PARAM_COOKIE_PRESERVATIVE = 2304,
	SCTP_PARAM_HOST_NAME_ADDRESS = 2816,
	SCTP_PARAM_SUPPORTED_ADDRESS_TYPES = 3072,
	SCTP_PARAM_ECN_CAPABLE = 128,
	SCTP_PARAM_RANDOM = 640,
	SCTP_PARAM_CHUNKS = 896,
	SCTP_PARAM_HMAC_ALGO = 1152,
	SCTP_PARAM_SUPPORTED_EXT = 2176,
	SCTP_PARAM_FWD_TSN_SUPPORT = 192,
	SCTP_PARAM_ADD_IP = 448,
	SCTP_PARAM_DEL_IP = 704,
	SCTP_PARAM_ERR_CAUSE = 960,
	SCTP_PARAM_SET_PRIMARY = 1216,
	SCTP_PARAM_SUCCESS_REPORT = 1472,
	SCTP_PARAM_ADAPTATION_LAYER_IND = 1728,
	SCTP_PARAM_RESET_OUT_REQUEST = 3328,
	SCTP_PARAM_RESET_IN_REQUEST = 3584,
	SCTP_PARAM_RESET_TSN_REQUEST = 3840,
	SCTP_PARAM_RESET_RESPONSE = 4096,
	SCTP_PARAM_RESET_ADD_OUT_STREAMS = 4352,
	SCTP_PARAM_RESET_ADD_IN_STREAMS = 4608,
};

struct sctp_datahdr {
	__be32 tsn;
	__be16 stream;
	__be16 ssn;
	__u32 ppid;
	__u8 payload[0];
};

struct sctp_idatahdr {
	__be32 tsn;
	__be16 stream;
	__be16 reserved;
	__be32 mid;
	union {
		__u32 ppid;
		__be32 fsn;
	};
	__u8 payload[0];
};

struct sctp_inithdr {
	__be32 init_tag;
	__be32 a_rwnd;
	__be16 num_outbound_streams;
	__be16 num_inbound_streams;
	__be32 initial_tsn;
	__u8 params[0];
};

struct sctp_init_chunk {
	struct sctp_chunkhdr chunk_hdr;
	struct sctp_inithdr init_hdr;
};

struct sctp_ipv4addr_param {
	struct sctp_paramhdr param_hdr;
	struct in_addr addr;
};

struct sctp_ipv6addr_param {
	struct sctp_paramhdr param_hdr;
	struct in6_addr addr;
};

struct sctp_cookie_preserve_param {
	struct sctp_paramhdr param_hdr;
	__be32 lifespan_increment;
};

struct sctp_hostname_param {
	struct sctp_paramhdr param_hdr;
	uint8_t hostname[0];
};

struct sctp_supported_addrs_param {
	struct sctp_paramhdr param_hdr;
	__be16 types[0];
};

struct sctp_adaptation_ind_param {
	struct sctp_paramhdr param_hdr;
	__be32 adaptation_ind;
};

struct sctp_supported_ext_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_random_param {
	struct sctp_paramhdr param_hdr;
	__u8 random_val[0];
};

struct sctp_chunks_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_hmac_algo_param {
	struct sctp_paramhdr param_hdr;
	__be16 hmac_ids[0];
};

struct sctp_cookie_param {
	struct sctp_paramhdr p;
	__u8 body[0];
};

struct sctp_gap_ack_block {
	__be16 start;
	__be16 end;
};

union sctp_sack_variable {
	struct sctp_gap_ack_block gab;
	__be32 dup;
};

struct sctp_sackhdr {
	__be32 cum_tsn_ack;
	__be32 a_rwnd;
	__be16 num_gap_ack_blocks;
	__be16 num_dup_tsns;
	union sctp_sack_variable variable[0];
};

struct sctp_heartbeathdr {
	struct sctp_paramhdr info;
};

struct sctp_shutdownhdr {
	__be32 cum_tsn_ack;
};

struct sctp_errhdr {
	__be16 cause;
	__be16 length;
	__u8 variable[0];
};

struct sctp_ecnehdr {
	__be32 lowest_tsn;
};

struct sctp_cwrhdr {
	__be32 lowest_tsn;
};

struct sctp_fwdtsn_skip {
	__be16 stream;
	__be16 ssn;
};

struct sctp_fwdtsn_hdr {
	__be32 new_cum_tsn;
	struct sctp_fwdtsn_skip skip[0];
};

struct sctp_ifwdtsn_skip {
	__be16 stream;
	__u8 reserved;
	__u8 flags;
	__be32 mid;
};

struct sctp_ifwdtsn_hdr {
	__be32 new_cum_tsn;
	struct sctp_ifwdtsn_skip skip[0];
};

struct sctp_addip_param {
	struct sctp_paramhdr param_hdr;
	__be32 crr_id;
};

struct sctp_addiphdr {
	__be32 serial;
	__u8 params[0];
};

struct sctp_authhdr {
	__be16 shkey_id;
	__be16 hmac_id;
	__u8 hmac[0];
};

union sctp_addr {
	struct sockaddr_in v4;
	struct sockaddr_in6 v6;
	struct sockaddr sa;
};

struct sctp_cookie {
	__u32 my_vtag;
	__u32 peer_vtag;
	__u32 my_ttag;
	__u32 peer_ttag;
	ktime_t expiration;
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u32 initial_tsn;
	union sctp_addr peer_addr;
	__u16 my_port;
	__u8 prsctp_capable;
	__u8 padding;
	__u32 adaptation_ind;
	__u8 auth_random[36];
	__u8 auth_hmacs[10];
	__u8 auth_chunks[20];
	__u32 raw_addr_list_len;
	struct sctp_init_chunk peer_init[0];
};

struct sctp_tsnmap {
	long unsigned int *tsn_map;
	__u32 base_tsn;
	__u32 cumulative_tsn_ack_point;
	__u32 max_tsn_seen;
	__u16 len;
	__u16 pending_data;
	__u16 num_dup_tsns;
	__be32 dup_tsns[16];
};

struct sctp_inithdr_host {
	__u32 init_tag;
	__u32 a_rwnd;
	__u16 num_outbound_streams;
	__u16 num_inbound_streams;
	__u32 initial_tsn;
};

enum sctp_state {
	SCTP_STATE_CLOSED = 0,
	SCTP_STATE_COOKIE_WAIT = 1,
	SCTP_STATE_COOKIE_ECHOED = 2,
	SCTP_STATE_ESTABLISHED = 3,
	SCTP_STATE_SHUTDOWN_PENDING = 4,
	SCTP_STATE_SHUTDOWN_SENT = 5,
	SCTP_STATE_SHUTDOWN_RECEIVED = 6,
	SCTP_STATE_SHUTDOWN_ACK_SENT = 7,
};

struct sctp_stream_out_ext;

struct sctp_stream_out {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	struct sctp_stream_out_ext *ext;
	__u8 state;
};

struct sctp_stream_in {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	__u32 fsn;
	__u32 fsn_uo;
	char pd_mode;
	char pd_mode_uo;
};

struct sctp_stream_interleave;

struct sctp_stream {
	struct {
		struct __genradix tree;
		struct sctp_stream_out type[0];
	} out;
	struct {
		struct __genradix tree;
		struct sctp_stream_in type[0];
	} in;
	__u16 outcnt;
	__u16 incnt;
	struct sctp_stream_out *out_curr;
	union {
		struct {
			struct list_head prio_list;
		};
		struct {
			struct list_head rr_list;
			struct sctp_stream_out_ext *rr_next;
		};
	};
	struct sctp_stream_interleave *si;
};

struct sctp_sched_ops;

struct sctp_association;

struct sctp_outq {
	struct sctp_association *asoc;
	struct list_head out_chunk_list;
	struct sctp_sched_ops *sched;
	unsigned int out_qlen;
	unsigned int error;
	struct list_head control_chunk_list;
	struct list_head sacked;
	struct list_head retransmit;
	struct list_head abandoned;
	__u32 outstanding_bytes;
	char fast_rtx;
	char cork;
};

struct sctp_ulpq {
	char pd_mode;
	struct sctp_association *asoc;
	struct sk_buff_head reasm;
	struct sk_buff_head reasm_uo;
	struct sk_buff_head lobby;
};

struct sctp_priv_assoc_stats {
	struct __kernel_sockaddr_storage obs_rto_ipaddr;
	__u64 max_obs_rto;
	__u64 isacks;
	__u64 osacks;
	__u64 opackets;
	__u64 ipackets;
	__u64 rtxchunks;
	__u64 outofseqtsns;
	__u64 idupchunks;
	__u64 gapcnt;
	__u64 ouodchunks;
	__u64 iuodchunks;
	__u64 oodchunks;
	__u64 iodchunks;
	__u64 octrlchunks;
	__u64 ictrlchunks;
};

struct sctp_transport;

struct sctp_auth_bytes;

struct sctp_shared_key;

struct sctp_association {
	struct sctp_ep_common base;
	struct list_head asocs;
	sctp_assoc_t assoc_id;
	struct sctp_endpoint *ep;
	struct sctp_cookie c;
	struct {
		struct list_head transport_addr_list;
		__u32 rwnd;
		__u16 transport_count;
		__u16 port;
		struct sctp_transport *primary_path;
		union sctp_addr primary_addr;
		struct sctp_transport *active_path;
		struct sctp_transport *retran_path;
		struct sctp_transport *last_sent_to;
		struct sctp_transport *last_data_from;
		struct sctp_tsnmap tsn_map;
		__be16 addip_disabled_mask;
		__u16 ecn_capable: 1;
		__u16 ipv4_address: 1;
		__u16 ipv6_address: 1;
		__u16 hostname_address: 1;
		__u16 asconf_capable: 1;
		__u16 prsctp_capable: 1;
		__u16 reconf_capable: 1;
		__u16 intl_capable: 1;
		__u16 auth_capable: 1;
		__u16 sack_needed: 1;
		__u16 sack_generation: 1;
		__u16 zero_window_announced: 1;
		__u32 sack_cnt;
		__u32 adaptation_ind;
		struct sctp_inithdr_host i;
		void *cookie;
		int cookie_len;
		__u32 addip_serial;
		struct sctp_random_param *peer_random;
		struct sctp_chunks_param *peer_chunks;
		struct sctp_hmac_algo_param *peer_hmacs;
	} peer;
	enum sctp_state state;
	int overall_error_count;
	ktime_t cookie_life;
	long unsigned int rto_initial;
	long unsigned int rto_max;
	long unsigned int rto_min;
	int max_burst;
	int max_retrans;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u16 max_init_attempts;
	__u16 init_retries;
	long unsigned int max_init_timeo;
	long unsigned int hbinterval;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u8 pmtu_pending;
	__u32 pathmtu;
	__u32 param_flags;
	__u32 sackfreq;
	long unsigned int sackdelay;
	long unsigned int timeouts[11];
	struct timer_list timers[11];
	struct sctp_transport *shutdown_last_sent_to;
	struct sctp_transport *init_last_sent_to;
	int shutdown_retries;
	__u32 next_tsn;
	__u32 ctsn_ack_point;
	__u32 adv_peer_ack_point;
	__u32 highest_sacked;
	__u32 fast_recovery_exit;
	__u8 fast_recovery;
	__u16 unack_data;
	__u32 rtx_data_chunks;
	__u32 rwnd;
	__u32 a_rwnd;
	__u32 rwnd_over;
	__u32 rwnd_press;
	int sndbuf_used;
	atomic_t rmem_alloc;
	wait_queue_head_t wait;
	__u32 frag_point;
	__u32 user_frag;
	int init_err_counter;
	int init_cycle;
	__u16 default_stream;
	__u16 default_flags;
	__u32 default_ppid;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	struct sctp_stream stream;
	struct sctp_outq outqueue;
	struct sctp_ulpq ulpq;
	__u32 last_ecne_tsn;
	__u32 last_cwr_tsn;
	int numduptsns;
	struct sctp_chunk *addip_last_asconf;
	struct list_head asconf_ack_list;
	struct list_head addip_chunk_list;
	__u32 addip_serial;
	int src_out_of_asoc_ok;
	union sctp_addr *asconf_addr_del_pending;
	struct sctp_transport *new_transport;
	struct list_head endpoint_shared_keys;
	struct sctp_auth_bytes *asoc_shared_key;
	struct sctp_shared_key *shkey;
	__u16 default_hmac_id;
	__u16 active_key_id;
	__u8 need_ecne: 1;
	__u8 temp: 1;
	__u8 pf_expose: 2;
	__u8 force_delay: 1;
	__u8 strreset_enable;
	__u8 strreset_outstanding;
	__u32 strreset_outseq;
	__u32 strreset_inseq;
	__u32 strreset_result[2];
	struct sctp_chunk *strreset_chunk;
	struct sctp_priv_assoc_stats stats;
	int sent_cnt_removable;
	__u16 subscribe;
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	struct callback_head rcu;
};

struct sctp_auth_bytes {
	refcount_t refcnt;
	__u32 len;
	__u8 data[0];
};

struct sctp_shared_key {
	struct list_head key_list;
	struct sctp_auth_bytes *key;
	refcount_t refcnt;
	__u16 key_id;
	__u8 deactivated;
};

enum {
	SCTP_MAX_STREAM = 65535,
};

enum sctp_event_timeout {
	SCTP_EVENT_TIMEOUT_NONE = 0,
	SCTP_EVENT_TIMEOUT_T1_COOKIE = 1,
	SCTP_EVENT_TIMEOUT_T1_INIT = 2,
	SCTP_EVENT_TIMEOUT_T2_SHUTDOWN = 3,
	SCTP_EVENT_TIMEOUT_T3_RTX = 4,
	SCTP_EVENT_TIMEOUT_T4_RTO = 5,
	SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD = 6,
	SCTP_EVENT_TIMEOUT_HEARTBEAT = 7,
	SCTP_EVENT_TIMEOUT_RECONF = 8,
	SCTP_EVENT_TIMEOUT_SACK = 9,
	SCTP_EVENT_TIMEOUT_AUTOCLOSE = 10,
};

enum {
	SCTP_MAX_DUP_TSNS = 16,
};

enum sctp_scope {
	SCTP_SCOPE_GLOBAL = 0,
	SCTP_SCOPE_PRIVATE = 1,
	SCTP_SCOPE_LINK = 2,
	SCTP_SCOPE_LOOPBACK = 3,
	SCTP_SCOPE_UNUSABLE = 4,
};

enum {
	SCTP_AUTH_HMAC_ID_RESERVED_0 = 0,
	SCTP_AUTH_HMAC_ID_SHA1 = 1,
	SCTP_AUTH_HMAC_ID_RESERVED_2 = 2,
	SCTP_AUTH_HMAC_ID_SHA256 = 3,
	__SCTP_AUTH_HMAC_MAX = 4,
};

struct sctp_ulpevent {
	struct sctp_association *asoc;
	struct sctp_chunk *chunk;
	unsigned int rmem_len;
	union {
		__u32 mid;
		__u16 ssn;
	};
	union {
		__u32 ppid;
		__u32 fsn;
	};
	__u32 tsn;
	__u32 cumtsn;
	__u16 stream;
	__u16 flags;
	__u16 msg_flags;
} __attribute__((packed));

union sctp_addr_param;

union sctp_params {
	void *v;
	struct sctp_paramhdr *p;
	struct sctp_cookie_preserve_param *life;
	struct sctp_hostname_param *dns;
	struct sctp_cookie_param *cookie;
	struct sctp_supported_addrs_param *sat;
	struct sctp_ipv4addr_param *v4;
	struct sctp_ipv6addr_param *v6;
	union sctp_addr_param *addr;
	struct sctp_adaptation_ind_param *aind;
	struct sctp_supported_ext_param *ext;
	struct sctp_random_param *random;
	struct sctp_chunks_param *chunks;
	struct sctp_hmac_algo_param *hmac_algo;
	struct sctp_addip_param *addip;
};

struct sctp_sender_hb_info;

struct sctp_signed_cookie;

struct sctp_datamsg;

struct sctp_chunk {
	struct list_head list;
	refcount_t refcnt;
	int sent_count;
	union {
		struct list_head transmitted_list;
		struct list_head stream_list;
	};
	struct list_head frag_list;
	struct sk_buff *skb;
	union {
		struct sk_buff *head_skb;
		struct sctp_shared_key *shkey;
	};
	union sctp_params param_hdr;
	union {
		__u8 *v;
		struct sctp_datahdr *data_hdr;
		struct sctp_inithdr *init_hdr;
		struct sctp_sackhdr *sack_hdr;
		struct sctp_heartbeathdr *hb_hdr;
		struct sctp_sender_hb_info *hbs_hdr;
		struct sctp_shutdownhdr *shutdown_hdr;
		struct sctp_signed_cookie *cookie_hdr;
		struct sctp_ecnehdr *ecne_hdr;
		struct sctp_cwrhdr *ecn_cwr_hdr;
		struct sctp_errhdr *err_hdr;
		struct sctp_addiphdr *addip_hdr;
		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
		struct sctp_authhdr *auth_hdr;
		struct sctp_idatahdr *idata_hdr;
		struct sctp_ifwdtsn_hdr *ifwdtsn_hdr;
	} subh;
	__u8 *chunk_end;
	struct sctp_chunkhdr *chunk_hdr;
	struct sctphdr *sctp_hdr;
	struct sctp_sndrcvinfo sinfo;
	struct sctp_association *asoc;
	struct sctp_ep_common *rcvr;
	long unsigned int sent_at;
	union sctp_addr source;
	union sctp_addr dest;
	struct sctp_datamsg *msg;
	struct sctp_transport *transport;
	struct sk_buff *auth_chunk;
	__u16 rtt_in_progress: 1;
	__u16 has_tsn: 1;
	__u16 has_ssn: 1;
	__u16 singleton: 1;
	__u16 end_of_packet: 1;
	__u16 ecn_ce_done: 1;
	__u16 pdiscard: 1;
	__u16 tsn_gap_acked: 1;
	__u16 data_accepted: 1;
	__u16 auth: 1;
	__u16 has_asconf: 1;
	__u16 tsn_missing_report: 2;
	__u16 fast_retransmit: 2;
};

struct sctp_stream_interleave {
	__u16 data_chunk_len;
	__u16 ftsn_chunk_len;
	struct sctp_chunk * (*make_datafrag)(const struct sctp_association *, const struct sctp_sndrcvinfo *, int, __u8, gfp_t);
	void (*assign_number)(struct sctp_chunk *);
	bool (*validate_data)(struct sctp_chunk *);
	int (*ulpevent_data)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	int (*enqueue_event)(struct sctp_ulpq *, struct sctp_ulpevent *);
	void (*renege_events)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	void (*start_pd)(struct sctp_ulpq *, gfp_t);
	void (*abort_pd)(struct sctp_ulpq *, gfp_t);
	void (*generate_ftsn)(struct sctp_outq *, __u32);
	bool (*validate_ftsn)(struct sctp_chunk *);
	void (*report_ftsn)(struct sctp_ulpq *, __u32);
	void (*handle_ftsn)(struct sctp_ulpq *, struct sctp_chunk *);
};

struct sctp_bind_bucket {
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct hlist_node node;
	struct hlist_head owner;
	struct net *net;
};

enum sctp_socket_type {
	SCTP_SOCKET_UDP = 0,
	SCTP_SOCKET_UDP_HIGH_BANDWIDTH = 1,
	SCTP_SOCKET_TCP = 2,
};

struct sctp_pf;

struct sctp_sock {
	struct inet_sock inet;
	enum sctp_socket_type type;
	struct sctp_pf *pf;
	struct crypto_shash *hmac;
	char *sctp_hmac_alg;
	struct sctp_endpoint *ep;
	struct sctp_bind_bucket *bind_hash;
	__u16 default_stream;
	__u32 default_ppid;
	__u16 default_flags;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	int max_burst;
	__u32 hbinterval;
	__be16 udp_port;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 sackdelay;
	__u32 sackfreq;
	__u32 param_flags;
	__u32 default_ss;
	struct sctp_rtoinfo rtoinfo;
	struct sctp_paddrparams paddrparam;
	struct sctp_assocparams assocparams;
	__u16 subscribe;
	struct sctp_initmsg initmsg;
	int user_frag;
	__u32 autoclose;
	__u32 adaptation_ind;
	__u32 pd_point;
	__u16 nodelay: 1;
	__u16 pf_expose: 2;
	__u16 reuse: 1;
	__u16 disable_fragments: 1;
	__u16 v4mapped: 1;
	__u16 frag_interleave: 1;
	__u16 recvrcvinfo: 1;
	__u16 recvnxtinfo: 1;
	__u16 data_ready_signalled: 1;
	atomic_t pd_mode;
	struct sk_buff_head pd_lobby;
	struct list_head auto_asconf_list;
	int do_auto_asconf;
};

struct sctp_af;

struct sctp_pf {
	void (*event_msgname)(struct sctp_ulpevent *, char *, int *);
	void (*skb_msgname)(struct sk_buff *, char *, int *);
	int (*af_supported)(sa_family_t, struct sctp_sock *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *, struct sctp_sock *);
	int (*bind_verify)(struct sctp_sock *, union sctp_addr *);
	int (*send_verify)(struct sctp_sock *, union sctp_addr *);
	int (*supported_addrs)(const struct sctp_sock *, __be16 *);
	struct sock * (*create_accept_sk)(struct sock *, struct sctp_association *, bool);
	int (*addr_to_user)(struct sctp_sock *, union sctp_addr *);
	void (*to_sk_saddr)(union sctp_addr *, struct sock *);
	void (*to_sk_daddr)(union sctp_addr *, struct sock *);
	void (*copy_ip_options)(struct sock *, struct sock *);
	struct sctp_af *af;
};

struct sctp_signed_cookie {
	__u8 signature[32];
	__u32 __pad;
	struct sctp_cookie c;
} __attribute__((packed));

union sctp_addr_param {
	struct sctp_paramhdr p;
	struct sctp_ipv4addr_param v4;
	struct sctp_ipv6addr_param v6;
};

struct sctp_sender_hb_info {
	struct sctp_paramhdr param_hdr;
	union sctp_addr daddr;
	long unsigned int sent_at;
	__u64 hb_nonce;
};

struct sctp_af {
	int (*sctp_xmit)(struct sk_buff *, struct sctp_transport *);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*get_dst)(struct sctp_transport *, union sctp_addr *, struct flowi *, struct sock *);
	void (*get_saddr)(struct sctp_sock *, struct sctp_transport *, struct flowi *);
	void (*copy_addrlist)(struct list_head *, struct net_device *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *);
	void (*addr_copy)(union sctp_addr *, union sctp_addr *);
	void (*from_skb)(union sctp_addr *, struct sk_buff *, int);
	void (*from_sk)(union sctp_addr *, struct sock *);
	void (*from_addr_param)(union sctp_addr *, union sctp_addr_param *, __be16, int);
	int (*to_addr_param)(const union sctp_addr *, union sctp_addr_param *);
	int (*addr_valid)(union sctp_addr *, struct sctp_sock *, const struct sk_buff *);
	enum sctp_scope (*scope)(union sctp_addr *);
	void (*inaddr_any)(union sctp_addr *, __be16);
	int (*is_any)(const union sctp_addr *);
	int (*available)(union sctp_addr *, struct sctp_sock *);
	int (*skb_iif)(const struct sk_buff *);
	int (*is_ce)(const struct sk_buff *);
	void (*seq_dump_addr)(struct seq_file *, union sctp_addr *);
	void (*ecn_capable)(struct sock *);
	__u16 net_header_len;
	int sockaddr_len;
	int (*ip_options_len)(struct sock *);
	sa_family_t sa_family;
	struct list_head list;
};

struct sctp_packet {
	__u16 source_port;
	__u16 destination_port;
	__u32 vtag;
	struct list_head chunk_list;
	size_t overhead;
	size_t size;
	size_t max_size;
	struct sctp_transport *transport;
	struct sctp_chunk *auth;
	u8 has_cookie_echo: 1;
	u8 has_sack: 1;
	u8 has_auth: 1;
	u8 has_data: 1;
	u8 ipfragok: 1;
};

struct sctp_transport {
	struct list_head transports;
	struct rhlist_head node;
	refcount_t refcnt;
	__u32 rto_pending: 1;
	__u32 hb_sent: 1;
	__u32 pmtu_pending: 1;
	__u32 dst_pending_confirm: 1;
	__u32 sack_generation: 1;
	u32 dst_cookie;
	struct flowi fl;
	union sctp_addr ipaddr;
	struct sctp_af *af_specific;
	struct sctp_association *asoc;
	long unsigned int rto;
	__u32 rtt;
	__u32 rttvar;
	__u32 srtt;
	__u32 cwnd;
	__u32 ssthresh;
	__u32 partial_bytes_acked;
	__u32 flight_size;
	__u32 burst_limited;
	struct dst_entry *dst;
	union sctp_addr saddr;
	long unsigned int hbinterval;
	long unsigned int sackdelay;
	__u32 sackfreq;
	atomic_t mtu_info;
	ktime_t last_time_heard;
	long unsigned int last_time_sent;
	long unsigned int last_time_ecne_reduced;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 param_flags;
	int init_sent_count;
	int state;
	short unsigned int error_count;
	struct timer_list T3_rtx_timer;
	struct timer_list hb_timer;
	struct timer_list proto_unreach_timer;
	struct timer_list reconf_timer;
	struct list_head transmitted;
	struct sctp_packet packet;
	struct list_head send_ready;
	struct {
		__u32 next_tsn_at_change;
		char changeover_active;
		char cycling_changeover;
		char cacc_saw_newack;
	} cacc;
	__u64 hb_nonce;
	struct callback_head rcu;
};

struct sctp_datamsg {
	struct list_head chunks;
	refcount_t refcnt;
	long unsigned int expires_at;
	int send_error;
	u8 send_failed: 1;
	u8 can_delay: 1;
	u8 abandoned: 1;
};

struct sctp_stream_priorities {
	struct list_head prio_sched;
	struct list_head active;
	struct sctp_stream_out_ext *next;
	__u16 prio;
};

struct sctp_stream_out_ext {
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	struct list_head outq;
	union {
		struct {
			struct list_head prio_list;
			struct sctp_stream_priorities *prio_head;
		};
		struct {
			struct list_head rr_list;
		};
	};
};

struct task_security_struct {
	u32 osid;
	u32 sid;
	u32 exec_sid;
	u32 create_sid;
	u32 keycreate_sid;
	u32 sockcreate_sid;
};

enum label_initialized {
	LABEL_INVALID = 0,
	LABEL_INITIALIZED = 1,
	LABEL_PENDING = 2,
};

struct inode_security_struct {
	struct inode *inode;
	struct list_head list;
	u32 task_sid;
	u32 sid;
	u16 sclass;
	unsigned char initialized;
	spinlock_t lock;
};

struct file_security_struct {
	u32 sid;
	u32 fown_sid;
	u32 isid;
	u32 pseqno;
};

struct superblock_security_struct {
	struct super_block *sb;
	u32 sid;
	u32 def_sid;
	u32 mntpoint_sid;
	short unsigned int behavior;
	short unsigned int flags;
	struct mutex lock;
	struct list_head isec_head;
	spinlock_t isec_lock;
};

struct msg_security_struct {
	u32 sid;
};

struct ipc_security_struct {
	u16 sclass;
	u32 sid;
};

struct sk_security_struct {
	enum {
		NLBL_UNSET = 0,
		NLBL_REQUIRE = 1,
		NLBL_LABELED = 2,
		NLBL_REQSKB = 3,
		NLBL_CONNLABELED = 4,
	} nlbl_state;
	struct netlbl_lsm_secattr *nlbl_secattr;
	u32 sid;
	u32 peer_sid;
	u16 sclass;
	enum {
		SCTP_ASSOC_UNSET = 0,
		SCTP_ASSOC_SET = 1,
	} sctp_assoc_state;
};

struct tun_security_struct {
	u32 sid;
};

struct key_security_struct {
	u32 sid;
};

struct bpf_security_struct {
	u32 sid;
};

struct perf_event_security_struct {
	u32 sid;
};

struct selinux_mnt_opts {
	const char *fscontext;
	const char *context;
	const char *rootcontext;
	const char *defcontext;
};

enum {
	Opt_error = 4294967295,
	Opt_context = 0,
	Opt_defcontext = 1,
	Opt_fscontext = 2,
	Opt_rootcontext = 3,
	Opt_seclabel = 4,
};

enum sel_inos {
	SEL_ROOT_INO = 2,
	SEL_LOAD = 3,
	SEL_ENFORCE = 4,
	SEL_CONTEXT = 5,
	SEL_ACCESS = 6,
	SEL_CREATE = 7,
	SEL_RELABEL = 8,
	SEL_USER = 9,
	SEL_POLICYVERS = 10,
	SEL_COMMIT_BOOLS = 11,
	SEL_MLS = 12,
	SEL_DISABLE = 13,
	SEL_MEMBER = 14,
	SEL_CHECKREQPROT = 15,
	SEL_COMPAT_NET = 16,
	SEL_REJECT_UNKNOWN = 17,
	SEL_DENY_UNKNOWN = 18,
	SEL_STATUS = 19,
	SEL_POLICY = 20,
	SEL_VALIDATE_TRANS = 21,
	SEL_INO_NEXT = 22,
};

struct selinux_fs_info {
	struct dentry *bool_dir;
	unsigned int bool_num;
	char **bool_pending_names;
	unsigned int *bool_pending_values;
	struct dentry *class_dir;
	long unsigned int last_class_ino;
	bool policy_opened;
	struct dentry *policycap_dir;
	long unsigned int last_ino;
	struct selinux_state *state;
	struct super_block *sb;
};

struct policy_load_memory {
	size_t len;
	void *data;
};

enum {
	SELNL_MSG_SETENFORCE = 16,
	SELNL_MSG_POLICYLOAD = 17,
	SELNL_MSG_MAX = 18,
};

enum selinux_nlgroups {
	SELNLGRP_NONE = 0,
	SELNLGRP_AVC = 1,
	__SELNLGRP_MAX = 2,
};

struct selnl_msg_setenforce {
	__s32 val;
};

struct selnl_msg_policyload {
	__u32 seqno;
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	__XFRM_MSG_MAX = 39,
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	__RTM_MAX = 115,
};

struct nlmsg_perm {
	u16 nlmsg_type;
	u32 perm;
};

struct netif_security_struct {
	struct net *ns;
	int ifindex;
	u32 sid;
};

struct sel_netif {
	struct list_head list;
	struct netif_security_struct nsec;
	struct callback_head callback_head;
};

struct netnode_security_struct {
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} addr;
	u32 sid;
	u16 family;
};

struct sel_netnode_bkt {
	unsigned int size;
	struct list_head list;
};

struct sel_netnode {
	struct netnode_security_struct nsec;
	struct list_head list;
	struct callback_head rcu;
};

struct netport_security_struct {
	u32 sid;
	u16 port;
	u8 protocol;
};

struct sel_netport_bkt {
	int size;
	struct list_head list;
};

struct sel_netport {
	struct netport_security_struct psec;
	struct list_head list;
	struct callback_head rcu;
};

struct selinux_kernel_status {
	u32 version;
	u32 sequence;
	u32 enforcing;
	u32 policyload;
	u32 deny_unknown;
};

struct ebitmap_node {
	struct ebitmap_node *next;
	long unsigned int maps[6];
	u32 startbit;
};

struct ebitmap {
	struct ebitmap_node *node;
	u32 highbit;
};

struct policy_file {
	char *data;
	size_t len;
};

struct hashtab_node {
	void *key;
	void *datum;
	struct hashtab_node *next;
};

struct hashtab {
	struct hashtab_node **htable;
	u32 size;
	u32 nel;
};

struct hashtab_info {
	u32 slots_used;
	u32 max_chain_len;
};

struct hashtab_key_params {
	u32 (*hash)(const void *);
	int (*cmp)(const void *, const void *);
};

struct symtab {
	struct hashtab table;
	u32 nprim;
};

struct mls_level {
	u32 sens;
	struct ebitmap cat;
};

struct mls_range {
	struct mls_level level[2];
};

struct context___2 {
	u32 user;
	u32 role;
	u32 type;
	u32 len;
	struct mls_range range;
	char *str;
};

struct sidtab_str_cache;

struct sidtab_entry {
	u32 sid;
	u32 hash;
	struct context___2 context;
	struct sidtab_str_cache *cache;
	struct hlist_node list;
};

struct sidtab_str_cache {
	struct callback_head rcu_member;
	struct list_head lru_member;
	struct sidtab_entry *parent;
	u32 len;
	char str[0];
};

struct sidtab_node_inner;

struct sidtab_node_leaf;

union sidtab_entry_inner {
	struct sidtab_node_inner *ptr_inner;
	struct sidtab_node_leaf *ptr_leaf;
};

struct sidtab_node_inner {
	union sidtab_entry_inner entries[512];
};

struct sidtab_node_leaf {
	struct sidtab_entry entries[39];
};

struct sidtab_isid_entry {
	int set;
	struct sidtab_entry entry;
};

struct sidtab;

struct sidtab_convert_params {
	int (*func)(struct context___2 *, struct context___2 *, void *);
	void *args;
	struct sidtab *target;
};

struct sidtab {
	union sidtab_entry_inner roots[4];
	u32 count;
	struct sidtab_convert_params *convert;
	spinlock_t lock;
	u32 cache_free_slots;
	struct list_head cache_lru_list;
	spinlock_t cache_lock;
	struct sidtab_isid_entry isids[27];
	struct hlist_head context_to_sid[512];
};

struct avtab_key {
	u16 source_type;
	u16 target_type;
	u16 target_class;
	u16 specified;
};

struct avtab_extended_perms {
	u8 specified;
	u8 driver;
	struct extended_perms_data perms;
};

struct avtab_datum {
	union {
		u32 data;
		struct avtab_extended_perms *xperms;
	} u;
};

struct avtab_node {
	struct avtab_key key;
	struct avtab_datum datum;
	struct avtab_node *next;
};

struct avtab {
	struct avtab_node **htable;
	u32 nel;
	u32 nslot;
	u32 mask;
};

struct type_set;

struct constraint_expr {
	u32 expr_type;
	u32 attr;
	u32 op;
	struct ebitmap names;
	struct type_set *type_names;
	struct constraint_expr *next;
};

struct type_set {
	struct ebitmap types;
	struct ebitmap negset;
	u32 flags;
};

struct constraint_node {
	u32 permissions;
	struct constraint_expr *expr;
	struct constraint_node *next;
};

struct common_datum {
	u32 value;
	struct symtab permissions;
};

struct class_datum {
	u32 value;
	char *comkey;
	struct common_datum *comdatum;
	struct symtab permissions;
	struct constraint_node *constraints;
	struct constraint_node *validatetrans;
	char default_user;
	char default_role;
	char default_type;
	char default_range;
};

struct role_datum {
	u32 value;
	u32 bounds;
	struct ebitmap dominates;
	struct ebitmap types;
};

struct role_allow {
	u32 role;
	u32 new_role;
	struct role_allow *next;
};

struct type_datum {
	u32 value;
	u32 bounds;
	unsigned char primary;
	unsigned char attribute;
};

struct user_datum {
	u32 value;
	u32 bounds;
	struct ebitmap roles;
	struct mls_range range;
	struct mls_level dfltlevel;
};

struct cond_bool_datum {
	__u32 value;
	int state;
};

struct ocontext {
	union {
		char *name;
		struct {
			u8 protocol;
			u16 low_port;
			u16 high_port;
		} port;
		struct {
			u32 addr;
			u32 mask;
		} node;
		struct {
			u32 addr[4];
			u32 mask[4];
		} node6;
		struct {
			u64 subnet_prefix;
			u16 low_pkey;
			u16 high_pkey;
		} ibpkey;
		struct {
			char *dev_name;
			u8 port;
		} ibendport;
	} u;
	union {
		u32 sclass;
		u32 behavior;
	} v;
	struct context___2 context[2];
	u32 sid[2];
	struct ocontext *next;
};

struct genfs {
	char *fstype;
	struct ocontext *head;
	struct genfs *next;
};

struct cond_node;

struct policydb {
	int mls_enabled;
	struct symtab symtab[8];
	char **sym_val_to_name[8];
	struct class_datum **class_val_to_struct;
	struct role_datum **role_val_to_struct;
	struct user_datum **user_val_to_struct;
	struct type_datum **type_val_to_struct;
	struct avtab te_avtab;
	struct hashtab role_tr;
	struct ebitmap filename_trans_ttypes;
	struct hashtab filename_trans;
	u32 compat_filename_trans_count;
	struct cond_bool_datum **bool_val_to_struct;
	struct avtab te_cond_avtab;
	struct cond_node *cond_list;
	u32 cond_list_len;
	struct role_allow *role_allow;
	struct ocontext *ocontexts[9];
	struct genfs *genfs;
	struct hashtab range_tr;
	struct ebitmap *type_attr_map_array;
	struct ebitmap policycaps;
	struct ebitmap permissive_map;
	size_t len;
	unsigned int policyvers;
	unsigned int reject_unknown: 1;
	unsigned int allow_unknown: 1;
	u16 process_class;
	u32 process_trans_perms;
};

struct perm_datum {
	u32 value;
};

struct role_trans_key {
	u32 role;
	u32 type;
	u32 tclass;
};

struct role_trans_datum {
	u32 new_role;
};

struct filename_trans_key {
	u32 ttype;
	u16 tclass;
	const char *name;
};

struct filename_trans_datum {
	struct ebitmap stypes;
	u32 otype;
	struct filename_trans_datum *next;
};

struct level_datum {
	struct mls_level *level;
	unsigned char isalias;
};

struct cat_datum {
	u32 value;
	unsigned char isalias;
};

struct range_trans {
	u32 source_type;
	u32 target_type;
	u32 target_class;
};

struct cond_expr_node;

struct cond_expr {
	struct cond_expr_node *nodes;
	u32 len;
};

struct cond_av_list {
	struct avtab_node **nodes;
	u32 len;
};

struct cond_node {
	int cur_state;
	struct cond_expr expr;
	struct cond_av_list true_list;
	struct cond_av_list false_list;
};

struct policy_data {
	struct policydb *p;
	void *fp;
};

struct cond_expr_node {
	u32 expr_type;
	u32 bool;
};

struct policydb_compat_info {
	int version;
	int sym_num;
	int ocon_num;
};

struct selinux_mapping;

struct selinux_map {
	struct selinux_mapping *mapping;
	u16 size;
};

struct selinux_policy {
	struct sidtab *sidtab;
	struct policydb policydb;
	struct selinux_map map;
	u32 latest_granting;
};

struct selinux_mapping {
	u16 value;
	unsigned int num_perms;
	u32 perms[32];
};

struct convert_context_args {
	struct selinux_state *state;
	struct policydb *oldp;
	struct policydb *newp;
};

struct selinux_audit_rule {
	u32 au_seqno;
	struct context___2 au_ctxt;
};

struct cond_insertf_data {
	struct policydb *p;
	struct avtab_node **dst;
	struct cond_av_list *other;
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	unsigned int hash;
	struct sockaddr_un name[0];
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	long: 32;
	long: 64;
	long: 64;
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short int type;
	short int access;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
};

enum integrity_status {
	INTEGRITY_PASS = 0,
	INTEGRITY_PASS_IMMUTABLE = 1,
	INTEGRITY_FAIL = 2,
	INTEGRITY_NOLABEL = 3,
	INTEGRITY_NOXATTRS = 4,
	INTEGRITY_UNKNOWN = 5,
};

struct ima_digest_data {
	u8 algo;
	u8 length;
	union {
		struct {
			u8 unused;
			u8 type;
		} sha1;
		struct {
			u8 type;
			u8 algo;
		} ng;
		u8 data[2];
	} xattr;
	u8 digest[0];
};

struct integrity_iint_cache {
	struct rb_node rb_node;
	struct mutex mutex;
	struct inode *inode;
	u64 version;
	long unsigned int flags;
	long unsigned int measured_pcrs;
	long unsigned int atomic_flags;
	enum integrity_status ima_file_status: 4;
	enum integrity_status ima_mmap_status: 4;
	enum integrity_status ima_bprm_status: 4;
	enum integrity_status ima_read_status: 4;
	enum integrity_status ima_creds_status: 4;
	enum integrity_status evm_status: 4;
	struct ima_digest_data *ima_hash;
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

struct evm_ima_xattr_data {
	u8 type;
	u8 data[0];
};

enum ima_show_type {
	IMA_SHOW_BINARY = 0,
	IMA_SHOW_BINARY_NO_FIELD_LEN = 1,
	IMA_SHOW_BINARY_OLD_STRING_FMT = 2,
	IMA_SHOW_ASCII = 3,
};

struct modsig;

struct ima_event_data {
	struct integrity_iint_cache *iint;
	struct file *file;
	const unsigned char *filename;
	struct evm_ima_xattr_data *xattr_value;
	int xattr_len;
	const struct modsig *modsig;
	const char *violation;
	const void *buf;
	int buf_len;
};

struct ima_field_data {
	u8 *data;
	u32 len;
};

struct ima_template_field {
	const char field_id[16];
	int (*field_init)(struct ima_event_data *, struct ima_field_data *);
	void (*field_show)(struct seq_file *, enum ima_show_type, struct ima_field_data *);
};

struct ima_template_desc {
	struct list_head list;
	char *name;
	char *fmt;
	int num_fields;
	const struct ima_template_field **fields;
};

struct ima_template_entry {
	int pcr;
	struct tpm_digest *digests;
	struct ima_template_desc *template_desc;
	u32 template_data_len;
	struct ima_field_data template_data[0];
};

struct ima_queue_entry {
	struct hlist_node hnext;
	struct list_head later;
	struct ima_template_entry *entry;
};

struct ima_h_table {
	atomic_long_t len;
	atomic_long_t violations;
	struct hlist_head queue[1024];
};

enum ima_fs_flags {
	IMA_FS_BUSY = 0,
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

struct tpm_bank_info {
	u16 alg_id;
	u16 digest_size;
	u16 crypto_id;
};

struct tpm_chip;

struct tpm_class_ops {
	unsigned int flags;
	const u8 req_complete_mask;
	const u8 req_complete_val;
	bool (*req_canceled)(struct tpm_chip *, u8);
	int (*recv)(struct tpm_chip *, u8 *, size_t);
	int (*send)(struct tpm_chip *, u8 *, size_t);
	void (*cancel)(struct tpm_chip *);
	u8 (*status)(struct tpm_chip *);
	void (*update_timeouts)(struct tpm_chip *, long unsigned int *);
	void (*update_durations)(struct tpm_chip *, long unsigned int *);
	int (*go_idle)(struct tpm_chip *);
	int (*cmd_ready)(struct tpm_chip *);
	int (*request_locality)(struct tpm_chip *, int);
	int (*relinquish_locality)(struct tpm_chip *, int);
	void (*clk_enable)(struct tpm_chip *, bool);
};

struct tpm_bios_log {
	void *bios_event_log;
	void *bios_event_log_end;
};

struct tpm_chip_seqops {
	struct tpm_chip *chip;
	const struct seq_operations *seqops;
};

struct tpm_space {
	u32 context_tbl[3];
	u8 *context_buf;
	u32 session_tbl[3];
	u8 *session_buf;
	u32 buf_size;
};

struct tpm_chip {
	struct device dev;
	struct device devs;
	struct cdev cdev;
	struct cdev cdevs;
	struct rw_semaphore ops_sem;
	const struct tpm_class_ops *ops;
	struct tpm_bios_log log;
	struct tpm_chip_seqops bin_log_seqops;
	struct tpm_chip_seqops ascii_log_seqops;
	unsigned int flags;
	int dev_num;
	long unsigned int is_open;
	char hwrng_name[64];
	struct hwrng hwrng;
	struct mutex tpm_mutex;
	long unsigned int timeout_a;
	long unsigned int timeout_b;
	long unsigned int timeout_c;
	long unsigned int timeout_d;
	bool timeout_adjusted;
	long unsigned int duration[4];
	bool duration_adjusted;
	struct dentry *bios_dir[3];
	const struct attribute_group *groups[3];
	unsigned int groups_cnt;
	u32 nr_allocated_banks;
	struct tpm_bank_info *allocated_banks;
	acpi_handle acpi_dev_handle;
	char ppi_version[4];
	struct tpm_space work_space;
	u32 last_cc;
	u32 nr_commands;
	u32 *cc_attrs_tbl;
	int locality;
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

enum evm_ima_xattr_type {
	IMA_XATTR_DIGEST = 1,
	EVM_XATTR_HMAC = 2,
	EVM_IMA_XATTR_DIGSIG = 3,
	IMA_XATTR_DIGEST_NG = 4,
	EVM_XATTR_PORTABLE_DIGSIG = 5,
	IMA_XATTR_LAST = 6,
};

enum ima_hooks {
	NONE___2 = 0,
	FILE_CHECK = 1,
	MMAP_CHECK = 2,
	BPRM_CHECK = 3,
	CREDS_CHECK = 4,
	POST_SETATTR = 5,
	MODULE_CHECK = 6,
	FIRMWARE_CHECK = 7,
	KEXEC_KERNEL_CHECK = 8,
	KEXEC_INITRAMFS_CHECK = 9,
	POLICY_CHECK = 10,
	KEXEC_CMDLINE = 11,
	KEY_CHECK = 12,
	MAX_CHECK = 13,
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	void *__ctx[0];
};

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	struct crypto_tfm base;
};

enum tpm_algorithms {
	TPM_ALG_ERROR = 0,
	TPM_ALG_SHA1 = 4,
	TPM_ALG_KEYEDHASH = 8,
	TPM_ALG_SHA256 = 11,
	TPM_ALG_SHA384 = 12,
	TPM_ALG_SHA512 = 13,
	TPM_ALG_NULL = 16,
	TPM_ALG_SM3_256 = 18,
};

enum tpm_pcrs {
	TPM_PCR0 = 0,
	TPM_PCR8 = 8,
	TPM_PCR10 = 10,
};

struct ima_algo_desc {
	struct crypto_shash *tfm;
	enum hash_algo algo;
};

enum lsm_rule_types {
	LSM_OBJ_USER = 0,
	LSM_OBJ_ROLE = 1,
	LSM_OBJ_TYPE = 2,
	LSM_SUBJ_USER = 3,
	LSM_SUBJ_ROLE = 4,
	LSM_SUBJ_TYPE = 5,
};

enum policy_types {
	ORIGINAL_TCB = 1,
	DEFAULT_TCB = 2,
};

enum policy_rule_list {
	IMA_DEFAULT_POLICY = 1,
	IMA_CUSTOM_POLICY = 2,
};

struct ima_rule_opt_list {
	size_t count;
	char *items[0];
};

struct ima_rule_entry {
	struct list_head list;
	int action;
	unsigned int flags;
	enum ima_hooks func;
	int mask;
	long unsigned int fsmagic;
	uuid_t fsuuid;
	kuid_t uid;
	kuid_t fowner;
	bool (*uid_op)(kuid_t, kuid_t);
	bool (*fowner_op)(kuid_t, kuid_t);
	int pcr;
	struct {
		void *rule;
		char *args_p;
		int type;
	} lsm[6];
	char *fsname;
	struct ima_rule_opt_list *keyrings;
	struct ima_template_desc *template;
};

enum {
	Opt_measure = 0,
	Opt_dont_measure = 1,
	Opt_appraise = 2,
	Opt_dont_appraise = 3,
	Opt_audit = 4,
	Opt_hash___2 = 5,
	Opt_dont_hash = 6,
	Opt_obj_user = 7,
	Opt_obj_role = 8,
	Opt_obj_type = 9,
	Opt_subj_user = 10,
	Opt_subj_role = 11,
	Opt_subj_type = 12,
	Opt_func = 13,
	Opt_mask = 14,
	Opt_fsmagic = 15,
	Opt_fsname = 16,
	Opt_fsuuid = 17,
	Opt_uid_eq = 18,
	Opt_euid_eq = 19,
	Opt_fowner_eq = 20,
	Opt_uid_gt = 21,
	Opt_euid_gt = 22,
	Opt_fowner_gt = 23,
	Opt_uid_lt = 24,
	Opt_euid_lt = 25,
	Opt_fowner_lt = 26,
	Opt_appraise_type = 27,
	Opt_appraise_flag = 28,
	Opt_permit_directio = 29,
	Opt_pcr = 30,
	Opt_template = 31,
	Opt_keyrings = 32,
	Opt_err___9 = 33,
};

enum {
	mask_exec = 0,
	mask_write = 1,
	mask_read = 2,
	mask_append = 3,
};

struct ima_kexec_hdr {
	u16 version;
	u16 _reserved0;
	u32 _reserved1;
	u64 buffer_size;
	u64 count;
};

enum header_fields {
	HDR_PCR = 0,
	HDR_DIGEST = 1,
	HDR_TEMPLATE_NAME = 2,
	HDR_TEMPLATE_DATA = 3,
	HDR__LAST = 4,
};

enum data_formats {
	DATA_FMT_DIGEST = 0,
	DATA_FMT_DIGEST_WITH_ALGO = 1,
	DATA_FMT_STRING = 2,
	DATA_FMT_HEX = 3,
};

struct ima_key_entry {
	struct list_head list;
	void *payload;
	size_t payload_len;
	char *keyring_name;
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	void *__ctx[0];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct crypto_comp {
	struct crypto_tfm base;
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	CRYPTOA_U32 = 3,
	__CRYPTOA_MAX = 4,
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_attr_u32 {
	u32 num;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	void *__ctx[0];
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	void *__ctx[0];
};

struct crypto_skcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	struct crypto_alg base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	struct hash_alg_common halg;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	union {
		struct {
			char head[88];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	void *ubuf[0];
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	union {
		struct {
			char head[96];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	union {
		struct {
			char head[80];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct crypto_kpp {
	struct crypto_tfm base;
};

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	unsigned int reqsize;
	struct crypto_alg base;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
};

struct asn1_decoder___2;

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	union {
		struct rtattr attr;
		struct {
			struct rtattr attr;
			struct crypto_attr_alg data;
		} alg;
		struct {
			struct rtattr attr;
			struct crypto_attr_u32 data;
		} nu32;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct cmac_tfm_ctx {
	struct crypto_cipher *child;
	u8 ctx[0];
};

struct cmac_desc_ctx {
	unsigned int len;
	u8 ctx[0];
};

struct hmac_ctx {
	struct crypto_shash *hash;
};

struct md5_state {
	u32 hash[4];
	u32 block[16];
	u64 byte_count;
};

struct sha1_state {
	u32 state[5];
	u64 count;
	u8 buffer[64];
};

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

enum blake2b_constant {
	BLAKE2B_BLOCKBYTES = 128,
	BLAKE2B_KEYBYTES = 64,
};

struct blake2b_state {
	u64 h[8];
	u64 t[2];
	u64 f[2];
	u8 buf[128];
	size_t buflen;
};

struct blake2b_tfm_ctx {
	u8 key[64];
	unsigned int keylen;
};

typedef struct {
	u64 a;
	u64 b;
} u128;

typedef struct {
	__be64 a;
	__be64 b;
} be128;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	struct skcipher_request subreq;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct aead_request subreq;
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher *null;
	u8 nonce[4];
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct ccm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn mac;
};

struct crypto_ccm_ctx {
	struct crypto_ahash *mac;
	struct crypto_skcipher *ctr;
};

struct crypto_rfc4309_ctx {
	struct crypto_aead *child;
	u8 nonce[3];
};

struct crypto_rfc4309_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct aead_request subreq;
};

struct crypto_ccm_req_priv_ctx {
	u8 odata[16];
	u8 idata[16];
	u8 auth_tag[16];
	u32 flags;
	struct scatterlist src[3];
	struct scatterlist dst[3];
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	};
};

struct cbcmac_tfm_ctx {
	struct crypto_cipher *child;
};

struct cbcmac_desc_ctx {
	unsigned int len;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct chksum_desc_ctx___2 {
	__u16 crc;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct xxhash64_tfm_ctx {
	u64 seed;
};

struct xxhash64_desc_ctx {
	struct xxh64_state xxhstate;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct random_ready_callback {
	struct list_head list;
	void (*func)(struct random_ready_callback *);
	struct module *owner;
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

typedef uint32_t drbg_flag_t;

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_state;

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	bool seeded;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct work_struct seed_work;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
	struct random_ready_callback random_ready;
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct rand_data {
	__u64 data;
	__u64 old_data;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	int rct_count;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int apt_base_set: 1;
	unsigned int health_failure: 1;
};

struct rand_data___2;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data___2 *entropy_collector;
	unsigned int reset_cnt;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx {
	u8 buffer[16];
	u32 bytes;
};

struct sockaddr_alg {
	__u16 salg_family;
	__u8 salg_type[14];
	__u32 salg_feat;
	__u32 salg_mask;
	__u8 salg_name[64];
};

struct af_alg_iv {
	__u32 ivlen;
	__u8 iv[0];
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct af_alg_type;

struct alg_sock {
	struct sock sk;
	struct sock *parent;
	atomic_t refcnt;
	atomic_t nokey_refcnt;
	const struct af_alg_type *type;
	void *private;
};

struct af_alg_type {
	void * (*bind)(const char *, u32, u32);
	void (*release)(void *);
	int (*setkey)(void *, const u8 *, unsigned int);
	int (*setentropy)(void *, sockptr_t, unsigned int);
	int (*accept)(void *, struct sock *);
	int (*accept_nokey)(void *, struct sock *);
	int (*setauthsize)(void *, unsigned int);
	struct proto_ops *ops;
	struct proto_ops *ops_nokey;
	struct module *owner;
	char name[14];
};

struct af_alg_control {
	struct af_alg_iv *iv;
	int op;
	unsigned int aead_assoclen;
};

struct af_alg_sgl {
	struct scatterlist sg[17];
	struct page *pages[16];
	unsigned int npages;
};

struct af_alg_tsgl {
	struct list_head list;
	unsigned int cur;
	struct scatterlist sg[0];
};

struct af_alg_rsgl {
	struct af_alg_sgl sgl;
	struct list_head list;
	size_t sg_num_bytes;
};

struct af_alg_async_req {
	struct kiocb *iocb;
	struct sock *sk;
	struct af_alg_rsgl first_rsgl;
	struct af_alg_rsgl *last_rsgl;
	struct list_head rsgl_list;
	struct scatterlist *tsgl;
	unsigned int tsgl_entries;
	unsigned int outlen;
	unsigned int areqlen;
	union {
		struct aead_request aead_req;
		struct skcipher_request skcipher_req;
	} cra_u;
};

struct af_alg_ctx {
	struct list_head tsgl_list;
	void *iv;
	size_t aead_assoclen;
	struct crypto_wait wait;
	size_t used;
	atomic_t rcvused;
	bool more;
	bool merge;
	bool enc;
	bool init;
	unsigned int len;
};

struct alg_type_list {
	const struct af_alg_type *type;
	struct list_head list;
};

struct hash_ctx {
	struct af_alg_sgl sgl;
	u8 *result;
	struct crypto_wait wait;
	unsigned int len;
	bool more;
	struct ahash_request req;
};

struct xor_block_template {
	struct xor_block_template *next;
	const char *name;
	int speed;
	void (*do_2)(long unsigned int, long unsigned int *, long unsigned int *);
	void (*do_3)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	void (*do_4)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
	void (*do_5)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[2];
};

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[2];
	u8 *s;
	u32 s_size;
	u8 *digest;
	u8 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
	const void *data;
	unsigned int data_size;
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecdsa_with_sha1 = 2,
	OID_id_ecPublicKey = 3,
	OID_rsaEncryption = 4,
	OID_md2WithRSAEncryption = 5,
	OID_md3WithRSAEncryption = 6,
	OID_md4WithRSAEncryption = 7,
	OID_sha1WithRSAEncryption = 8,
	OID_sha256WithRSAEncryption = 9,
	OID_sha384WithRSAEncryption = 10,
	OID_sha512WithRSAEncryption = 11,
	OID_sha224WithRSAEncryption = 12,
	OID_data = 13,
	OID_signed_data = 14,
	OID_email_address = 15,
	OID_contentType = 16,
	OID_messageDigest = 17,
	OID_signingTime = 18,
	OID_smimeCapabilites = 19,
	OID_smimeAuthenticatedAttrs = 20,
	OID_md2 = 21,
	OID_md4 = 22,
	OID_md5 = 23,
	OID_msIndirectData = 24,
	OID_msStatementType = 25,
	OID_msSpOpusInfo = 26,
	OID_msPeImageDataObjId = 27,
	OID_msIndividualSPKeyPurpose = 28,
	OID_msOutlookExpress = 29,
	OID_certAuthInfoAccess = 30,
	OID_sha1 = 31,
	OID_sha256 = 32,
	OID_sha384 = 33,
	OID_sha512 = 34,
	OID_sha224 = 35,
	OID_commonName = 36,
	OID_surname = 37,
	OID_countryName = 38,
	OID_locality = 39,
	OID_stateOrProvinceName = 40,
	OID_organizationName = 41,
	OID_organizationUnitName = 42,
	OID_title = 43,
	OID_description = 44,
	OID_name = 45,
	OID_givenName = 46,
	OID_initials = 47,
	OID_generationalQualifier = 48,
	OID_subjectKeyIdentifier = 49,
	OID_keyUsage = 50,
	OID_subjectAltName = 51,
	OID_issuerAltName = 52,
	OID_basicConstraints = 53,
	OID_crlDistributionPoints = 54,
	OID_certPolicies = 55,
	OID_authorityKeyIdentifier = 56,
	OID_extKeyUsage = 57,
	OID_gostCPSignA = 58,
	OID_gostCPSignB = 59,
	OID_gostCPSignC = 60,
	OID_gost2012PKey256 = 61,
	OID_gost2012PKey512 = 62,
	OID_gost2012Digest256 = 63,
	OID_gost2012Digest512 = 64,
	OID_gost2012Signature256 = 65,
	OID_gost2012Signature512 = 66,
	OID_gostTC26Sign256A = 67,
	OID_gostTC26Sign256B = 68,
	OID_gostTC26Sign256C = 69,
	OID_gostTC26Sign256D = 70,
	OID_gostTC26Sign512A = 71,
	OID_gostTC26Sign512B = 72,
	OID_gostTC26Sign512C = 73,
	OID_sm2 = 74,
	OID_sm3 = 75,
	OID_SM2_with_SM3 = 76,
	OID_sm3WithRSAEncryption = 77,
	OID__NR = 78,
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_pkey_algo = 7,
	ACT_x509_note_serial = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_key;
	bool unsupported_sig;
	bool blacklisted;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *cert_start;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID algo_oid;
	unsigned char nr_mpi;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct pkcs7_message___2 {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message___2 *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PREEMPT = 8,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_bio_bounce {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio_merge {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_queue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_get_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_complete {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_bounce {};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio_merge {};

struct trace_event_data_offsets_block_bio_queue {};

struct trace_event_data_offsets_block_get_rq {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, int, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct request_queue *, struct request *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct request_queue *, struct request *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_sleeprq)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct request_queue *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct request_queue *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request_queue *, struct request *, dev_t, sector_t);

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 5000,
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct rq_map_data {
	struct page **pages;
	int page_order;
	int nr_entries;
	long unsigned int offset;
	int null_mapped;
	int from_user;
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

struct mq_inflight {
	struct hd_struct *part;
	unsigned int inflight[2];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

typedef bool busy_iter_fn(struct blk_mq_hw_ctx *, struct request *, void *, bool);

typedef bool busy_tag_iter_fn(struct request *, void *, bool);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	busy_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	bool enable_accounting;
};

struct blk_mq_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_ctx *, char *);
	ssize_t (*store)(struct blk_mq_ctx *, const char *, size_t);
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

typedef u32 compat_caddr_t;

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct compat_blkpg_ioctl_arg {
	compat_int_t op;
	compat_int_t flags;
	compat_int_t datalen;
	compat_caddr_t data;
};

struct compat_hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	u32 start;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct disk_part_iter {
	struct gendisk *disk;
	struct hd_struct *part;
	int idx;
	unsigned int flags;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct parsed_partitions {
	struct block_device *bdev;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct page *v;
} Sector;

struct RigidDiskBlock {
	__u32 rdb_ID;
	__be32 rdb_SummedLongs;
	__s32 rdb_ChkSum;
	__u32 rdb_HostID;
	__be32 rdb_BlockBytes;
	__u32 rdb_Flags;
	__u32 rdb_BadBlockList;
	__be32 rdb_PartitionList;
	__u32 rdb_FileSysHeaderList;
	__u32 rdb_DriveInit;
	__u32 rdb_Reserved1[6];
	__u32 rdb_Cylinders;
	__u32 rdb_Sectors;
	__u32 rdb_Heads;
	__u32 rdb_Interleave;
	__u32 rdb_Park;
	__u32 rdb_Reserved2[3];
	__u32 rdb_WritePreComp;
	__u32 rdb_ReducedWrite;
	__u32 rdb_StepRate;
	__u32 rdb_Reserved3[5];
	__u32 rdb_RDBBlocksLo;
	__u32 rdb_RDBBlocksHi;
	__u32 rdb_LoCylinder;
	__u32 rdb_HiCylinder;
	__u32 rdb_CylBlocks;
	__u32 rdb_AutoParkSeconds;
	__u32 rdb_HighRDSKBlock;
	__u32 rdb_Reserved4;
	char rdb_DiskVendor[8];
	char rdb_DiskProduct[16];
	char rdb_DiskRevision[4];
	char rdb_ControllerVendor[8];
	char rdb_ControllerProduct[16];
	char rdb_ControllerRevision[4];
	__u32 rdb_Reserved5[10];
};

struct PartitionBlock {
	__be32 pb_ID;
	__be32 pb_SummedLongs;
	__s32 pb_ChkSum;
	__u32 pb_HostID;
	__be32 pb_Next;
	__u32 pb_Flags;
	__u32 pb_Reserved1[2];
	__u32 pb_DevFlags;
	__u8 pb_DriveName[32];
	__u32 pb_Reserved2[15];
	__be32 pb_Environment[17];
	__u32 pb_EReserved[15];
};

struct mac_partition {
	__be16 signature;
	__be16 res1;
	__be32 map_count;
	__be32 start_block;
	__be32 block_count;
	char name[32];
	char type[32];
	__be32 data_start;
	__be32 data_count;
	__be32 status;
	__be32 boot_start;
	__be32 boot_size;
	__be32 boot_load;
	__be32 boot_load2;
	__be32 boot_entry;
	__be32 boot_entry2;
	__be32 boot_cksum;
	char processor[16];
};

struct mac_driver_desc {
	__be16 signature;
	__be16 block_size;
	__be32 block_count;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

struct solaris_x86_slice {
	__le16 s_tag;
	__le16 s_flag;
	__le32 s_start;
	__le32 s_size;
};

struct solaris_x86_vtoc {
	unsigned int v_bootinfo[3];
	__le32 v_sanity;
	__le32 v_version;
	char v_volume[8];
	__le16 v_sectorsz;
	__le16 v_nparts;
	unsigned int v_reserved[10];
	struct solaris_x86_slice v_slice[16];
	unsigned int timestamp[16];
	char v_asciilabel[128];
};

struct bsd_partition {
	__le32 p_size;
	__le32 p_offset;
	__le32 p_fsize;
	__u8 p_fstype;
	__u8 p_frag;
	__le16 p_cpg;
};

struct bsd_disklabel {
	__le32 d_magic;
	__s16 d_type;
	__s16 d_subtype;
	char d_typename[16];
	char d_packname[16];
	__u32 d_secsize;
	__u32 d_nsectors;
	__u32 d_ntracks;
	__u32 d_ncylinders;
	__u32 d_secpercyl;
	__u32 d_secperunit;
	__u16 d_sparespertrack;
	__u16 d_sparespercyl;
	__u32 d_acylinders;
	__u16 d_rpm;
	__u16 d_interleave;
	__u16 d_trackskew;
	__u16 d_cylskew;
	__u32 d_headswitch;
	__u32 d_trkseek;
	__u32 d_flags;
	__u32 d_drivedata[5];
	__u32 d_spare[5];
	__le32 d_magic2;
	__le16 d_checksum;
	__le16 d_npartitions;
	__le32 d_bbsize;
	__le32 d_sbsize;
	struct bsd_partition d_partitions[16];
};

struct unixware_slice {
	__le16 s_label;
	__le16 s_flags;
	__le32 start_sect;
	__le32 nr_sects;
};

struct unixware_vtoc {
	__le32 v_magic;
	__le32 v_version;
	char v_name[8];
	__le16 v_nslices;
	__le16 v_unknown1;
	__le32 v_reserved[10];
	struct unixware_slice v_slice[16];
};

struct unixware_disklabel {
	__le32 d_type;
	__le32 d_magic;
	__le32 d_version;
	char d_serial[12];
	__le32 d_ncylinders;
	__le32 d_ntracks;
	__le32 d_nsectors;
	__le32 d_secsize;
	__le32 d_part_start;
	__le32 d_unknown1[12];
	__le32 d_alt_tbl;
	__le32 d_alt_len;
	__le32 d_phys_cyl;
	__le32 d_phys_trk;
	__le32 d_phys_sec;
	__le32 d_phys_bytes;
	__le32 d_unknown2;
	__le32 d_unknown3;
	__le32 d_pad[8];
	struct unixware_vtoc vtoc;
};

struct d_partition {
	__le32 p_size;
	__le32 p_offset;
	__le32 p_fsize;
	u8 p_fstype;
	u8 p_frag;
	__le16 p_cpg;
};

struct disklabel {
	__le32 d_magic;
	__le16 d_type;
	__le16 d_subtype;
	u8 d_typename[16];
	u8 d_packname[16];
	__le32 d_secsize;
	__le32 d_nsectors;
	__le32 d_ntracks;
	__le32 d_ncylinders;
	__le32 d_secpercyl;
	__le32 d_secprtunit;
	__le16 d_sparespertrack;
	__le16 d_sparespercyl;
	__le32 d_acylinders;
	__le16 d_rpm;
	__le16 d_interleave;
	__le16 d_trackskew;
	__le16 d_cylskew;
	__le32 d_headswitch;
	__le32 d_trkseek;
	__le32 d_flags;
	__le32 d_drivedata[5];
	__le32 d_spare[5];
	__le32 d_magic2;
	__le16 d_checksum;
	__le16 d_npartitions;
	__le32 d_bbsize;
	__le32 d_sbsize;
	struct d_partition d_partitions[18];
};

enum {
	LINUX_RAID_PARTITION___2 = 253,
};

struct sgi_volume {
	s8 name[8];
	__be32 block_num;
	__be32 num_bytes;
};

struct sgi_partition {
	__be32 num_blocks;
	__be32 first_block;
	__be32 type;
};

struct sgi_disklabel {
	__be32 magic_mushroom;
	__be16 root_part_num;
	__be16 swap_part_num;
	s8 boot_file[16];
	u8 _unused0[48];
	struct sgi_volume volume[15];
	struct sgi_partition partitions[16];
	__be32 csum;
	__be32 _unused1;
};

enum {
	SUN_WHOLE_DISK = 5,
	LINUX_RAID_PARTITION___3 = 253,
};

struct sun_info {
	__be16 id;
	__be16 flags;
};

struct sun_vtoc {
	__be32 version;
	char volume[8];
	__be16 nparts;
	struct sun_info infos[8];
	__be16 padding;
	__be32 bootinfo[3];
	__be32 sanity;
	__be32 reserved[10];
	__be32 timestamp[8];
};

struct sun_partition {
	__be32 start_cylinder;
	__be32 num_sectors;
};

struct sun_disklabel {
	unsigned char info[128];
	struct sun_vtoc vtoc;
	__be32 write_reinstruct;
	__be32 read_reinstruct;
	unsigned char spare[148];
	__be16 rspeed;
	__be16 pcylcount;
	__be16 sparecyl;
	__be16 obs1;
	__be16 obs2;
	__be16 ilfact;
	__be16 ncyl;
	__be16 nacyl;
	__be16 ntrks;
	__be16 nsect;
	__be16 obs3;
	__be16 obs4;
	struct sun_partition partitions[8];
	__be16 magic;
	__be16 csum;
};

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct d_partition___2 {
	__le32 p_res;
	u8 p_fstype;
	u8 p_res2[3];
	__le32 p_offset;
	__le32 p_size;
};

struct disklabel___2 {
	u8 d_reserved[270];
	struct d_partition___2 d_partitions[2];
	u8 d_blank[208];
	__le16 d_magic;
} __attribute__((packed));

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct scsi_request {
	unsigned char __cmd[16];
	unsigned char *cmd;
	short unsigned int cmd_len;
	int result;
	unsigned int sense_len;
	unsigned int resid_len;
	int retries;
	void *sense;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

struct compat_sg_io_hdr {
	compat_int_t interface_id;
	compat_int_t dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	compat_uint_t dxfer_len;
	compat_uint_t dxferp;
	compat_uptr_t cmdp;
	compat_uptr_t sbp;
	compat_uint_t timeout;
	compat_uint_t flags;
	compat_int_t pack_id;
	compat_uptr_t usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	compat_int_t resid;
	compat_uint_t duration;
	compat_uint_t info;
};

struct blk_cmd_filter {
	long unsigned int read_ok[4];
	long unsigned int write_ok[4];
};

struct compat_cdrom_generic_command {
	unsigned char cmd[12];
	compat_caddr_t buffer;
	compat_uint_t buflen;
	compat_int_t stat;
	compat_caddr_t sense;
	unsigned char data_direction;
	unsigned char pad[3];
	compat_int_t quiet;
	compat_int_t timeout;
	compat_caddr_t unused;
};

enum {
	OMAX_SB_LEN = 16,
};

struct bsg_device {
	struct request_queue *queue;
	spinlock_t lock;
	struct hlist_node dev_list;
	refcount_t ref_count;
	char name[20];
	int max_queue;
};

struct bsg_job;

typedef int bsg_job_fn(struct bsg_job *);

struct bsg_buffer {
	unsigned int payload_len;
	int sg_cnt;
	struct scatterlist *sg_list;
};

struct bsg_job {
	struct device *dev;
	struct kref kref;
	unsigned int timeout;
	void *request;
	void *reply;
	unsigned int request_len;
	unsigned int reply_len;
	struct bsg_buffer request_payload;
	struct bsg_buffer reply_payload;
	int result;
	unsigned int reply_payload_rcv_len;
	struct request *bidi_rq;
	struct bio *bidi_bio;
	void *dd_data;
};

typedef enum blk_eh_timer_return bsg_timeout_fn(struct request *);

struct bsg_set {
	struct blk_mq_tag_set tag_set;
	bsg_job_fn *job_fn;
	bsg_timeout_fn *timeout_fn;
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_init_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_bind_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(gfp_t, struct request_queue *, struct blkcg *);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef size_t blkcg_pol_stat_pd_fn(struct blkg_policy_data *, char *, size_t);

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_init_cpd_fn *cpd_init_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_bind_cpd_fn *cpd_bind_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
};

struct blkg_conf_ctx {
	struct gendisk *disk;
	struct blkcg_gq *blkg;
	char *body;
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

struct blkg_rwstat {
	struct percpu_counter cpu_cnt[5];
	atomic64_t aux_cnt[5];
};

struct blkg_rwstat_sample {
	u64 cnt[5];
};

struct throtl_service_queue {
	struct throtl_service_queue *parent_sq;
	struct list_head queued[2];
	unsigned int nr_queued[2];
	struct rb_root_cached pending_tree;
	unsigned int nr_pending;
	long unsigned int first_pending_disptime;
	struct timer_list pending_timer;
};

struct latency_bucket {
	long unsigned int total_latency;
	int samples;
};

struct avg_latency_bucket {
	long unsigned int latency;
	bool valid;
};

struct throtl_data {
	struct throtl_service_queue service_queue;
	struct request_queue *queue;
	unsigned int nr_queued[2];
	unsigned int throtl_slice;
	struct work_struct dispatch_work;
	unsigned int limit_index;
	bool limit_valid[2];
	long unsigned int low_upgrade_time;
	long unsigned int low_downgrade_time;
	unsigned int scale;
	struct latency_bucket tmp_buckets[18];
	struct avg_latency_bucket avg_buckets[18];
	struct latency_bucket *latency_buckets[2];
	long unsigned int last_calculate_time;
	long unsigned int filtered_latency;
	bool track_bio_latency;
};

struct throtl_grp;

struct throtl_qnode {
	struct list_head node;
	struct bio_list bios;
	struct throtl_grp *tg;
};

struct throtl_grp {
	struct blkg_policy_data pd;
	struct rb_node rb_node;
	struct throtl_data *td;
	struct throtl_service_queue service_queue;
	struct throtl_qnode qnode_on_self[2];
	struct throtl_qnode qnode_on_parent[2];
	long unsigned int disptime;
	unsigned int flags;
	bool has_rules[2];
	uint64_t bps[4];
	uint64_t bps_conf[4];
	unsigned int iops[4];
	unsigned int iops_conf[4];
	uint64_t bytes_disp[2];
	unsigned int io_disp[2];
	long unsigned int last_low_overflow_time[2];
	uint64_t last_bytes_disp[2];
	unsigned int last_io_disp[2];
	long unsigned int last_check_time;
	long unsigned int latency_target;
	long unsigned int latency_target_conf;
	long unsigned int slice_start[2];
	long unsigned int slice_end[2];
	long unsigned int last_finish_time;
	long unsigned int checked_last_finish_time;
	long unsigned int avg_idletime;
	long unsigned int idletime_threshold;
	long unsigned int idletime_threshold_conf;
	unsigned int bio_cnt;
	unsigned int bad_bio_cnt;
	long unsigned int bio_cnt_reset_time;
	struct blkg_rwstat stat_bytes;
	struct blkg_rwstat stat_ios;
};

enum tg_state_flags {
	THROTL_TG_PENDING = 1,
	THROTL_TG_WAS_EMPTY = 2,
};

enum {
	LIMIT_LOW = 0,
	LIMIT_MAX = 1,
	LIMIT_CNT = 2,
};

struct deadline_data {
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	struct request *next_rq[2];
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	spinlock_t lock;
	spinlock_t zone_lock;
	struct list_head dispatch;
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_throttled {};

typedef void (*btf_trace_kyber_latency)(void *, struct request_queue *, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_adjust)(void *, struct request_queue *, const char *, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, struct request_queue *, const char *);

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kyber_queue_data {
	struct request_queue *q;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_device;

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	void *priv;
};

struct vringh_config_ops;

struct virtio_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_MAX = 7,
};

struct rdma_restrack_entry {
	bool valid;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_hw_stats;

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const char * const *names;
	int num_counters;
	u64 value[0];
};

struct ib_device;

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u8 port;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

struct uverbs_attr_bundle;

struct rdma_cm_id;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_gid_attr;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct ib_pd;

struct ib_ah;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_flow_action_attrs_esp;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*req_ncomp_notif)(struct ib_cq *, int);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u8, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u8, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u8, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u8, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u8);
	struct net_device * (*get_netdev)(struct ib_device *, u8);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u8, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u8, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u8, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u8, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	struct ib_qp * (*create_qp)(struct ib_pd *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	int (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	struct ib_flow_action * (*create_flow_action_esp)(struct ib_device *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*modify_flow_action_esp)(struct ib_flow_action *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*set_vf_link_state)(struct ib_device *, int, u8, int);
	int (*get_vf_config)(struct ib_device *, int, u8, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u8, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u8, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u8, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_stats)(struct ib_device *, u8);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u8, int);
	int (*init_port)(struct ib_device *, u8, struct kobject *);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	u64 device_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	u64 max_dm_size;
	u32 max_sgl_rd;
};

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[3];
	u64 uverbs_cmd_mask;
	u64 uverbs_ex_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u8 phys_port_cnt;
	struct ib_device_attr attrs;
	struct attribute_group *hw_stats_ag;
	struct rdma_hw_stats *hw_stats;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	u64 sig_err_offset;
	u32 key;
};

enum ib_uverbs_flow_action_esp_keymat {
	IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = 0,
};

struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
	__u64 iv;
	__u32 iv_algo;
	__u32 salt;
	__u32 icv_len;
	__u32 key_len;
	__u32 aes_key[8];
};

enum ib_uverbs_flow_action_esp_replay {
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = 0,
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = 1,
};

struct ib_uverbs_flow_action_esp_replay_bmp {
	__u32 size;
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u8 port_num;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

struct ib_ucq_object;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

struct ib_event;

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
};

struct ib_uqp_object;

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u8 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_usrq_object;

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
};

struct ib_uwq_object;

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u8 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mr_status {
	u32 fail_status;
	struct ib_sig_err sig_err;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u8 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_REG_MR = 8,
	IB_WC_MASKED_COMP_SWAP = 9,
	IB_WC_MASKED_FETCH_ADD = 10,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u8 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u8 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_uobject;

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u8 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u8 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_rdmacg_object {};

struct ib_uverbs_file;

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	bool cleanup_retryable;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u8 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u8 port;
	union ib_flow_spec flows[0];
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_flow_action_attrs_esp_keymats {
	enum ib_uverbs_flow_action_esp_keymat protocol;
	union {
		struct ib_uverbs_flow_action_esp_keymat_aes_gcm aes_gcm;
	} keymat;
};

struct ib_flow_action_attrs_esp_replays {
	enum ib_uverbs_flow_action_esp_replay protocol;
	union {
		struct ib_uverbs_flow_action_esp_replay_bmp bmp;
	} replay;
};

struct ib_flow_spec_list {
	struct ib_flow_spec_list *next;
	union ib_flow_spec spec;
};

struct ib_flow_action_attrs_esp {
	struct ib_flow_action_attrs_esp_keymats *keymat;
	struct ib_flow_action_attrs_esp_replays *replay;
	struct ib_flow_spec_list *encap;
	u32 esn;
	u32 spi;
	u32 seq;
	u32 tfc_pad;
	u64 flags;
	u64 hard_limit_pkts;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	spinlock_t netdev_lock;
	struct net_device *netdev;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct rdma_hw_stats *hw_stats;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u8, struct net_device *, void *);
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	long unsigned int start_pgoff;
	size_t npages;
	bool driver_removed;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

typedef void (*swap_func_t)(void *, void *, int);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct siprand_state {
	long unsigned int v0;
	long unsigned int v1;
	long unsigned int v2;
	long unsigned int v3;
};

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

typedef int (*cmp_func)(void *, const struct list_head *, const struct list_head *);

struct rhltable {
	struct rhashtable ht;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[512];
		u8 data[4096];
	};
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

struct arc4_ctx {
	u32 S[256];
	u32 x;
	u32 y;
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
};

struct pcim_iomap_devres {
	void *table[6];
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef z_stream *z_streamp;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

typedef uint8_t BYTE;

typedef uint16_t U16;

typedef uint32_t U32;

typedef uint64_t U64;

typedef uintptr_t uptrval;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef struct {
	size_t bitContainer;
	int bitPos;
	char *startPtr;
	char *ptr;
	char *endPtr;
} BIT_CStream_t;

typedef unsigned int FSE_CTable;

typedef struct {
	ptrdiff_t value;
	const void *stateTable;
	const void *symbolTT;
	unsigned int stateLog;
} FSE_CState_t;

typedef struct {
	int deltaFindState;
	U32 deltaNbBits;
} FSE_symbolCompressionTransform;

typedef s16 int16_t;

typedef int16_t S16;

struct HUF_CElt_s {
	U16 val;
	BYTE nbBits;
};

typedef struct HUF_CElt_s HUF_CElt;

typedef enum {
	HUF_repeat_none = 0,
	HUF_repeat_check = 1,
	HUF_repeat_valid = 2,
} HUF_repeat;

struct nodeElt_s {
	U32 count;
	U16 parent;
	BYTE byte;
	BYTE nbBits;
};

typedef struct nodeElt_s nodeElt;

typedef struct {
	U32 base;
	U32 curr;
} rankPos;

typedef enum {
	ZSTDcs_created = 0,
	ZSTDcs_init = 1,
	ZSTDcs_ongoing = 2,
	ZSTDcs_ending = 3,
} ZSTD_compressionStage_e;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef struct {
	U32 price;
	U32 off;
	U32 mlen;
	U32 litlen;
	U32 rep[3];
} ZSTD_optimal_t;

typedef struct {
	U32 off;
	U32 len;
} ZSTD_match_t;

struct seqDef_s;

typedef struct seqDef_s seqDef;

typedef struct {
	seqDef *sequencesStart;
	seqDef *sequences;
	BYTE *litStart;
	BYTE *lit;
	BYTE *llCode;
	BYTE *mlCode;
	BYTE *ofCode;
	U32 longLengthID;
	U32 longLengthPos;
	ZSTD_optimal_t *priceTable;
	ZSTD_match_t *matchTable;
	U32 *matchLengthFreq;
	U32 *litLengthFreq;
	U32 *litFreq;
	U32 *offCodeFreq;
	U32 matchLengthSum;
	U32 matchSum;
	U32 litLengthSum;
	U32 litSum;
	U32 offCodeSum;
	U32 log2matchLengthSum;
	U32 log2matchSum;
	U32 log2litLengthSum;
	U32 log2litSum;
	U32 log2offCodeSum;
	U32 factor;
	U32 staticPrices;
	U32 cachedPrice;
	U32 cachedLitLength;
	const BYTE *cachedLiterals;
} seqStore_t;

struct HUF_CElt_s___2;

typedef struct HUF_CElt_s___2 HUF_CElt___2;

struct ZSTD_CCtx_s {
	const BYTE *nextSrc;
	const BYTE *base;
	const BYTE *dictBase;
	U32 dictLimit;
	U32 lowLimit;
	U32 nextToUpdate;
	U32 nextToUpdate3;
	U32 hashLog3;
	U32 loadedDictEnd;
	U32 forceWindow;
	U32 forceRawDict;
	ZSTD_compressionStage_e stage;
	U32 rep[3];
	U32 repToConfirm[3];
	U32 dictID;
	ZSTD_parameters params;
	void *workSpace;
	size_t workSpaceSize;
	size_t blockSize;
	U64 frameContentSize;
	struct xxh64_state xxhState;
	ZSTD_customMem customMem;
	seqStore_t seqStore;
	U32 *hashTable;
	U32 *hashTable3;
	U32 *chainTable;
	HUF_CElt___2 *hufTable;
	U32 flagStaticTables;
	HUF_repeat flagStaticHufTable;
	FSE_CTable offcodeCTable[187];
	FSE_CTable matchlengthCTable[363];
	FSE_CTable litlengthCTable[329];
	unsigned int tmpCounters[1536];
};

typedef struct ZSTD_CCtx_s ZSTD_CCtx;

struct ZSTD_CDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictContentSize;
	ZSTD_CCtx *refContext;
};

typedef struct ZSTD_CDict_s ZSTD_CDict;

typedef enum {
	zcss_init = 0,
	zcss_load = 1,
	zcss_flush = 2,
	zcss_final = 3,
} ZSTD_cStreamStage;

struct ZSTD_CStream_s___2 {
	ZSTD_CCtx *cctx;
	ZSTD_CDict *cdictLocal;
	const ZSTD_CDict *cdict;
	char *inBuff;
	size_t inBuffSize;
	size_t inToCompress;
	size_t inBuffPos;
	size_t inBuffTarget;
	size_t blockSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outBuffContentSize;
	size_t outBuffFlushedSize;
	ZSTD_cStreamStage stage;
	U32 checksum;
	U32 frameEnded;
	U64 pledgedSrcSize;
	U64 inputProcessed;
	ZSTD_parameters params;
	ZSTD_customMem customMem;
};

typedef struct ZSTD_CStream_s___2 ZSTD_CStream___2;

typedef int32_t S32;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

struct seqDef_s {
	U32 offset;
	U16 litLength;
	U16 matchLength;
};

typedef enum {
	ZSTDcrp_continue = 0,
	ZSTDcrp_noMemset = 1,
	ZSTDcrp_fullReset = 2,
} ZSTD_compResetPolicy_e;

typedef void (*ZSTD_blockCompressor)(ZSTD_CCtx *, const void *, size_t);

typedef enum {
	zsf_gather = 0,
	zsf_flush = 1,
	zsf_end = 2,
} ZSTD_flush_e;

typedef size_t (*searchMax_f)(ZSTD_CCtx *, const BYTE *, const BYTE *, size_t *, U32, U32);

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef unsigned int FSE_DTable;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	void *ptr;
	const void *end;
} ZSTD_stack;

typedef U32 HUF_DTable;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	BYTE byte;
	BYTE nbBits;
} HUF_DEltX2;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX4;

typedef struct {
	BYTE symbol;
	BYTE weight;
} sortedSymbol_t;

typedef U32 rankValCol_t[13];

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef struct {
	FSE_DTable LLTable[513];
	FSE_DTable OFTable[257];
	FSE_DTable MLTable[513];
	HUF_DTable hufTable[4097];
	U64 workspace[384];
	U32 rep[3];
} ZSTD_entropyTables_t;

typedef struct {
	long long unsigned int frameContentSize;
	unsigned int windowSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameParams;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

struct ZSTD_DCtx_s {
	const FSE_DTable *LLTptr;
	const FSE_DTable *MLTptr;
	const FSE_DTable *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyTables_t entropy;
	const void *previousDstEnd;
	const void *base;
	const void *vBase;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameParams fParams;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	U32 dictID;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	BYTE litBuffer[131080];
	BYTE headerBuffer[18];
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

struct ZSTD_DStream_s___2 {
	ZSTD_DCtx *dctx;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	ZSTD_frameParams fParams;
	ZSTD_dStreamStage stage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t blockSize;
	BYTE headerBuffer[18];
	size_t lhSize;
	ZSTD_customMem customMem;
	void *legacyContext;
	U32 previousLegacyVersion;
	U32 legacyVersion;
	U32 hostageByte;
};

typedef struct ZSTD_DStream_s___2 ZSTD_DStream___2;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef uintptr_t uPtrDiff;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef union {
	FSE_decode_t realData;
	U32 alignedBy4;
} FSE_decode_t4;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
	const BYTE *match;
} seq_t;

typedef struct {
	BIT_DStream_t DStream;
	FSE_DState_t stateLL;
	FSE_DState_t stateOffb;
	FSE_DState_t stateML;
	size_t prevOffset[3];
	const BYTE *base;
	size_t pos;
	uPtrDiff gotoDict;
} seqState_t;

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2___2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj___2 {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct raid6_recov_calls {
	void (*data2)(int, size_t, int, int, void **);
	void (*datap)(int, size_t, int, void **);
	int (*valid)();
	const char *name;
	int priority;
};

typedef u64 unative_t;

struct raid6_sse_constants {
	u64 x1d[2];
};

struct raid6_avx2_constants {
	u64 x1d[4];
};

struct raid6_avx512_constants {
	u64 x1d[8];
};

struct ts_state {
	unsigned int offset;
	char cb[40];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_linear_state {
	unsigned int len;
	const void *data;
};

struct ei_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
	int etype;
	void *priv;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef mpi_limb_t UWtype;

typedef unsigned int UHWtype;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct gcry_mpi_point *MPI_POINT;

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct barrett_ctx_s___2;

typedef struct barrett_ctx_s___2 *mpi_barrett_t___2;

struct barrett_ctx_s___2 {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

enum {
	IRQ_POLL_F_SCHED = 0,
	IRQ_POLL_F_DISABLE = 1,
};

struct font_desc {
	int idx;
	const char *name;
	int width;
	int height;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

typedef u16 ucs2_char_t;

struct msr {
	union {
		struct {
			u32 l;
			u32 h;
		};
		u64 q;
	};
};

struct msr_info {
	u32 msr_no;
	struct msr reg;
	struct msr *msrs;
	int err;
};

struct msr_regs_info {
	u32 *regs;
	int err;
};

struct msr_info_completion {
	struct msr_info msr;
	struct completion done;
};

struct trace_event_raw_msr_trace_class {
	struct trace_entry ent;
	unsigned int msr;
	u64 val;
	int failed;
	char __data[0];
};

struct trace_event_data_offsets_msr_trace_class {};

typedef void (*btf_trace_read_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_write_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_rdpmc)(void *, unsigned int, u64, int);

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct xz_dec___2;

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 2,
	ZSTD_error_version_unsupported = 3,
	ZSTD_error_parameter_unknown = 4,
	ZSTD_error_frameParameter_unsupported = 5,
	ZSTD_error_frameParameter_unsupportedBy32bits = 6,
	ZSTD_error_frameParameter_windowTooLarge = 7,
	ZSTD_error_compressionParameter_unsupported = 8,
	ZSTD_error_init_missing = 9,
	ZSTD_error_memory_allocation = 10,
	ZSTD_error_stage_wrong = 11,
	ZSTD_error_dstSize_tooSmall = 12,
	ZSTD_error_srcSize_wrong = 13,
	ZSTD_error_corruption_detected = 14,
	ZSTD_error_checksum_wrong = 15,
	ZSTD_error_tableLog_tooLarge = 16,
	ZSTD_error_maxSymbolValue_tooLarge = 17,
	ZSTD_error_maxSymbolValue_tooSmall = 18,
	ZSTD_error_dictionary_corrupted = 19,
	ZSTD_error_dictionary_wrong = 20,
	ZSTD_error_dictionaryCreation_failed = 21,
	ZSTD_error_maxCode = 22,
} ZSTD_ErrorCode;

struct ZSTD_DCtx_s___2;

typedef struct ZSTD_DCtx_s___2 ZSTD_DCtx___2;

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct xa_limit {
	u32 max;
	u32 min;
};

enum {
	st_wordstart = 0,
	st_wordcmp = 1,
	st_wordskip = 2,
	st_bufcpy = 3,
};

enum {
	st_wordstart___2 = 0,
	st_wordcmp___2 = 1,
	st_wordskip___2 = 2,
};

struct in6_addr___2;

enum reg_type {
	REG_TYPE_RM = 0,
	REG_TYPE_REG = 1,
	REG_TYPE_INDEX = 2,
	REG_TYPE_BASE = 3,
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct callback_head callback_head;
	bool supplier_preactivated;
};

struct regulator;

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int base;
	u16 ngpio;
	const char * const *names;
	bool can_sleep;
	long unsigned int *valid_mask;
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_LOW_POWER_MODE = 15,
	PIN_CONFIG_OUTPUT_ENABLE = 16,
	PIN_CONFIG_OUTPUT = 17,
	PIN_CONFIG_POWER_SOURCE = 18,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 19,
	PIN_CONFIG_SLEW_RATE = 20,
	PIN_CONFIG_SKEW_DELAY = 21,
	PIN_CONFIG_PERSIST_STATE = 22,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct gpio_desc;

struct gpio_device {
	int id;
	struct device dev;
	struct cdev chrdev;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head notifier;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc *desc[0];
};

struct gpio_array {
	struct gpio_desc **desc;
	unsigned int size;
	struct gpio_chip *chip;
	long unsigned int *get_mask;
	long unsigned int *set_mask;
	long unsigned int invert_mask[0];
};

struct gpio_desc {
	struct gpio_device *gdev;
	long unsigned int flags;
	const char *label;
	const char *name;
	unsigned int debounce_period_us;
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

typedef u64 acpi_io_address;

typedef u32 acpi_object_type;

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_hotplug_profile {
	struct kobject kobj;
	int (*scan_dependent)(struct acpi_device *);
	void (*notify_online)(struct acpi_device *);
	bool enabled: 1;
	bool demand_offline: 1;
};

struct acpi_device_status {
	u32 present: 1;
	u32 enabled: 1;
	u32 show_in_ui: 1;
	u32 functional: 1;
	u32 battery_present: 1;
	u32 reserved: 27;
};

struct acpi_device_flags {
	u32 dynamic_status: 1;
	u32 removable: 1;
	u32 ejectable: 1;
	u32 power_manageable: 1;
	u32 match_driver: 1;
	u32 initialized: 1;
	u32 visited: 1;
	u32 hotplug_notify: 1;
	u32 is_dock_station: 1;
	u32 of_compatible_ok: 1;
	u32 coherent_dma: 1;
	u32 cca_seen: 1;
	u32 enumeration_by_parent: 1;
	u32 reserved: 19;
};

typedef char acpi_bus_id[8];

struct acpi_pnp_type {
	u32 hardware_id: 1;
	u32 bus_address: 1;
	u32 platform_id: 1;
	u32 reserved: 29;
};

typedef u64 acpi_bus_address;

typedef char acpi_device_name[40];

typedef char acpi_device_class[20];

struct acpi_device_pnp {
	acpi_bus_id bus_id;
	struct acpi_pnp_type type;
	acpi_bus_address bus_address;
	char *unique_id;
	struct list_head ids;
	acpi_device_name device_name;
	acpi_device_class device_class;
	union acpi_object *str_obj;
};

struct acpi_device_power_flags {
	u32 explicit_get: 1;
	u32 power_resources: 1;
	u32 inrush_current: 1;
	u32 power_removed: 1;
	u32 ignore_parent: 1;
	u32 dsw_present: 1;
	u32 reserved: 26;
};

struct acpi_device_power_state {
	struct {
		u8 valid: 1;
		u8 explicit_set: 1;
		u8 reserved: 6;
	} flags;
	int power;
	int latency;
	struct list_head resources;
};

struct acpi_device_power {
	int state;
	struct acpi_device_power_flags flags;
	struct acpi_device_power_state states[5];
};

struct acpi_device_wakeup_flags {
	u8 valid: 1;
	u8 notifier_present: 1;
};

struct acpi_device_wakeup_context {
	void (*func)(struct acpi_device_wakeup_context *);
	struct device *dev;
};

struct acpi_device_wakeup {
	acpi_handle gpe_device;
	u64 gpe_number;
	u64 sleep_state;
	struct list_head resources;
	struct acpi_device_wakeup_flags flags;
	struct acpi_device_wakeup_context context;
	struct wakeup_source *ws;
	int prepare_count;
	int enable_count;
};

struct acpi_device_perf_flags {
	u8 reserved: 8;
};

struct acpi_device_perf_state;

struct acpi_device_perf {
	int state;
	struct acpi_device_perf_flags flags;
	int state_count;
	struct acpi_device_perf_state *states;
};

struct acpi_device_dir {
	struct proc_dir_entry *entry;
};

struct acpi_device_data {
	const union acpi_object *pointer;
	struct list_head properties;
	const union acpi_object *of_compatible;
	struct list_head subnodes;
};

struct acpi_scan_handler;

struct acpi_hotplug_context;

struct acpi_driver;

struct acpi_device {
	int device_type;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct acpi_device *parent;
	struct list_head children;
	struct list_head node;
	struct list_head wakeup_list;
	struct list_head del_list;
	struct acpi_device_status status;
	struct acpi_device_flags flags;
	struct acpi_device_pnp pnp;
	struct acpi_device_power power;
	struct acpi_device_wakeup wakeup;
	struct acpi_device_perf performance;
	struct acpi_device_dir dir;
	struct acpi_device_data data;
	struct acpi_scan_handler *handler;
	struct acpi_hotplug_context *hp;
	struct acpi_driver *driver;
	const struct acpi_gpio_mapping *driver_gpios;
	void *driver_data;
	struct device dev;
	unsigned int physical_node_count;
	unsigned int dep_unmet;
	struct list_head physical_node_list;
	struct mutex physical_node_lock;
	void (*remove)(struct acpi_device *);
};

struct acpi_scan_handler {
	const struct acpi_device_id *ids;
	struct list_head list_node;
	bool (*match)(const char *, const struct acpi_device_id **);
	int (*attach)(struct acpi_device *, const struct acpi_device_id *);
	void (*detach)(struct acpi_device *);
	void (*bind)(struct device *);
	void (*unbind)(struct device *);
	struct acpi_hotplug_profile hotplug;
};

struct acpi_hotplug_context {
	struct acpi_device *self;
	int (*notify)(struct acpi_device *, u32);
	void (*uevent)(struct acpi_device *, u32);
	void (*fixup)(struct acpi_device *);
};

typedef int (*acpi_op_add)(struct acpi_device *);

typedef int (*acpi_op_remove)(struct acpi_device *);

typedef void (*acpi_op_notify)(struct acpi_device *, u32);

struct acpi_device_ops {
	acpi_op_add add;
	acpi_op_remove remove;
	acpi_op_notify notify;
};

struct acpi_driver {
	char name[80];
	char class[80];
	const struct acpi_device_id *ids;
	unsigned int flags;
	struct acpi_device_ops ops;
	struct device_driver drv;
	struct module *owner;
};

struct acpi_device_perf_state {
	struct {
		u8 valid: 1;
		u8 reserved: 7;
	} flags;
	u8 power;
	u8 performance;
	int latency;
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	long unsigned int lflags;
	int dflags;
};

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	unsigned int quirks;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

struct devres;

struct gpio {
	unsigned int gpio;
	long unsigned int flags;
	const char *label;
};

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
};

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

struct gpioline_info {
	__u32 line_offset;
	__u32 flags;
	char name[32];
	char consumer[32];
};

struct gpioline_info_changed {
	struct gpioline_info info;
	__u64 timestamp;
	__u32 event_type;
	__u32 padding[5];
};

struct gpiohandle_request {
	__u32 lineoffsets[64];
	__u32 flags;
	__u8 default_values[64];
	char consumer_label[32];
	__u32 lines;
	int fd;
};

struct gpiohandle_config {
	__u32 flags;
	__u8 default_values[64];
	__u32 padding[4];
};

struct gpiohandle_data {
	__u8 values[64];
};

struct gpioevent_request {
	__u32 lineoffset;
	__u32 handleflags;
	__u32 eventflags;
	char consumer_label[32];
	int fd;
};

struct gpioevent_data {
	__u64 timestamp;
	__u32 id;
};

struct linehandle_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *descs[64];
	u32 num_descs;
};

struct linereq;

struct line {
	struct gpio_desc *desc;
	struct linereq *req;
	unsigned int irq;
	u64 eflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	u32 event_buffer_size;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct lineevent_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *desc;
	u32 eflags;
	int irq;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpioevent_data *type;
			const struct gpioevent_data *const_type;
			char (*rectype)[0];
			struct gpioevent_data *ptr;
			const struct gpioevent_data *ptr_const;
		};
		struct gpioevent_data buf[16];
	} events;
	u64 timestamp;
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	long unsigned int *watched_lines;
	atomic_t watch_abi_version;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct gpiod_data {
	struct gpio_desc *desc;
	struct mutex mutex;
	struct kernfs_node *value_kn;
	int irq;
	unsigned char irq_flags;
	bool direction_can_change;
};

struct acpi_connection_info {
	u8 *connection;
	u16 length;
	u8 access_length;
};

struct acpi_resource_irq {
	u8 descriptor_length;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	u8 interrupts[1];
};

struct acpi_resource_dma {
	u8 type;
	u8 bus_master;
	u8 transfer;
	u8 channel_count;
	u8 channels[1];
};

struct acpi_resource_start_dependent {
	u8 descriptor_length;
	u8 compatibility_priority;
	u8 performance_robustness;
};

struct acpi_resource_io {
	u8 io_decode;
	u8 alignment;
	u8 address_length;
	u16 minimum;
	u16 maximum;
} __attribute__((packed));

struct acpi_resource_fixed_io {
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_dma {
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct acpi_resource_vendor {
	u16 byte_length;
	u8 byte_data[1];
} __attribute__((packed));

struct acpi_resource_vendor_typed {
	u16 byte_length;
	u8 uuid_subtype;
	u8 uuid[16];
	u8 byte_data[1];
};

struct acpi_resource_end_tag {
	u8 checksum;
};

struct acpi_resource_memory24 {
	u8 write_protect;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct acpi_resource_memory32 {
	u8 write_protect;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_memory32 {
	u8 write_protect;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct acpi_memory_attribute {
	u8 write_protect;
	u8 caching;
	u8 range_type;
	u8 translation;
};

struct acpi_io_attribute {
	u8 range_type;
	u8 translation;
	u8 translation_type;
	u8 reserved1;
};

union acpi_resource_attribute {
	struct acpi_memory_attribute mem;
	struct acpi_io_attribute io;
	u8 type_specific;
};

struct acpi_resource_label {
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_source {
	u8 index;
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_address16_attribute {
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
};

struct acpi_address32_attribute {
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
};

struct acpi_address64_attribute {
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
};

struct acpi_resource_address {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
};

struct acpi_resource_address16 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address16_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address32 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address32_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address64_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_extended_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	u8 revision_ID;
	struct acpi_address64_attribute address;
	u64 type_specific;
} __attribute__((packed));

struct acpi_resource_extended_irq {
	u8 producer_consumer;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	struct acpi_resource_source resource_source;
	u32 interrupts[1];
} __attribute__((packed));

struct acpi_resource_generic_register {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_resource_gpio {
	u8 revision_id;
	u8 connection_type;
	u8 producer_consumer;
	u8 pin_config;
	u8 shareable;
	u8 wake_capable;
	u8 io_restriction;
	u8 triggering;
	u8 polarity;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_common_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_i2c_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 access_mode;
	u16 slave_address;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_spi_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 wire_mode;
	u8 device_polarity;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_uart_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 endian;
	u8 data_bits;
	u8 stop_bits;
	u8 flow_control;
	u8 parity;
	u8 lines_enabled;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u32 default_baud_rate;
} __attribute__((packed));

struct acpi_resource_pin_function {
	u8 revision_id;
	u8 pin_config;
	u8 shareable;
	u16 function_number;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group {
	u8 revision_id;
	u8 producer_consumer;
	u16 pin_table_length;
	u16 vendor_length;
	u16 *pin_table;
	struct acpi_resource_label resource_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_function {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u16 function_number;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

union acpi_resource_data {
	struct acpi_resource_irq irq;
	struct acpi_resource_dma dma;
	struct acpi_resource_start_dependent start_dpf;
	struct acpi_resource_io io;
	struct acpi_resource_fixed_io fixed_io;
	struct acpi_resource_fixed_dma fixed_dma;
	struct acpi_resource_vendor vendor;
	struct acpi_resource_vendor_typed vendor_typed;
	struct acpi_resource_end_tag end_tag;
	struct acpi_resource_memory24 memory24;
	struct acpi_resource_memory32 memory32;
	struct acpi_resource_fixed_memory32 fixed_memory32;
	struct acpi_resource_address16 address16;
	struct acpi_resource_address32 address32;
	struct acpi_resource_address64 address64;
	struct acpi_resource_extended_address64 ext_address64;
	struct acpi_resource_extended_irq extended_irq;
	struct acpi_resource_generic_register generic_reg;
	struct acpi_resource_gpio gpio;
	struct acpi_resource_i2c_serialbus i2c_serial_bus;
	struct acpi_resource_spi_serialbus spi_serial_bus;
	struct acpi_resource_uart_serialbus uart_serial_bus;
	struct acpi_resource_common_serialbus common_serial_bus;
	struct acpi_resource_pin_function pin_function;
	struct acpi_resource_pin_config pin_config;
	struct acpi_resource_pin_group pin_group;
	struct acpi_resource_pin_group_function pin_group_function;
	struct acpi_resource_pin_group_config pin_group_config;
	struct acpi_resource_address address;
};

struct acpi_resource {
	u32 type;
	u32 length;
	union acpi_resource_data data;
} __attribute__((packed));

struct acpi_gpiolib_dmi_quirk {
	bool no_edge_events_on_boot;
	char *ignore_wake;
};

struct acpi_gpio_event {
	struct list_head node;
	acpi_handle handle;
	irq_handler_t handler;
	unsigned int pin;
	unsigned int irq;
	long unsigned int irqflags;
	bool irq_is_wake;
	bool irq_requested;
	struct gpio_desc *desc;
};

struct acpi_gpio_connection {
	struct list_head node;
	unsigned int pin;
	struct gpio_desc *desc;
};

struct acpi_gpio_chip {
	struct acpi_connection_info conn_info;
	struct list_head conns;
	struct mutex conn_lock;
	struct gpio_chip *chip;
	struct list_head events;
	struct list_head deferred_req_irqs_list_entry;
};

struct acpi_gpio_lookup {
	struct acpi_gpio_info info;
	int index;
	int pin_index;
	bool active_low;
	struct gpio_desc *desc;
	int n;
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

typedef u64 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCI_SPEED_UNKNOWN = 255,
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	struct msi_controller *msi;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, int);
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_platform_pm_ops {
	bool (*bridge_d3)(struct pci_dev *);
	bool (*is_manageable)(struct pci_dev *);
	int (*set_state)(struct pci_dev *, pci_power_t);
	pci_power_t (*get_state)(struct pci_dev *);
	void (*refresh_state)(struct pci_dev *);
	pci_power_t (*choose_state)(struct pci_dev *);
	int (*set_wakeup)(struct pci_dev *, bool);
	bool (*need_resume)(struct pci_dev *);
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	void (*error_resume)(struct pci_dev *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

struct pci_vpd_ops;

struct pci_vpd {
	const struct pci_vpd_ops *ops;
	struct bin_attribute *attr;
	struct mutex lock;
	unsigned int len;
	u16 flag;
	u8 cap;
	unsigned int busy: 1;
	unsigned int valid: 1;
};

struct pci_vpd_ops {
	ssize_t (*read)(struct pci_dev *, loff_t, size_t, void *);
	ssize_t (*write)(struct pci_dev *, loff_t, size_t, const void *);
	int (*set_size)(struct pci_dev *, size_t);
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum enable_type {
	undefined = 4294967295,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

typedef int (*pcie_pm_callback_t)(struct pcie_device *);

struct aspm_latency {
	u32 l0s;
	u32 l1;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	char: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
	struct aspm_latency latency_up;
	struct aspm_latency latency_dw;
	struct aspm_latency acceptable[8];
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct pci_filp_private {
	enum pci_mmap_state mmap_state;
	int write_combine;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

typedef u64 acpi_size;

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

struct acpi_bus_type {
	struct list_head list;
	const char *name;
	bool (*match)(struct device *);
	struct acpi_device * (*find_companion)(struct device *);
	void (*setup)(struct device *);
	void (*cleanup)(struct device *);
};

struct acpi_pci_root {
	struct acpi_device *device;
	struct pci_bus *bus;
	u16 segment;
	struct resource secondary;
	u32 osc_support_set;
	u32 osc_control_set;
	phys_addr_t mcfg_addr;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

struct hpx_type0 {
	u32 revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 enable_serr;
	u8 enable_perr;
};

struct hpx_type1 {
	u32 revision;
	u8 max_mem_read;
	u8 avg_max_split;
	u16 tot_max_split;
};

struct hpx_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hpx_type3 {
	u16 device_type;
	u16 function_type;
	u16 config_space_location;
	u16 pci_exp_cap_id;
	u16 pci_exp_cap_ver;
	u16 pci_exp_vendor_id;
	u16 dvsec_id;
	u16 dvsec_rev;
	u16 match_offset;
	u32 match_mask_and;
	u32 match_value;
	u16 reg_offset;
	u32 reg_mask_and;
	u32 reg_mask_or;
};

enum hpx_type3_dev_type {
	HPX_TYPE_ENDPOINT = 1,
	HPX_TYPE_LEG_END = 2,
	HPX_TYPE_RC_END = 4,
	HPX_TYPE_RC_EC = 8,
	HPX_TYPE_ROOT_PORT = 16,
	HPX_TYPE_UPSTREAM = 32,
	HPX_TYPE_DOWNSTREAM = 64,
	HPX_TYPE_PCI_BRIDGE = 128,
	HPX_TYPE_PCIE_BRIDGE = 256,
};

enum hpx_type3_fn_type {
	HPX_FN_NORMAL = 1,
	HPX_FN_SRIOV_PHYS = 2,
	HPX_FN_SRIOV_VIRT = 4,
};

enum hpx_type3_cfg_loc {
	HPX_CFG_PCICFG = 0,
	HPX_CFG_PCIE_CAP = 1,
	HPX_CFG_PCIE_CAP_EXT = 2,
	HPX_CFG_VEND_CAP = 3,
	HPX_CFG_DVSEC = 4,
	HPX_CFG_MAX = 5,
};

enum pci_irq_reroute_variant {
	INTEL_IRQ_REROUTE_VARIANT = 1,
	MAX_IRQ_REROUTE_VARIANTS = 3,
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CAP_CSS_NVM = 1,
	NVME_CAP_CSS_CSI = 64,
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, int);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = 4294967295,
	DMI_DEV_TYPE_OEM_STRING = 4294967294,
	DMI_DEV_TYPE_DEV_ONBOARD = 4294967293,
	DMI_DEV_TYPE_DEV_SLOT = 4294967292,
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

enum acpi_attr_enum {
	ACPI_ATTR_LABEL_SHOW = 0,
	ACPI_ATTR_INDEX_SHOW = 1,
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 1,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	bool itc;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	unsigned char pixel_repeat;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = 4294967295,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct vgastate {
	void *vgabase;
	long unsigned int membase;
	__u32 memsize;
	__u32 flags;
	__u32 depth;
	__u32 num_attr;
	__u32 num_crtc;
	__u32 num_gfx;
	__u32 num_seq;
	void *vidstate;
};

struct linux_logo {
	int type;
	unsigned int width;
	unsigned int height;
	unsigned int clutsize;
	const unsigned char *clut;
	const unsigned char *data;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_info;

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct backlight_device;

struct fb_deferred_io;

struct fb_ops;

struct fb_tile_ops;

struct apertures_struct;

struct fb_info {
	atomic_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct work_struct queue;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct backlight_device *bl_dev;
	struct mutex bl_curve_mutex;
	u8 bl_curve[128];
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	struct fb_tile_ops *tileops;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io {
	long unsigned int delay;
	struct mutex lock;
	struct list_head pagelist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct fb_tilemap {
	__u32 width;
	__u32 height;
	__u32 depth;
	__u32 length;
	const __u8 *data;
};

struct fb_tilerect {
	__u32 sx;
	__u32 sy;
	__u32 width;
	__u32 height;
	__u32 index;
	__u32 fg;
	__u32 bg;
	__u32 rop;
};

struct fb_tilearea {
	__u32 sx;
	__u32 sy;
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
};

struct fb_tileblit {
	__u32 sx;
	__u32 sy;
	__u32 width;
	__u32 height;
	__u32 fg;
	__u32 bg;
	__u32 length;
	__u32 *indices;
};

struct fb_tilecursor {
	__u32 sx;
	__u32 sy;
	__u32 mode;
	__u32 shape;
	__u32 fg;
	__u32 bg;
};

struct fb_tile_ops {
	void (*fb_settile)(struct fb_info *, struct fb_tilemap *);
	void (*fb_tilecopy)(struct fb_info *, struct fb_tilearea *);
	void (*fb_tilefill)(struct fb_info *, struct fb_tilerect *);
	void (*fb_tileblit)(struct fb_info *, struct fb_tileblit *);
	void (*fb_tilecursor)(struct fb_info *, struct fb_tilecursor *);
	int (*fb_get_tilemax)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	int fb_blank;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_ops;

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum backlight_notification {
	BACKLIGHT_REGISTERED = 0,
	BACKLIGHT_UNREGISTERED = 1,
};

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	int (*check_fb)(struct backlight_device *, struct fb_info *);
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct logo_data {
	int depth;
	int needs_directpalette;
	int needs_truepalette;
	int needs_cmapreset;
	const struct linux_logo *logo;
};

struct fb_fix_screeninfo32 {
	char id[16];
	compat_caddr_t smem_start;
	u32 smem_len;
	u32 type;
	u32 type_aux;
	u32 visual;
	u16 xpanstep;
	u16 ypanstep;
	u16 ywrapstep;
	u32 line_length;
	compat_caddr_t mmio_start;
	u32 mmio_len;
	u32 accel;
	u16 reserved[3];
};

struct fb_cmap32 {
	u32 start;
	u32 len;
	compat_caddr_t red;
	compat_caddr_t green;
	compat_caddr_t blue;
	compat_caddr_t transp;
};

struct dmt_videomode {
	u32 dmt_id;
	u32 std_2byte_code;
	u32 cvt_3byte_code;
	const struct fb_videomode *mode;
};

struct broken_edid {
	u8 manufacturer[4];
	u32 model;
	u32 fix;
};

struct __fb_timings {
	u32 dclk;
	u32 hfreq;
	u32 vfreq;
	u32 hactive;
	u32 vactive;
	u32 hblank;
	u32 vblank;
	u32 htotal;
	u32 vtotal;
};

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef unsigned char u_char;

typedef short unsigned int u_short;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short scrollmode;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct timer_list cursor_timer;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	int flags;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

struct vesafb_par {
	u32 pseudo_palette[256];
	int wc_cookie;
	struct resource *region;
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char type[20];
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct idle_cpu {
	struct cpuidle_state *state_table;
	long unsigned int auto_demotion_disable_flags;
	bool byt_auto_demotion_disable_flag;
	bool disable_promotion_to_c1e;
	bool use_acpi;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct acpi_lpi_state {
	u32 min_residency;
	u32 wake_latency;
	u32 flags;
	u32 arch_flags;
	u32 res_cnt_freq;
	u32 enable_parent_state;
	u64 address;
	u8 index;
	u8 entry_method;
	char desc[32];
};

struct acpi_processor_power {
	int count;
	union {
		struct acpi_processor_cx states[8];
		struct acpi_lpi_state lpi_states[8];
	};
	int timer_broadcast_on_state;
};

struct acpi_psd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_pct_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_processor_px {
	u64 core_frequency;
	u64 power;
	u64 transition_latency;
	u64 bus_master_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_performance {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	short: 16;
	unsigned int state_count;
	int: 32;
	struct acpi_processor_px *states;
	struct acpi_psd_package domain_info;
	cpumask_var_t shared_cpu_map;
	unsigned int shared_type;
	int: 32;
} __attribute__((packed));

struct acpi_tsd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_tx_tss {
	u64 freqpercentage;
	u64 power;
	u64 transition_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_tx {
	u16 power;
	u16 performance;
};

struct acpi_processor;

struct acpi_processor_throttling {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	short: 16;
	unsigned int state_count;
	int: 32;
	struct acpi_processor_tx_tss *states_tss;
	struct acpi_tsd_package domain_info;
	cpumask_var_t shared_cpu_map;
	int (*acpi_processor_get_throttling)(struct acpi_processor *);
	int (*acpi_processor_set_throttling)(struct acpi_processor *, int, bool);
	u32 address;
	u8 duty_offset;
	u8 duty_width;
	u8 tsd_valid_flag;
	char: 8;
	unsigned int shared_type;
	struct acpi_processor_tx states[16];
	int: 32;
} __attribute__((packed));

struct acpi_processor_lx {
	int px;
	int tx;
};

struct acpi_processor_limit {
	struct acpi_processor_lx state;
	struct acpi_processor_lx thermal;
	struct acpi_processor_lx user;
};

struct acpi_processor {
	acpi_handle handle;
	u32 acpi_id;
	phys_cpuid_t phys_id;
	u32 id;
	u32 pblk;
	int performance_platform_limit;
	int throttling_platform_limit;
	struct acpi_processor_flags flags;
	struct acpi_processor_power power;
	struct acpi_processor_performance *performance;
	struct acpi_processor_throttling throttling;
	struct acpi_processor_limit limit;
	struct thermal_cooling_device *cdev;
	struct device *dev;
	struct freq_qos_request perflib_req;
	struct freq_qos_request thermal_req;
};

enum ipmi_addr_src {
	SI_INVALID = 0,
	SI_HOTMOD = 1,
	SI_HARDCODED = 2,
	SI_SPMI = 3,
	SI_ACPI = 4,
	SI_SMBIOS = 5,
	SI_PCI = 6,
	SI_DEVICETREE = 7,
	SI_PLATFORM = 8,
	SI_LAST = 9,
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

enum si_type {
	SI_TYPE_INVALID = 0,
	SI_KCS = 1,
	SI_SMIC = 2,
	SI_BT = 3,
};

enum ipmi_addr_space {
	IPMI_IO_ADDR_SPACE = 0,
	IPMI_MEM_ADDR_SPACE = 1,
};

enum ipmi_plat_interface_type {
	IPMI_PLAT_IF_SI = 0,
	IPMI_PLAT_IF_SSIF = 1,
};

struct ipmi_plat_data {
	enum ipmi_plat_interface_type iftype;
	unsigned int type;
	unsigned int space;
	long unsigned int addr;
	unsigned int regspacing;
	unsigned int regsize;
	unsigned int regshift;
	unsigned int irq;
	unsigned int slave_addr;
	enum ipmi_addr_src addr_source;
};

struct ipmi_dmi_info {
	enum si_type si_type;
	unsigned int space;
	long unsigned int addr;
	u8 slave_addr;
	struct ipmi_dmi_info *next;
};

typedef u16 acpi_owner_id;

union acpi_name_union {
	u32 integer;
	char ascii[4];
};

struct acpi_table_desc {
	acpi_physical_address address;
	struct acpi_table_header *pointer;
	u32 length;
	union acpi_name_union signature;
	acpi_owner_id owner_id;
	u8 flags;
	u16 validation_count;
};

struct acpi_madt_io_sapic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 global_irq_base;
	u64 address;
};

struct acpi_madt_interrupt_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u8 type;
	u8 id;
	u8 eid;
	u8 io_sapic_vector;
	u32 global_irq;
	u32 flags;
};

struct acpi_madt_generic_interrupt {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 cpu_interface_number;
	u32 uid;
	u32 flags;
	u32 parking_version;
	u32 performance_interrupt;
	u64 parked_address;
	u64 base_address;
	u64 gicv_base_address;
	u64 gich_base_address;
	u32 vgic_interrupt;
	u64 gicr_base_address;
	u64 arm_mpidr;
	u8 efficiency_class;
	u8 reserved2[1];
	u16 spe_interrupt;
} __attribute__((packed));

struct acpi_madt_generic_distributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 gic_id;
	u64 base_address;
	u32 global_irq_base;
	u8 version;
	u8 reserved2[3];
};

typedef int (*acpi_tbl_table_handler)(struct acpi_table_header *);

enum acpi_subtable_type {
	ACPI_SUBTABLE_COMMON = 0,
	ACPI_SUBTABLE_HMAT = 1,
};

struct acpi_subtable_entry {
	union acpi_subtable_headers *hdr;
	enum acpi_subtable_type type;
};

enum acpi_predicate {
	all_versions = 0,
	less_than_or_equal = 1,
	equal = 2,
	greater_than_or_equal = 3,
};

struct acpi_platform_list {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	char *table;
	enum acpi_predicate pred;
	char *reason;
	u32 data;
};

typedef char *acpi_string;

struct acpi_osi_entry {
	char string[64];
	bool enable;
};

struct acpi_osi_config {
	u8 default_disabling;
	unsigned int linux_enable: 1;
	unsigned int linux_dmi: 1;
	unsigned int linux_cmdline: 1;
	unsigned int darwin_enable: 1;
	unsigned int darwin_dmi: 1;
	unsigned int darwin_cmdline: 1;
};

struct acpi_predefined_names {
	const char *name;
	u8 type;
	char *val;
};

typedef u32 (*acpi_osd_handler)(void *);

typedef void (*acpi_osd_exec_callback)(void *);

typedef u32 (*acpi_gpe_handler)(acpi_handle, u32, void *);

typedef void (*acpi_notify_handler)(acpi_handle, u32, void *);

typedef void (*acpi_object_handler)(acpi_handle, void *);

typedef acpi_status (*acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);

typedef acpi_status (*acpi_adr_space_setup)(acpi_handle, u32, void *, void **);

struct acpi_pci_id {
	u16 segment;
	u16 bus;
	u16 device;
	u16 function;
};

struct acpi_mem_mapping {
	acpi_physical_address physical_address;
	u8 *logical_address;
	acpi_size length;
	struct acpi_mem_mapping *next_mm;
};

struct acpi_mem_space_context {
	u32 length;
	acpi_physical_address address;
	struct acpi_mem_mapping *cur_mm;
	struct acpi_mem_mapping *first_mm;
};

typedef enum {
	OSL_GLOBAL_LOCK_HANDLER = 0,
	OSL_NOTIFY_HANDLER = 1,
	OSL_GPE_HANDLER = 2,
	OSL_DEBUGGER_MAIN_THREAD = 3,
	OSL_DEBUGGER_EXEC_THREAD = 4,
	OSL_EC_POLL_HANDLER = 5,
	OSL_EC_BURST_HANDLER = 6,
} acpi_execute_type;

union acpi_operand_object;

struct acpi_namespace_node {
	union acpi_operand_object *object;
	u8 descriptor_type;
	u8 type;
	u16 flags;
	union acpi_name_union name;
	struct acpi_namespace_node *parent;
	struct acpi_namespace_node *child;
	struct acpi_namespace_node *peer;
	acpi_owner_id owner_id;
};

struct acpi_object_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
};

struct acpi_object_integer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 fill[3];
	u64 value;
};

struct acpi_object_string {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	char *pointer;
	u32 length;
};

struct acpi_object_buffer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 *pointer;
	u32 length;
	u32 aml_length;
	u8 *aml_start;
	struct acpi_namespace_node *node;
};

struct acpi_object_package {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	union acpi_operand_object **elements;
	u8 *aml_start;
	u32 aml_length;
	u32 count;
};

struct acpi_object_event {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	void *os_semaphore;
};

struct acpi_walk_state;

typedef acpi_status (*acpi_internal_method)(struct acpi_walk_state *);

struct acpi_object_method {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 info_flags;
	u8 param_count;
	u8 sync_level;
	union acpi_operand_object *mutex;
	union acpi_operand_object *node;
	u8 *aml_start;
	union {
		acpi_internal_method implementation;
		union acpi_operand_object *handler;
	} dispatch;
	u32 aml_length;
	acpi_owner_id owner_id;
	u8 thread_count;
};

struct acpi_thread_state;

struct acpi_object_mutex {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 sync_level;
	u16 acquisition_depth;
	void *os_mutex;
	u64 thread_id;
	struct acpi_thread_state *owner_thread;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
	struct acpi_namespace_node *node;
	u8 original_sync_level;
};

struct acpi_object_region {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler;
	union acpi_operand_object *next;
	acpi_physical_address address;
	u32 length;
};

struct acpi_object_notify_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_gpe_block_info;

struct acpi_object_device {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	struct acpi_gpe_block_info *gpe_block;
};

struct acpi_object_power_resource {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	u32 system_level;
	u32 resource_order;
};

struct acpi_object_processor {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 proc_id;
	u8 length;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	acpi_io_address address;
};

struct acpi_object_thermal_zone {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_object_field_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
};

struct acpi_object_region_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u16 resource_length;
	union acpi_operand_object *region_obj;
	u8 *resource_buffer;
	u16 pin_number_index;
	u8 *internal_pcc_buffer;
};

struct acpi_object_buffer_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u8 is_create_field;
	union acpi_operand_object *buffer_obj;
};

struct acpi_object_bank_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
	union acpi_operand_object *bank_obj;
};

struct acpi_object_index_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *index_obj;
	union acpi_operand_object *data_obj;
};

struct acpi_object_notify_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	u32 handler_type;
	acpi_notify_handler handler;
	void *context;
	union acpi_operand_object *next[2];
};

struct acpi_object_addr_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	u8 handler_flags;
	acpi_adr_space_handler handler;
	struct acpi_namespace_node *node;
	void *context;
	acpi_adr_space_setup setup;
	union acpi_operand_object *region_list;
	union acpi_operand_object *next;
};

struct acpi_object_reference {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 class;
	u8 target_type;
	u8 resolved;
	void *object;
	struct acpi_namespace_node *node;
	union acpi_operand_object **where;
	u8 *index_pointer;
	u8 *aml;
	u32 value;
};

struct acpi_object_extra {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *method_REG;
	struct acpi_namespace_node *scope_node;
	void *region_context;
	u8 *aml_start;
	u32 aml_length;
};

struct acpi_object_data {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	acpi_object_handler handler;
	void *pointer;
};

struct acpi_object_cache_list {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *next;
};

union acpi_operand_object {
	struct acpi_object_common common;
	struct acpi_object_integer integer;
	struct acpi_object_string string;
	struct acpi_object_buffer buffer;
	struct acpi_object_package package;
	struct acpi_object_event event;
	struct acpi_object_method method;
	struct acpi_object_mutex mutex;
	struct acpi_object_region region;
	struct acpi_object_notify_common common_notify;
	struct acpi_object_device device;
	struct acpi_object_power_resource power_resource;
	struct acpi_object_processor processor;
	struct acpi_object_thermal_zone thermal_zone;
	struct acpi_object_field_common common_field;
	struct acpi_object_region_field field;
	struct acpi_object_buffer_field buffer_field;
	struct acpi_object_bank_field bank_field;
	struct acpi_object_index_field index_field;
	struct acpi_object_notify_handler notify;
	struct acpi_object_addr_handler address_space;
	struct acpi_object_reference reference;
	struct acpi_object_extra extra;
	struct acpi_object_data data;
	struct acpi_object_cache_list cache;
	struct acpi_namespace_node node;
};

union acpi_parse_object;

union acpi_generic_state;

struct acpi_parse_state {
	u8 *aml_start;
	u8 *aml;
	u8 *aml_end;
	u8 *pkg_start;
	u8 *pkg_end;
	union acpi_parse_object *start_op;
	struct acpi_namespace_node *start_node;
	union acpi_generic_state *scope;
	union acpi_parse_object *start_scope;
	u32 aml_size;
};

typedef acpi_status (*acpi_parse_downwards)(struct acpi_walk_state *, union acpi_parse_object **);

typedef acpi_status (*acpi_parse_upwards)(struct acpi_walk_state *);

struct acpi_opcode_info;

struct acpi_walk_state {
	struct acpi_walk_state *next;
	u8 descriptor_type;
	u8 walk_type;
	u16 opcode;
	u8 next_op_info;
	u8 num_operands;
	u8 operand_index;
	acpi_owner_id owner_id;
	u8 last_predicate;
	u8 current_result;
	u8 return_used;
	u8 scope_depth;
	u8 pass_number;
	u8 namespace_override;
	u8 result_size;
	u8 result_count;
	u8 *aml;
	u32 arg_types;
	u32 method_breakpoint;
	u32 user_breakpoint;
	u32 parse_flags;
	struct acpi_parse_state parser_state;
	u32 prev_arg_types;
	u32 arg_count;
	u16 method_nesting_depth;
	u8 method_is_nested;
	struct acpi_namespace_node arguments[7];
	struct acpi_namespace_node local_variables[8];
	union acpi_operand_object *operands[9];
	union acpi_operand_object **params;
	u8 *aml_last_while;
	union acpi_operand_object **caller_return_desc;
	union acpi_generic_state *control_state;
	struct acpi_namespace_node *deferred_node;
	union acpi_operand_object *implicit_return_obj;
	struct acpi_namespace_node *method_call_node;
	union acpi_parse_object *method_call_op;
	union acpi_operand_object *method_desc;
	struct acpi_namespace_node *method_node;
	char *method_pathname;
	union acpi_parse_object *op;
	const struct acpi_opcode_info *op_info;
	union acpi_parse_object *origin;
	union acpi_operand_object *result_obj;
	union acpi_generic_state *results;
	union acpi_operand_object *return_desc;
	union acpi_generic_state *scope_info;
	union acpi_parse_object *prev_op;
	union acpi_parse_object *next_op;
	struct acpi_thread_state *thread;
	acpi_parse_downwards descending_callback;
	acpi_parse_upwards ascending_callback;
};

struct acpi_gpe_handler_info {
	acpi_gpe_handler address;
	void *context;
	struct acpi_namespace_node *method_node;
	u8 original_flags;
	u8 originally_enabled;
};

struct acpi_gpe_notify_info {
	struct acpi_namespace_node *device_node;
	struct acpi_gpe_notify_info *next;
};

union acpi_gpe_dispatch_info {
	struct acpi_namespace_node *method_node;
	struct acpi_gpe_handler_info *handler;
	struct acpi_gpe_notify_info *notify_list;
};

struct acpi_gpe_register_info;

struct acpi_gpe_event_info {
	union acpi_gpe_dispatch_info dispatch;
	struct acpi_gpe_register_info *register_info;
	u8 flags;
	u8 gpe_number;
	u8 runtime_count;
	u8 disable_for_dispatch;
};

struct acpi_gpe_address {
	u8 space_id;
	u64 address;
};

struct acpi_gpe_register_info {
	struct acpi_gpe_address status_address;
	struct acpi_gpe_address enable_address;
	u16 base_gpe_number;
	u8 enable_for_wake;
	u8 enable_for_run;
	u8 mask_for_run;
	u8 enable_mask;
};

struct acpi_gpe_xrupt_info;

struct acpi_gpe_block_info {
	struct acpi_namespace_node *node;
	struct acpi_gpe_block_info *previous;
	struct acpi_gpe_block_info *next;
	struct acpi_gpe_xrupt_info *xrupt_block;
	struct acpi_gpe_register_info *register_info;
	struct acpi_gpe_event_info *event_info;
	u64 address;
	u32 register_count;
	u16 gpe_count;
	u16 block_base_number;
	u8 space_id;
	u8 initialized;
};

struct acpi_gpe_xrupt_info {
	struct acpi_gpe_xrupt_info *previous;
	struct acpi_gpe_xrupt_info *next;
	struct acpi_gpe_block_info *gpe_block_list_head;
	u32 interrupt_number;
};

struct acpi_common_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
};

struct acpi_update_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *object;
};

struct acpi_pkg_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 index;
	union acpi_operand_object *source_object;
	union acpi_operand_object *dest_object;
	struct acpi_walk_state *walk_state;
	void *this_target_obj;
	u32 num_packages;
};

struct acpi_control_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u16 opcode;
	union acpi_parse_object *predicate_op;
	u8 *aml_predicate_start;
	u8 *package_end;
	u64 loop_timeout;
};

union acpi_parse_value {
	u64 integer;
	u32 size;
	char *string;
	u8 *buffer;
	char *name;
	union acpi_parse_object *arg;
};

struct acpi_parse_obj_common {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
};

struct acpi_parse_obj_named {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	char *path;
	u8 *data;
	u32 length;
	u32 name;
};

struct acpi_parse_obj_asl {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	union acpi_parse_object *child;
	union acpi_parse_object *parent_method;
	char *filename;
	u8 file_changed;
	char *parent_filename;
	char *external_name;
	char *namepath;
	char name_seg[4];
	u32 extra_value;
	u32 column;
	u32 line_number;
	u32 logical_line_number;
	u32 logical_byte_offset;
	u32 end_line;
	u32 end_logical_line;
	u32 acpi_btype;
	u32 aml_length;
	u32 aml_subtree_length;
	u32 final_aml_length;
	u32 final_aml_offset;
	u32 compile_flags;
	u16 parse_opcode;
	u8 aml_opcode_length;
	u8 aml_pkg_len_bytes;
	u8 extra;
	char parse_op_name[20];
};

union acpi_parse_object {
	struct acpi_parse_obj_common common;
	struct acpi_parse_obj_named named;
	struct acpi_parse_obj_asl asl;
};

struct acpi_scope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	struct acpi_namespace_node *node;
};

struct acpi_pscope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 arg_count;
	union acpi_parse_object *op;
	u8 *arg_end;
	u8 *pkg_end;
	u32 arg_list;
};

struct acpi_thread_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 current_sync_level;
	struct acpi_walk_state *walk_state_list;
	union acpi_operand_object *acquired_mutex_list;
	u64 thread_id;
};

struct acpi_result_values {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *obj_desc[8];
};

struct acpi_global_notify_handler {
	acpi_notify_handler handler;
	void *context;
};

struct acpi_notify_info {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 handler_list_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler_list_head;
	struct acpi_global_notify_handler *global;
};

union acpi_generic_state {
	struct acpi_common_state common;
	struct acpi_control_state control;
	struct acpi_update_state update;
	struct acpi_scope_state scope;
	struct acpi_pscope_state parse_scope;
	struct acpi_pkg_state pkg;
	struct acpi_thread_state thread;
	struct acpi_result_values results;
	struct acpi_notify_info notify;
};

struct acpi_opcode_info {
	u32 parse_args;
	u32 runtime_args;
	u16 flags;
	u8 object_type;
	u8 class;
	u8 type;
};

struct acpi_os_dpc {
	acpi_osd_exec_callback function;
	void *context;
	struct work_struct work;
};

struct acpi_ioremap {
	struct list_head list;
	void *virt;
	acpi_physical_address phys;
	acpi_size size;
	union {
		long unsigned int refcount;
		struct rcu_work rwork;
	} track;
};

struct acpi_hp_work {
	struct work_struct work;
	struct acpi_device *adev;
	u32 src;
};

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

struct acpi_pld_info {
	u8 revision;
	u8 ignore_color;
	u8 red;
	u8 green;
	u8 blue;
	u16 width;
	u16 height;
	u8 user_visible;
	u8 dock;
	u8 lid;
	u8 panel;
	u8 vertical_position;
	u8 horizontal_position;
	u8 shape;
	u8 group_orientation;
	u8 group_token;
	u8 group_position;
	u8 bay;
	u8 ejectable;
	u8 ospm_eject_required;
	u8 cabinet_number;
	u8 card_cage_number;
	u8 reference;
	u8 rotation;
	u8 order;
	u8 reserved;
	u16 vertical_offset;
	u16 horizontal_offset;
};

struct acpi_handle_list {
	u32 count;
	acpi_handle handles[10];
};

struct acpi_device_bus_id {
	char bus_id[15];
	unsigned int instance_no;
	struct list_head node;
};

struct acpi_dev_match_info {
	struct acpi_device_id hid[2];
	const char *uid;
	s64 hrv;
};

struct nvs_region {
	__u64 phys_start;
	__u64 size;
	struct list_head node;
};

struct nvs_page {
	long unsigned int phys_start;
	unsigned int size;
	void *kaddr;
	void *data;
	bool unmap;
	struct list_head node;
};

struct acpi_wakeup_handler {
	struct list_head list_node;
	bool (*wakeup)(void *);
	void *context;
};

typedef u32 acpi_event_status;

struct lpi_device_info {
	char *name;
	int enabled;
	union acpi_object *package;
};

struct lpi_device_constraint {
	int uid;
	int min_dstate;
	int function_states;
};

struct lpi_constraints {
	acpi_handle handle;
	int min_dstate;
};

struct acpi_hardware_id {
	struct list_head list;
	const char *id;
};

struct acpi_data_node {
	const char *name;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct fwnode_handle *parent;
	struct acpi_device_data data;
	struct list_head sibling;
	struct kobject kobj;
	struct completion kobj_done;
};

struct acpi_data_node_attr {
	struct attribute attr;
	ssize_t (*show)(struct acpi_data_node *, char *);
	ssize_t (*store)(struct acpi_data_node *, const char *, size_t);
};

struct acpi_device_physical_node {
	unsigned int node_id;
	struct list_head node;
	struct device *dev;
	bool put_online: 1;
};

enum acpi_bus_device_type {
	ACPI_BUS_TYPE_DEVICE = 0,
	ACPI_BUS_TYPE_POWER = 1,
	ACPI_BUS_TYPE_PROCESSOR = 2,
	ACPI_BUS_TYPE_THERMAL = 3,
	ACPI_BUS_TYPE_POWER_BUTTON = 4,
	ACPI_BUS_TYPE_SLEEP_BUTTON = 5,
	ACPI_BUS_TYPE_ECDT_EC = 6,
	ACPI_BUS_DEVICE_TYPE_COUNT = 7,
};

struct acpi_osc_context {
	char *uuid_str;
	int rev;
	struct acpi_buffer cap;
	struct acpi_buffer ret;
};

struct acpi_pnp_device_id {
	u32 length;
	char *string;
};

struct acpi_pnp_device_id_list {
	u32 count;
	u32 list_size;
	struct acpi_pnp_device_id ids[0];
};

struct acpi_device_info {
	u32 info_size;
	u32 name;
	acpi_object_type type;
	u8 param_count;
	u16 valid;
	u8 flags;
	u8 highest_dstates[4];
	u8 lowest_dstates[5];
	u64 address;
	struct acpi_pnp_device_id hardware_id;
	struct acpi_pnp_device_id unique_id;
	struct acpi_pnp_device_id class_code;
	struct acpi_pnp_device_id_list compatible_id_list;
};

struct acpi_table_spcr {
	struct acpi_table_header header;
	u8 interface_type;
	u8 reserved[3];
	struct acpi_generic_address serial_port;
	u8 interrupt_type;
	u8 pc_interrupt;
	u32 interrupt;
	u8 baud_rate;
	u8 parity;
	u8 stop_bits;
	u8 flow_control;
	u8 terminal_type;
	u8 reserved1;
	u16 pci_device_id;
	u16 pci_vendor_id;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u32 pci_flags;
	u8 pci_segment;
	u32 reserved2;
} __attribute__((packed));

struct acpi_table_stao {
	struct acpi_table_header header;
	u8 ignore_uart;
} __attribute__((packed));

enum acpi_reconfig_event {
	ACPI_RECONFIG_DEVICE_ADD = 0,
	ACPI_RECONFIG_DEVICE_REMOVE = 1,
};

struct acpi_probe_entry;

typedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *, struct acpi_probe_entry *);

struct acpi_probe_entry {
	__u8 id[5];
	__u8 type;
	acpi_probe_entry_validate_subtbl subtable_valid;
	union {
		acpi_tbl_table_handler probe_table;
		acpi_tbl_entry_handler probe_subtbl;
	};
	kernel_ulong_t driver_data;
};

struct acpi_dep_data {
	struct list_head node;
	acpi_handle master;
	acpi_handle slave;
};

struct acpi_table_events_work {
	struct work_struct work;
	void *table;
	u32 event;
};

struct resource_win {
	struct resource res;
	resource_size_t offset;
};

struct res_proc_context {
	struct list_head *list;
	int (*preproc)(struct acpi_resource *, void *);
	void *preproc_data;
	int count;
	int error;
};

struct acpi_processor_errata {
	u8 smp;
	struct {
		u8 throttle: 1;
		u8 fdma: 1;
		u8 reserved: 6;
		u32 bmisx;
	} piix4;
};

struct acpi_table_ecdt {
	struct acpi_table_header header;
	struct acpi_generic_address control;
	struct acpi_generic_address data;
	u32 uid;
	u8 gpe;
	u8 id[1];
} __attribute__((packed));

struct transaction;

struct acpi_ec {
	acpi_handle handle;
	int gpe;
	int irq;
	long unsigned int command_addr;
	long unsigned int data_addr;
	bool global_lock;
	long unsigned int flags;
	long unsigned int reference_count;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct list_head list;
	struct transaction *curr;
	spinlock_t lock;
	struct work_struct work;
	long unsigned int timestamp;
	long unsigned int nr_pending_queries;
	bool busy_polling;
	unsigned int polling_guard;
};

struct transaction {
	const u8 *wdata;
	u8 *rdata;
	short unsigned int irq_count;
	u8 command;
	u8 wi;
	u8 ri;
	u8 wlen;
	u8 rlen;
	u8 flags;
};

typedef int (*acpi_ec_query_func)(void *);

enum ec_command {
	ACPI_EC_COMMAND_READ = 128,
	ACPI_EC_COMMAND_WRITE = 129,
	ACPI_EC_BURST_ENABLE = 130,
	ACPI_EC_BURST_DISABLE = 131,
	ACPI_EC_COMMAND_QUERY = 132,
};

enum {
	EC_FLAGS_QUERY_ENABLED = 0,
	EC_FLAGS_QUERY_PENDING = 1,
	EC_FLAGS_QUERY_GUARDING = 2,
	EC_FLAGS_EVENT_HANDLER_INSTALLED = 3,
	EC_FLAGS_EC_HANDLER_INSTALLED = 4,
	EC_FLAGS_QUERY_METHODS_INSTALLED = 5,
	EC_FLAGS_STARTED = 6,
	EC_FLAGS_STOPPED = 7,
	EC_FLAGS_EVENTS_MASKED = 8,
};

struct acpi_ec_query_handler {
	struct list_head node;
	acpi_ec_query_func func;
	acpi_handle handle;
	void *data;
	u8 query_bit;
	struct kref kref;
};

struct acpi_ec_query {
	struct transaction transaction;
	struct work_struct work;
	struct acpi_ec_query_handler *handler;
};

struct dock_station {
	acpi_handle handle;
	long unsigned int last_dock_time;
	u32 flags;
	struct list_head dependent_devices;
	struct list_head sibling;
	struct platform_device *dock_device;
};

struct dock_dependent_device {
	struct list_head list;
	struct acpi_device *adev;
};

enum dock_callback_type {
	DOCK_CALL_HANDLER = 0,
	DOCK_CALL_FIXUP = 1,
	DOCK_CALL_UEVENT = 2,
};

struct acpi_pci_root_ops;

struct acpi_pci_root_info {
	struct acpi_pci_root *root;
	struct acpi_device *bridge;
	struct acpi_pci_root_ops *ops;
	struct list_head resources;
	char name[16];
};

struct acpi_pci_root_ops {
	struct pci_ops *pci_ops;
	int (*init_info)(struct acpi_pci_root_info *);
	void (*release_info)(struct acpi_pci_root_info *);
	int (*prepare_resources)(struct acpi_pci_root_info *);
};

struct pci_osc_bit_struct {
	u32 bit;
	char *desc;
};

struct acpi_handle_node {
	struct list_head node;
	acpi_handle handle;
};

struct acpi_pci_link_irq {
	u32 active;
	u8 triggering;
	u8 polarity;
	u8 resource_type;
	u8 possible_count;
	u32 possible[16];
	u8 initialized: 1;
	u8 reserved: 7;
};

struct acpi_pci_link {
	struct list_head list;
	struct acpi_device *device;
	struct acpi_pci_link_irq irq;
	int refcnt;
};

struct acpi_pci_routing_table {
	u32 length;
	u32 pin;
	u64 address;
	u32 source_index;
	char source[4];
};

struct acpi_prt_entry {
	struct acpi_pci_id id;
	u8 pin;
	acpi_handle link;
	u32 index;
};

struct prt_quirk {
	const struct dmi_system_id *system;
	unsigned int segment;
	unsigned int bus;
	unsigned int device;
	unsigned char pin;
	const char *source;
	const char *actual_source;
};

struct apd_private_data;

struct apd_device_desc {
	unsigned int fixed_clk_rate;
	struct property_entry *properties;
	int (*setup)(struct apd_private_data *);
};

struct apd_private_data {
	struct clk *clk;
	struct acpi_device *adev;
	const struct apd_device_desc *dev_desc;
};

struct acpi_power_dependent_device {
	struct device *dev;
	struct list_head node;
};

struct acpi_power_resource {
	struct acpi_device device;
	struct list_head list_node;
	char *name;
	u32 system_level;
	u32 order;
	unsigned int ref_count;
	bool wakeup_enabled;
	struct mutex resource_lock;
	struct list_head dependents;
};

struct acpi_power_resource_entry {
	struct list_head node;
	struct acpi_power_resource *resource;
};

struct acpi_bus_event {
	struct list_head node;
	acpi_device_class device_class;
	acpi_bus_id bus_id;
	u32 type;
	u32 data;
};

struct acpi_genl_event {
	acpi_device_class device_class;
	char bus_id[15];
	u32 type;
	u32 data;
};

enum {
	ACPI_GENL_ATTR_UNSPEC = 0,
	ACPI_GENL_ATTR_EVENT = 1,
	__ACPI_GENL_ATTR_MAX = 2,
};

enum {
	ACPI_GENL_CMD_UNSPEC = 0,
	ACPI_GENL_CMD_EVENT = 1,
	__ACPI_GENL_CMD_MAX = 2,
};

struct acpi_ged_device {
	struct device *dev;
	struct list_head event_list;
};

struct acpi_ged_event {
	struct list_head node;
	struct device *dev;
	unsigned int gsi;
	unsigned int irq;
	acpi_handle handle;
};

struct acpi_table_bert {
	struct acpi_table_header header;
	u32 region_length;
	u64 address;
};

struct acpi_table_attr {
	struct bin_attribute attr;
	char name[4];
	int instance;
	char filename[8];
	struct list_head node;
};

struct acpi_data_attr {
	struct bin_attribute attr;
	u64 addr;
};

struct acpi_data_obj {
	char *name;
	int (*fn)(void *, struct acpi_data_attr *);
};

struct event_counter {
	u32 count;
	u32 flags;
};

struct acpi_device_properties {
	const guid_t *guid;
	const union acpi_object *properties;
	struct list_head list;
};

struct always_present_id {
	struct acpi_device_id hid[2];
	struct x86_cpu_id cpu_ids[2];
	struct dmi_system_id dmi_ids[2];
	const char *uid;
};

struct acpi_lpat {
	int temp;
	int raw;
};

struct acpi_lpat_conversion_table {
	struct acpi_lpat *lpat;
	int lpat_count;
};

struct acpi_table_lpit {
	struct acpi_table_header header;
};

struct acpi_lpit_header {
	u32 type;
	u32 length;
	u16 unique_id;
	u16 reserved;
	u32 flags;
};

struct acpi_lpit_native {
	struct acpi_lpit_header header;
	struct acpi_generic_address entry_trigger;
	u32 residency;
	u32 latency;
	struct acpi_generic_address residency_counter;
	u64 counter_frequency;
} __attribute__((packed));

struct lpit_residency_info {
	struct acpi_generic_address gaddr;
	u64 frequency;
	void *iomem_addr;
};

enum {
	ACPI_REFCLASS_LOCAL = 0,
	ACPI_REFCLASS_ARG = 1,
	ACPI_REFCLASS_REFOF = 2,
	ACPI_REFCLASS_INDEX = 3,
	ACPI_REFCLASS_TABLE = 4,
	ACPI_REFCLASS_NAME = 5,
	ACPI_REFCLASS_DEBUG = 6,
	ACPI_REFCLASS_MAX = 6,
};

struct acpi_common_descriptor {
	void *common_pointer;
	u8 descriptor_type;
};

union acpi_descriptor {
	struct acpi_common_descriptor common;
	union acpi_operand_object object;
	struct acpi_namespace_node node;
	union acpi_parse_object op;
};

struct acpi_create_field_info {
	struct acpi_namespace_node *region_node;
	struct acpi_namespace_node *field_node;
	struct acpi_namespace_node *register_node;
	struct acpi_namespace_node *data_register_node;
	struct acpi_namespace_node *connection_node;
	u8 *resource_buffer;
	u32 bank_value;
	u32 field_bit_position;
	u32 field_bit_length;
	u16 resource_length;
	u16 pin_number_index;
	u8 field_flags;
	u8 attribute;
	u8 field_type;
	u8 access_length;
};

struct acpi_init_walk_info {
	u32 table_index;
	u32 object_count;
	u32 method_count;
	u32 serial_method_count;
	u32 non_serial_method_count;
	u32 serialized_method_count;
	u32 device_count;
	u32 op_region_count;
	u32 field_count;
	u32 buffer_count;
	u32 package_count;
	u32 op_region_init;
	u32 field_init;
	u32 buffer_init;
	u32 package_init;
	acpi_owner_id owner_id;
};

typedef u32 acpi_name;

typedef acpi_status (*acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);

struct acpi_name_info {
	char name[4];
	u16 argument_list;
	u8 expected_btypes;
} __attribute__((packed));

struct acpi_package_info {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 object_type2;
	u8 count2;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info2 {
	u8 type;
	u8 count;
	u8 object_type[4];
	u8 reserved;
};

struct acpi_package_info3 {
	u8 type;
	u8 count;
	u8 object_type[2];
	u8 tail_object_type;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info4 {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 sub_object_types;
	u8 pkg_count;
	u16 reserved;
} __attribute__((packed));

union acpi_predefined_info {
	struct acpi_name_info info;
	struct acpi_package_info ret_info;
	struct acpi_package_info2 ret_info2;
	struct acpi_package_info3 ret_info3;
	struct acpi_package_info4 ret_info4;
};

struct acpi_evaluate_info {
	struct acpi_namespace_node *prefix_node;
	const char *relative_pathname;
	union acpi_operand_object **parameters;
	struct acpi_namespace_node *node;
	union acpi_operand_object *obj_desc;
	char *full_pathname;
	const union acpi_predefined_info *predefined;
	union acpi_operand_object *return_object;
	union acpi_operand_object *parent_package;
	u32 return_flags;
	u32 return_btype;
	u16 param_count;
	u16 node_flags;
	u8 pass_number;
	u8 return_object_type;
	u8 flags;
};

enum {
	AML_FIELD_ACCESS_ANY = 0,
	AML_FIELD_ACCESS_BYTE = 1,
	AML_FIELD_ACCESS_WORD = 2,
	AML_FIELD_ACCESS_DWORD = 3,
	AML_FIELD_ACCESS_QWORD = 4,
	AML_FIELD_ACCESS_BUFFER = 5,
};

typedef enum {
	ACPI_IMODE_LOAD_PASS1 = 1,
	ACPI_IMODE_LOAD_PASS2 = 2,
	ACPI_IMODE_EXECUTE = 3,
} acpi_interpreter_mode;

typedef acpi_status (*acpi_execute_op)(struct acpi_walk_state *);

typedef void (*acpi_gbl_event_handler)(u32, acpi_handle, u32, void *);

typedef u32 (*acpi_event_handler)(void *);

struct acpi_fixed_event_handler {
	acpi_event_handler handler;
	void *context;
};

struct acpi_fixed_event_info {
	u8 status_register_id;
	u8 enable_register_id;
	u16 status_bit_mask;
	u16 enable_bit_mask;
};

struct acpi_gpe_walk_info {
	struct acpi_namespace_node *gpe_device;
	struct acpi_gpe_block_info *gpe_block;
	u16 count;
	acpi_owner_id owner_id;
	u8 execute_by_owner_id;
};

struct acpi_gpe_device_info {
	u32 index;
	u32 next_block_base_index;
	acpi_status status;
	struct acpi_namespace_node *gpe_device;
};

typedef acpi_status (*acpi_gpe_callback)(struct acpi_gpe_xrupt_info *, struct acpi_gpe_block_info *, void *);

struct acpi_table_facs {
	char signature[4];
	u32 length;
	u32 hardware_signature;
	u32 firmware_waking_vector;
	u32 global_lock;
	u32 flags;
	u64 xfirmware_waking_vector;
	u8 version;
	u8 reserved[3];
	u32 ospm_flags;
	u8 reserved1[24];
};

struct acpi_reg_walk_info {
	u32 function;
	u32 reg_run_count;
	acpi_adr_space_type space_id;
};

typedef u32 (*acpi_sci_handler)(void *);

struct acpi_sci_handler_info {
	struct acpi_sci_handler_info *next;
	acpi_sci_handler address;
	void *context;
};

enum {
	AML_FIELD_UPDATE_PRESERVE = 0,
	AML_FIELD_UPDATE_WRITE_AS_ONES = 32,
	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 64,
};

struct acpi_signal_fatal_info {
	u32 type;
	u32 code;
	u32 argument;
};

enum {
	MATCH_MTR = 0,
	MATCH_MEQ = 1,
	MATCH_MLE = 2,
	MATCH_MLT = 3,
	MATCH_MGE = 4,
	MATCH_MGT = 5,
};

enum {
	AML_FIELD_ATTRIB_QUICK = 2,
	AML_FIELD_ATTRIB_SEND_RECEIVE = 4,
	AML_FIELD_ATTRIB_BYTE = 6,
	AML_FIELD_ATTRIB_WORD = 8,
	AML_FIELD_ATTRIB_BLOCK = 10,
	AML_FIELD_ATTRIB_BYTES = 11,
	AML_FIELD_ATTRIB_PROCESS_CALL = 12,
	AML_FIELD_ATTRIB_BLOCK_PROCESS_CALL = 13,
	AML_FIELD_ATTRIB_RAW_BYTES = 14,
	AML_FIELD_ATTRIB_RAW_PROCESS_BYTES = 15,
};

typedef enum {
	ACPI_TRACE_AML_METHOD = 0,
	ACPI_TRACE_AML_OPCODE = 1,
	ACPI_TRACE_AML_REGION = 2,
} acpi_trace_event_type;

struct acpi_gpe_block_status_context {
	struct acpi_gpe_register_info *gpe_skip_register_info;
	u8 gpe_skip_mask;
	u8 retval;
};

struct acpi_bit_register_info {
	u8 parent_register;
	u8 bit_position;
	u16 access_bit_mask;
};

struct acpi_port_info {
	char *name;
	u16 start;
	u16 end;
	u8 osi_dependency;
};

struct acpi_pci_device {
	acpi_handle device;
	struct acpi_pci_device *next;
};

typedef acpi_status (*acpi_init_handler)(acpi_handle, u32);

struct acpi_device_walk_info {
	struct acpi_table_desc *table_desc;
	struct acpi_evaluate_info *evaluate_info;
	u32 device_count;
	u32 num_STA;
	u32 num_INI;
};

struct acpi_table_list {
	struct acpi_table_desc *tables;
	u32 current_table_count;
	u32 max_table_count;
	u8 flags;
};

enum acpi_return_package_types {
	ACPI_PTYPE1_FIXED = 1,
	ACPI_PTYPE1_VAR = 2,
	ACPI_PTYPE1_OPTION = 3,
	ACPI_PTYPE2 = 4,
	ACPI_PTYPE2_COUNT = 5,
	ACPI_PTYPE2_PKG_COUNT = 6,
	ACPI_PTYPE2_FIXED = 7,
	ACPI_PTYPE2_MIN = 8,
	ACPI_PTYPE2_REV_FIXED = 9,
	ACPI_PTYPE2_FIX_VAR = 10,
	ACPI_PTYPE2_VAR_VAR = 11,
	ACPI_PTYPE2_UUID_PAIR = 12,
	ACPI_PTYPE_CUSTOM = 13,
};

typedef acpi_status (*acpi_object_converter)(struct acpi_namespace_node *, union acpi_operand_object *, union acpi_operand_object **);

struct acpi_simple_repair_info {
	char name[4];
	u32 unexpected_btypes;
	u32 package_index;
	acpi_object_converter object_converter;
};

typedef acpi_status (*acpi_repair_function)(struct acpi_evaluate_info *, union acpi_operand_object **);

struct acpi_repair_info {
	char name[4];
	acpi_repair_function repair_function;
};

struct acpi_namestring_info {
	const char *external_name;
	const char *next_external_char;
	char *internal_name;
	u32 length;
	u32 num_segments;
	u32 num_carats;
	u8 fully_qualified;
};

typedef acpi_status (*acpi_walk_callback)(acpi_handle, u32, void *, void **);

struct acpi_rw_lock {
	void *writer_mutex;
	void *reader_mutex;
	u32 num_readers;
};

struct acpi_get_devices_info {
	acpi_walk_callback user_function;
	void *context;
	const char *hid;
};

struct aml_resource_small_header {
	u8 descriptor_type;
};

struct aml_resource_irq {
	u8 descriptor_type;
	u16 irq_mask;
	u8 flags;
} __attribute__((packed));

struct aml_resource_dma {
	u8 descriptor_type;
	u8 dma_channel_mask;
	u8 flags;
};

struct aml_resource_start_dependent {
	u8 descriptor_type;
	u8 flags;
};

struct aml_resource_end_dependent {
	u8 descriptor_type;
};

struct aml_resource_io {
	u8 descriptor_type;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u8 alignment;
	u8 address_length;
};

struct aml_resource_fixed_io {
	u8 descriptor_type;
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct aml_resource_vendor_small {
	u8 descriptor_type;
};

struct aml_resource_end_tag {
	u8 descriptor_type;
	u8 checksum;
};

struct aml_resource_fixed_dma {
	u8 descriptor_type;
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct aml_resource_large_header {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory24 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_vendor_large {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_fixed_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
} __attribute__((packed));

struct aml_resource_extended_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u8 revision_ID;
	u8 reserved;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
	u64 type_specific;
} __attribute__((packed));

struct aml_resource_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
} __attribute__((packed));

struct aml_resource_address32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address16 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_extended_irq {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u8 interrupt_count;
	u32 interrupts[1];
} __attribute__((packed));

struct aml_resource_generic_register {
	u8 descriptor_type;
	u16 resource_length;
	u8 address_space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct aml_resource_gpio {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 connection_type;
	u16 flags;
	u16 int_flags;
	u8 pin_config;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_common_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_i2c_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u16 slave_address;
} __attribute__((packed));

struct aml_resource_spi_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
} __attribute__((packed));

struct aml_resource_uart_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 default_baud_rate;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u8 parity;
	u8 lines_enabled;
} __attribute__((packed));

struct aml_resource_pin_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config;
	u16 function_number;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 pin_table_offset;
	u16 label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 function_number;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

union aml_resource {
	u8 descriptor_type;
	struct aml_resource_small_header small_header;
	struct aml_resource_large_header large_header;
	struct aml_resource_irq irq;
	struct aml_resource_dma dma;
	struct aml_resource_start_dependent start_dpf;
	struct aml_resource_end_dependent end_dpf;
	struct aml_resource_io io;
	struct aml_resource_fixed_io fixed_io;
	struct aml_resource_fixed_dma fixed_dma;
	struct aml_resource_vendor_small vendor_small;
	struct aml_resource_end_tag end_tag;
	struct aml_resource_memory24 memory24;
	struct aml_resource_generic_register generic_reg;
	struct aml_resource_vendor_large vendor_large;
	struct aml_resource_memory32 memory32;
	struct aml_resource_fixed_memory32 fixed_memory32;
	struct aml_resource_address16 address16;
	struct aml_resource_address32 address32;
	struct aml_resource_address64 address64;
	struct aml_resource_extended_address64 ext_address64;
	struct aml_resource_extended_irq extended_irq;
	struct aml_resource_gpio gpio;
	struct aml_resource_i2c_serialbus i2c_serial_bus;
	struct aml_resource_spi_serialbus spi_serial_bus;
	struct aml_resource_uart_serialbus uart_serial_bus;
	struct aml_resource_common_serialbus common_serial_bus;
	struct aml_resource_pin_function pin_function;
	struct aml_resource_pin_config pin_config;
	struct aml_resource_pin_group pin_group;
	struct aml_resource_pin_group_function pin_group_function;
	struct aml_resource_pin_group_config pin_group_config;
	struct aml_resource_address address;
	u32 dword_item;
	u16 word_item;
	u8 byte_item;
};

struct acpi_rsconvert_info {
	u8 opcode;
	u8 resource_offset;
	u8 aml_offset;
	u8 value;
};

enum {
	ACPI_RSC_INITGET = 0,
	ACPI_RSC_INITSET = 1,
	ACPI_RSC_FLAGINIT = 2,
	ACPI_RSC_1BITFLAG = 3,
	ACPI_RSC_2BITFLAG = 4,
	ACPI_RSC_3BITFLAG = 5,
	ACPI_RSC_ADDRESS = 6,
	ACPI_RSC_BITMASK = 7,
	ACPI_RSC_BITMASK16 = 8,
	ACPI_RSC_COUNT = 9,
	ACPI_RSC_COUNT16 = 10,
	ACPI_RSC_COUNT_GPIO_PIN = 11,
	ACPI_RSC_COUNT_GPIO_RES = 12,
	ACPI_RSC_COUNT_GPIO_VEN = 13,
	ACPI_RSC_COUNT_SERIAL_RES = 14,
	ACPI_RSC_COUNT_SERIAL_VEN = 15,
	ACPI_RSC_DATA8 = 16,
	ACPI_RSC_EXIT_EQ = 17,
	ACPI_RSC_EXIT_LE = 18,
	ACPI_RSC_EXIT_NE = 19,
	ACPI_RSC_LENGTH = 20,
	ACPI_RSC_MOVE_GPIO_PIN = 21,
	ACPI_RSC_MOVE_GPIO_RES = 22,
	ACPI_RSC_MOVE_SERIAL_RES = 23,
	ACPI_RSC_MOVE_SERIAL_VEN = 24,
	ACPI_RSC_MOVE8 = 25,
	ACPI_RSC_MOVE16 = 26,
	ACPI_RSC_MOVE32 = 27,
	ACPI_RSC_MOVE64 = 28,
	ACPI_RSC_SET8 = 29,
	ACPI_RSC_SOURCE = 30,
	ACPI_RSC_SOURCEX = 31,
};

typedef u16 acpi_rs_length;

typedef u32 acpi_rsdesc_size;

struct acpi_vendor_uuid {
	u8 subtype;
	u8 data[16];
};

typedef acpi_status (*acpi_walk_resource_callback)(struct acpi_resource *, void *);

struct acpi_vendor_walk_info {
	struct acpi_vendor_uuid *uuid;
	struct acpi_buffer *buffer;
	acpi_status status;
};

typedef acpi_status (*acpi_table_handler)(u32, void *, void *);

struct acpi_fadt_info {
	const char *name;
	u16 address64;
	u16 address32;
	u16 length;
	u8 default_length;
	u8 flags;
};

struct acpi_fadt_pm_info {
	struct acpi_generic_address *target;
	u16 source;
	u8 register_num;
};

struct acpi_table_rsdp {
	char signature[8];
	u8 checksum;
	char oem_id[6];
	u8 revision;
	u32 rsdt_physical_address;
	u32 length;
	u64 xsdt_physical_address;
	u8 extended_checksum;
	u8 reserved[3];
} __attribute__((packed));

struct acpi_address_range {
	struct acpi_address_range *next;
	struct acpi_namespace_node *region_node;
	acpi_physical_address start_address;
	acpi_physical_address end_address;
};

struct acpi_pkg_info {
	u8 *free_space;
	acpi_size length;
	u32 object_space;
	u32 num_packages;
};

struct acpi_exception_info {
	char *name;
};

typedef u32 (*acpi_interface_handler)(acpi_string, u32);

struct acpi_mutex_info {
	void *mutex;
	u32 use_count;
	u64 thread_id;
};

struct acpi_comment_node {
	char *comment;
	struct acpi_comment_node *next;
};

struct acpi_interface_info {
	char *name;
	struct acpi_interface_info *next;
	u8 flags;
	u8 value;
};

typedef acpi_status (*acpi_pkg_callback)(u8, union acpi_operand_object *, union acpi_generic_state *, void *);

typedef u32 acpi_mutex_handle;

typedef acpi_status (*acpi_walk_aml_callback)(u8 *, u32, u32, u8, void **);

struct acpi_fan_fps {
	u64 control;
	u64 trip_point;
	u64 speed;
	u64 noise_level;
	u64 power;
	char name[20];
	struct device_attribute dev_attr;
};

struct acpi_fan_fif {
	u64 revision;
	u64 fine_grain_ctrl;
	u64 step_size;
	u64 low_speed_notification;
};

struct acpi_fan {
	bool acpi4;
	struct acpi_fan_fif fif;
	struct acpi_fan_fps *fps;
	int fps_count;
	struct thermal_cooling_device *cdev;
};

struct acpi_lpi_states_array {
	unsigned int size;
	unsigned int composite_states_size;
	struct acpi_lpi_state *entries;
	struct acpi_lpi_state *composite_states[8];
};

struct throttling_tstate {
	unsigned int cpu;
	int target_state;
};

struct acpi_processor_throttling_arg {
	struct acpi_processor *pr;
	int target_state;
	bool force;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
	THERMAL_TREND_RAISE_FULL = 3,
	THERMAL_TREND_DROP_FULL = 4,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_zone_device;

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	int (*notify)(struct thermal_zone_device *, int, enum thermal_trip_type);
};

struct thermal_attr;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	int trips;
	long unsigned int trips_disabled;
	int passive_delay;
	int polling_delay;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	unsigned int forced_passive;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

struct acpi_thermal_state {
	u8 critical: 1;
	u8 hot: 1;
	u8 passive: 1;
	u8 active: 1;
	u8 reserved: 4;
	int active_index;
};

struct acpi_thermal_state_flags {
	u8 valid: 1;
	u8 enabled: 1;
	u8 reserved: 6;
};

struct acpi_thermal_critical {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
};

struct acpi_thermal_hot {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
};

struct acpi_thermal_passive {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
	long unsigned int tc1;
	long unsigned int tc2;
	long unsigned int tsp;
	struct acpi_handle_list devices;
};

struct acpi_thermal_active {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
	struct acpi_handle_list devices;
};

struct acpi_thermal_trips {
	struct acpi_thermal_critical critical;
	struct acpi_thermal_hot hot;
	struct acpi_thermal_passive passive;
	struct acpi_thermal_active active[10];
};

struct acpi_thermal_flags {
	u8 cooling_mode: 1;
	u8 devices: 1;
	u8 reserved: 6;
};

struct acpi_thermal {
	struct acpi_device *device;
	acpi_bus_id name;
	long unsigned int temperature;
	long unsigned int last_temperature;
	long unsigned int polling_frequency;
	volatile u8 zombie;
	struct acpi_thermal_flags flags;
	struct acpi_thermal_state state;
	struct acpi_thermal_trips trips;
	struct acpi_handle_list devices;
	struct thermal_zone_device *thermal_zone;
	int kelvin_offset;
	struct work_struct thermal_check_work;
};

struct acpi_table_slit {
	struct acpi_table_header header;
	u64 locality_count;
	u8 entry[1];
} __attribute__((packed));

struct acpi_table_srat {
	struct acpi_table_header header;
	u32 table_revision;
	u64 reserved;
};

enum acpi_srat_type {
	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
	ACPI_SRAT_TYPE_GICC_AFFINITY = 3,
	ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 4,
	ACPI_SRAT_TYPE_GENERIC_AFFINITY = 5,
	ACPI_SRAT_TYPE_RESERVED = 6,
};

struct acpi_srat_mem_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u64 base_address;
	u64 length;
	u32 reserved1;
	u32 flags;
	u64 reserved2;
} __attribute__((packed));

struct acpi_srat_gicc_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
} __attribute__((packed));

struct acpi_srat_generic_affinity {
	struct acpi_subtable_header header;
	u8 reserved;
	u8 device_handle_type;
	u32 proximity_domain;
	u8 device_handle[16];
	u32 flags;
	u32 reserved1;
};

struct acpi_pci_ioapic {
	acpi_handle root_handle;
	acpi_handle handle;
	u32 gsi_base;
	struct resource res;
	struct pci_dev *pdev;
	struct list_head list;
};

struct acpi_pcct_hw_reduced {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_shared_memory {
	u32 signature;
	u16 command;
	u16 status;
};

struct mbox_chan;

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_controller;

struct mbox_client;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	struct list_head node;
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct cpc_register_resource {
	acpi_object_type type;
	u64 *sys_mem_vaddr;
	union {
		struct cpc_reg reg;
		u64 int_value;
	} cpc_entry;
};

struct cpc_desc {
	int num_entries;
	int version;
	int cpu_id;
	int write_cmd_status;
	int write_cmd_id;
	struct cpc_register_resource cpc_regs[21];
	struct acpi_psd_package domain_info;
	struct kobject kobj;
};

enum cppc_regs {
	HIGHEST_PERF = 0,
	NOMINAL_PERF = 1,
	LOW_NON_LINEAR_PERF = 2,
	LOWEST_PERF = 3,
	GUARANTEED_PERF = 4,
	DESIRED_PERF = 5,
	MIN_PERF = 6,
	MAX_PERF = 7,
	PERF_REDUC_TOLERANCE = 8,
	TIME_WINDOW = 9,
	CTR_WRAP_TIME = 10,
	REFERENCE_CTR = 11,
	DELIVERED_CTR = 12,
	PERF_LIMITED = 13,
	ENABLE = 14,
	AUTO_SEL_ENABLE = 15,
	AUTO_ACT_WINDOW = 16,
	ENERGY_PERF = 17,
	REFERENCE_PERF = 18,
	LOWEST_FREQ = 19,
	NOMINAL_FREQ = 20,
};

struct cppc_perf_caps {
	u32 guaranteed_perf;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_freq;
	u32 nominal_freq;
};

struct cppc_perf_ctrls {
	u32 max_perf;
	u32 min_perf;
	u32 desired_perf;
};

struct cppc_perf_fb_ctrs {
	u64 reference;
	u64 delivered;
	u64 reference_perf;
	u64 wraparound_time;
};

struct cppc_cpudata {
	int cpu;
	struct cppc_perf_caps perf_caps;
	struct cppc_perf_ctrls perf_ctrls;
	struct cppc_perf_fb_ctrs perf_fb_ctrs;
	struct cpufreq_policy *cur_policy;
	unsigned int shared_type;
	cpumask_var_t shared_cpu_map;
};

struct cppc_pcc_data {
	struct mbox_chan *pcc_channel;
	void *pcc_comm_addr;
	bool pcc_channel_acquired;
	unsigned int deadline_us;
	unsigned int pcc_mpar;
	unsigned int pcc_mrtt;
	unsigned int pcc_nominal;
	bool pending_pcc_write_cmd;
	bool platform_owns_pcc;
	unsigned int pcc_write_cnt;
	struct rw_semaphore pcc_lock;
	wait_queue_head_t pcc_write_wait_q;
	ktime_t last_cmd_cmpl_time;
	ktime_t last_mpar_reset;
	int mpar_count;
	int refcount;
};

struct cppc_attr {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, ssize_t);
};

struct pnp_resource {
	struct list_head list;
	struct resource res;
};

struct pnp_port {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

typedef struct {
	long unsigned int bits[4];
} pnp_irq_mask_t;

struct pnp_irq {
	pnp_irq_mask_t map;
	unsigned char flags;
};

struct pnp_dma {
	unsigned char map;
	unsigned char flags;
};

struct pnp_mem {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_option {
	struct list_head list;
	unsigned int flags;
	long unsigned int type;
	union {
		struct pnp_port port;
		struct pnp_irq irq;
		struct pnp_dma dma;
		struct pnp_mem mem;
	} u;
};

struct pnp_info_buffer {
	char *buffer;
	char *curr;
	long unsigned int size;
	long unsigned int len;
	int stop;
	int error;
};

typedef struct pnp_info_buffer pnp_info_buffer_t;

struct pnp_fixup {
	char id[7];
	void (*quirk_function)(struct pnp_dev *);
};

struct acpipnp_parse_option_s {
	struct pnp_dev *dev;
	unsigned int option_flags;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_hw;

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
	long unsigned int flags;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct gpio_desc___2;

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc___2 *gpiod;
};

struct pmc_clk {
	const char *name;
	long unsigned int freq;
	const char *parent_name;
};

struct pmc_clk_data {
	void *base;
	const struct pmc_clk *clks;
	bool critical;
};

struct clk_plt_fixed {
	struct clk_hw *clk;
	struct clk_lookup *lookup;
};

struct clk_plt {
	struct clk_hw hw;
	void *reg;
	struct clk_lookup *lookup;
	spinlock_t lock;
};

struct clk_plt_data {
	struct clk_plt_fixed **parents;
	u8 nparents;
	struct clk_plt *clks[6];
	struct clk_lookup *mclk_lookup;
	struct clk_lookup *ether_clk_lookup;
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan___2 {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan___2 *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	struct mutex chan_mutex;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan___2 *);
	void (*device_free_chan_resources)(struct dma_chan___2 *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan___2 *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan___2 *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan___2 *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan___2 *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan___2 *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan___2 *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan___2 *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan___2 *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan___2 *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan___2 *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan___2 *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan___2 *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan___2 *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan___2 *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan___2 *);
	int (*device_resume)(struct dma_chan___2 *);
	int (*device_terminate_all)(struct dma_chan___2 *);
	void (*device_synchronize)(struct dma_chan___2 *);
	enum dma_status (*device_tx_status)(struct dma_chan___2 *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan___2 *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_chan_dev {
	struct dma_chan___2 *chan;
	struct device device;
	int dev_id;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	unsigned int slave_id;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan___2 *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct dma_chan_tbl_ent {
	struct dma_chan___2 *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct acpi_table_csrt {
	struct acpi_table_header header;
};

struct acpi_csrt_group {
	u32 length;
	u32 vendor_id;
	u32 subvendor_id;
	u16 device_id;
	u16 subdevice_id;
	u16 revision;
	u16 reserved;
	u32 shared_info_length;
};

struct acpi_csrt_shared_info {
	u16 major_version;
	u16 minor_version;
	u32 mmio_base_low;
	u32 mmio_base_high;
	u32 gsi_interrupt;
	u8 interrupt_polarity;
	u8 interrupt_mode;
	u8 num_channels;
	u8 dma_address_width;
	u16 base_request_line;
	u16 num_handshake_signals;
	u32 max_block_size;
};

struct acpi_dma_spec {
	int chan_id;
	int slave_id;
	struct device *dev;
};

struct acpi_dma {
	struct list_head dma_controllers;
	struct device *dev;
	struct dma_chan___2 * (*acpi_dma_xlate)(struct acpi_dma_spec *, struct acpi_dma *);
	void *data;
	short unsigned int base_request_line;
	short unsigned int end_request_line;
};

struct acpi_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct acpi_dma_parser_data {
	struct acpi_dma_spec dma_spec;
	size_t index;
	size_t n;
};

struct dca_ops;

struct dca_provider {
	struct list_head node;
	const struct dca_ops *ops;
	struct device *cd;
	int id;
};

struct dca_ops {
	int (*add_requester)(struct dca_provider *, struct device *);
	int (*remove_requester)(struct dca_provider *, struct device *);
	u8 (*get_tag)(struct dca_provider *, struct device *, int);
	int (*dev_managed)(struct dca_provider *, struct device *);
};

struct ioat_dma_descriptor {
	uint32_t size;
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int null: 1;
			unsigned int src_brk: 1;
			unsigned int dest_brk: 1;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int rsvd2: 13;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t dst_addr;
	uint64_t next;
	uint64_t rsv1;
	uint64_t rsv2;
	union {
		uint64_t user1;
		uint64_t tx_cnt;
	};
	uint64_t user2;
};

struct ioat_xor_descriptor {
	uint32_t size;
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int src_cnt: 3;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int rsvd: 13;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t dst_addr;
	uint64_t next;
	uint64_t src_addr2;
	uint64_t src_addr3;
	uint64_t src_addr4;
	uint64_t src_addr5;
};

struct ioat_xor_ext_descriptor {
	uint64_t src_addr6;
	uint64_t src_addr7;
	uint64_t src_addr8;
	uint64_t next;
	uint64_t rsvd[4];
};

struct ioat_pq_descriptor {
	union {
		uint32_t size;
		uint32_t dwbes;
		struct {
			unsigned int rsvd: 25;
			unsigned int p_val_err: 1;
			unsigned int q_val_err: 1;
			unsigned int rsvd1: 4;
			unsigned int wbes: 1;
		} dwbes_f;
	};
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int src_cnt: 3;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int p_disable: 1;
			unsigned int q_disable: 1;
			unsigned int rsvd2: 2;
			unsigned int wb_en: 1;
			unsigned int prl_en: 1;
			unsigned int rsvd3: 7;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t p_addr;
	uint64_t next;
	uint64_t src_addr2;
	union {
		uint64_t src_addr3;
		uint64_t sed_addr;
	};
	uint8_t coef[8];
	uint64_t q_addr;
};

struct ioat_pq_ext_descriptor {
	uint64_t src_addr4;
	uint64_t src_addr5;
	uint64_t src_addr6;
	uint64_t next;
	uint64_t src_addr7;
	uint64_t src_addr8;
	uint64_t rsvd[2];
};

struct ioat_pq_update_descriptor {
	uint32_t size;
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int src_cnt: 3;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int p_disable: 1;
			unsigned int q_disable: 1;
			unsigned int rsvd: 3;
			unsigned int coef: 8;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t p_addr;
	uint64_t next;
	uint64_t src_addr2;
	uint64_t p_src;
	uint64_t q_src;
	uint64_t q_addr;
};

struct ioat_raw_descriptor {
	uint64_t field[8];
};

struct ioat_sed_raw_descriptor {
	uint64_t a[8];
	uint64_t b[8];
	uint64_t c[8];
};

enum ioat_irq_mode {
	IOAT_NOIRQ = 0,
	IOAT_MSIX = 1,
	IOAT_MSI = 2,
	IOAT_INTX = 3,
};

struct dma_pool___2;

struct ioatdma_chan;

struct ioatdma_device {
	struct pci_dev *pdev;
	void *reg_base;
	struct dma_pool___2 *completion_pool;
	struct dma_pool___2 *sed_hw_pool[5];
	struct dma_device dma_dev;
	u8 version;
	struct msix_entry msix_entries[4];
	struct ioatdma_chan *idx[4];
	struct dca_provider *dca;
	enum ioat_irq_mode irq_mode;
	u32 cap;
	u64 msixtba0;
	u64 msixdata0;
	u32 msixpba;
};

struct ioat_descs {
	void *virt;
	dma_addr_t hw;
};

struct ioat_ring_ent;

struct ioatdma_chan {
	struct dma_chan___2 dma_chan;
	void *reg_base;
	dma_addr_t last_completion;
	spinlock_t cleanup_lock;
	long unsigned int state;
	struct timer_list timer;
	struct ioatdma_device *ioat_dma;
	dma_addr_t completion_dma;
	u64 *completion;
	struct tasklet_struct cleanup_task;
	struct kobject kobj;
	size_t xfercap_log;
	u16 head;
	u16 issued;
	u16 tail;
	u16 dmacount;
	u16 alloc_order;
	u16 produce;
	struct ioat_ring_ent **ring;
	spinlock_t prep_lock;
	struct ioat_descs descs[8];
	int desc_chunks;
	int intr_coalesce;
	int prev_intr_coalesce;
};

struct ioat_sed_ent;

struct ioat_ring_ent {
	union {
		struct ioat_dma_descriptor *hw;
		struct ioat_xor_descriptor *xor;
		struct ioat_xor_ext_descriptor *xor_ex;
		struct ioat_pq_descriptor *pq;
		struct ioat_pq_ext_descriptor *pq_ex;
		struct ioat_pq_update_descriptor *pqu;
		struct ioat_raw_descriptor *raw;
	};
	size_t len;
	struct dma_async_tx_descriptor txd;
	enum sum_check_flags *result;
	struct ioat_sed_ent *sed;
};

struct ioat_sed_ent {
	struct ioat_sed_raw_descriptor *hw;
	dma_addr_t dma;
	struct ioat_ring_ent *parent;
	unsigned int hw_pool;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct ioat_pq16a_descriptor {
	uint8_t coef[8];
	uint64_t src_addr3;
	uint64_t src_addr4;
	uint64_t src_addr5;
	uint64_t src_addr6;
	uint64_t src_addr7;
	uint64_t src_addr8;
	uint64_t src_addr9;
};

struct ioat_dca_slot {
	struct pci_dev *pdev;
	u16 rid;
};

struct ioat_dca_priv {
	void *iobase;
	void *dca_base;
	int max_requesters;
	int requester_count;
	u8 tag_map[8];
	struct ioat_dca_slot req_slots[0];
};

struct ioat_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct dma_chan___2 *, char *);
	ssize_t (*store)(struct dma_chan___2 *, const char *, size_t);
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

typedef struct vring_desc vring_desc_t;

typedef struct vring_avail vring_avail_t;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 next;
	u16 last;
};

struct vring_desc_extra_packed {
	dma_addr_t addr;
	u32 len;
	u16 flags;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	union {
		struct {
			struct vring vring;
			u16 avail_flags_shadow;
			u16 avail_idx_shadow;
			struct vring_desc_state_split *desc_state;
			dma_addr_t queue_dma_addr;
			size_t queue_size_in_bytes;
		} split;
		struct {
			struct {
				unsigned int num;
				struct vring_packed_desc *desc;
				struct vring_packed_desc_event *driver;
				struct vring_packed_desc_event *device;
			} vring;
			bool avail_wrap_counter;
			bool used_wrap_counter;
			u16 avail_used_flags;
			u16 next_avail_idx;
			u16 event_flags_shadow;
			struct vring_desc_state_packed *desc_state;
			struct vring_desc_extra_packed *desc_extra;
			dma_addr_t ring_dma_addr;
			dma_addr_t driver_event_dma_addr;
			dma_addr_t device_event_dma_addr;
			size_t ring_size_in_bytes;
			size_t event_size_in_bytes;
		} packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	u8 *isr;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	size_t notify_len;
	size_t device_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	void *ioaddr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct virtio_pci_vq_info **vqs;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

struct virtio_balloon_config {
	__le32 num_pages;
	__le32 actual;
	union {
		__le32 free_page_hint_cmd_id;
		__le32 free_page_report_cmd_id;
	};
	__le32 poison_val;
};

struct virtio_balloon_stat {
	__virtio16 tag;
	__virtio64 val;
} __attribute__((packed));

enum virtio_balloon_vq {
	VIRTIO_BALLOON_VQ_INFLATE = 0,
	VIRTIO_BALLOON_VQ_DEFLATE = 1,
	VIRTIO_BALLOON_VQ_STATS = 2,
	VIRTIO_BALLOON_VQ_FREE_PAGE = 3,
	VIRTIO_BALLOON_VQ_REPORTING = 4,
	VIRTIO_BALLOON_VQ_MAX = 5,
};

enum virtio_balloon_config_read {
	VIRTIO_BALLOON_CONFIG_READ_CMD_ID = 0,
};

struct virtio_balloon {
	struct virtio_device *vdev;
	struct virtqueue *inflate_vq;
	struct virtqueue *deflate_vq;
	struct virtqueue *stats_vq;
	struct virtqueue *free_page_vq;
	struct workqueue_struct *balloon_wq;
	struct work_struct report_free_page_work;
	struct work_struct update_balloon_stats_work;
	struct work_struct update_balloon_size_work;
	spinlock_t stop_update_lock;
	bool stop_update;
	long: 56;
	long unsigned int config_read_bitmap;
	struct list_head free_page_list;
	spinlock_t free_page_list_lock;
	long unsigned int num_free_page_blocks;
	u32 cmd_id_received_cache;
	__virtio32 cmd_id_active;
	__virtio32 cmd_id_stop;
	int: 32;
	wait_queue_head_t acked;
	unsigned int num_pages;
	int: 32;
	struct balloon_dev_info vb_dev_info;
	struct mutex balloon_lock;
	unsigned int num_pfns;
	__virtio32 pfns[256];
	struct virtio_balloon_stat stats[10];
	struct shrinker shrinker;
	struct notifier_block oom_nb;
	struct virtqueue *reporting_vq;
	struct page_reporting_dev_info pr_dev_info;
} __attribute__((packed));

struct serial_struct32 {
	compat_int_t type;
	compat_int_t line;
	compat_uint_t port;
	compat_int_t irq;
	compat_int_t flags;
	compat_int_t xmit_fifo_size;
	compat_int_t custom_divisor;
	compat_int_t baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char;
	compat_int_t hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	compat_uint_t iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	compat_int_t reserved;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[64];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pts_fs_info___2;

struct tty_audit_buf {
	struct mutex mutex;
	dev_t dev;
	unsigned int icanon: 1;
	size_t valid;
	unsigned char *data;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct consolefontdesc {
	short unsigned int charcount;
	short unsigned int charheight;
	char *chardata;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct compat_consolefontdesc {
	short unsigned int charcount;
	short unsigned int charheight;
	compat_caddr_t chardata;
};

struct compat_console_font_op {
	compat_uint_t op;
	compat_uint_t flags;
	compat_uint_t width;
	compat_uint_t height;
	compat_uint_t charcount;
	compat_caddr_t data;
};

struct compat_unimapdesc {
	short unsigned int entry_ct;
	compat_caddr_t entries;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	char: 1;
	unsigned char modeflags: 5;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct uni_pagedir {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, int);
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	__u32 padding[5];
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef unsigned int upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int timeout;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct gpio_desc___2 *rs485_term_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	upf_t flags;
	unsigned int type;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

enum {
	PLAT8250_DEV_LEGACY = 4294967295,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct uart_8250_port;

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	short unsigned int bugs;
	bool fifo_bug;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char mcr_mask;
	unsigned char mcr_force;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	unsigned char lsr_saved_flags;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	int (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, int);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *);
	void (*rs485_stop_tx)(struct uart_8250_port *);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan___2 *rxchan;
	struct dma_chan___2 *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct irq_info {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct serial_private;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct quatech_feature {
	u16 devid;
	bool amcc;
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_4000000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_endrun_2_4000000 = 71,
	pbn_oxsemi = 72,
	pbn_oxsemi_1_4000000 = 73,
	pbn_oxsemi_2_4000000 = 74,
	pbn_oxsemi_4_4000000 = 75,
	pbn_oxsemi_8_4000000 = 76,
	pbn_intel_i960 = 77,
	pbn_sgi_ioc3 = 78,
	pbn_computone_4 = 79,
	pbn_computone_6 = 80,
	pbn_computone_8 = 81,
	pbn_sbsxrsio = 82,
	pbn_pasemi_1682M = 83,
	pbn_ni8430_2 = 84,
	pbn_ni8430_4 = 85,
	pbn_ni8430_8 = 86,
	pbn_ni8430_16 = 87,
	pbn_ADDIDATA_PCIe_1_3906250 = 88,
	pbn_ADDIDATA_PCIe_2_3906250 = 89,
	pbn_ADDIDATA_PCIe_4_3906250 = 90,
	pbn_ADDIDATA_PCIe_8_3906250 = 91,
	pbn_ce4100_1_115200 = 92,
	pbn_omegapci = 93,
	pbn_NETMOS9900_2s_115200 = 94,
	pbn_brcm_trumanage = 95,
	pbn_fintek_4 = 96,
	pbn_fintek_8 = 97,
	pbn_fintek_12 = 98,
	pbn_fintek_F81504A = 99,
	pbn_fintek_F81508A = 100,
	pbn_fintek_F81512A = 101,
	pbn_wch382_2 = 102,
	pbn_wch384_4 = 103,
	pbn_wch384_8 = 104,
	pbn_pericom_PI7C9X7951 = 105,
	pbn_pericom_PI7C9X7952 = 106,
	pbn_pericom_PI7C9X7954 = 107,
	pbn_pericom_PI7C9X7958 = 108,
	pbn_sunix_pci_1s = 109,
	pbn_sunix_pci_2s = 110,
	pbn_sunix_pci_4s = 111,
	pbn_sunix_pci_8s = 112,
	pbn_sunix_pci_16s = 113,
	pbn_moxa8250_2p = 114,
	pbn_moxa8250_4p = 115,
	pbn_moxa8250_8p = 116,
};

struct exar8250_platform {
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*register_gpio)(struct pci_dev *, struct uart_8250_port *);
};

struct exar8250;

struct exar8250_board {
	unsigned int num_ports;
	unsigned int reg_shift;
	int (*setup)(struct exar8250 *, struct pci_dev *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct exar8250 {
	unsigned int nr;
	struct exar8250_board *board;
	void *virt;
	int line[0];
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

struct mctrl_gpios___2 {
	struct uart_port *port;
	struct gpio_desc___2 *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	cycles_t last_time;
	long int last_delta;
	long int last_delta2;
};

struct trace_event_raw_add_device_randomness {
	struct trace_entry ent;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__mix_pool_bytes {
	struct trace_entry ent;
	const char *pool_name;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_credit_entropy_bits {
	struct trace_entry ent;
	const char *pool_name;
	int bits;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_push_to_pool {
	struct trace_entry ent;
	const char *pool_name;
	int pool_bits;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_debit_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int debit_bits;
	char __data[0];
};

struct trace_event_raw_add_input_randomness {
	struct trace_entry ent;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_add_disk_randomness {
	struct trace_entry ent;
	dev_t dev;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_xfer_secondary_pool {
	struct trace_entry ent;
	const char *pool_name;
	int xfer_bits;
	int request_bits;
	int pool_entropy;
	int input_entropy;
	char __data[0];
};

struct trace_event_raw_random__get_random_bytes {
	struct trace_entry ent;
	int nbytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__extract_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int nbytes;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random_read {
	struct trace_entry ent;
	int got_bits;
	int need_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_urandom_read {
	struct trace_entry ent;
	int got_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_prandom_u32 {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_data_offsets_add_device_randomness {};

struct trace_event_data_offsets_random__mix_pool_bytes {};

struct trace_event_data_offsets_credit_entropy_bits {};

struct trace_event_data_offsets_push_to_pool {};

struct trace_event_data_offsets_debit_entropy {};

struct trace_event_data_offsets_add_input_randomness {};

struct trace_event_data_offsets_add_disk_randomness {};

struct trace_event_data_offsets_xfer_secondary_pool {};

struct trace_event_data_offsets_random__get_random_bytes {};

struct trace_event_data_offsets_random__extract_entropy {};

struct trace_event_data_offsets_random_read {};

struct trace_event_data_offsets_urandom_read {};

struct trace_event_data_offsets_prandom_u32 {};

typedef void (*btf_trace_add_device_randomness)(void *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes_nolock)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_credit_entropy_bits)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_push_to_pool)(void *, const char *, int, int);

typedef void (*btf_trace_debit_entropy)(void *, const char *, int);

typedef void (*btf_trace_add_input_randomness)(void *, int);

typedef void (*btf_trace_add_disk_randomness)(void *, dev_t, int);

typedef void (*btf_trace_xfer_secondary_pool)(void *, const char *, int, int, int, int);

typedef void (*btf_trace_get_random_bytes)(void *, int, long unsigned int);

typedef void (*btf_trace_get_random_bytes_arch)(void *, int, long unsigned int);

typedef void (*btf_trace_extract_entropy)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_extract_entropy_user)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_random_read)(void *, int, int, int, int);

typedef void (*btf_trace_urandom_read)(void *, int, int, int);

typedef void (*btf_trace_prandom_u32)(void *, unsigned int);

struct poolinfo {
	int poolbitshift;
	int poolwords;
	int poolbytes;
	int poolfracbits;
	int tap1;
	int tap2;
	int tap3;
	int tap4;
	int tap5;
};

struct crng_state {
	__u32 state[16];
	long unsigned int init_time;
	spinlock_t lock;
};

struct entropy_store {
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	spinlock_t lock;
	short unsigned int add_ptr;
	short unsigned int input_rotate;
	int entropy_count;
	unsigned int initialized: 1;
	unsigned int last_data_init: 1;
	__u8 last_data[10];
};

struct fast_pool {
	__u32 pool[4];
	long unsigned int last;
	short unsigned int reg_idx;
	unsigned char count;
};

struct batched_entropy {
	union {
		u64 entropy_u64[8];
		u32 entropy_u32[16];
	};
	unsigned int position;
	spinlock_t batch_lock;
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct ports_driver_data {
	struct class *class;
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	unsigned int next_vtermno;
	struct list_head consoles;
};

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct port {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct hpet_info {
	long unsigned int hi_ireqfreq;
	long unsigned int hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

struct hpet_timer {
	u64 hpet_config;
	union {
		u64 _hpet_hc64;
		u32 _hpet_hc32;
		long unsigned int _hpet_compare;
	} _u1;
	u64 hpet_fsb[2];
};

struct hpet {
	u64 hpet_cap;
	u64 res0;
	u64 hpet_config;
	u64 res1;
	u64 hpet_isr;
	u64 res2[25];
	union {
		u64 _hpet_mc64;
		u32 _hpet_mc32;
		long unsigned int _hpet_mc;
	} _u0;
	u64 res3;
	struct hpet_timer hpet_timers[1];
};

struct hpets;

struct hpet_dev {
	struct hpets *hd_hpets;
	struct hpet *hd_hpet;
	struct hpet_timer *hd_timer;
	long unsigned int hd_ireqfreq;
	long unsigned int hd_irqdata;
	wait_queue_head_t hd_waitqueue;
	struct fasync_struct *hd_async_queue;
	unsigned int hd_flags;
	unsigned int hd_irq;
	unsigned int hd_hdwirq;
	char hd_name[7];
};

struct hpets {
	struct hpets *hp_next;
	struct hpet *hp_hpet;
	long unsigned int hp_hpet_phys;
	struct clocksource *hp_clocksource;
	long long unsigned int hp_tick_freq;
	long unsigned int hp_delta;
	unsigned int hp_ntimer;
	unsigned int hp_which;
	struct hpet_dev hp_dev[0];
};

struct compat_hpet_info {
	compat_ulong_t hi_ireqfreq;
	compat_ulong_t hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

struct nvram_ops {
	ssize_t (*get_size)();
	unsigned char (*read_byte)(int);
	void (*write_byte)(unsigned char, int);
	ssize_t (*read)(char *, size_t, loff_t *);
	ssize_t (*write)(char *, size_t, loff_t *);
	long int (*initialize)();
	long int (*set_checksum)();
};

struct intel_rng_hw {
	struct pci_dev *dev;
	void *mem;
	u8 bios_cntl_off;
	u8 bios_cntl_val;
	u8 fwh_dec_en1_off;
	u8 fwh_dec_en1_val;
};

enum {
	VIA_STRFILT_CNT_SHIFT = 16,
	VIA_STRFILT_FAIL = 32768,
	VIA_STRFILT_ENABLE = 16384,
	VIA_RAWBITS_ENABLE = 8192,
	VIA_RNG_ENABLE = 64,
	VIA_NOISESRC1 = 256,
	VIA_NOISESRC2 = 512,
	VIA_XSTORE_CNT_MASK = 15,
	VIA_RNG_CHUNK_8 = 0,
	VIA_RNG_CHUNK_4 = 1,
	VIA_RNG_CHUNK_4_MASK = 4294967295,
	VIA_RNG_CHUNK_2 = 2,
	VIA_RNG_CHUNK_2_MASK = 65535,
	VIA_RNG_CHUNK_1 = 3,
	VIA_RNG_CHUNK_1_MASK = 255,
};

struct agp_bridge_data___2;

struct agp_memory {
	struct agp_memory *next;
	struct agp_memory *prev;
	struct agp_bridge_data___2 *bridge;
	struct page **pages;
	size_t page_count;
	int key;
	int num_scratch_pages;
	off_t pg_start;
	u32 type;
	u32 physical;
	bool is_bound;
	bool is_flushed;
	struct list_head mapped_list;
	struct scatterlist *sg_list;
	int num_sg;
};

struct agp_bridge_driver;

struct agp_bridge_data___2 {
	const struct agp_version *version;
	const struct agp_bridge_driver *driver;
	const struct vm_operations_struct *vm_ops;
	void *previous_size;
	void *current_size;
	void *dev_private_data;
	struct pci_dev *dev;
	u32 *gatt_table;
	u32 *gatt_table_real;
	long unsigned int scratch_page;
	struct page *scratch_page_page;
	dma_addr_t scratch_page_dma;
	long unsigned int gart_bus_addr;
	long unsigned int gatt_bus_addr;
	u32 mode;
	enum chipset_type type;
	long unsigned int *key_list;
	atomic_t current_memory_agp;
	atomic_t agp_in_use;
	int max_memory_agp;
	int aperture_size_idx;
	int capndx;
	int flags;
	char major_version;
	char minor_version;
	struct list_head list;
	u32 apbase_config;
	struct list_head mapped_list;
	spinlock_t mapped_lock;
};

enum aper_size_type {
	U8_APER_SIZE = 0,
	U16_APER_SIZE = 1,
	U32_APER_SIZE = 2,
	LVL2_APER_SIZE = 3,
	FIXED_APER_SIZE = 4,
};

struct gatt_mask {
	long unsigned int mask;
	u32 type;
};

struct agp_bridge_driver {
	struct module *owner;
	const void *aperture_sizes;
	int num_aperture_sizes;
	enum aper_size_type size_type;
	bool cant_use_aperture;
	bool needs_scratch_page;
	const struct gatt_mask *masks;
	int (*fetch_size)();
	int (*configure)();
	void (*agp_enable)(struct agp_bridge_data___2 *, u32);
	void (*cleanup)();
	void (*tlb_flush)(struct agp_memory *);
	long unsigned int (*mask_memory)(struct agp_bridge_data___2 *, dma_addr_t, int);
	void (*cache_flush)();
	int (*create_gatt_table)(struct agp_bridge_data___2 *);
	int (*free_gatt_table)(struct agp_bridge_data___2 *);
	int (*insert_memory)(struct agp_memory *, off_t, int);
	int (*remove_memory)(struct agp_memory *, off_t, int);
	struct agp_memory * (*alloc_by_type)(size_t, int);
	void (*free_by_type)(struct agp_memory *);
	struct page * (*agp_alloc_page)(struct agp_bridge_data___2 *);
	int (*agp_alloc_pages)(struct agp_bridge_data___2 *, struct agp_memory *, size_t);
	void (*agp_destroy_page)(struct page *, int);
	void (*agp_destroy_pages)(struct agp_memory *);
	int (*agp_type_to_mask_type)(struct agp_bridge_data___2 *, int);
};

struct agp_info {
	struct agp_version version;
	u32 bridge_id;
	u32 agp_mode;
	long unsigned int aper_base;
	size_t aper_size;
	size_t pg_total;
	size_t pg_system;
	size_t pg_used;
};

struct agp_setup {
	u32 agp_mode;
};

struct agp_segment {
	off_t pg_start;
	size_t pg_count;
	int prot;
};

struct agp_segment_priv {
	off_t pg_start;
	size_t pg_count;
	pgprot_t prot;
};

struct agp_region {
	pid_t pid;
	size_t seg_count;
	struct agp_segment *seg_list;
};

struct agp_allocate {
	int key;
	size_t pg_count;
	u32 type;
	u32 physical;
};

struct agp_bind {
	int key;
	off_t pg_start;
};

struct agp_unbind {
	int key;
	u32 priority;
};

struct agp_client {
	struct agp_client *next;
	struct agp_client *prev;
	pid_t pid;
	int num_segments;
	struct agp_segment_priv **segments;
};

struct agp_controller {
	struct agp_controller *next;
	struct agp_controller *prev;
	pid_t pid;
	int num_clients;
	struct agp_memory *pool;
	struct agp_client *clients;
};

struct agp_file_private {
	struct agp_file_private *next;
	struct agp_file_private *prev;
	pid_t my_pid;
	long unsigned int access_flags;
};

struct agp_front_data {
	struct mutex agp_mutex;
	struct agp_controller *current_controller;
	struct agp_controller *controllers;
	struct agp_file_private *file_priv_list;
	bool used_by_controller;
	bool backend_acquired;
};

struct aper_size_info_8 {
	int size;
	int num_entries;
	int page_order;
	u8 size_value;
};

struct aper_size_info_16 {
	int size;
	int num_entries;
	int page_order;
	u16 size_value;
};

struct aper_size_info_32 {
	int size;
	int num_entries;
	int page_order;
	u32 size_value;
};

struct aper_size_info_lvl2 {
	int size;
	int num_entries;
	u32 size_value;
};

struct aper_size_info_fixed {
	int size;
	int num_entries;
	int page_order;
};

struct agp_3_5_dev {
	struct list_head list;
	u8 capndx;
	u32 maxbw;
	struct pci_dev *dev;
};

struct isoch_data {
	u32 maxbw;
	u32 n;
	u32 y;
	u32 l;
	u32 rq;
	struct agp_3_5_dev *dev;
};

struct agp_info32 {
	struct agp_version version;
	u32 bridge_id;
	u32 agp_mode;
	compat_long_t aper_base;
	compat_size_t aper_size;
	compat_size_t pg_total;
	compat_size_t pg_system;
	compat_size_t pg_used;
};

struct agp_segment32 {
	compat_off_t pg_start;
	compat_size_t pg_count;
	compat_int_t prot;
};

struct agp_region32 {
	compat_pid_t pid;
	compat_size_t seg_count;
	struct agp_segment32 *seg_list;
};

struct agp_allocate32 {
	compat_int_t key;
	compat_size_t pg_count;
	u32 type;
	u32 physical;
};

struct agp_bind32 {
	compat_int_t key;
	compat_off_t pg_start;
};

struct agp_unbind32 {
	compat_int_t key;
	u32 priority;
};

struct intel_agp_driver_description {
	unsigned int chip_id;
	char *name;
	const struct agp_bridge_driver *driver;
};

struct intel_gtt_driver {
	unsigned int gen: 8;
	unsigned int is_g33: 1;
	unsigned int is_pineview: 1;
	unsigned int is_ironlake: 1;
	unsigned int has_pgtbl_enable: 1;
	unsigned int dma_mask_size: 8;
	int (*setup)();
	void (*cleanup)();
	void (*write_entry)(dma_addr_t, unsigned int, unsigned int);
	bool (*check_flags)(unsigned int);
	void (*chipset_flush)();
};

struct _intel_private {
	const struct intel_gtt_driver *driver;
	struct pci_dev *pcidev;
	struct pci_dev *bridge_dev;
	u8 *registers;
	phys_addr_t gtt_phys_addr;
	u32 PGETBL_save;
	u32 *gtt;
	bool clear_fake_agp;
	int num_dcache_entries;
	void *i9xx_flush_page;
	char *i81x_gtt_table;
	struct resource ifp_resource;
	int resource_valid;
	struct page *scratch_page;
	phys_addr_t scratch_page_dma;
	int refcount;
	unsigned int needs_dmar: 1;
	phys_addr_t gma_bus_addr;
	resource_size_t stolen_size;
	unsigned int gtt_total_entries;
	unsigned int gtt_mappable_entries;
};

struct intel_gtt_driver_description {
	unsigned int gmch_chip_id;
	char *name;
	const struct intel_gtt_driver *gtt_driver;
};

struct agp_device_ids {
	short unsigned int device_id;
	enum chipset_type chipset;
	const char *chipset_name;
	int (*chipset_setup)(struct pci_dev *);
};

enum tpm2_startup_types {
	TPM2_SU_CLEAR = 0,
	TPM2_SU_STATE = 1,
};

enum tpm_chip_flags {
	TPM_CHIP_FLAG_TPM2 = 2,
	TPM_CHIP_FLAG_IRQ = 4,
	TPM_CHIP_FLAG_VIRTUAL = 8,
	TPM_CHIP_FLAG_HAVE_TIMEOUTS = 16,
	TPM_CHIP_FLAG_ALWAYS_POWERED = 32,
	TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED = 64,
};

enum tpm2_structures {
	TPM2_ST_NO_SESSIONS = 32769,
	TPM2_ST_SESSIONS = 32770,
};

enum tpm2_return_codes {
	TPM2_RC_SUCCESS = 0,
	TPM2_RC_HASH = 131,
	TPM2_RC_HANDLE = 139,
	TPM2_RC_INITIALIZE = 256,
	TPM2_RC_FAILURE = 257,
	TPM2_RC_DISABLED = 288,
	TPM2_RC_COMMAND_CODE = 323,
	TPM2_RC_TESTING = 2314,
	TPM2_RC_REFERENCE_H0 = 2320,
	TPM2_RC_RETRY = 2338,
};

struct tpm_header {
	__be16 tag;
	__be32 length;
	union {
		__be32 ordinal;
		__be32 return_code;
	};
} __attribute__((packed));

struct file_priv {
	struct tpm_chip *chip;
	struct tpm_space *space;
	struct mutex buffer_mutex;
	struct timer_list user_read_timer;
	struct work_struct timeout_work;
	struct work_struct async_work;
	wait_queue_head_t async_wait;
	ssize_t response_length;
	bool response_read;
	bool command_enqueued;
	u8 data_buffer[4096];
};

enum TPM_OPS_FLAGS {
	TPM_OPS_AUTO_STARTUP = 1,
};

enum tpm2_timeouts {
	TPM2_TIMEOUT_A = 750,
	TPM2_TIMEOUT_B = 2000,
	TPM2_TIMEOUT_C = 200,
	TPM2_TIMEOUT_D = 30,
	TPM2_DURATION_SHORT = 20,
	TPM2_DURATION_MEDIUM = 750,
	TPM2_DURATION_LONG = 2000,
	TPM2_DURATION_LONG_LONG = 300000,
	TPM2_DURATION_DEFAULT = 120000,
};

enum tpm2_command_codes {
	TPM2_CC_FIRST = 287,
	TPM2_CC_HIERARCHY_CONTROL = 289,
	TPM2_CC_HIERARCHY_CHANGE_AUTH = 297,
	TPM2_CC_CREATE_PRIMARY = 305,
	TPM2_CC_SEQUENCE_COMPLETE = 318,
	TPM2_CC_SELF_TEST = 323,
	TPM2_CC_STARTUP = 324,
	TPM2_CC_SHUTDOWN = 325,
	TPM2_CC_NV_READ = 334,
	TPM2_CC_CREATE = 339,
	TPM2_CC_LOAD = 343,
	TPM2_CC_SEQUENCE_UPDATE = 348,
	TPM2_CC_UNSEAL = 350,
	TPM2_CC_CONTEXT_LOAD = 353,
	TPM2_CC_CONTEXT_SAVE = 354,
	TPM2_CC_FLUSH_CONTEXT = 357,
	TPM2_CC_VERIFY_SIGNATURE = 375,
	TPM2_CC_GET_CAPABILITY = 378,
	TPM2_CC_GET_RANDOM = 379,
	TPM2_CC_PCR_READ = 382,
	TPM2_CC_PCR_EXTEND = 386,
	TPM2_CC_EVENT_SEQUENCE_COMPLETE = 389,
	TPM2_CC_HASH_SEQUENCE_START = 390,
	TPM2_CC_CREATE_LOADED = 401,
	TPM2_CC_LAST = 403,
};

struct tpm_buf {
	unsigned int flags;
	u8 *data;
};

enum tpm_timeout {
	TPM_TIMEOUT = 5,
	TPM_TIMEOUT_RETRY = 100,
	TPM_TIMEOUT_RANGE_US = 300,
	TPM_TIMEOUT_POLL = 1,
	TPM_TIMEOUT_USECS_MIN = 100,
	TPM_TIMEOUT_USECS_MAX = 500,
};

enum tpm_buf_flags {
	TPM_BUF_OVERFLOW = 1,
};

struct stclear_flags_t {
	__be16 tag;
	u8 deactivated;
	u8 disableForceClear;
	u8 physicalPresence;
	u8 physicalPresenceLock;
	u8 bGlobalLock;
} __attribute__((packed));

struct tpm1_version {
	u8 major;
	u8 minor;
	u8 rev_major;
	u8 rev_minor;
};

struct tpm1_version2 {
	__be16 tag;
	struct tpm1_version version;
};

struct timeout_t {
	__be32 a;
	__be32 b;
	__be32 c;
	__be32 d;
};

struct duration_t {
	__be32 tpm_short;
	__be32 tpm_medium;
	__be32 tpm_long;
};

struct permanent_flags_t {
	__be16 tag;
	u8 disable;
	u8 ownership;
	u8 deactivated;
	u8 readPubek;
	u8 disableOwnerClear;
	u8 allowMaintenance;
	u8 physicalPresenceLifetimeLock;
	u8 physicalPresenceHWEnable;
	u8 physicalPresenceCMDEnable;
	u8 CEKPUsed;
	u8 TPMpost;
	u8 TPMpostLock;
	u8 FIPS;
	u8 operator;
	u8 enableRevokeEK;
	u8 nvLocked;
	u8 readSRKPub;
	u8 tpmEstablished;
	u8 maintenanceDone;
	u8 disableFullDALogicInfo;
};

typedef union {
	struct permanent_flags_t perm_flags;
	struct stclear_flags_t stclear_flags;
	__u8 owned;
	__be32 num_pcrs;
	struct tpm1_version version1;
	struct tpm1_version2 version2;
	__be32 manufacturer_id;
	struct timeout_t timeout;
	struct duration_t duration;
} cap_t;

enum tpm_capabilities {
	TPM_CAP_FLAG = 4,
	TPM_CAP_PROP = 5,
	TPM_CAP_VERSION_1_1 = 6,
	TPM_CAP_VERSION_1_2 = 26,
};

enum tpm_sub_capabilities {
	TPM_CAP_PROP_PCR = 257,
	TPM_CAP_PROP_MANUFACTURER = 259,
	TPM_CAP_FLAG_PERM = 264,
	TPM_CAP_FLAG_VOL = 265,
	TPM_CAP_PROP_OWNER = 273,
	TPM_CAP_PROP_TIS_TIMEOUT = 277,
	TPM_CAP_PROP_TIS_DURATION = 288,
};

struct tpm1_get_random_out {
	__be32 rng_data_len;
	u8 rng_data[128];
};

enum tpm2_const {
	TPM2_PLATFORM_PCR = 24,
	TPM2_PCR_SELECT_MIN = 3,
};

enum tpm2_permanent_handles {
	TPM2_RS_PW = 1073741833,
};

enum tpm2_capabilities {
	TPM2_CAP_HANDLES = 1,
	TPM2_CAP_COMMANDS = 2,
	TPM2_CAP_PCRS = 5,
	TPM2_CAP_TPM_PROPERTIES = 6,
};

enum tpm2_properties {
	TPM_PT_TOTAL_COMMANDS = 297,
};

enum tpm2_cc_attrs {
	TPM2_CC_ATTR_CHANDLES = 25,
	TPM2_CC_ATTR_RHANDLE = 28,
};

struct tpm2_hash {
	unsigned int crypto_id;
	unsigned int tpm_id;
};

struct tpm2_pcr_read_out {
	__be32 update_cnt;
	__be32 pcr_selects_cnt;
	__be16 hash_alg;
	u8 pcr_select_size;
	u8 pcr_select[3];
	__be32 digests_cnt;
	__be16 digest_size;
	u8 digest[0];
} __attribute__((packed));

struct tpm2_null_auth_area {
	__be32 handle;
	__be16 nonce_size;
	u8 attributes;
	__be16 auth_size;
} __attribute__((packed));

struct tpm2_get_random_out {
	__be16 size;
	u8 buffer[128];
};

struct tpm2_get_cap_out {
	u8 more_data;
	__be32 subcap_id;
	__be32 property_cnt;
	__be32 property_id;
	__be32 value;
} __attribute__((packed));

struct tpm2_pcr_selection {
	__be16 hash_alg;
	u8 size_of_select;
	u8 pcr_select[3];
};

struct tpmrm_priv {
	struct file_priv priv;
	struct tpm_space space;
};

enum tpm2_handle_types {
	TPM2_HT_HMAC_SESSION = 33554432,
	TPM2_HT_POLICY_SESSION = 50331648,
	TPM2_HT_TRANSIENT = 2147483648,
};

struct tpm2_context {
	__be64 sequence;
	__be32 saved_handle;
	__be32 hierarchy;
	__be16 blob_size;
} __attribute__((packed));

struct tpm2_cap_handles {
	u8 more_data;
	__be32 capability;
	__be32 count;
	__be32 handles[0];
} __attribute__((packed));

struct tpm_readpubek_out {
	u8 algorithm[4];
	u8 encscheme[2];
	u8 sigscheme[2];
	__be32 paramsize;
	u8 parameters[12];
	__be32 keysize;
	u8 modulus[256];
	u8 checksum[20];
};

struct tcpa_event {
	u32 pcr_index;
	u32 event_type;
	u8 pcr_value[20];
	u32 event_size;
	u8 event_data[0];
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

struct tcpa_pc_event {
	u32 event_id;
	u32 event_size;
	u8 event_data[0];
};

enum tcpa_pc_event_ids {
	SMBIOS = 1,
	BIS_CERT = 2,
	POST_BIOS_ROM = 3,
	ESCD = 4,
	CMOS = 5,
	NVRAM = 6,
	OPTION_ROM_EXEC = 7,
	OPTION_ROM_CONFIG = 8,
	OPTION_ROM_MICROCODE = 10,
	S_CRTM_VERSION = 11,
	S_CRTM_CONTENTS = 12,
	POST_CONTENTS = 13,
	HOST_TABLE_OF_DEVICES = 14,
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

struct acpi_table_tpm2 {
	struct acpi_table_header header;
	u16 platform_class;
	u16 reserved;
	u64 control_address;
	u32 start_method;
} __attribute__((packed));

struct acpi_tpm2_phy {
	u8 start_method_specific[12];
	u32 log_area_minimum_length;
	u64 log_area_start_address;
};

enum bios_platform_class {
	BIOS_CLIENT = 0,
	BIOS_SERVER = 1,
};

struct client_hdr {
	u32 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct server_hdr {
	u16 reserved;
	u64 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct acpi_tcpa {
	struct acpi_table_header hdr;
	u16 platform_class;
	union {
		struct client_hdr client;
		struct server_hdr server;
	};
} __attribute__((packed));

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

enum tis_access {
	TPM_ACCESS_VALID = 128,
	TPM_ACCESS_ACTIVE_LOCALITY = 32,
	TPM_ACCESS_REQUEST_PENDING = 4,
	TPM_ACCESS_REQUEST_USE = 2,
};

enum tis_status {
	TPM_STS_VALID = 128,
	TPM_STS_COMMAND_READY = 64,
	TPM_STS_GO = 32,
	TPM_STS_DATA_AVAIL = 16,
	TPM_STS_DATA_EXPECT = 8,
	TPM_STS_READ_ZERO = 35,
};

enum tis_int_flags {
	TPM_GLOBAL_INT_ENABLE = 2147483648,
	TPM_INTF_BURST_COUNT_STATIC = 256,
	TPM_INTF_CMD_READY_INT = 128,
	TPM_INTF_INT_EDGE_FALLING = 64,
	TPM_INTF_INT_EDGE_RISING = 32,
	TPM_INTF_INT_LEVEL_LOW = 16,
	TPM_INTF_INT_LEVEL_HIGH = 8,
	TPM_INTF_LOCALITY_CHANGE_INT = 4,
	TPM_INTF_STS_VALID_INT = 2,
	TPM_INTF_DATA_AVAIL_INT = 1,
};

enum tis_defaults {
	TIS_MEM_LEN = 20480,
	TIS_SHORT_TIMEOUT = 750,
	TIS_LONG_TIMEOUT = 2000,
};

enum tpm_tis_flags {
	TPM_TIS_ITPM_WORKAROUND = 1,
};

struct tpm_tis_phy_ops;

struct tpm_tis_data {
	u16 manufacturer_id;
	int locality;
	int irq;
	bool irq_tested;
	unsigned int flags;
	void *ilb_base_addr;
	u16 clkrun_enabled;
	wait_queue_head_t int_queue;
	wait_queue_head_t read_queue;
	const struct tpm_tis_phy_ops *phy_ops;
	short unsigned int rng_quality;
};

struct tpm_tis_phy_ops {
	int (*read_bytes)(struct tpm_tis_data *, u32, u16, u8 *);
	int (*write_bytes)(struct tpm_tis_data *, u32, u16, const u8 *);
	int (*read16)(struct tpm_tis_data *, u32, u16 *);
	int (*read32)(struct tpm_tis_data *, u32, u32 *);
	int (*write32)(struct tpm_tis_data *, u32, u32);
};

struct tis_vendor_durations_override {
	u32 did_vid;
	struct tpm1_version version;
	long unsigned int durations[3];
};

struct tis_vendor_timeout_override {
	u32 did_vid;
	long unsigned int timeout_us[4];
};

struct tpm_info {
	struct resource res;
	int irq;
};

struct tpm_tis_tcg_phy {
	struct tpm_tis_data priv;
	void *iobase;
};

enum crb_defaults {
	CRB_ACPI_START_REVISION_ID = 1,
	CRB_ACPI_START_INDEX = 1,
};

enum crb_loc_ctrl {
	CRB_LOC_CTRL_REQUEST_ACCESS = 1,
	CRB_LOC_CTRL_RELINQUISH = 2,
};

enum crb_loc_state {
	CRB_LOC_STATE_LOC_ASSIGNED = 2,
	CRB_LOC_STATE_TPM_REG_VALID_STS = 128,
};

enum crb_ctrl_req {
	CRB_CTRL_REQ_CMD_READY = 1,
	CRB_CTRL_REQ_GO_IDLE = 2,
};

enum crb_ctrl_sts {
	CRB_CTRL_STS_ERROR = 1,
	CRB_CTRL_STS_TPM_IDLE = 2,
};

enum crb_start {
	CRB_START_INVOKE = 1,
};

enum crb_cancel {
	CRB_CANCEL_INVOKE = 1,
};

struct crb_regs_head {
	u32 loc_state;
	u32 reserved1;
	u32 loc_ctrl;
	u32 loc_sts;
	u8 reserved2[32];
	u64 intf_id;
	u64 ctrl_ext;
};

struct crb_regs_tail {
	u32 ctrl_req;
	u32 ctrl_sts;
	u32 ctrl_cancel;
	u32 ctrl_start;
	u32 ctrl_int_enable;
	u32 ctrl_int_sts;
	u32 ctrl_cmd_size;
	u32 ctrl_cmd_pa_low;
	u32 ctrl_cmd_pa_high;
	u32 ctrl_rsp_size;
	u64 ctrl_rsp_pa;
};

enum crb_status {
	CRB_DRV_STS_COMPLETE = 1,
};

struct crb_priv {
	u32 sm;
	const char *hid;
	struct crb_regs_head *regs_h;
	struct crb_regs_tail *regs_t;
	u8 *cmd;
	u8 *rsp;
	u32 cmd_size;
	u32 smc_func_id;
};

struct tpm2_crb_smc {
	u32 interrupt;
	u8 interrupt_flags;
	u8 op_flags;
	u16 reserved2;
	u32 smc_func_id;
};

struct acpi_table_dmar {
	struct acpi_table_header header;
	u8 width;
	u8 flags;
	u8 reserved[10];
};

struct acpi_dmar_header {
	u16 type;
	u16 length;
};

enum acpi_dmar_type {
	ACPI_DMAR_TYPE_HARDWARE_UNIT = 0,
	ACPI_DMAR_TYPE_RESERVED_MEMORY = 1,
	ACPI_DMAR_TYPE_ROOT_ATS = 2,
	ACPI_DMAR_TYPE_HARDWARE_AFFINITY = 3,
	ACPI_DMAR_TYPE_NAMESPACE = 4,
	ACPI_DMAR_TYPE_RESERVED = 5,
};

struct acpi_dmar_device_scope {
	u8 entry_type;
	u8 length;
	u16 reserved;
	u8 enumeration_id;
	u8 bus;
};

enum acpi_dmar_scope_type {
	ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0,
	ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1,
	ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2,
	ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3,
	ACPI_DMAR_SCOPE_TYPE_HPET = 4,
	ACPI_DMAR_SCOPE_TYPE_NAMESPACE = 5,
	ACPI_DMAR_SCOPE_TYPE_RESERVED = 6,
};

struct acpi_dmar_pci_path {
	u8 device;
	u8 function;
};

struct acpi_dmar_hardware_unit {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
	u64 address;
};

struct acpi_dmar_reserved_memory {
	struct acpi_dmar_header header;
	u16 reserved;
	u16 segment;
	u64 base_address;
	u64 end_address;
};

struct acpi_dmar_atsr {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
};

struct acpi_dmar_rhsa {
	struct acpi_dmar_header header;
	u32 reserved;
	u64 base_address;
	u32 proximity_domain;
} __attribute__((packed));

struct acpi_dmar_andd {
	struct acpi_dmar_header header;
	u8 reserved[3];
	u8 device_number;
	char device_name[1];
} __attribute__((packed));

struct dmar_dev_scope {
	struct device *dev;
	u8 bus;
	u8 devfn;
};

struct intel_iommu;

struct dmar_drhd_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 reg_base_addr;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u16 segment;
	u8 ignored: 1;
	u8 include_all: 1;
	u8 gfx_dedicated: 1;
	struct intel_iommu *iommu;
};

struct iommu_flush {
	void (*flush_context)(struct intel_iommu *, u16, u16, u8, u64);
	void (*flush_iotlb)(struct intel_iommu *, u16, u64, unsigned int, u64);
};

struct dmar_domain;

struct root_entry;

struct q_inval;

struct ir_table;

struct intel_iommu {
	void *reg;
	u64 reg_phys;
	u64 reg_size;
	u64 cap;
	u64 ecap;
	u64 vccap;
	u32 gcmd;
	raw_spinlock_t register_lock;
	int seq_id;
	int agaw;
	int msagaw;
	unsigned int irq;
	unsigned int pr_irq;
	u16 segment;
	unsigned char name[13];
	long unsigned int *domain_ids;
	struct dmar_domain ***domains;
	spinlock_t lock;
	struct root_entry *root_entry;
	struct iommu_flush flush;
	struct q_inval *qi;
	u32 *iommu_state;
	struct ir_table *ir_table;
	struct irq_domain *ir_domain;
	struct irq_domain *ir_msi_domain;
	struct iommu_device iommu;
	int node;
	u32 flags;
	struct dmar_drhd_unit *drhd;
};

struct dmar_pci_path {
	u8 bus;
	u8 device;
	u8 function;
};

struct dmar_pci_notify_info {
	struct pci_dev *dev;
	long unsigned int event;
	int bus;
	u16 seg;
	u16 level;
	struct dmar_pci_path path[0];
};

struct irte {
	union {
		struct {
			__u64 present: 1;
			__u64 fpd: 1;
			__u64 __res0: 6;
			__u64 avail: 4;
			__u64 __res1: 3;
			__u64 pst: 1;
			__u64 vector: 8;
			__u64 __res2: 40;
		};
		struct {
			__u64 r_present: 1;
			__u64 r_fpd: 1;
			__u64 dst_mode: 1;
			__u64 redir_hint: 1;
			__u64 trigger_mode: 1;
			__u64 dlvry_mode: 3;
			__u64 r_avail: 4;
			__u64 r_res0: 4;
			__u64 r_vector: 8;
			__u64 r_res1: 8;
			__u64 dest_id: 32;
		};
		struct {
			__u64 p_present: 1;
			__u64 p_fpd: 1;
			__u64 p_res0: 6;
			__u64 p_avail: 4;
			__u64 p_res1: 2;
			__u64 p_urgent: 1;
			__u64 p_pst: 1;
			__u64 p_vector: 8;
			__u64 p_res2: 14;
			__u64 pda_l: 26;
		};
		__u64 low;
	};
	union {
		struct {
			__u64 sid: 16;
			__u64 sq: 2;
			__u64 svt: 2;
			__u64 __res3: 44;
		};
		struct {
			__u64 p_sid: 16;
			__u64 p_sq: 2;
			__u64 p_svt: 2;
			__u64 p_res3: 12;
			__u64 pda_h: 32;
		};
		__u64 high;
	};
};

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_magazine;

struct iova_cpu_rcache;

struct iova_rcache {
	spinlock_t lock;
	long unsigned int depot_size;
	struct iova_magazine *depot[32];
	struct iova_cpu_rcache *cpu_rcaches;
};

struct iova_domain;

typedef void (*iova_flush_cb)(struct iova_domain *);

typedef void (*iova_entry_dtor)(long unsigned int);

struct iova_fq;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova_fq *fq;
	atomic64_t fq_flush_start_cnt;
	atomic64_t fq_flush_finish_cnt;
	struct iova anchor;
	struct iova_rcache rcaches[6];
	iova_flush_cb flush_cb;
	iova_entry_dtor entry_dtor;
	struct timer_list fq_timer;
	atomic_t fq_timer_on;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	long unsigned int data;
	u64 counter;
};

struct iova_fq {
	struct iova_fq_entry entries[256];
	unsigned int head;
	unsigned int tail;
	spinlock_t lock;
};

enum {
	QI_FREE = 0,
	QI_IN_USE = 1,
	QI_DONE = 2,
	QI_ABORT = 3,
};

struct qi_desc {
	u64 qw0;
	u64 qw1;
	u64 qw2;
	u64 qw3;
};

struct q_inval {
	raw_spinlock_t q_lock;
	void *desc;
	int *desc_status;
	int free_head;
	int free_tail;
	int free_cnt;
};

struct ir_table {
	struct irte *base;
	long unsigned int *bitmap;
};

struct root_entry {
	u64 lo;
	u64 hi;
};

struct dma_pte;

struct dmar_domain {
	int nid;
	unsigned int iommu_refcnt[128];
	u16 iommu_did[128];
	unsigned int auxd_refcnt;
	bool has_iotlb_device;
	struct list_head devices;
	struct list_head auxd;
	struct iova_domain iovad;
	struct dma_pte *pgd;
	int gaw;
	int agaw;
	int flags;
	int iommu_coherency;
	int iommu_snooping;
	int iommu_count;
	int iommu_superpage;
	u64 max_addr;
	u32 default_pasid;
	struct iommu_domain domain;
};

struct dma_pte {
	u64 val;
};

typedef int (*dmar_res_handler_t)(struct acpi_dmar_header *, void *);

struct dmar_res_callback {
	dmar_res_handler_t cb[5];
	void *arg[5];
	bool ignore_unhandled;
	bool print_entry;
};

enum faulttype {
	DMA_REMAP = 0,
	INTR_REMAP = 1,
	UNKNOWN = 2,
};

struct memory_notify {
	long unsigned int start_pfn;
	long unsigned int nr_pages;
	int status_change_nid_normal;
	int status_change_nid_high;
	int status_change_nid;
};

typedef unsigned int ioasid_t;

enum {
	SR_DMAR_FECTL_REG = 0,
	SR_DMAR_FEDATA_REG = 1,
	SR_DMAR_FEADDR_REG = 2,
	SR_DMAR_FEUADDR_REG = 3,
	MAX_SR_DMAR_REGS = 4,
};

struct context_entry {
	u64 lo;
	u64 hi;
};

struct pasid_table;

struct device_domain_info {
	struct list_head link;
	struct list_head global;
	struct list_head table;
	struct list_head auxiliary_domains;
	u32 segment;
	u8 bus;
	u8 devfn;
	u16 pfsid;
	u8 pasid_supported: 3;
	u8 pasid_enabled: 1;
	u8 pri_supported: 1;
	u8 pri_enabled: 1;
	u8 ats_supported: 1;
	u8 ats_enabled: 1;
	u8 auxd_enabled: 1;
	u8 ats_qdep;
	struct device *dev;
	struct intel_iommu *iommu;
	struct dmar_domain *domain;
	struct pasid_table *pasid_table;
};

struct pasid_table {
	void *table;
	int order;
	u32 max_pasid;
	struct list_head dev;
};

struct dmar_rmrr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 base_address;
	u64 end_address;
	struct dmar_dev_scope *devices;
	int devices_cnt;
};

struct dmar_atsr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u8 include_all: 1;
};

struct domain_context_mapping_data {
	struct dmar_domain *domain;
	struct intel_iommu *iommu;
	struct pasid_table *table;
};

struct pasid_dir_entry {
	u64 val;
};

struct pasid_entry {
	u64 val[8];
};

struct pasid_table_opaque {
	struct pasid_table **pasid_table;
	int segment;
	int bus;
	int devfn;
};

struct trace_event_raw_dma_map {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	dma_addr_t dev_addr;
	phys_addr_t phys_addr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_dma_unmap {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	dma_addr_t dev_addr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_dma_map_sg {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	dma_addr_t dev_addr;
	phys_addr_t phys_addr;
	size_t size;
	int index;
	int total;
	char __data[0];
};

struct trace_event_data_offsets_dma_map {
	u32 dev_name;
};

struct trace_event_data_offsets_dma_unmap {
	u32 dev_name;
};

struct trace_event_data_offsets_dma_map_sg {
	u32 dev_name;
};

typedef void (*btf_trace_map_single)(void *, struct device *, dma_addr_t, phys_addr_t, size_t);

typedef void (*btf_trace_bounce_map_single)(void *, struct device *, dma_addr_t, phys_addr_t, size_t);

typedef void (*btf_trace_unmap_single)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_unmap_sg)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_bounce_unmap_single)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_map_sg)(void *, struct device *, int, int, struct scatterlist *);

typedef void (*btf_trace_bounce_map_sg)(void *, struct device *, int, int, struct scatterlist *);

enum irq_remap_cap {
	IRQ_POSTING_CAP = 0,
};

struct vcpu_data {
	u64 pi_desc_addr;
	u32 vector;
};

struct irq_remap_ops {
	int capability;
	int (*prepare)();
	int (*enable)();
	void (*disable)();
	int (*reenable)(int);
	int (*enable_faulting)();
	struct irq_domain * (*get_irq_domain)(struct irq_alloc_info *);
};

enum irq_mode {
	IRQ_REMAPPING = 0,
	IRQ_POSTING = 1,
};

struct ioapic_scope {
	struct intel_iommu *iommu;
	unsigned int id;
	unsigned int bus;
	unsigned int devfn;
};

struct hpet_scope {
	struct intel_iommu *iommu;
	u8 id;
	unsigned int bus;
	unsigned int devfn;
};

struct irq_2_iommu {
	struct intel_iommu *iommu;
	u16 irte_index;
	u16 sub_handle;
	u8 irte_mask;
	enum irq_mode mode;
};

struct intel_ir_data {
	struct irq_2_iommu irq_2_iommu;
	struct irte irte_entry;
	union {
		struct msi_msg msi_entry;
	};
};

struct set_msi_sid_data {
	struct pci_dev *pdev;
	u16 alias;
	int count;
	int busmatch_count;
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct mutex mutex;
	struct blocking_notifier_head notifier;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *domain;
	struct list_head entry;
};

enum iommu_fault_type {
	IOMMU_FAULT_DMA_UNRECOV = 1,
	IOMMU_FAULT_PAGE_REQ = 2,
};

enum iommu_inv_granularity {
	IOMMU_INV_GRANU_DOMAIN = 0,
	IOMMU_INV_GRANU_PASID = 1,
	IOMMU_INV_GRANU_ADDR = 2,
	IOMMU_INV_GRANU_NR = 3,
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	char *driver_override;
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	struct msi_desc *msi_desc;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct __group_domain_type {
	struct device *dev;
	unsigned int type;
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	u32 driver;
};

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_detach_device_from_domain)(void *, struct device *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

typedef ioasid_t (*ioasid_alloc_fn_t)(ioasid_t, ioasid_t, void *);

typedef void (*ioasid_free_fn_t)(ioasid_t, void *);

struct ioasid_set {
	int dummy;
};

struct ioasid_allocator_ops {
	ioasid_alloc_fn_t alloc;
	ioasid_free_fn_t free;
	struct list_head list;
	void *pdata;
};

struct ioasid_data {
	ioasid_t id;
	struct ioasid_set *set;
	void *private;
	struct callback_head rcu;
};

struct ioasid_allocator_data {
	struct ioasid_allocator_ops *ops;
	struct list_head list;
	struct list_head slist;
	long unsigned int flags;
	struct xarray xa;
	struct callback_head rcu;
};

struct iova_magazine {
	long unsigned int size;
	long unsigned int pfns[128];
};

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct mipi_dsi_host;

struct mipi_dsi_device;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	long unsigned int hs_rate;
	long unsigned int lp_rate;
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	int (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

struct drm_dsc_picture_parameter_set {
	u8 dsc_version;
	u8 pps_identifier;
	u8 pps_reserved;
	u8 pps_3;
	u8 pps_4;
	u8 bits_per_pixel_low;
	__be16 pic_height;
	__be16 pic_width;
	__be16 slice_height;
	__be16 slice_width;
	__be16 chunk_size;
	u8 initial_xmit_delay_high;
	u8 initial_xmit_delay_low;
	__be16 initial_dec_delay;
	u8 pps20_reserved;
	u8 initial_scale_value;
	__be16 scale_increment_interval;
	u8 scale_decrement_interval_high;
	u8 scale_decrement_interval_low;
	u8 pps26_reserved;
	u8 first_line_bpg_offset;
	__be16 nfl_bpg_offset;
	__be16 slice_bpg_offset;
	__be16 initial_offset;
	__be16 final_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	__be16 rc_model_size;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	u8 rc_tgt_offset;
	u8 rc_buf_thresh[14];
	__be16 rc_range_parameters[15];
	u8 native_422_420;
	u8 second_line_bpg_offset;
	__be16 nsl_bpg_offset;
	__be16 second_line_offset_adj;
	u32 pps_long_94_reserved;
	u32 pps_long_98_reserved;
	u32 pps_long_102_reserved;
	u32 pps_long_106_reserved;
	u32 pps_long_110_reserved;
	u32 pps_long_114_reserved;
	u32 pps_long_118_reserved;
	u32 pps_long_122_reserved;
	__be16 pps_short_126_reserved;
} __attribute__((packed));

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	void *cookie;
	void (*irq_set_state)(void *, bool);
	unsigned int (*set_vga_decode)(void *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cn_msg {
	struct cb_id id;
	__u32 seq;
	__u32 ack;
	__u16 len;
	__u16 flags;
	__u8 data[0];
};

struct cn_queue_dev {
	atomic_t refcnt;
	unsigned char name[32];
	struct list_head queue_list;
	spinlock_t queue_lock;
	struct sock *nls;
};

struct cn_callback_id {
	unsigned char name[32];
	struct cb_id id;
};

struct cn_callback_entry {
	struct list_head callback_entry;
	refcount_t refcnt;
	struct cn_queue_dev *pdev;
	struct cn_callback_id id;
	void (*callback)(struct cn_msg *, struct netlink_skb_parms *);
	u32 seq;
	u32 group;
};

struct cn_dev {
	struct cb_id id;
	u32 seq;
	u32 groups;
	struct sock *nls;
	struct cn_queue_dev *cbdev;
};

enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2,
};

struct fork_proc_event {
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
	__kernel_pid_t child_pid;
	__kernel_pid_t child_tgid;
};

struct exec_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct id_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	union {
		__u32 ruid;
		__u32 rgid;
	} r;
	union {
		__u32 euid;
		__u32 egid;
	} e;
};

struct sid_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct ptrace_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t tracer_pid;
	__kernel_pid_t tracer_tgid;
};

struct comm_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	char comm[16];
};

struct coredump_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct exit_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__u32 exit_code;
	__u32 exit_signal;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct proc_event {
	enum what what;
	__u32 cpu;
	__u64 timestamp_ns;
	union {
		struct {
			__u32 err;
		} ack;
		struct fork_proc_event fork;
		struct exec_proc_event exec;
		struct id_proc_event id;
		struct sid_proc_event sid;
		struct ptrace_proc_event ptrace;
		struct comm_proc_event comm;
		struct coredump_proc_event coredump;
		struct exit_proc_event exit;
	} event_data;
};

struct local_event {
	local_lock_t lock;
	__u32 count;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct master;

struct component {
	struct list_head node;
	struct master *master;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct master {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *dev;
	struct component_match *match;
	struct dentry *dentry;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map___2 {
	struct probe *probes[255];
	struct mutex *lock;
};

typedef int (*dr_match_t)(struct device *, void *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
};

struct devres___2 {
	struct devres_node node;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

typedef void * (*devcon_match_fn_t)(struct fwnode_handle *, const char *, void *);

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 92,
};

struct reset_control;

struct mii_bus;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc___2 *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
	PHY_CABLETEST = 6,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_RGMII = 8,
	PHY_INTERFACE_MODE_RGMII_ID = 9,
	PHY_INTERFACE_MODE_RGMII_RXID = 10,
	PHY_INTERFACE_MODE_RGMII_TXID = 11,
	PHY_INTERFACE_MODE_RTBI = 12,
	PHY_INTERFACE_MODE_SMII = 13,
	PHY_INTERFACE_MODE_XGMII = 14,
	PHY_INTERFACE_MODE_XLGMII = 15,
	PHY_INTERFACE_MODE_MOCA = 16,
	PHY_INTERFACE_MODE_QSGMII = 17,
	PHY_INTERFACE_MODE_TRGMII = 18,
	PHY_INTERFACE_MODE_1000BASEX = 19,
	PHY_INTERFACE_MODE_2500BASEX = 20,
	PHY_INTERFACE_MODE_RXAUI = 21,
	PHY_INTERFACE_MODE_XAUI = 22,
	PHY_INTERFACE_MODE_10GBASER = 23,
	PHY_INTERFACE_MODE_USXGMII = 24,
	PHY_INTERFACE_MODE_10GKR = 25,
	PHY_INTERFACE_MODE_MAX = 26,
} phy_interface_t;

struct phylink;

struct phy_driver;

struct phy_package_shared;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	u32 eee_broken_modes;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	u8 mdix;
	u8 mdix_ctrl;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc___2 *reset_gpiod;
	enum {
		MDIOBUS_NO_CAP = 0,
		MDIOBUS_C22 = 1,
		MDIOBUS_C45 = 2,
		MDIOBUS_C22_C45 = 3,
	} probe_capabilities;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*ack_interrupt)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	int (*did_interrupt)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
};

struct software_node;

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct swnode {
	int id;
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

typedef int (*pm_callback_t)(struct device *);

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_ENABLED = 2,
	PCE_STATUS_ERROR = 3,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
};

struct firmware_fallback_config {
	unsigned int force_sysfs_fallback;
	unsigned int ignore_sysfs_fallback;
	int old_timeout;
	int loading_timeout;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	bool is_paged_buf;
	struct page **pages;
	int nr_pages;
	int page_array_size;
	bool need_uevent;
	struct list_head pending_list;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct fw_sysfs {
	bool nowait;
	struct device dev;
	struct fw_priv *fw_priv;
	struct firmware *fw;
};

typedef void (*node_registration_func_t)(struct node___2 *);

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_COMPRESSED = 2,
	REGCACHE_FLAT = 3,
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	bool fast_io;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

struct regmap;

struct regmap_async {
	struct list_head list;
	struct regmap *map;
	void *work_buf;
};

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

typedef void (*regmap_hw_free_context)(void *);

struct regmap_bus {
	bool fast_io;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t val_bytes;
	void (*format_write)(struct regmap *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct hwspinlock;

struct regcache_ops;

struct regmap {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap *);
	int (*exit)(struct regmap *);
	void (*debugfs_init)(struct regmap *);
	int (*read)(struct regmap *, unsigned int, unsigned int *);
	int (*write)(struct regmap *, unsigned int, unsigned int);
	int (*sync)(struct regmap *, unsigned int, unsigned int);
	int (*drop)(struct regmap *, unsigned int, unsigned int);
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_field {
	struct regmap *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	int type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);

struct regcache_rbtree_node {
	void *block;
	long int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_debugfs_node {
	struct regmap *map;
	struct list_head link;
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

struct brd_device {
	int brd_number;
	struct request_queue *brd_queue;
	struct gendisk *brd_disk;
	struct list_head brd_list;
	spinlock_t brd_lock;
	struct xarray brd_pages;
};

typedef long unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
};

struct loop_func_table;

struct loop_device {
	int lo_number;
	atomic_t lo_refcnt;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	char lo_file_name[64];
	char lo_crypt_name[64];
	char lo_encrypt_key[32];
	int lo_encrypt_key_size;
	struct loop_func_table *lo_encryption;
	__u32 lo_init[2];
	kuid_t lo_key_owner;
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct file *lo_backing_file;
	struct block_device *lo_device;
	void *key_data;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	struct kthread_worker worker;
	struct task_struct *worker_task;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
};

struct loop_func_table {
	int number;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	int (*init)(struct loop_device *, const struct loop_info64 *);
	int (*release)(struct loop_device *);
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct module *owner;
};

struct loop_cmd {
	struct kthread_work work;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *css;
};

struct compat_loop_info {
	compat_int_t lo_number;
	compat_dev_t lo_device;
	compat_ulong_t lo_inode;
	compat_dev_t lo_rdevice;
	compat_int_t lo_offset;
	compat_int_t lo_encrypt_type;
	compat_int_t lo_encrypt_key_size;
	compat_int_t lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	compat_ulong_t lo_init[2];
	char reserved[4];
};

typedef int (*encdec_cbc_t)(struct skcipher_request *);

struct virtio_blk_geometry {
	__virtio16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_config {
	__virtio64 capacity;
	__virtio32 size_max;
	__virtio32 seg_max;
	struct virtio_blk_geometry geometry;
	__virtio32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__virtio16 min_io_size;
	__virtio32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__virtio16 num_queues;
	__virtio32 max_discard_sectors;
	__virtio32 max_discard_seg;
	__virtio32 discard_sector_alignment;
	__virtio32 max_write_zeroes_sectors;
	__virtio32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
} __attribute__((packed));

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 64;
	long: 64;
};

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	refcount_t refs;
	unsigned int sg_elems;
	int index;
	int num_vqs;
	struct virtio_blk_vq *vqs;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	u8 status;
	struct scatterlist sg[0];
};

struct seqcount_ww_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_ww_mutex seqcount_ww_mutex_t;

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf;

struct dma_buf_attachment;

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	void * (*vmap)(struct dma_buf *);
	void (*vunmap)(struct dma_buf *, void *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	void *vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_excl;
	struct dma_buf_poll_cb_t cb_shared;
};

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	seqcount_ww_mutex_t seq;
	struct dma_fence *fence_excl;
	struct dma_resv_list *fence;
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 shared_count;
	u32 shared_max;
	struct dma_fence *shared[0];
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

struct dma_fence_chain {
	struct dma_fence base;
	spinlock_t lock;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
	struct irq_work work;
};

enum seqno_fence_condition {
	SEQNO_FENCE_WAIT_GEQUAL = 0,
	SEQNO_FENCE_WAIT_NONZERO = 1,
};

struct seqno_fence {
	struct dma_fence base;
	const struct dma_fence_ops *ops;
	struct dma_buf *sync_buf;
	uint32_t seqno_ofs;
	enum seqno_fence_condition condition;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = 2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

struct ide_io_ports {
	long unsigned int data_addr;
	union {
		long unsigned int error_addr;
		long unsigned int feature_addr;
	};
	long unsigned int nsect_addr;
	long unsigned int lbal_addr;
	long unsigned int lbam_addr;
	long unsigned int lbah_addr;
	long unsigned int device_addr;
	union {
		long unsigned int status_addr;
		long unsigned int command_addr;
	};
	long unsigned int ctl_addr;
	long unsigned int irq_addr;
};

typedef u8 hwif_chipset_t;

typedef enum {
	ide_stopped = 0,
	ide_started = 1,
} ide_startstop_t;

struct ide_taskfile {
	u8 data;
	union {
		u8 error;
		u8 feature;
	};
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	union {
		u8 status;
		u8 command;
	};
};

struct ide_cmd {
	struct ide_taskfile tf;
	struct ide_taskfile hob;
	struct {
		struct {
			u8 tf;
			u8 hob;
		} out;
		struct {
			u8 tf;
			u8 hob;
		} in;
	} valid;
	u16 tf_flags;
	u8 ftf_flags;
	int protocol;
	int sg_nents;
	int orig_sg_nents;
	int sg_dma_direction;
	unsigned int nbytes;
	unsigned int nleft;
	unsigned int last_xfer_len;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	struct request *rq;
};

struct ide_atapi_pc {
	u8 c[12];
	int retries;
	int error;
	int req_xfer;
	struct request *rq;
	long unsigned int flags;
	long unsigned int timeout;
};

struct ide_drive_s;

struct ide_disk_ops {
	int (*check)(struct ide_drive_s *, const char *);
	int (*get_capacity)(struct ide_drive_s *);
	void (*unlock_native_capacity)(struct ide_drive_s *);
	void (*setup)(struct ide_drive_s *);
	void (*flush)(struct ide_drive_s *);
	int (*init_media)(struct ide_drive_s *, struct gendisk *);
	int (*set_doorlock)(struct ide_drive_s *, struct gendisk *, int);
	ide_startstop_t (*do_request)(struct ide_drive_s *, struct request *, sector_t);
	int (*ioctl)(struct ide_drive_s *, struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct ide_drive_s *, struct block_device *, fmode_t, unsigned int, long unsigned int);
};

struct ide_proc_devset;

struct hwif_s;

struct ide_drive_s {
	char name[4];
	char driver_req[10];
	struct request_queue *queue;
	bool (*prep_rq)(struct ide_drive_s *, struct request *);
	struct blk_mq_tag_set tag_set;
	struct request *rq;
	void *driver_data;
	u16 *id;
	struct proc_dir_entry *proc;
	const struct ide_proc_devset *settings;
	struct hwif_s *hwif;
	const struct ide_disk_ops *disk_ops;
	long unsigned int dev_flags;
	long unsigned int sleep;
	long unsigned int timeout;
	u8 special_flags;
	u8 select;
	u8 retry_pio;
	u8 waiting_for_dma;
	u8 dma;
	u8 init_speed;
	u8 current_speed;
	u8 desired_speed;
	u8 pio_mode;
	u8 dma_mode;
	u8 dn;
	u8 acoustic;
	u8 media;
	u8 ready_stat;
	u8 mult_count;
	u8 mult_req;
	u8 io_32bit;
	u8 bad_wstat;
	u8 head;
	u8 sect;
	u8 bios_head;
	u8 bios_sect;
	u8 pc_delay;
	unsigned int bios_cyl;
	unsigned int cyl;
	void *drive_data;
	unsigned int failures;
	unsigned int max_failures;
	u64 probed_capacity;
	u64 capacity64;
	int lun;
	int crc_count;
	long unsigned int debug_mask;
	struct list_head list;
	struct device gendev;
	struct completion gendev_rel_comp;
	struct ide_atapi_pc *pc;
	struct ide_atapi_pc *failed_pc;
	int (*pc_callback)(struct ide_drive_s *, int);
	ide_startstop_t (*irq_handler)(struct ide_drive_s *);
	long unsigned int atapi_flags;
	struct ide_atapi_pc request_sense_pc;
	bool sense_rq_armed;
	bool sense_rq_active;
	struct request *sense_rq;
	struct request_sense sense_data;
	struct work_struct rq_work;
	struct list_head rq_list;
};

enum {
	IDE_DFLAG_KEEP_SETTINGS = 1,
	IDE_DFLAG_USING_DMA = 2,
	IDE_DFLAG_UNMASK = 4,
	IDE_DFLAG_NOFLUSH = 8,
	IDE_DFLAG_DSC_OVERLAP = 16,
	IDE_DFLAG_NICE1 = 32,
	IDE_DFLAG_PRESENT = 64,
	IDE_DFLAG_NOHPA = 128,
	IDE_DFLAG_ID_READ = 256,
	IDE_DFLAG_NOPROBE = 512,
	IDE_DFLAG_REMOVABLE = 1024,
	IDE_DFLAG_FORCED_GEOM = 4096,
	IDE_DFLAG_NO_UNMASK = 8192,
	IDE_DFLAG_NO_IO_32BIT = 16384,
	IDE_DFLAG_DOORLOCKING = 32768,
	IDE_DFLAG_NODMA = 65536,
	IDE_DFLAG_BLOCKED = 131072,
	IDE_DFLAG_SLEEPING = 262144,
	IDE_DFLAG_POST_RESET = 524288,
	IDE_DFLAG_UDMA33_WARNED = 1048576,
	IDE_DFLAG_LBA48 = 2097152,
	IDE_DFLAG_WCACHE = 4194304,
	IDE_DFLAG_NOWERR = 8388608,
	IDE_DFLAG_DMA_PIO_RETRY = 16777216,
	IDE_DFLAG_LBA = 33554432,
	IDE_DFLAG_NO_UNLOAD = 67108864,
	IDE_DFLAG_PARKED = 134217728,
	IDE_DFLAG_MEDIA_CHANGED = 268435456,
	IDE_DFLAG_WP = 536870912,
	IDE_DFLAG_FORMAT_IN_PROGRESS = 1073741824,
	IDE_DFLAG_NIEN_QUIRK = 2147483648,
};

typedef struct ide_drive_s ide_drive_t;

struct ide_devset;

struct ide_proc_devset {
	const char *name;
	const struct ide_devset *setting;
	int min;
	int max;
	int (*mulf)(ide_drive_t *);
	int (*divf)(ide_drive_t *);
};

struct ide_host;

struct ide_tp_ops;

struct ide_port_ops;

struct ide_dma_ops;

struct hwif_s {
	struct hwif_s *mate;
	struct proc_dir_entry *proc;
	struct ide_host *host;
	char name[6];
	struct ide_io_ports io_ports;
	long unsigned int sata_scr[3];
	ide_drive_t *devices[3];
	long unsigned int port_flags;
	u8 major;
	u8 index;
	u8 channel;
	u32 host_flags;
	u8 pio_mask;
	u8 ultra_mask;
	u8 mwdma_mask;
	u8 swdma_mask;
	u8 cbl;
	hwif_chipset_t chipset;
	struct device *dev;
	void (*rw_disk)(ide_drive_t *, struct request *);
	const struct ide_tp_ops *tp_ops;
	const struct ide_port_ops *port_ops;
	const struct ide_dma_ops *dma_ops;
	unsigned int *dmatable_cpu;
	dma_addr_t dmatable_dma;
	int prd_max_nents;
	int prd_ent_size;
	struct scatterlist *sg_table;
	int sg_max_nents;
	struct ide_cmd cmd;
	int rqsize;
	int irq;
	long unsigned int dma_base;
	long unsigned int config_data;
	long unsigned int select_data;
	long unsigned int extra_base;
	unsigned int extra_ports;
	unsigned int present: 1;
	unsigned int busy: 1;
	struct device gendev;
	struct device *portdev;
	struct completion gendev_rel_comp;
	void *hwif_data;
	ide_startstop_t (*handler)(ide_drive_t *);
	unsigned int polling: 1;
	ide_drive_t *cur_dev;
	struct request *rq;
	struct timer_list timer;
	long unsigned int poll_timeout;
	int (*expiry)(ide_drive_t *);
	int req_gen;
	int req_gen_timer;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ide_tp_ops {
	void (*exec_command)(struct hwif_s *, u8);
	u8 (*read_status)(struct hwif_s *);
	u8 (*read_altstatus)(struct hwif_s *);
	void (*write_devctl)(struct hwif_s *, u8);
	void (*dev_select)(ide_drive_t *);
	void (*tf_load)(ide_drive_t *, struct ide_taskfile *, u8);
	void (*tf_read)(ide_drive_t *, struct ide_taskfile *, u8);
	void (*input_data)(ide_drive_t *, struct ide_cmd *, void *, unsigned int);
	void (*output_data)(ide_drive_t *, struct ide_cmd *, void *, unsigned int);
};

struct ide_port_ops {
	void (*init_dev)(ide_drive_t *);
	void (*set_pio_mode)(struct hwif_s *, ide_drive_t *);
	void (*set_dma_mode)(struct hwif_s *, ide_drive_t *);
	blk_status_t (*reset_poll)(ide_drive_t *);
	void (*pre_reset)(ide_drive_t *);
	void (*resetproc)(ide_drive_t *);
	void (*maskproc)(ide_drive_t *, int);
	void (*quirkproc)(ide_drive_t *);
	void (*clear_irq)(ide_drive_t *);
	int (*test_irq)(struct hwif_s *);
	u8 (*mdma_filter)(ide_drive_t *);
	u8 (*udma_filter)(ide_drive_t *);
	u8 (*cable_detect)(struct hwif_s *);
};

struct ide_dma_ops {
	void (*dma_host_set)(struct ide_drive_s *, int);
	int (*dma_setup)(struct ide_drive_s *, struct ide_cmd *);
	void (*dma_start)(struct ide_drive_s *);
	int (*dma_end)(struct ide_drive_s *);
	int (*dma_test_irq)(struct ide_drive_s *);
	void (*dma_lost_irq)(struct ide_drive_s *);
	int (*dma_check)(struct ide_drive_s *, struct ide_cmd *);
	int (*dma_timer_expiry)(struct ide_drive_s *);
	void (*dma_clear)(struct ide_drive_s *);
	u8 (*dma_sff_read_status)(struct hwif_s *);
};

typedef struct hwif_s ide_hwif_t;

struct ide_host {
	ide_hwif_t *ports[5];
	unsigned int n_ports;
	struct device *dev[2];
	int (*init_chipset)(struct pci_dev *);
	void (*get_lock)(irq_handler_t, void *);
	void (*release_lock)();
	irq_handler_t irq_handler;
	long unsigned int host_flags;
	int irq_flags;
	void *host_priv;
	ide_hwif_t *cur_port;
	volatile long unsigned int host_busy;
};

struct ide_devset {
	int (*get)(ide_drive_t *);
	int (*set)(ide_drive_t *, int);
	unsigned int flags;
};

typedef struct {
	const char *name;
	umode_t mode;
	int (*show)(struct seq_file *, void *);
} ide_proc_entry_t;

struct ide_driver {
	const char *version;
	ide_startstop_t (*do_request)(ide_drive_t *, struct request *, sector_t);
	struct device_driver gen_driver;
	int (*probe)(ide_drive_t *);
	void (*remove)(ide_drive_t *);
	void (*resume)(ide_drive_t *);
	void (*shutdown)(ide_drive_t *);
	ide_proc_entry_t * (*proc_entries)(ide_drive_t *);
	const struct ide_proc_devset * (*proc_devsets)(ide_drive_t *);
};

struct chs_geom {
	unsigned int cyl;
	u8 head;
	u8 sect;
};

enum {
	BUSSTATE_OFF = 0,
	BUSSTATE_ON = 1,
	BUSSTATE_TRISTATE = 2,
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

enum ata_priv_type {
	ATA_PRIV_MISC = 0,
	ATA_PRIV_TASKFILE = 1,
	ATA_PRIV_PC = 2,
	ATA_PRIV_SENSE = 3,
	ATA_PRIV_PM_SUSPEND = 4,
	ATA_PRIV_PM_RESUME = 5,
};

struct ide_request {
	struct scsi_request sreq;
	u8 sense[96];
	u8 type;
	void *special;
};

enum {
	IDE_VALID_ERROR = 2,
	IDE_VALID_FEATURE = 2,
	IDE_VALID_NSECT = 4,
	IDE_VALID_LBAL = 8,
	IDE_VALID_LBAM = 16,
	IDE_VALID_LBAH = 32,
	IDE_VALID_DEVICE = 64,
	IDE_VALID_LBA = 56,
	IDE_VALID_OUT_TF = 62,
	IDE_VALID_IN_TF = 60,
	IDE_VALID_OUT_HOB = 62,
	IDE_VALID_IN_HOB = 62,
};

enum {
	IDE_TFLAG_LBA48 = 1,
	IDE_TFLAG_WRITE = 2,
	IDE_TFLAG_CUSTOM_HANDLER = 4,
	IDE_TFLAG_DMA_PIO_FALLBACK = 8,
	IDE_TFLAG_IO_16BIT = 16,
	IDE_TFLAG_DYN = 32,
	IDE_TFLAG_FS = 64,
	IDE_TFLAG_MULTI_PIO = 128,
	IDE_TFLAG_SET_XFER = 256,
};

struct ide_ioctl_devset {
	unsigned int get_ioctl;
	unsigned int set_ioctl;
	const struct ide_devset *setting;
};

enum {
	IDE_DRV_ERROR_GENERAL = 101,
	IDE_DRV_ERROR_FILEMARK = 102,
	IDE_DRV_ERROR_EOD = 103,
};

enum {
	WAIT_DRQ = 1000,
	WAIT_READY = 5000,
	WAIT_PIDENTIFY = 10000,
	WAIT_WORSTCASE = 30000,
	WAIT_CMD = 10000,
	WAIT_FLOPPY_CMD = 50000,
	WAIT_TAPE_CMD = 900000,
	WAIT_MIN_SLEEP = 20,
};

enum {
	IDE_SFLAG_SET_GEOMETRY = 1,
	IDE_SFLAG_RECALIBRATE = 2,
	IDE_SFLAG_SET_MULTMODE = 4,
};

enum {
	IDE_FTFLAG_FLAGGED = 1,
	IDE_FTFLAG_SET_IN_FLAGS = 2,
	IDE_FTFLAG_OUT_DATA = 4,
	IDE_FTFLAG_IN_DATA = 8,
};

typedef ide_startstop_t ide_handler_t(ide_drive_t *);

typedef int ide_expiry_t(ide_drive_t *);

enum {
	IDE_PM_START_SUSPEND = 0,
	IDE_PM_FLUSH_CACHE = 0,
	IDE_PM_STANDBY = 1,
	IDE_PM_START_RESUME = 2,
	IDE_PM_RESTORE_PIO = 2,
	IDE_PM_IDLE = 3,
	IDE_PM_RESTORE_DMA = 4,
	IDE_PM_COMPLETED = 5,
};

enum {
	IDE_HFLAG_ISA_PORTS = 1,
	IDE_HFLAG_SINGLE = 2,
	IDE_HFLAG_PIO_NO_BLACKLIST = 4,
	IDE_HFLAG_QD_2ND_PORT = 8,
	IDE_HFLAG_ABUSE_PREFETCH = 16,
	IDE_HFLAG_ABUSE_FAST_DEVSEL = 32,
	IDE_HFLAG_ABUSE_DMA_MODES = 64,
	IDE_HFLAG_SET_PIO_MODE_KEEP_DMA = 128,
	IDE_HFLAG_POST_SET_MODE = 256,
	IDE_HFLAG_NO_SET_MODE = 512,
	IDE_HFLAG_TRUST_BIOS_FOR_DMA = 1024,
	IDE_HFLAG_CS5520 = 2048,
	IDE_HFLAG_NO_ATAPI_DMA = 4096,
	IDE_HFLAG_NON_BOOTABLE = 8192,
	IDE_HFLAG_NO_DMA = 16384,
	IDE_HFLAG_NO_AUTODMA = 32768,
	IDE_HFLAG_MMIO = 65536,
	IDE_HFLAG_NO_LBA48 = 131072,
	IDE_HFLAG_NO_LBA48_DMA = 262144,
	IDE_HFLAG_ERROR_STOPS_FIFO = 524288,
	IDE_HFLAG_SERIALIZE = 1048576,
	IDE_HFLAG_DTC2278 = 2097152,
	IDE_HFLAG_4DRIVES = 4194304,
	IDE_HFLAG_TRM290 = 8388608,
	IDE_HFLAG_IO_32BIT = 16777216,
	IDE_HFLAG_UNMASK_IRQS = 33554432,
	IDE_HFLAG_BROKEN_ALTSTATUS = 67108864,
	IDE_HFLAG_SERIALIZE_DMA = 134217728,
	IDE_HFLAG_CLEAR_SIMPLEX = 268435456,
	IDE_HFLAG_NO_DSC = 536870912,
	IDE_HFLAG_NO_IO_32BIT = 1073741824,
	IDE_HFLAG_NO_UNMASK_IRQS = 2147483648,
};

struct ide_pm_state {
	int pm_step;
	u32 pm_state;
	void *data;
};

enum {
	IDE_AFLAG_DRQ_INTERRUPT = 1,
	IDE_AFLAG_NO_EJECT = 2,
	IDE_AFLAG_PRE_ATAPI12 = 4,
	IDE_AFLAG_TOCADDR_AS_BCD = 8,
	IDE_AFLAG_TOCTRACKS_AS_BCD = 16,
	IDE_AFLAG_TOC_VALID = 64,
	IDE_AFLAG_DOOR_LOCKED = 128,
	IDE_AFLAG_NO_SPEED_SELECT = 256,
	IDE_AFLAG_VERTOS_300_SSD = 512,
	IDE_AFLAG_VERTOS_600_ESD = 1024,
	IDE_AFLAG_SANYO_3CD = 2048,
	IDE_AFLAG_FULL_CAPS_PAGE = 4096,
	IDE_AFLAG_PLAY_AUDIO_OK = 8192,
	IDE_AFLAG_LE_SPEED_FIELDS = 16384,
	IDE_AFLAG_CLIK_DRIVE = 32768,
	IDE_AFLAG_ZIP_DRIVE = 65536,
	IDE_AFLAG_SRFP = 131072,
	IDE_AFLAG_IGNORE_DSC = 262144,
	IDE_AFLAG_ADDRESS_VALID = 524288,
	IDE_AFLAG_BUSY = 1048576,
	IDE_AFLAG_DETECT_BS = 2097152,
	IDE_AFLAG_FILEMARK = 4194304,
	IDE_AFLAG_MEDIUM_PRESENT = 8388608,
	IDE_AFLAG_NO_AUTOCLOSE = 16777216,
};

struct drive_list_entry {
	const char *id_model;
	const char *id_firmware;
};

enum {
	ide_unknown = 0,
	ide_generic = 1,
	ide_pci = 2,
	ide_cmd640 = 3,
	ide_dtc2278 = 4,
	ide_ali14xx = 5,
	ide_qd65xx = 6,
	ide_umc8672 = 7,
	ide_ht6560b = 8,
	ide_4drives = 9,
	ide_pmac = 10,
	ide_acorn = 11,
	ide_au1xxx = 12,
	ide_palm3710 = 13,
};

struct ide_hw {
	union {
		struct ide_io_ports io_ports;
		long unsigned int io_ports_array[10];
	};
	int irq;
	struct device *dev;
	struct device *parent;
	long unsigned int config;
};

enum {
	IDE_PFLAG_PROBING = 1,
};

struct ide_pci_enablebit {
	u8 reg;
	u8 mask;
	u8 val;
};

struct ide_port_info {
	char *name;
	int (*init_chipset)(struct pci_dev *);
	void (*get_lock)(irq_handler_t, void *);
	void (*release_lock)();
	void (*init_iops)(ide_hwif_t *);
	void (*init_hwif)(ide_hwif_t *);
	int (*init_dma)(ide_hwif_t *, const struct ide_port_info *);
	const struct ide_tp_ops *tp_ops;
	const struct ide_port_ops *port_ops;
	const struct ide_dma_ops *dma_ops;
	struct ide_pci_enablebit enablebits[2];
	hwif_chipset_t chipset;
	u16 max_sectors;
	u32 host_flags;
	int irq_flags;
	u8 pio_mask;
	u8 swdma_mask;
	u8 mwdma_mask;
	u8 udma_mask;
};

union ide_reg_valid_s {
	unsigned int all: 16;
	struct {
		unsigned int data: 1;
		unsigned int error_feature: 1;
		unsigned int sector: 1;
		unsigned int nsector: 1;
		unsigned int lcyl: 1;
		unsigned int hcyl: 1;
		unsigned int select: 1;
		unsigned int status_command: 1;
		unsigned int data_hob: 1;
		unsigned int error_feature_hob: 1;
		unsigned int sector_hob: 1;
		unsigned int nsector_hob: 1;
		unsigned int lcyl_hob: 1;
		unsigned int hcyl_hob: 1;
		unsigned int select_hob: 1;
		unsigned int control_hob: 1;
	} b;
};

typedef union ide_reg_valid_s ide_reg_valid_t;

struct ide_task_request_s {
	__u8 io_ports[8];
	__u8 hob_ports[8];
	ide_reg_valid_t out_flags;
	ide_reg_valid_t in_flags;
	int data_phase;
	int req_cmd;
	long unsigned int out_size;
	long unsigned int in_size;
};

typedef struct ide_task_request_s ide_task_request_t;

struct ide_pio_info {
	const char *name;
	int pio;
};

struct ide_timing {
	u8 mode;
	u8 setup;
	u16 act8b;
	u16 rec8b;
	u16 cyc8b;
	u16 active;
	u16 recover;
	u16 cycle;
	u16 udma;
};

enum {
	IDE_TIMING_SETUP = 1,
	IDE_TIMING_ACT8B = 2,
	IDE_TIMING_REC8B = 4,
	IDE_TIMING_CYC8B = 8,
	IDE_TIMING_8BIT = 14,
	IDE_TIMING_ACTIVE = 16,
	IDE_TIMING_RECOVER = 32,
	IDE_TIMING_CYCLE = 64,
	IDE_TIMING_UDMA = 128,
	IDE_TIMING_ALL = 255,
};

enum {
	PC_FLAG_ABORT = 1,
	PC_FLAG_SUPPRESS_ERROR = 2,
	PC_FLAG_WAIT_FOR_DSC = 4,
	PC_FLAG_DMA_OK = 8,
	PC_FLAG_DMA_IN_PROGRESS = 16,
	PC_FLAG_DMA_ERROR = 32,
	PC_FLAG_WRITING = 64,
};

enum {
	REQ_IDETAPE_PC1 = 1,
	REQ_IDETAPE_PC2 = 2,
	REQ_IDETAPE_READ = 4,
	REQ_IDETAPE_WRITE = 8,
};

struct chipset_bus_clock_list_entry {
	u8 xfer_speed;
	u8 chipset_settings;
	u8 ultra_settings;
};

enum {
	AMD_IDE_CONFIG = 65,
	AMD_CABLE_DETECT = 66,
	AMD_DRIVE_TIMING = 72,
	AMD_8BIT_TIMING = 78,
	AMD_ADDRESS_SETUP = 76,
	AMD_UDMA_TIMING = 80,
};

struct atiixp_ide_timing {
	u8 command_width;
	u8 recover_width;
};

enum ata_clock {
	ATA_CLOCK_25MHZ = 0,
	ATA_CLOCK_33MHZ = 1,
	ATA_CLOCK_40MHZ = 2,
	ATA_CLOCK_50MHZ = 3,
	ATA_CLOCK_66MHZ = 4,
	NUM_ATA_CLOCKS = 5,
};

struct hpt_timings {
	u32 pio_mask;
	u32 dma_mask;
	u32 ultra_mask;
	u32 *clock_table[5];
};

struct hpt_info {
	char *chip_name;
	u8 chip_type;
	u8 udma_mask;
	u8 dpll_clk;
	u8 pci_clk;
	struct hpt_timings *timings;
	u8 clock;
};

enum {
	HPT36x = 0,
	HPT370 = 1,
	HPT370A = 2,
	HPT374 = 3,
	HPT372 = 4,
	HPT372A = 5,
	HPT302 = 6,
	HPT371 = 7,
	HPT372N = 8,
	HPT302N = 9,
	HPT371N = 10,
};

struct ide_info;

struct it821x_dev {
	unsigned int smart: 1;
	unsigned int timing10: 1;
	u8 clock_mode;
	u8 want[4];
	u16 pio[2];
	u16 mwdma[2];
	u16 udma[2];
	u16 quirks;
};

typedef enum {
	PORT_PATA0 = 0,
	PORT_PATA1 = 1,
	PORT_SATA = 2,
} port_type;

struct pio_timing {
	u8 reg0c;
	u8 reg0d;
	u8 reg13;
};

struct mwdma_timing {
	u8 reg0e;
	u8 reg0f;
};

struct udma_timing {
	u8 reg10;
	u8 reg11;
	u8 reg12;
};

struct ich_laptop {
	u16 device;
	u16 subvendor;
	u16 subdevice;
};

struct sis_laptop {
	u16 device;
	u16 subvendor;
	u16 subdevice;
};

enum {
	VIA_IDFLAG_SINGLE = 2,
};

struct via_isa_bridge {
	char *name;
	u16 id;
	u8 rev_min;
	u8 rev_max;
	u8 udma_mask;
	u8 flags;
};

struct via82cxxx_dev {
	struct via_isa_bridge *via_config;
	unsigned int via_80w;
};

struct ide_disk_obj {
	ide_drive_t *drive;
	struct ide_driver *driver;
	struct gendisk *disk;
	struct device dev;
	unsigned int openers;
	struct ide_atapi_pc queued_pc;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	int progress_indication;
	int blocks;
	int block_size;
	int bs_factor;
	u8 cap_desc[8];
	u8 flexible_disk_page[32];
};

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	atomic_t device_busy;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	unsigned char current_tag;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int active_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_pointer {
	char *ptr;
	int this_residual;
	struct scatterlist *buffer;
	int buffers_residual;
	dma_addr_t dma_handle;
	volatile int Status;
	volatile int Message;
	volatile int have_data_in;
	volatile int sent_command;
	volatile int phase;
};

struct scsi_cmnd {
	struct scsi_request req;
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	struct request *request;
	unsigned char *sense_buffer;
	void (*scsi_done)(struct scsi_cmnd *);
	struct scsi_pointer SCp;
	unsigned char *host_scribble;
	int result;
	int flags;
	long unsigned int state;
	unsigned char tag;
	unsigned int extra_len;
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct scsi_host_cmd_pool;

struct scsi_host_template {
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*compat_ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	int (*map_queues)(struct Scsi_Host *);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int max_host_blocked;
	struct device_attribute **shost_attrs;
	struct device_attribute **sdev_attrs;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
	unsigned int cmd_size;
	struct scsi_host_cmd_pool *cmd_pool;
	int rpm_autosuspend_delay;
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *, bool);
	void *priv;
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	int (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	unsigned char eh_cmnd[16];
	struct scatterlist sense_sgl;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_RETRY = 2,
	ACTION_DELAYED_RETRY = 3,
};

struct value_name_pair;

struct sa_name_list {
	int opcode;
	const struct value_name_pair *arr;
	int arr_sz;
};

struct value_name_pair {
	int value;
	const char *name;
};

struct error_info {
	short unsigned int code12;
	short unsigned int size;
};

struct error_info2 {
	unsigned char code1;
	unsigned char code2_min;
	unsigned char code2_max;
	const char *str;
	const char *fmt;
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 10000,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

struct scsi_nl_hdr {
	__u8 version;
	__u8 transport;
	__u16 magic;
	__u16 msgtype;
	__u16 msglen;
};

struct spi_transport_attrs {
	int period;
	int min_period;
	int offset;
	int max_offset;
	unsigned int width: 1;
	unsigned int max_width: 1;
	unsigned int iu: 1;
	unsigned int max_iu: 1;
	unsigned int dt: 1;
	unsigned int qas: 1;
	unsigned int max_qas: 1;
	unsigned int wr_flow: 1;
	unsigned int rd_strm: 1;
	unsigned int rti: 1;
	unsigned int pcomp_en: 1;
	unsigned int hold_mcs: 1;
	unsigned int initial_dv: 1;
	long unsigned int flags;
	unsigned int support_sync: 1;
	unsigned int support_wide: 1;
	unsigned int support_dt: 1;
	unsigned int support_dt_only;
	unsigned int support_ius;
	unsigned int support_qas;
	unsigned int dv_pending: 1;
	unsigned int dv_in_progress: 1;
	struct mutex dv_mutex;
};

enum spi_signal_type {
	SPI_SIGNAL_UNKNOWN = 1,
	SPI_SIGNAL_SE = 2,
	SPI_SIGNAL_LVD = 3,
	SPI_SIGNAL_HVD = 4,
};

struct spi_host_attrs {
	enum spi_signal_type signalling;
};

struct spi_function_template {
	void (*get_period)(struct scsi_target *);
	void (*set_period)(struct scsi_target *, int);
	void (*get_offset)(struct scsi_target *);
	void (*set_offset)(struct scsi_target *, int);
	void (*get_width)(struct scsi_target *);
	void (*set_width)(struct scsi_target *, int);
	void (*get_iu)(struct scsi_target *);
	void (*set_iu)(struct scsi_target *, int);
	void (*get_dt)(struct scsi_target *);
	void (*set_dt)(struct scsi_target *, int);
	void (*get_qas)(struct scsi_target *);
	void (*set_qas)(struct scsi_target *, int);
	void (*get_wr_flow)(struct scsi_target *);
	void (*set_wr_flow)(struct scsi_target *, int);
	void (*get_rd_strm)(struct scsi_target *);
	void (*set_rd_strm)(struct scsi_target *, int);
	void (*get_rti)(struct scsi_target *);
	void (*set_rti)(struct scsi_target *, int);
	void (*get_pcomp_en)(struct scsi_target *);
	void (*set_pcomp_en)(struct scsi_target *, int);
	void (*get_hold_mcs)(struct scsi_target *);
	void (*set_hold_mcs)(struct scsi_target *, int);
	void (*get_signalling)(struct Scsi_Host *);
	void (*set_signalling)(struct Scsi_Host *, enum spi_signal_type);
	int (*deny_binding)(struct scsi_target *);
	long unsigned int show_period: 1;
	long unsigned int show_offset: 1;
	long unsigned int show_width: 1;
	long unsigned int show_iu: 1;
	long unsigned int show_dt: 1;
	long unsigned int show_qas: 1;
	long unsigned int show_wr_flow: 1;
	long unsigned int show_rd_strm: 1;
	long unsigned int show_rti: 1;
	long unsigned int show_pcomp_en: 1;
	long unsigned int show_hold_mcs: 1;
};

enum {
	SPI_BLIST_NOIUS = 1,
};

struct spi_internal {
	struct scsi_transport_template t;
	struct spi_function_template *f;
};

enum spi_compare_returns {
	SPI_COMPARE_SUCCESS = 0,
	SPI_COMPARE_FAILURE = 1,
	SPI_COMPARE_SKIP_TEST = 2,
};

struct work_queue_wrapper {
	struct work_struct work;
	struct scsi_device *sdev;
};

enum fc_port_type {
	FC_PORTTYPE_UNKNOWN = 0,
	FC_PORTTYPE_OTHER = 1,
	FC_PORTTYPE_NOTPRESENT = 2,
	FC_PORTTYPE_NPORT = 3,
	FC_PORTTYPE_NLPORT = 4,
	FC_PORTTYPE_LPORT = 5,
	FC_PORTTYPE_PTP = 6,
	FC_PORTTYPE_NPIV = 7,
};

enum fc_port_state {
	FC_PORTSTATE_UNKNOWN = 0,
	FC_PORTSTATE_NOTPRESENT = 1,
	FC_PORTSTATE_ONLINE = 2,
	FC_PORTSTATE_OFFLINE = 3,
	FC_PORTSTATE_BLOCKED = 4,
	FC_PORTSTATE_BYPASSED = 5,
	FC_PORTSTATE_DIAGNOSTICS = 6,
	FC_PORTSTATE_LINKDOWN = 7,
	FC_PORTSTATE_ERROR = 8,
	FC_PORTSTATE_LOOPBACK = 9,
	FC_PORTSTATE_DELETED = 10,
};

enum fc_vport_state {
	FC_VPORT_UNKNOWN = 0,
	FC_VPORT_ACTIVE = 1,
	FC_VPORT_DISABLED = 2,
	FC_VPORT_LINKDOWN = 3,
	FC_VPORT_INITIALIZING = 4,
	FC_VPORT_NO_FABRIC_SUPP = 5,
	FC_VPORT_NO_FABRIC_RSCS = 6,
	FC_VPORT_FABRIC_LOGOUT = 7,
	FC_VPORT_FABRIC_REJ_WWN = 8,
	FC_VPORT_FAILED = 9,
};

enum fc_tgtid_binding_type {
	FC_TGTID_BIND_NONE = 0,
	FC_TGTID_BIND_BY_WWPN = 1,
	FC_TGTID_BIND_BY_WWNN = 2,
	FC_TGTID_BIND_BY_ID = 3,
};

struct fc_vport_identifiers {
	u64 node_name;
	u64 port_name;
	u32 roles;
	bool disable;
	enum fc_port_type vport_type;
	char symbolic_name[64];
};

struct fc_vport {
	enum fc_vport_state vport_state;
	enum fc_vport_state vport_last_state;
	u64 node_name;
	u64 port_name;
	u32 roles;
	u32 vport_id;
	enum fc_port_type vport_type;
	char symbolic_name[64];
	void *dd_data;
	struct Scsi_Host *shost;
	unsigned int channel;
	u32 number;
	u8 flags;
	struct list_head peers;
	struct device dev;
	struct work_struct vport_delete_work;
};

struct fc_rport_identifiers {
	u64 node_name;
	u64 port_name;
	u32 port_id;
	u32 roles;
};

struct fc_rport {
	u32 maxframe_size;
	u32 supported_classes;
	u32 dev_loss_tmo;
	u64 node_name;
	u64 port_name;
	u32 port_id;
	u32 roles;
	enum fc_port_state port_state;
	u32 scsi_target_id;
	u32 fast_io_fail_tmo;
	void *dd_data;
	unsigned int channel;
	u32 number;
	u8 flags;
	struct list_head peers;
	struct device dev;
	struct delayed_work dev_loss_work;
	struct work_struct scan_work;
	struct delayed_work fail_io_work;
	struct work_struct stgt_delete_work;
	struct work_struct rport_delete_work;
	struct request_queue *rqst_q;
};

struct fc_starget_attrs {
	u64 node_name;
	u64 port_name;
	u32 port_id;
};

struct fc_host_statistics {
	u64 seconds_since_last_reset;
	u64 tx_frames;
	u64 tx_words;
	u64 rx_frames;
	u64 rx_words;
	u64 lip_count;
	u64 nos_count;
	u64 error_frames;
	u64 dumped_frames;
	u64 link_failure_count;
	u64 loss_of_sync_count;
	u64 loss_of_signal_count;
	u64 prim_seq_protocol_err_count;
	u64 invalid_tx_word_count;
	u64 invalid_crc_count;
	u64 fcp_input_requests;
	u64 fcp_output_requests;
	u64 fcp_control_requests;
	u64 fcp_input_megabytes;
	u64 fcp_output_megabytes;
	u64 fcp_packet_alloc_failures;
	u64 fcp_packet_aborts;
	u64 fcp_frame_alloc_failures;
	u64 fc_no_free_exch;
	u64 fc_no_free_exch_xid;
	u64 fc_xid_not_found;
	u64 fc_xid_busy;
	u64 fc_seq_not_found;
	u64 fc_non_bls_resp;
};

enum fc_host_event_code {
	FCH_EVT_LIP = 1,
	FCH_EVT_LINKUP = 2,
	FCH_EVT_LINKDOWN = 3,
	FCH_EVT_LIPRESET = 4,
	FCH_EVT_RSCN = 5,
	FCH_EVT_ADAPTER_CHANGE = 259,
	FCH_EVT_PORT_UNKNOWN = 512,
	FCH_EVT_PORT_OFFLINE = 513,
	FCH_EVT_PORT_ONLINE = 514,
	FCH_EVT_PORT_FABRIC = 516,
	FCH_EVT_LINK_UNKNOWN = 1280,
	FCH_EVT_LINK_FPIN = 1281,
	FCH_EVT_VENDOR_UNIQUE = 65535,
};

struct fc_host_attrs {
	u64 node_name;
	u64 port_name;
	u64 permanent_port_name;
	u32 supported_classes;
	u8 supported_fc4s[32];
	u32 supported_speeds;
	u32 maxframe_size;
	u16 max_npiv_vports;
	char serial_number[80];
	char manufacturer[80];
	char model[256];
	char model_description[256];
	char hardware_version[64];
	char driver_version[64];
	char firmware_version[64];
	char optionrom_version[64];
	u32 port_id;
	enum fc_port_type port_type;
	enum fc_port_state port_state;
	u8 active_fc4s[32];
	u32 speed;
	u64 fabric_name;
	char symbolic_name[256];
	char system_hostname[256];
	u32 dev_loss_tmo;
	enum fc_tgtid_binding_type tgtid_bind_type;
	struct list_head rports;
	struct list_head rport_bindings;
	struct list_head vports;
	u32 next_rport_number;
	u32 next_target_id;
	u32 next_vport_number;
	u16 npiv_vports_inuse;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	char devloss_work_q_name[20];
	struct workqueue_struct *devloss_work_q;
	struct request_queue *rqst_q;
};

struct fc_function_template {
	void (*get_rport_dev_loss_tmo)(struct fc_rport *);
	void (*set_rport_dev_loss_tmo)(struct fc_rport *, u32);
	void (*get_starget_node_name)(struct scsi_target *);
	void (*get_starget_port_name)(struct scsi_target *);
	void (*get_starget_port_id)(struct scsi_target *);
	void (*get_host_port_id)(struct Scsi_Host *);
	void (*get_host_port_type)(struct Scsi_Host *);
	void (*get_host_port_state)(struct Scsi_Host *);
	void (*get_host_active_fc4s)(struct Scsi_Host *);
	void (*get_host_speed)(struct Scsi_Host *);
	void (*get_host_fabric_name)(struct Scsi_Host *);
	void (*get_host_symbolic_name)(struct Scsi_Host *);
	void (*set_host_system_hostname)(struct Scsi_Host *);
	struct fc_host_statistics * (*get_fc_host_stats)(struct Scsi_Host *);
	void (*reset_fc_host_stats)(struct Scsi_Host *);
	int (*issue_fc_host_lip)(struct Scsi_Host *);
	void (*dev_loss_tmo_callbk)(struct fc_rport *);
	void (*terminate_rport_io)(struct fc_rport *);
	void (*set_vport_symbolic_name)(struct fc_vport *);
	int (*vport_create)(struct fc_vport *, bool);
	int (*vport_disable)(struct fc_vport *, bool);
	int (*vport_delete)(struct fc_vport *);
	int (*bsg_request)(struct bsg_job *);
	int (*bsg_timeout)(struct bsg_job *);
	u32 dd_fcrport_size;
	u32 dd_fcvport_size;
	u32 dd_bsg_size;
	long unsigned int show_rport_maxframe_size: 1;
	long unsigned int show_rport_supported_classes: 1;
	long unsigned int show_rport_dev_loss_tmo: 1;
	long unsigned int show_starget_node_name: 1;
	long unsigned int show_starget_port_name: 1;
	long unsigned int show_starget_port_id: 1;
	long unsigned int show_host_node_name: 1;
	long unsigned int show_host_port_name: 1;
	long unsigned int show_host_permanent_port_name: 1;
	long unsigned int show_host_supported_classes: 1;
	long unsigned int show_host_supported_fc4s: 1;
	long unsigned int show_host_supported_speeds: 1;
	long unsigned int show_host_maxframe_size: 1;
	long unsigned int show_host_serial_number: 1;
	long unsigned int show_host_manufacturer: 1;
	long unsigned int show_host_model: 1;
	long unsigned int show_host_model_description: 1;
	long unsigned int show_host_hardware_version: 1;
	long unsigned int show_host_driver_version: 1;
	long unsigned int show_host_firmware_version: 1;
	long unsigned int show_host_optionrom_version: 1;
	long unsigned int show_host_port_id: 1;
	long unsigned int show_host_port_type: 1;
	long unsigned int show_host_port_state: 1;
	long unsigned int show_host_active_fc4s: 1;
	long unsigned int show_host_speed: 1;
	long unsigned int show_host_fabric_name: 1;
	long unsigned int show_host_symbolic_name: 1;
	long unsigned int show_host_system_hostname: 1;
	long unsigned int disable_target_scan: 1;
};

struct fc_nl_event {
	struct scsi_nl_hdr snlh;
	__u64 seconds;
	__u64 vendor_id;
	__u16 host_no;
	__u16 event_datalen;
	__u32 event_num;
	__u32 event_code;
	__u32 event_data;
};

struct fc_bsg_host_add_rport {
	__u8 reserved;
	__u8 port_id[3];
};

struct fc_bsg_host_del_rport {
	__u8 reserved;
	__u8 port_id[3];
};

struct fc_bsg_host_els {
	__u8 command_code;
	__u8 port_id[3];
};

struct fc_bsg_ctels_reply {
	__u32 status;
	struct {
		__u8 action;
		__u8 reason_code;
		__u8 reason_explanation;
		__u8 vendor_unique;
	} rjt_data;
};

struct fc_bsg_host_ct {
	__u8 reserved;
	__u8 port_id[3];
	__u32 preamble_word0;
	__u32 preamble_word1;
	__u32 preamble_word2;
};

struct fc_bsg_host_vendor {
	__u64 vendor_id;
	__u32 vendor_cmd[0];
};

struct fc_bsg_host_vendor_reply {
	__u32 vendor_rsp[0];
};

struct fc_bsg_rport_els {
	__u8 els_code;
};

struct fc_bsg_rport_ct {
	__u32 preamble_word0;
	__u32 preamble_word1;
	__u32 preamble_word2;
};

struct fc_bsg_request {
	__u32 msgcode;
	union {
		struct fc_bsg_host_add_rport h_addrport;
		struct fc_bsg_host_del_rport h_delrport;
		struct fc_bsg_host_els h_els;
		struct fc_bsg_host_ct h_ct;
		struct fc_bsg_host_vendor h_vendor;
		struct fc_bsg_rport_els r_els;
		struct fc_bsg_rport_ct r_ct;
	} rqst_data;
} __attribute__((packed));

struct fc_bsg_reply {
	__u32 result;
	__u32 reply_payload_rcv_len;
	union {
		struct fc_bsg_host_vendor_reply vendor_reply;
		struct fc_bsg_ctels_reply ctels_reply;
	} reply_data;
};

struct fc_internal {
	struct scsi_transport_template t;
	struct fc_function_template *f;
	struct device_attribute private_starget_attrs[3];
	struct device_attribute *starget_attrs[4];
	struct device_attribute private_host_attrs[29];
	struct device_attribute *host_attrs[30];
	struct transport_container rport_attr_cont;
	struct device_attribute private_rport_attrs[10];
	struct device_attribute *rport_attrs[11];
	struct transport_container vport_attr_cont;
	struct device_attribute private_vport_attrs[9];
	struct device_attribute *vport_attrs[10];
};

enum sas_device_type {
	SAS_PHY_UNUSED = 0,
	SAS_END_DEVICE = 1,
	SAS_EDGE_EXPANDER_DEVICE = 2,
	SAS_FANOUT_EXPANDER_DEVICE = 3,
	SAS_HA = 4,
	SAS_SATA_DEV = 5,
	SAS_SATA_PM = 7,
	SAS_SATA_PM_PORT = 8,
	SAS_SATA_PENDING = 9,
};

enum sas_protocol {
	SAS_PROTOCOL_NONE = 0,
	SAS_PROTOCOL_SATA = 1,
	SAS_PROTOCOL_SMP = 2,
	SAS_PROTOCOL_STP = 4,
	SAS_PROTOCOL_SSP = 8,
	SAS_PROTOCOL_ALL = 14,
	SAS_PROTOCOL_STP_ALL = 5,
};

enum sas_linkrate {
	SAS_LINK_RATE_UNKNOWN = 0,
	SAS_PHY_DISABLED = 1,
	SAS_PHY_RESET_PROBLEM = 2,
	SAS_SATA_SPINUP_HOLD = 3,
	SAS_SATA_PORT_SELECTOR = 4,
	SAS_PHY_RESET_IN_PROGRESS = 5,
	SAS_LINK_RATE_1_5_GBPS = 8,
	SAS_LINK_RATE_G1 = 8,
	SAS_LINK_RATE_3_0_GBPS = 9,
	SAS_LINK_RATE_G2 = 9,
	SAS_LINK_RATE_6_0_GBPS = 10,
	SAS_LINK_RATE_12_0_GBPS = 11,
	SAS_LINK_RATE_FAILED = 16,
	SAS_PHY_VIRTUAL = 17,
};

struct sas_identify {
	enum sas_device_type device_type;
	enum sas_protocol initiator_port_protocols;
	enum sas_protocol target_port_protocols;
	u64 sas_address;
	u8 phy_identifier;
};

struct sas_phy {
	struct device dev;
	int number;
	int enabled;
	struct sas_identify identify;
	enum sas_linkrate negotiated_linkrate;
	enum sas_linkrate minimum_linkrate_hw;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate_hw;
	enum sas_linkrate maximum_linkrate;
	u32 invalid_dword_count;
	u32 running_disparity_error_count;
	u32 loss_of_dword_sync_count;
	u32 phy_reset_problem_count;
	struct list_head port_siblings;
	void *hostdata;
};

struct sas_rphy {
	struct device dev;
	struct sas_identify identify;
	struct list_head list;
	struct request_queue *q;
	u32 scsi_target_id;
};

struct sas_end_device {
	struct sas_rphy rphy;
	unsigned int ready_led_meaning: 1;
	unsigned int tlr_supported: 1;
	unsigned int tlr_enabled: 1;
	u16 I_T_nexus_loss_timeout;
	u16 initiator_response_timeout;
};

struct sas_expander_device {
	int level;
	int next_port_id;
	char vendor_id[9];
	char product_id[17];
	char product_rev[5];
	char component_vendor_id[9];
	u16 component_id;
	u8 component_revision_id;
	struct sas_rphy rphy;
};

struct sas_port {
	struct device dev;
	int port_identifier;
	int num_phys;
	unsigned int is_backlink: 1;
	struct sas_rphy *rphy;
	struct mutex phy_list_mutex;
	struct list_head phy_list;
	struct list_head del_list;
};

struct sas_phy_linkrates {
	enum sas_linkrate maximum_linkrate;
	enum sas_linkrate minimum_linkrate;
};

struct sas_function_template {
	int (*get_linkerrors)(struct sas_phy *);
	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
	int (*get_bay_identifier)(struct sas_rphy *);
	int (*phy_reset)(struct sas_phy *, int);
	int (*phy_enable)(struct sas_phy *, int);
	int (*phy_setup)(struct sas_phy *);
	void (*phy_release)(struct sas_phy *);
	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
	void (*smp_handler)(struct bsg_job *, struct Scsi_Host *, struct sas_rphy *);
};

struct sas_domain_function_template;

struct sas_internal {
	struct scsi_transport_template t;
	struct sas_function_template *f;
	struct sas_domain_function_template *dft;
	struct device_attribute private_host_attrs[0];
	struct device_attribute private_phy_attrs[17];
	struct device_attribute private_port_attrs[1];
	struct device_attribute private_rphy_attrs[8];
	struct device_attribute private_end_dev_attrs[5];
	struct device_attribute private_expander_attrs[7];
	struct transport_container phy_attr_cont;
	struct transport_container port_attr_cont;
	struct transport_container rphy_attr_cont;
	struct transport_container end_dev_attr_cont;
	struct transport_container expander_attr_cont;
	struct device_attribute *host_attrs[1];
	struct device_attribute *phy_attrs[18];
	struct device_attribute *port_attrs[2];
	struct device_attribute *rphy_attrs[9];
	struct device_attribute *end_dev_attrs[6];
	struct device_attribute *expander_attrs[8];
};

struct sas_host_attrs {
	struct list_head rphy_list;
	struct mutex lock;
	struct request_queue *q;
	u32 next_target_id;
	u32 next_expander_id;
	int next_port_id;
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = 4294967295,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_CFG_MASK = 4095,
	ATA_DFLAG_PIO = 4096,
	ATA_DFLAG_NCQ_OFF = 8192,
	ATA_DFLAG_SLEEPING = 32768,
	ATA_DFLAG_DUBIOUS_XFER = 65536,
	ATA_DFLAG_NO_UNLOAD = 131072,
	ATA_DFLAG_UNLOCK_HPA = 262144,
	ATA_DFLAG_NCQ_SEND_RECV = 524288,
	ATA_DFLAG_NCQ_PRIO = 1048576,
	ATA_DFLAG_NCQ_PRIO_ENABLE = 2097152,
	ATA_DFLAG_INIT_MASK = 16777215,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DB_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_FAILED = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 5000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_PERDEV_MASK = 33,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_PROBE_MAX_TRIES = 3,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	u8 feature;
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	u8 command;
	u32 auxiliary;
};

struct ata_port;

struct ata_device;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_link;

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[12];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	struct ata_ering_entry ring[32];
};

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	union acpi_object *gtf_cache;
	unsigned int gtf_filter;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	int spdn_cnt;
	struct ata_ering ering;
	long: 64;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

enum sw_activity {
	OFF = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	bool (*qc_fill_rtf)(struct ata_queued_cmd *);
	int (*cable_detect)(struct ata_port *);
	long unsigned int (*mode_filter)(struct ata_device *, long unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, u16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	void (*phy_reset)(struct ata_port *);
	void (*eng_timeout)(struct ata_port *);
	const struct ata_port_operations *inherits;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_acpi_drive {
	u32 pio;
	u32 dma;
};

struct ata_acpi_gtm {
	struct ata_acpi_drive drive[2];
	u32 flags;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	long unsigned int sas_tag_allocated;
	u64 qc_active;
	int nr_active_links;
	unsigned int sas_last_tag;
	long: 64;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct work_struct scsi_rescan_task;
	unsigned int hsm_task_state;
	u32 msg_enable;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	long unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	struct ata_acpi_gtm __acpi_init_gtm;
	long: 32;
	long: 64;
	long: 64;
	u8 sector_buf[512];
};

enum sas_oob_mode {
	OOB_NOT_CONNECTED = 0,
	SATA_OOB_MODE = 1,
	SAS_OOB_MODE = 2,
};

enum phy_func {
	PHY_FUNC_NOP = 0,
	PHY_FUNC_LINK_RESET = 1,
	PHY_FUNC_HARD_RESET = 2,
	PHY_FUNC_DISABLE = 3,
	PHY_FUNC_CLEAR_ERROR_LOG = 5,
	PHY_FUNC_CLEAR_AFFIL = 6,
	PHY_FUNC_TX_SATA_PS_SIGNAL = 7,
	PHY_FUNC_RELEASE_SPINUP_HOLD = 16,
	PHY_FUNC_SET_LINK_RATE = 17,
	PHY_FUNC_GET_EVENTS = 18,
};

enum sas_open_rej_reason {
	SAS_OREJ_UNKNOWN = 0,
	SAS_OREJ_BAD_DEST = 1,
	SAS_OREJ_CONN_RATE = 2,
	SAS_OREJ_EPROTO = 3,
	SAS_OREJ_RESV_AB0 = 4,
	SAS_OREJ_RESV_AB1 = 5,
	SAS_OREJ_RESV_AB2 = 6,
	SAS_OREJ_RESV_AB3 = 7,
	SAS_OREJ_WRONG_DEST = 8,
	SAS_OREJ_STP_NORES = 9,
	SAS_OREJ_NO_DEST = 10,
	SAS_OREJ_PATH_BLOCKED = 11,
	SAS_OREJ_RSVD_CONT0 = 12,
	SAS_OREJ_RSVD_CONT1 = 13,
	SAS_OREJ_RSVD_INIT0 = 14,
	SAS_OREJ_RSVD_INIT1 = 15,
	SAS_OREJ_RSVD_STOP0 = 16,
	SAS_OREJ_RSVD_STOP1 = 17,
	SAS_OREJ_RSVD_RETRY = 18,
};

struct dev_to_host_fis {
	u8 fis_type;
	u8 flags;
	u8 status;
	u8 error;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 _r_a;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_b;
	u8 _r_c;
	u32 _r_d;
};

struct host_to_dev_fis {
	u8 fis_type;
	u8 flags;
	u8 command;
	u8 features;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 features_exp;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_a;
	u8 control;
	u32 _r_b;
};

struct report_general_resp {
	__be16 change_count;
	__be16 route_indexes;
	u8 _r_a;
	u8 num_phys;
	u8 conf_route_table: 1;
	u8 configuring: 1;
	u8 config_others: 1;
	u8 orej_retry_supp: 1;
	u8 stp_cont_awt: 1;
	u8 self_config: 1;
	u8 zone_config: 1;
	u8 t2t_supp: 1;
	u8 _r_c;
	u8 enclosure_logical_id[8];
	u8 _r_d[12];
};

struct discover_resp {
	u8 _r_a[5];
	u8 phy_id;
	__be16 _r_b;
	u8 _r_c: 4;
	u8 attached_dev_type: 3;
	u8 _r_d: 1;
	u8 linkrate: 4;
	u8 _r_e: 4;
	u8 attached_sata_host: 1;
	u8 iproto: 3;
	u8 _r_f: 4;
	u8 attached_sata_dev: 1;
	u8 tproto: 3;
	u8 _r_g: 3;
	u8 attached_sata_ps: 1;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	u8 _r_h[7];
	u8 hmin_linkrate: 4;
	u8 pmin_linkrate: 4;
	u8 hmax_linkrate: 4;
	u8 pmax_linkrate: 4;
	u8 change_count;
	u8 pptv: 4;
	u8 _r_i: 3;
	u8 virtual: 1;
	u8 routing_attr: 4;
	u8 _r_j: 4;
	u8 conn_type;
	u8 conn_el_index;
	u8 conn_phy_link;
	u8 _r_k[8];
};

struct report_phy_sata_resp {
	u8 _r_a[5];
	u8 phy_id;
	u8 _r_b;
	u8 affil_valid: 1;
	u8 affil_supp: 1;
	u8 _r_c: 6;
	u32 _r_d;
	u8 stp_sas_addr[8];
	struct dev_to_host_fis fis;
	u32 _r_e;
	u8 affil_stp_ini_addr[8];
	__be32 crc;
};

struct smp_resp {
	u8 frame_type;
	u8 function;
	u8 result;
	u8 reserved;
	union {
		struct report_general_resp rg;
		struct discover_resp disc;
		struct report_phy_sata_resp rps;
	};
};

enum sas_class {
	SAS = 0,
	EXPANDER = 1,
};

enum sas_phy_role {
	PHY_ROLE_NONE = 0,
	PHY_ROLE_TARGET = 64,
	PHY_ROLE_INITIATOR = 128,
};

enum sas_phy_type {
	PHY_TYPE_PHYSICAL = 0,
	PHY_TYPE_VIRTUAL = 1,
};

enum port_event {
	PORTE_BYTES_DMAED = 0,
	PORTE_BROADCAST_RCVD = 1,
	PORTE_LINK_RESET_ERR = 2,
	PORTE_TIMER_EVENT = 3,
	PORTE_HARD_RESET = 4,
	PORT_NUM_EVENTS = 5,
};

enum phy_event {
	PHYE_LOSS_OF_SIGNAL = 0,
	PHYE_OOB_DONE = 1,
	PHYE_OOB_ERROR = 2,
	PHYE_SPINUP_HOLD = 3,
	PHYE_RESUME_TIMEOUT = 4,
	PHYE_SHUTDOWN = 5,
	PHY_NUM_EVENTS = 6,
};

enum discover_event {
	DISCE_DISCOVER_DOMAIN = 0,
	DISCE_REVALIDATE_DOMAIN = 1,
	DISCE_SUSPEND = 2,
	DISCE_RESUME = 3,
	DISC_NUM_EVENTS = 4,
};

enum routing_attribute {
	DIRECT_ROUTING = 0,
	SUBTRACTIVE_ROUTING = 1,
	TABLE_ROUTING = 2,
};

enum ex_phy_state {
	PHY_EMPTY = 0,
	PHY_VACANT = 1,
	PHY_NOT_PRESENT = 2,
	PHY_DEVICE_DISCOVERED = 3,
};

struct ex_phy {
	int phy_id;
	enum ex_phy_state phy_state;
	enum sas_device_type attached_dev_type;
	enum sas_linkrate linkrate;
	u8 attached_sata_host: 1;
	u8 attached_sata_dev: 1;
	u8 attached_sata_ps: 1;
	enum sas_protocol attached_tproto;
	enum sas_protocol attached_iproto;
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	int phy_change_count;
	enum routing_attribute routing_attr;
	u8 virtual: 1;
	int last_da_index;
	struct sas_phy *phy;
	struct sas_port *port;
};

struct expander_device {
	struct list_head children;
	int ex_change_count;
	u16 max_route_indexes;
	u8 num_phys;
	u8 t2t_supp: 1;
	u8 configuring: 1;
	u8 conf_route_table: 1;
	u8 enclosure_logical_id[8];
	struct ex_phy *ex_phy;
	struct sas_port *parent_port;
	struct mutex cmd_mutex;
};

struct sata_device {
	unsigned int class;
	u8 port_no;
	struct ata_port *ap;
	struct ata_host *ata_host;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct smp_resp rps_resp;
	u8 fis[24];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ssp_device {
	struct list_head eh_list_node;
	struct scsi_lun reset_lun;
};

struct asd_sas_port;

struct domain_device {
	spinlock_t done_lock;
	enum sas_device_type dev_type;
	enum sas_linkrate linkrate;
	enum sas_linkrate min_linkrate;
	enum sas_linkrate max_linkrate;
	int pathways;
	struct domain_device *parent;
	struct list_head siblings;
	struct asd_sas_port *port;
	struct sas_phy *phy;
	struct list_head dev_list_node;
	struct list_head disco_list_node;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	struct sas_rphy *rphy;
	u8 sas_addr[8];
	u8 hashed_sas_addr[3];
	u8 frame_rcvd[32];
	long: 40;
	long: 64;
	union {
		struct expander_device ex_dev;
		struct sata_device sata_dev;
		struct ssp_device ssp_dev;
	};
	void *lldd_dev;
	long unsigned int state;
	struct kref kref;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sas_work {
	struct list_head drain_node;
	struct work_struct work;
};

struct sas_discovery_event {
	struct sas_work work;
	struct asd_sas_port *port;
};

struct sas_discovery {
	struct sas_discovery_event disc_work[4];
	long unsigned int pending;
	u8 fanout_sas_addr[8];
	u8 eeds_a[8];
	u8 eeds_b[8];
	int max_level;
};

struct sas_ha_struct;

struct asd_sas_port {
	struct sas_discovery disc;
	struct domain_device *port_dev;
	spinlock_t dev_list_lock;
	struct list_head dev_list;
	struct list_head disco_list;
	struct list_head destroy_list;
	struct list_head sas_port_del_list;
	enum sas_linkrate linkrate;
	struct sas_work work;
	int suspended;
	int id;
	enum sas_class class;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_oob_mode oob_mode;
	spinlock_t phy_list_lock;
	struct list_head phy_list;
	int num_phys;
	u32 phy_mask;
	struct sas_ha_struct *ha;
	struct sas_port *port;
	void *lldd_port;
};

struct scsi_core {
	struct Scsi_Host *shost;
};

struct asd_sas_phy;

struct sas_ha_struct {
	struct list_head defer_q;
	struct mutex drain_mutex;
	long unsigned int state;
	spinlock_t lock;
	int eh_active;
	wait_queue_head_t eh_wait_q;
	struct list_head eh_dev_q;
	struct mutex disco_mutex;
	struct scsi_core core;
	char *sas_ha_name;
	struct device *dev;
	struct module *lldd_module;
	struct workqueue_struct *event_q;
	struct workqueue_struct *disco_q;
	u8 *sas_addr;
	u8 hashed_sas_addr[3];
	spinlock_t phy_port_lock;
	struct asd_sas_phy **sas_phy;
	struct asd_sas_port **sas_port;
	int num_phys;
	int strict_wide_ports;
	int (*notify_port_event)(struct asd_sas_phy *, enum port_event);
	int (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
	void *lldd_ha;
	struct list_head eh_done_q;
	struct list_head eh_ata_q;
	int event_thres;
};

struct asd_sas_event {
	struct sas_work work;
	struct asd_sas_phy *phy;
	int event;
};

struct asd_sas_phy {
	atomic_t event_nr;
	int in_shutdown;
	int error;
	int suspended;
	struct sas_phy *phy;
	int enabled;
	int id;
	enum sas_class class;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_phy_type type;
	enum sas_phy_role role;
	enum sas_oob_mode oob_mode;
	enum sas_linkrate linkrate;
	u8 *sas_addr;
	u8 attached_sas_addr[8];
	spinlock_t frame_rcvd_lock;
	u8 *frame_rcvd;
	int frame_rcvd_size;
	spinlock_t sas_prim_lock;
	u32 sas_prim;
	struct list_head port_phy_el;
	struct asd_sas_port *port;
	struct sas_ha_struct *ha;
	void *lldd_phy;
};

enum sas_ha_state {
	SAS_HA_REGISTERED = 0,
	SAS_HA_DRAINING = 1,
	SAS_HA_ATA_EH_ACTIVE = 2,
	SAS_HA_FROZEN = 3,
};

enum service_response {
	SAS_TASK_COMPLETE = 0,
	SAS_TASK_UNDELIVERED = 4294967295,
};

enum exec_status {
	__SAM_STAT_CHECK_CONDITION = 2,
	SAS_DEV_NO_RESPONSE = 128,
	SAS_DATA_UNDERRUN = 129,
	SAS_DATA_OVERRUN = 130,
	SAS_INTERRUPTED = 131,
	SAS_QUEUE_FULL = 132,
	SAS_DEVICE_UNKNOWN = 133,
	SAS_SG_ERR = 134,
	SAS_OPEN_REJECT = 135,
	SAS_OPEN_TO = 136,
	SAS_PROTO_RESPONSE = 137,
	SAS_PHY_DOWN = 138,
	SAS_NAK_R_ERR = 139,
	SAS_PENDING = 140,
	SAS_ABORTED_TASK = 141,
};

struct task_status_struct {
	enum service_response resp;
	enum exec_status stat;
	int buf_valid_size;
	u8 buf[96];
	u32 residual;
	enum sas_open_rej_reason open_rej_reason;
};

struct sas_ata_task {
	struct host_to_dev_fis fis;
	u8 atapi_packet[16];
	u8 retry_count;
	u8 dma_xfer: 1;
	u8 use_ncq: 1;
	u8 set_affil_pol: 1;
	u8 stp_affil_pol: 1;
	u8 device_control_reg_update: 1;
} __attribute__((packed));

struct sas_smp_task {
	struct scatterlist smp_req;
	struct scatterlist smp_resp;
};

enum task_attribute {
	TASK_ATTR_SIMPLE = 0,
	TASK_ATTR_HOQ = 1,
	TASK_ATTR_ORDERED = 2,
	TASK_ATTR_ACA = 4,
};

struct sas_ssp_task {
	u8 retry_count;
	u8 LUN[8];
	u8 enable_first_burst: 1;
	enum task_attribute task_attr;
	u8 task_prio;
	struct scsi_cmnd *cmd;
};

struct sas_task_slow;

struct sas_task {
	struct domain_device *dev;
	spinlock_t task_state_lock;
	unsigned int task_state_flags;
	enum sas_protocol task_proto;
	union {
		struct sas_ata_task ata_task;
		struct sas_smp_task smp_task;
		struct sas_ssp_task ssp_task;
	};
	struct scatterlist *scatter;
	int num_scatter;
	u32 total_xfer_len;
	u8 data_dir: 2;
	struct task_status_struct task_status;
	void (*task_done)(struct sas_task *);
	void *lldd_task;
	void *uldd_task;
	struct sas_task_slow *slow_task;
};

struct sas_task_slow {
	struct timer_list timer;
	struct completion completion;
	struct sas_task *task;
};

struct sas_domain_function_template {
	void (*lldd_port_formed)(struct asd_sas_phy *);
	void (*lldd_port_deformed)(struct asd_sas_phy *);
	int (*lldd_dev_found)(struct domain_device *);
	void (*lldd_dev_gone)(struct domain_device *);
	int (*lldd_execute_task)(struct sas_task *, gfp_t);
	int (*lldd_abort_task)(struct sas_task *);
	int (*lldd_abort_task_set)(struct domain_device *, u8 *);
	int (*lldd_clear_aca)(struct domain_device *, u8 *);
	int (*lldd_clear_task_set)(struct domain_device *, u8 *);
	int (*lldd_I_T_nexus_reset)(struct domain_device *);
	int (*lldd_ata_check_ready)(struct domain_device *);
	void (*lldd_ata_set_dmamode)(struct domain_device *);
	int (*lldd_lu_reset)(struct domain_device *, u8 *);
	int (*lldd_query_task)(struct sas_task *);
	int (*lldd_clear_nexus_port)(struct asd_sas_port *);
	int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);
	int (*lldd_write_gpio)(struct sas_ha_struct *, u8, u8, u8, u8 *);
};

struct sas_phy_data {
	struct sas_phy *phy;
	struct mutex event_lock;
	int hard_reset;
	int reset_result;
	struct sas_work reset_work;
	int enable;
	int enable_result;
	struct sas_work enable_work;
};

struct sas_identify_frame {
	u8 frame_type: 4;
	u8 dev_type: 3;
	u8 _un0: 1;
	u8 _un1;
	union {
		struct {
			u8 _un20: 1;
			u8 smp_iport: 1;
			u8 stp_iport: 1;
			u8 ssp_iport: 1;
			u8 _un247: 4;
		};
		u8 initiator_bits;
	};
	union {
		struct {
			u8 _un30: 1;
			u8 smp_tport: 1;
			u8 stp_tport: 1;
			u8 ssp_tport: 1;
			u8 _un347: 4;
		};
		u8 target_bits;
	};
	u8 _un4_11[8];
	u8 sas_addr[8];
	u8 phy_id;
	u8 _un21_27[7];
	__be32 crc;
};

enum {
	SAS_DEV_GONE = 0,
	SAS_DEV_FOUND = 1,
	SAS_DEV_DESTROY = 2,
	SAS_DEV_EH_PENDING = 3,
	SAS_DEV_LU_RESET = 4,
	SAS_DEV_RESET = 5,
};

enum task_disposition {
	TASK_IS_DONE = 0,
	TASK_IS_ABORTED = 1,
	TASK_IS_AT_LU = 2,
	TASK_IS_NOT_AT_LU = 3,
	TASK_ABORT_FAILED = 4,
};

struct ssp_response_iu {
	u8 _r_a[10];
	u8 datapres: 2;
	u8 _r_b: 6;
	u8 status;
	u32 _r_c;
	__be32 sense_data_len;
	__be32 response_data_len;
	u8 resp_data[0];
	u8 sense_data[0];
};

enum blogic_msglevel {
	BLOGIC_ANNOUNCE_LEVEL = 0,
	BLOGIC_INFO_LEVEL = 1,
	BLOGIC_NOTICE_LEVEL = 2,
	BLOGIC_WARN_LEVEL = 3,
	BLOGIC_ERR_LEVEL = 4,
};

enum blogic_adapter_type {
	BLOGIC_MULTIMASTER = 1,
	BLOGIC_FLASHPOINT = 2,
};

enum blogic_adapter_bus_type {
	BLOGIC_UNKNOWN_BUS = 0,
	BLOGIC_ISA_BUS = 1,
	BLOGIC_EISA_BUS = 2,
	BLOGIC_PCI_BUS = 3,
	BLOGIC_VESA_BUS = 4,
	BLOGIC_MCA_BUS = 5,
};

enum blogic_bios_diskgeometry {
	BLOGIC_BIOS_NODISK = 0,
	BLOGIC_BIOS_DISK64x32 = 1,
	BLOGIC_BIOS_DISK128x32 = 2,
	BLOGIC_BIOS_DISK255x63 = 3,
};

struct blogic_byte_count {
	unsigned int units;
	unsigned int billions;
};

struct blogic_probeinfo {
	enum blogic_adapter_type adapter_type;
	enum blogic_adapter_bus_type adapter_bus_type;
	long unsigned int io_addr;
	long unsigned int pci_addr;
	struct pci_dev *pci_device;
	unsigned char bus;
	unsigned char dev;
	unsigned char irq_ch;
};

struct blogic_probe_options {
	bool noprobe: 1;
	bool noprobe_isa: 1;
	bool noprobe_pci: 1;
	bool nosort_pci: 1;
	bool multimaster_first: 1;
	bool flashpoint_first: 1;
	bool limited_isa: 1;
	bool probe330: 1;
	bool probe334: 1;
	bool probe230: 1;
	bool probe234: 1;
	bool probe130: 1;
	bool probe134: 1;
};

struct blogic_global_options {
	bool trace_probe: 1;
	bool trace_hw_reset: 1;
	bool trace_config: 1;
	bool trace_err: 1;
};

union blogic_cntrl_reg {
	unsigned char all;
	struct {
		char: 4;
		bool bus_reset: 1;
		bool int_reset: 1;
		bool soft_reset: 1;
		bool hard_reset: 1;
	} cr;
};

union blogic_stat_reg {
	unsigned char all;
	struct {
		bool cmd_invalid: 1;
		bool rsvd: 1;
		bool datain_ready: 1;
		bool cmd_param_busy: 1;
		bool adapter_ready: 1;
		bool init_reqd: 1;
		bool diag_failed: 1;
		bool diag_active: 1;
	} sr;
};

union blogic_int_reg {
	unsigned char all;
	struct {
		bool mailin_loaded: 1;
		bool mailout_avail: 1;
		bool cmd_complete: 1;
		bool ext_busreset: 1;
		unsigned char rsvd: 3;
		bool int_valid: 1;
	} ir;
};

union blogic_geo_reg {
	unsigned char all;
	struct {
		enum blogic_bios_diskgeometry d0_geo: 2;
		enum blogic_bios_diskgeometry d1_geo: 2;
		char: 3;
		bool ext_trans_enable: 1;
	} gr;
};

enum blogic_opcode {
	BLOGIC_TEST_CMP_COMPLETE = 0,
	BLOGIC_INIT_MBOX = 1,
	BLOGIC_EXEC_MBOX_CMD = 2,
	BLOGIC_EXEC_BIOS_CMD = 3,
	BLOGIC_GET_BOARD_ID = 4,
	BLOGIC_ENABLE_OUTBOX_AVAIL_INT = 5,
	BLOGIC_SET_SELECT_TIMEOUT = 6,
	BLOGIC_SET_PREEMPT_TIME = 7,
	BLOGIC_SET_TIMEOFF_BUS = 8,
	BLOGIC_SET_TXRATE = 9,
	BLOGIC_INQ_DEV0TO7 = 10,
	BLOGIC_INQ_CONFIG = 11,
	BLOGIC_TGT_MODE = 12,
	BLOGIC_INQ_SETUPINFO = 13,
	BLOGIC_WRITE_LOCALRAM = 26,
	BLOGIC_READ_LOCALRAM = 27,
	BLOGIC_WRITE_BUSMASTER_FIFO = 28,
	BLOGIC_READ_BUSMASTER_FIFO = 29,
	BLOGIC_ECHO_CMDDATA = 31,
	BLOGIC_ADAPTER_DIAG = 32,
	BLOGIC_SET_OPTIONS = 33,
	BLOGIC_INQ_DEV8TO15 = 35,
	BLOGIC_INQ_DEV = 36,
	BLOGIC_DISABLE_INT = 37,
	BLOGIC_INIT_EXT_MBOX = 129,
	BLOGIC_EXEC_SCS_CMD = 131,
	BLOGIC_INQ_FWVER_D3 = 132,
	BLOGIC_INQ_FWVER_LETTER = 133,
	BLOGIC_INQ_PCI_INFO = 134,
	BLOGIC_INQ_MODELNO = 139,
	BLOGIC_INQ_SYNC_PERIOD = 140,
	BLOGIC_INQ_EXTSETUP = 141,
	BLOGIC_STRICT_RR = 143,
	BLOGIC_STORE_LOCALRAM = 144,
	BLOGIC_FETCH_LOCALRAM = 145,
	BLOGIC_STORE_TO_EEPROM = 146,
	BLOGIC_LOAD_AUTOSCSICODE = 148,
	BLOGIC_MOD_IOADDR = 149,
	BLOGIC_SETCCB_FMT = 150,
	BLOGIC_WRITE_INQBUF = 154,
	BLOGIC_READ_INQBUF = 155,
	BLOGIC_FLASH_LOAD = 167,
	BLOGIC_READ_SCAMDATA = 168,
	BLOGIC_WRITE_SCAMDATA = 169,
};

struct blogic_board_id {
	unsigned char type;
	unsigned char custom_features;
	unsigned char fw_ver_digit1;
	unsigned char fw_ver_digit2;
};

struct blogic_config {
	char: 5;
	bool dma_ch5: 1;
	bool dma_ch6: 1;
	bool dma_ch7: 1;
	bool irq_ch9: 1;
	bool irq_ch10: 1;
	bool irq_ch11: 1;
	bool irq_ch12: 1;
	char: 1;
	bool irq_ch14: 1;
	bool irq_ch15: 1;
	char: 1;
	unsigned char id: 4;
};

struct blogic_syncval {
	unsigned char offset: 4;
	unsigned char tx_period: 3;
	bool sync: 1;
};

struct blogic_setup_info {
	bool sync: 1;
	bool parity: 1;
	unsigned char tx_rate;
	unsigned char preempt_time;
	unsigned char timeoff_bus;
	unsigned char mbox_count;
	unsigned char mbox_addr[3];
	struct blogic_syncval sync0to7[8];
	unsigned char disconnect_ok0to7;
	unsigned char sig;
	unsigned char char_d;
	unsigned char bus_type;
	unsigned char wide_tx_ok0to7;
	unsigned char wide_tx_active0to7;
	struct blogic_syncval sync8to15[8];
	unsigned char disconnect_ok8to15;
	char: 8;
	unsigned char wide_tx_ok8to15;
	unsigned char wide_tx_active8to15;
};

struct blogic_extmbox_req {
	unsigned char mbox_count;
	u32 base_mbox_addr;
} __attribute__((packed));

enum blogic_isa_ioport {
	BLOGIC_IO_330 = 0,
	BLOGIC_IO_334 = 1,
	BLOGIC_IO_230 = 2,
	BLOGIC_IO_234 = 3,
	BLOGIC_IO_130 = 4,
	BLOGIC_IO_134 = 5,
	BLOGIC_IO_DISABLE = 6,
	BLOGIC_IO_DISABLE2 = 7,
};

struct blogic_adapter_info {
	enum blogic_isa_ioport isa_port;
	unsigned char irq_ch;
	bool low_term: 1;
	bool high_term: 1;
	char: 2;
	bool JP1: 1;
	bool JP2: 1;
	bool JP3: 1;
	bool genericinfo_valid: 1;
	char: 8;
};

struct blogic_ext_setup {
	unsigned char bus_type;
	unsigned char bios_addr;
	short unsigned int sg_limit;
	unsigned char mbox_count;
	u32 base_mbox_addr;
	struct {
		char: 2;
		bool fast_on_eisa: 1;
		char: 3;
		bool level_int: 1;
	} misc;
	unsigned char fw_rev[3];
	bool wide: 1;
	bool differential: 1;
	bool scam: 1;
	bool ultra: 1;
	bool smart_term: 1;
} __attribute__((packed));

enum blogic_rr_req {
	BLOGIC_AGGRESSIVE_RR = 0,
	BLOGIC_STRICT_RR_MODE = 1,
};

struct blogic_fetch_localram {
	unsigned char offset;
	unsigned char count;
};

struct blogic_autoscsi {
	unsigned char factory_sig[2];
	unsigned char info_bytes;
	unsigned char adapter_type[6];
	char: 8;
	bool floppy: 1;
	bool floppy_sec: 1;
	bool level_int: 1;
	char: 2;
	unsigned char systemram_bios: 3;
	unsigned char dma_ch: 7;
	bool dma_autoconf: 1;
	unsigned char irq_ch: 7;
	bool irq_autoconf: 1;
	unsigned char dma_tx_rate;
	unsigned char scsi_id;
	bool low_term: 1;
	bool parity: 1;
	bool high_term: 1;
	bool noisy_cable: 1;
	bool fast_sync_neg: 1;
	bool reset_enabled: 1;
	char: 1;
	bool active_negation: 1;
	unsigned char bus_on_delay;
	unsigned char bus_off_delay;
	bool bios_enabled: 1;
	bool int19_redir_enabled: 1;
	bool ext_trans_enable: 1;
	bool removable_as_fixed: 1;
	char: 1;
	bool morethan2_drives: 1;
	bool bios_int: 1;
	bool floptical: 1;
	short unsigned int dev_enabled;
	short unsigned int wide_ok;
	short unsigned int fast_ok;
	short unsigned int sync_ok;
	short unsigned int discon_ok;
	short unsigned int send_start_unit;
	short unsigned int ignore_bios_scan;
	unsigned char pci_int_pin: 2;
	unsigned char adapter_ioport: 2;
	bool strict_rr_enabled: 1;
	bool vesabus_33mhzplus: 1;
	bool vesa_burst_write: 1;
	bool vesa_burst_read: 1;
	short unsigned int ultra_ok;
	long: 40;
	unsigned char autoscsi_maxlun;
	char: 1;
	bool scam_dominant: 1;
	bool scam_enabled: 1;
	bool scam_lev2: 1;
	char: 4;
	bool int13_exten: 1;
	char: 1;
	bool cd_boot: 1;
	char: 5;
	unsigned char boot_id: 4;
	unsigned char boot_ch: 4;
	unsigned char force_scan_order: 1;
	short unsigned int nontagged_to_alt_ok;
	short unsigned int reneg_sync_on_check;
	unsigned char rsvd[10];
	unsigned char manuf_diag[2];
	short unsigned int cksum;
} __attribute__((packed));

struct blogic_autoscsi_byte45 {
	unsigned char force_scan_order: 1;
};

struct blogic_bios_drvmap {
	unsigned char tgt_idbit3: 1;
	char: 2;
	enum blogic_bios_diskgeometry diskgeom: 2;
	unsigned char tgt_id: 3;
};

enum blogic_setccb_fmt {
	BLOGIC_LEGACY_LUN_CCB = 0,
	BLOGIC_EXT_LUN_CCB = 1,
};

enum blogic_action {
	BLOGIC_OUTBOX_FREE = 0,
	BLOGIC_MBOX_START = 1,
	BLOGIC_MBOX_ABORT = 2,
};

enum blogic_cmplt_code {
	BLOGIC_INBOX_FREE = 0,
	BLOGIC_CMD_COMPLETE_GOOD = 1,
	BLOGIC_CMD_ABORT_BY_HOST = 2,
	BLOGIC_CMD_NOTFOUND = 3,
	BLOGIC_CMD_COMPLETE_ERROR = 4,
	BLOGIC_INVALID_CCB = 5,
};

enum blogic_ccb_opcode {
	BLOGIC_INITIATOR_CCB = 0,
	BLOGIC_TGT_CCB = 1,
	BLOGIC_INITIATOR_CCB_SG = 2,
	BLOGIC_INITIATOR_CCBB_RESIDUAL = 3,
	BLOGIC_INITIATOR_CCB_SG_RESIDUAL = 4,
	BLOGIC_BDR = 129,
};

enum blogic_datadir {
	BLOGIC_UNCHECKED_TX = 0,
	BLOGIC_DATAIN_CHECKED = 1,
	BLOGIC_DATAOUT_CHECKED = 2,
	BLOGIC_NOTX = 3,
};

enum blogic_adapter_status {
	BLOGIC_CMD_CMPLT_NORMAL = 0,
	BLOGIC_LINK_CMD_CMPLT = 10,
	BLOGIC_LINK_CMD_CMPLT_FLAG = 11,
	BLOGIC_DATA_UNDERRUN = 12,
	BLOGIC_SELECT_TIMEOUT = 17,
	BLOGIC_DATA_OVERRUN = 18,
	BLOGIC_NOEXPECT_BUSFREE = 19,
	BLOGIC_INVALID_BUSPHASE = 20,
	BLOGIC_INVALID_OUTBOX_CODE = 21,
	BLOGIC_INVALID_CMD_CODE = 22,
	BLOGIC_LINKCCB_BADLUN = 23,
	BLOGIC_BAD_CMD_PARAM = 26,
	BLOGIC_AUTOREQSENSE_FAIL = 27,
	BLOGIC_TAGQUEUE_REJECT = 28,
	BLOGIC_BAD_MSG_RCVD = 29,
	BLOGIC_HW_FAIL = 32,
	BLOGIC_NORESPONSE_TO_ATN = 33,
	BLOGIC_HW_RESET = 34,
	BLOGIC_RST_FROM_OTHERDEV = 35,
	BLOGIC_BAD_RECONNECT = 36,
	BLOGIC_HW_BDR = 37,
	BLOGIC_ABRT_QUEUE = 38,
	BLOGIC_ADAPTER_SW_ERROR = 39,
	BLOGIC_HW_TIMEOUT = 48,
	BLOGIC_PARITY_ERR = 52,
};

enum blogic_tgt_status {
	BLOGIC_OP_GOOD = 0,
	BLOGIC_CHECKCONDITION = 2,
	BLOGIC_DEVBUSY = 8,
};

enum blogic_queuetag {
	BLOGIC_SIMPLETAG = 0,
	BLOGIC_HEADTAG = 1,
	BLOGIC_ORDEREDTAG = 2,
	BLOGIC_RSVDTAG = 3,
};

struct blogic_sg_seg {
	u32 segbytes;
	u32 segdata;
};

enum blogic_ccb_status {
	BLOGIC_CCB_FREE = 0,
	BLOGIC_CCB_ACTIVE = 1,
	BLOGIC_CCB_COMPLETE = 2,
	BLOGIC_CCB_RESET = 3,
};

struct blogic_adapter;

struct blogic_ccb {
	enum blogic_ccb_opcode opcode;
	char: 3;
	enum blogic_datadir datadir: 2;
	bool tag_enable: 1;
	enum blogic_queuetag queuetag: 2;
	unsigned char cdblen;
	unsigned char sense_datalen;
	u32 datalen;
	void *data;
	short: 16;
	enum blogic_adapter_status adapter_status;
	enum blogic_tgt_status tgt_status;
	unsigned char tgt_id;
	unsigned char lun: 5;
	bool legacytag_enable: 1;
	enum blogic_queuetag legacy_tag: 2;
	unsigned char cdb[12];
	u32 rsvd_int;
	u32 sensedata;
	void (*callback)(struct blogic_ccb *);
	u32 base_addr;
	enum blogic_cmplt_code comp_code;
	dma_addr_t allocgrp_head;
	unsigned int allocgrp_size;
	u32 dma_handle;
	enum blogic_ccb_status status;
	long unsigned int serial;
	struct scsi_cmnd *command;
	struct blogic_adapter *adapter;
	struct blogic_ccb *next;
	struct blogic_ccb *next_all;
	struct blogic_sg_seg sglist[128];
};

struct fpoint_info {
	u32 base_addr;
	bool present;
	unsigned char irq_ch;
	unsigned char scsi_id;
	unsigned char scsi_lun;
	u16 fw_rev;
	u16 sync_ok;
	u16 fast_ok;
	u16 ultra_ok;
	u16 discon_ok;
	u16 wide_ok;
	bool parity: 1;
	bool wide: 1;
	bool softreset: 1;
	bool ext_trans_enable: 1;
	bool low_term: 1;
	bool high_term: 1;
	bool report_underrun: 1;
	bool scam_enabled: 1;
	bool scam_lev2: 1;
	unsigned char family;
	unsigned char bus_type;
	unsigned char model[3];
	unsigned char relative_cardnum;
	unsigned char rsvd[4];
	u32 os_rsvd;
	unsigned char translation_info[4];
	u32 rsvd2[5];
	u32 sec_range;
};

struct blogic_tgt_flags {
	bool tgt_exists: 1;
	bool tagq_ok: 1;
	bool wide_ok: 1;
	bool tagq_active: 1;
	bool wide_active: 1;
	bool cmd_good: 1;
	bool tgt_info_in: 1;
};

struct blogic_tgt_stats {
	unsigned int cmds_tried;
	unsigned int cmds_complete;
	unsigned int read_cmds;
	unsigned int write_cmds;
	struct blogic_byte_count bytesread;
	struct blogic_byte_count byteswritten;
	unsigned int read_sz_buckets[10];
	unsigned int write_sz_buckets[10];
	short unsigned int aborts_request;
	short unsigned int aborts_tried;
	short unsigned int aborts_done;
	short unsigned int bdr_request;
	short unsigned int bdr_tried;
	short unsigned int bdr_done;
	short unsigned int adapter_reset_req;
	short unsigned int adapter_reset_attempt;
	short unsigned int adapter_reset_done;
};

struct blogic_drvr_options;

struct blogic_outbox;

struct blogic_inbox;

struct blogic_adapter {
	struct Scsi_Host *scsi_host;
	struct pci_dev *pci_device;
	enum blogic_adapter_type adapter_type;
	enum blogic_adapter_bus_type adapter_bus_type;
	long unsigned int io_addr;
	long unsigned int pci_addr;
	short unsigned int addr_count;
	unsigned char host_no;
	unsigned char model[9];
	unsigned char fw_ver[6];
	unsigned char full_model[18];
	unsigned char bus;
	unsigned char dev;
	unsigned char irq_ch;
	unsigned char dma_ch;
	unsigned char scsi_id;
	bool irq_acquired: 1;
	bool dma_chan_acquired: 1;
	bool ext_trans_enable: 1;
	bool parity: 1;
	bool reset_enabled: 1;
	bool level_int: 1;
	bool wide: 1;
	bool differential: 1;
	bool scam: 1;
	bool ultra: 1;
	bool ext_lun: 1;
	bool terminfo_valid: 1;
	bool low_term: 1;
	bool high_term: 1;
	bool need_bouncebuf: 1;
	bool strict_rr: 1;
	bool scam_enabled: 1;
	bool scam_lev2: 1;
	bool adapter_initd: 1;
	bool adapter_extreset: 1;
	bool adapter_intern_err: 1;
	bool processing_ccbs;
	volatile bool adapter_cmd_complete;
	short unsigned int adapter_sglimit;
	short unsigned int drvr_sglimit;
	short unsigned int maxdev;
	short unsigned int maxlun;
	short unsigned int mbox_count;
	short unsigned int initccbs;
	short unsigned int inc_ccbs;
	short unsigned int alloc_ccbs;
	short unsigned int drvr_qdepth;
	short unsigned int adapter_qdepth;
	short unsigned int untag_qdepth;
	short unsigned int common_qdepth;
	short unsigned int bus_settle_time;
	short unsigned int sync_ok;
	short unsigned int fast_ok;
	short unsigned int ultra_ok;
	short unsigned int wide_ok;
	short unsigned int discon_ok;
	short unsigned int tagq_ok;
	short unsigned int ext_resets;
	short unsigned int adapter_intern_errors;
	short unsigned int tgt_count;
	short unsigned int msgbuflen;
	u32 bios_addr;
	struct blogic_drvr_options *drvr_opts;
	struct fpoint_info fpinfo;
	void *cardhandle;
	struct list_head host_list;
	struct blogic_ccb *all_ccbs;
	struct blogic_ccb *free_ccbs;
	struct blogic_ccb *firstccb;
	struct blogic_ccb *lastccb;
	struct blogic_ccb *bdr_pend[16];
	struct blogic_tgt_flags tgt_flags[16];
	unsigned char qdepth[16];
	unsigned char sync_period[16];
	unsigned char sync_offset[16];
	unsigned char active_cmds[16];
	unsigned int cmds_since_rst[16];
	long unsigned int last_seqpoint[16];
	long unsigned int last_resettried[16];
	long unsigned int last_resetdone[16];
	struct blogic_outbox *first_outbox;
	struct blogic_outbox *last_outbox;
	struct blogic_outbox *next_outbox;
	struct blogic_inbox *first_inbox;
	struct blogic_inbox *last_inbox;
	struct blogic_inbox *next_inbox;
	struct blogic_tgt_stats tgt_stats[16];
	unsigned char *mbox_space;
	dma_addr_t mbox_space_handle;
	unsigned int mbox_sz;
	long unsigned int ccb_offset;
	char msgbuf[9700];
};

struct blogic_outbox {
	u32 ccb;
	int: 24;
	enum blogic_action action;
};

struct blogic_inbox {
	u32 ccb;
	enum blogic_adapter_status adapter_status;
	enum blogic_tgt_status tgt_status;
	char: 8;
	enum blogic_cmplt_code comp_code;
};

struct blogic_drvr_options {
	short unsigned int tagq_ok;
	short unsigned int tagq_ok_mask;
	short unsigned int bus_settle_time;
	short unsigned int stop_tgt_inquiry;
	unsigned char common_qdepth;
	unsigned char qdepth[16];
};

struct bios_diskparam {
	int heads;
	int sectors;
	int cylinders;
};

struct scsi_inquiry {
	unsigned char devtype: 5;
	unsigned char dev_qual: 3;
	unsigned char dev_modifier: 7;
	bool rmb: 1;
	unsigned char ansi_ver: 3;
	unsigned char ecma_ver: 3;
	unsigned char iso_ver: 2;
	unsigned char resp_fmt: 4;
	char: 2;
	bool TrmIOP: 1;
	bool AENC: 1;
	unsigned char addl_len;
	short: 16;
	bool SftRe: 1;
	bool CmdQue: 1;
	char: 1;
	bool linked: 1;
	bool sync: 1;
	bool WBus16: 1;
	bool WBus32: 1;
	bool RelAdr: 1;
	unsigned char vendor[8];
	unsigned char product[16];
	unsigned char product_rev[4];
};

typedef long unsigned int u_long;

typedef enum {
	CAM_REQ_INPROG = 0,
	CAM_REQ_CMP = 1,
	CAM_REQ_ABORTED = 2,
	CAM_UA_ABORT = 3,
	CAM_REQ_CMP_ERR = 4,
	CAM_BUSY = 5,
	CAM_REQ_INVALID = 6,
	CAM_PATH_INVALID = 7,
	CAM_SEL_TIMEOUT = 8,
	CAM_CMD_TIMEOUT = 9,
	CAM_SCSI_STATUS_ERROR = 10,
	CAM_SCSI_BUS_RESET = 11,
	CAM_UNCOR_PARITY = 12,
	CAM_AUTOSENSE_FAIL = 13,
	CAM_NO_HBA = 14,
	CAM_DATA_RUN_ERR = 15,
	CAM_UNEXP_BUSFREE = 16,
	CAM_SEQUENCE_FAIL = 17,
	CAM_CCB_LEN_ERR = 18,
	CAM_PROVIDE_FAIL = 19,
	CAM_BDR_SENT = 20,
	CAM_REQ_TERMIO = 21,
	CAM_UNREC_HBA_ERROR = 22,
	CAM_REQ_TOO_BIG = 23,
	CAM_UA_TERMIO = 24,
	CAM_MSG_REJECT_REC = 25,
	CAM_DEV_NOT_THERE = 26,
	CAM_RESRC_UNAVAIL = 27,
	CAM_REQUEUE_REQ = 28,
	CAM_DEV_QFRZN = 64,
	CAM_STATUS_MASK = 63,
} cam_status;

enum {
	CAM_DIR_IN = 2,
	CAM_DIR_OUT = 1,
	CAM_DIR_NONE = 3,
};

struct scsi_sense {
	uint8_t opcode;
	uint8_t byte2;
	uint8_t unused[2];
	uint8_t length;
	uint8_t control;
};

struct scsi_sense_data {
	uint8_t error_code;
	uint8_t segment;
	uint8_t flags;
	uint8_t info[4];
	uint8_t extra_len;
	uint8_t cmd_spec_info[4];
	uint8_t add_sense_code;
	uint8_t add_sense_code_qual;
	uint8_t fru;
	uint8_t sense_key_spec[3];
	uint8_t extra_bytes[14];
};

typedef struct pci_dev *ahc_dev_softc_t;

typedef struct scsi_cmnd *ahc_io_ctx_t;

typedef uint32_t bus_size_t;

typedef enum {
	BUS_SPACE_MEMIO = 0,
	BUS_SPACE_PIO = 1,
} bus_space_tag_t;

typedef union {
	u_long ioport;
	volatile uint8_t *maddr;
} bus_space_handle_t;

struct bus_dma_segment {
	dma_addr_t ds_addr;
	bus_size_t ds_len;
};

typedef struct bus_dma_segment bus_dma_segment_t;

struct ahc_linux_dma_tag {
	bus_size_t alignment;
	bus_size_t boundary;
	bus_size_t maxsize;
};

typedef struct ahc_linux_dma_tag *bus_dma_tag_t;

typedef dma_addr_t bus_dmamap_t;

struct ahc_reg_parse_entry {
	char *name;
	uint8_t value;
	uint8_t mask;
};

typedef struct ahc_reg_parse_entry ahc_reg_parse_entry_t;

typedef enum {
	AHC_NONE = 0,
	AHC_CHIPID_MASK = 255,
	AHC_AIC7770 = 1,
	AHC_AIC7850 = 2,
	AHC_AIC7855 = 3,
	AHC_AIC7859 = 4,
	AHC_AIC7860 = 5,
	AHC_AIC7870 = 6,
	AHC_AIC7880 = 7,
	AHC_AIC7895 = 8,
	AHC_AIC7895C = 9,
	AHC_AIC7890 = 10,
	AHC_AIC7896 = 11,
	AHC_AIC7892 = 12,
	AHC_AIC7899 = 13,
	AHC_VL = 256,
	AHC_EISA = 512,
	AHC_PCI = 1024,
	AHC_BUS_MASK = 3840,
} ahc_chip;

typedef enum {
	AHC_FENONE = 0,
	AHC_ULTRA = 1,
	AHC_ULTRA2 = 2,
	AHC_WIDE = 4,
	AHC_TWIN = 8,
	AHC_MORE_SRAM = 16,
	AHC_CMD_CHAN = 32,
	AHC_QUEUE_REGS = 64,
	AHC_SG_PRELOAD = 128,
	AHC_SPIOCAP = 256,
	AHC_MULTI_TID = 512,
	AHC_HS_MAILBOX = 1024,
	AHC_DT = 2048,
	AHC_NEW_TERMCTL = 4096,
	AHC_MULTI_FUNC = 8192,
	AHC_LARGE_SCBS = 16384,
	AHC_AUTORATE = 32768,
	AHC_AUTOPAUSE = 65536,
	AHC_TARGETMODE = 131072,
	AHC_MULTIROLE = 262144,
	AHC_REMOVABLE = 524288,
	AHC_HVD = 1048576,
	AHC_AIC7770_FE = 0,
	AHC_AIC7850_FE = 196865,
	AHC_AIC7860_FE = 196865,
	AHC_AIC7870_FE = 196608,
	AHC_AIC7880_FE = 196609,
	AHC_AIC7890_FE = 153330,
	AHC_AIC7892_FE = 253682,
	AHC_AIC7895_FE = 221233,
	AHC_AIC7895C_FE = 221745,
	AHC_AIC7896_FE = 161522,
	AHC_AIC7899_FE = 261874,
} ahc_feature;

typedef enum {
	AHC_BUGNONE = 0,
	AHC_TMODE_WIDEODD_BUG = 1,
	AHC_AUTOFLUSH_BUG = 2,
	AHC_CACHETHEN_BUG = 4,
	AHC_CACHETHEN_DIS_BUG = 8,
	AHC_PCI_2_1_RETRY_BUG = 16,
	AHC_PCI_MWI_BUG = 32,
	AHC_SCBCHAN_UPLOAD_BUG = 64,
} ahc_bug;

typedef enum {
	AHC_FNONE = 0,
	AHC_PRIMARY_CHANNEL = 3,
	AHC_USEDEFAULTS = 4,
	AHC_SEQUENCER_DEBUG = 8,
	AHC_SHARED_SRAM = 16,
	AHC_LARGE_SEEPROM = 32,
	AHC_RESET_BUS_A = 64,
	AHC_RESET_BUS_B = 128,
	AHC_EXTENDED_TRANS_A = 256,
	AHC_EXTENDED_TRANS_B = 512,
	AHC_TERM_ENB_A = 1024,
	AHC_TERM_ENB_B = 2048,
	AHC_INITIATORROLE = 4096,
	AHC_TARGETROLE = 8192,
	AHC_NEWEEPROM_FMT = 16384,
	AHC_TQINFIFO_BLOCKED = 65536,
	AHC_INT50_SPEEDFLEX = 131072,
	AHC_SCB_BTT = 262144,
	AHC_BIOS_ENABLED = 524288,
	AHC_ALL_INTERRUPTS = 1048576,
	AHC_PAGESCBS = 4194304,
	AHC_EDGE_INTERRUPT = 8388608,
	AHC_39BIT_ADDRESSING = 16777216,
	AHC_LSCBS_ENABLED = 33554432,
	AHC_SCB_CONFIG_USED = 67108864,
	AHC_NO_BIOS_INIT = 134217728,
	AHC_DISABLE_PCI_PERR = 268435456,
	AHC_HAS_TERM_LOGIC = 536870912,
} ahc_flag;

struct status_pkt {
	uint32_t residual_datacnt;
	uint32_t residual_sg_ptr;
	uint8_t scsi_status;
};

struct target_data {
	uint32_t residual_datacnt;
	uint32_t residual_sg_ptr;
	uint8_t scsi_status;
	uint8_t target_phases;
	uint8_t data_phase;
	uint8_t initiator_tag;
};

struct hardware_scb {
	union {
		uint8_t cdb[12];
		uint32_t cdb_ptr;
		struct status_pkt status;
		struct target_data tdata;
	} shared_data;
	uint32_t dataptr;
	uint32_t datacnt;
	uint32_t sgptr;
	uint8_t control;
	uint8_t scsiid;
	uint8_t lun;
	uint8_t tag;
	uint8_t cdb_len;
	uint8_t scsirate;
	uint8_t scsioffset;
	uint8_t next;
	uint8_t cdb32[32];
};

struct ahc_dma_seg {
	uint32_t addr;
	uint32_t len;
};

struct sg_map_node {
	bus_dmamap_t sg_dmamap;
	dma_addr_t sg_physaddr;
	struct ahc_dma_seg *sg_vaddr;
	struct {
		struct sg_map_node *sle_next;
	} links;
};

typedef enum {
	SCB_FREE = 0,
	SCB_OTHERTCL_TIMEOUT = 2,
	SCB_DEVICE_RESET = 4,
	SCB_SENSE = 8,
	SCB_CDB32_PTR = 16,
	SCB_RECOVERY_SCB = 32,
	SCB_AUTO_NEGOTIATE = 64,
	SCB_NEGOTIATE = 128,
	SCB_ABORT = 256,
	SCB_UNTAGGEDQ = 512,
	SCB_ACTIVE = 1024,
	SCB_TARGET_IMMEDIATE = 2048,
	SCB_TRANSMISSION_ERROR = 4096,
	SCB_TARGET_SCB = 8192,
	SCB_SILENT = 16384,
} scb_flag;

struct ahc_softc;

struct scb_platform_data;

struct scb {
	struct hardware_scb *hscb;
	union {
		struct {
			struct scb *sle_next;
		} sle;
		struct {
			struct scb *tqe_next;
			struct scb **tqe_prev;
		} tqe;
	} links;
	struct {
		struct scb *le_next;
		struct scb **le_prev;
	} pending_links;
	ahc_io_ctx_t io_ctx;
	struct ahc_softc *ahc_softc;
	scb_flag flags;
	struct scb_platform_data *platform_data;
	struct sg_map_node *sg_map;
	struct ahc_dma_seg *sg_list;
	dma_addr_t sg_list_phys;
	u_int sg_count;
};

struct scb_tailq {
	struct scb *tqh_first;
	struct scb **tqh_last;
};

struct ahc_aic7770_softc {
	uint8_t busspd;
	uint8_t bustime;
};

struct ahc_pci_softc {
	uint32_t devconfig;
	uint16_t targcrccnt;
	uint8_t command;
	uint8_t csize_lattime;
	uint8_t optionmode;
	uint8_t crccontrol1;
	uint8_t dscommand0;
	uint8_t dspcistatus;
	uint8_t scbbaddr;
	uint8_t dff_thrsh;
};

union ahc_bus_softc {
	struct ahc_aic7770_softc aic7770_softc;
	struct ahc_pci_softc pci_softc;
};

typedef void (*ahc_bus_intr_t)(struct ahc_softc *);

typedef int (*ahc_bus_chip_init_t)(struct ahc_softc *);

struct ahc_tmode_lstate;

typedef enum {
	MSG_TYPE_NONE = 0,
	MSG_TYPE_INITIATOR_MSGOUT = 1,
	MSG_TYPE_INITIATOR_MSGIN = 2,
	MSG_TYPE_TARGET_MSGOUT = 3,
	MSG_TYPE_TARGET_MSGIN = 4,
} ahc_msg_type;

struct scb_data;

struct ahc_platform_data;

struct ahc_tmode_tstate;

struct seeprom_config;

struct cs;

struct target_cmd;

struct ahc_softc {
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	struct scb_data *scb_data;
	struct scb *next_queued_scb;
	struct {
		struct scb *lh_first;
	} pending_scbs;
	u_int untagged_queue_lock;
	struct scb_tailq untagged_queues[16];
	union ahc_bus_softc bus_softc;
	struct ahc_platform_data *platform_data;
	ahc_dev_softc_t dev_softc;
	struct device *dev;
	ahc_bus_intr_t bus_intr;
	ahc_bus_chip_init_t bus_chip_init;
	struct ahc_tmode_tstate *enabled_targets[16];
	struct ahc_tmode_lstate *black_hole;
	struct ahc_tmode_lstate *pending_device;
	ahc_chip chip;
	ahc_feature features;
	ahc_bug bugs;
	ahc_flag flags;
	struct seeprom_config *seep_config;
	uint8_t unpause;
	uint8_t pause;
	uint8_t qoutfifonext;
	uint8_t qinfifonext;
	uint8_t *qoutfifo;
	uint8_t *qinfifo;
	struct cs *critical_sections;
	u_int num_critical_sections;
	char channel;
	char channel_b;
	uint8_t our_id;
	uint8_t our_id_b;
	int unsolicited_ints;
	struct target_cmd *targetcmds;
	uint8_t tqinfifonext;
	uint8_t seqctl;
	uint8_t send_msg_perror;
	ahc_msg_type msg_type;
	uint8_t msgout_buf[12];
	uint8_t msgin_buf[12];
	u_int msgout_len;
	u_int msgout_index;
	u_int msgin_index;
	bus_dma_tag_t parent_dmat;
	bus_dma_tag_t shared_data_dmat;
	bus_dmamap_t shared_data_dmamap;
	dma_addr_t shared_data_busaddr;
	dma_addr_t dma_bug_buf;
	u_int enabled_luns;
	u_int init_level;
	u_int pci_cachesize;
	u_int pci_target_perr_count;
	u_int instruction_ram_size;
	const char *description;
	char *name;
	int unit;
	int seltime;
	int seltime_b;
	uint16_t user_discenable;
	uint16_t user_tagenable;
};

struct ahc_linux_device;

struct scb_platform_data {
	struct ahc_linux_device *dev;
	dma_addr_t buf_busaddr;
	uint32_t xfer_len;
	uint32_t sense_resid;
};

struct scb_data {
	struct {
		struct scb *slh_first;
	} free_scbs;
	struct scb *scbindex[256];
	struct hardware_scb *hscbs;
	struct scb *scbarray;
	struct scsi_sense_data *sense;
	bus_dma_tag_t hscb_dmat;
	bus_dmamap_t hscb_dmamap;
	dma_addr_t hscb_busaddr;
	bus_dma_tag_t sense_dmat;
	bus_dmamap_t sense_dmamap;
	dma_addr_t sense_busaddr;
	bus_dma_tag_t sg_dmat;
	struct {
		struct sg_map_node *slh_first;
	} sg_maps;
	uint8_t numscbs;
	uint8_t maxhscbs;
	uint8_t init_level;
};

struct target_cmd {
	uint8_t scsiid;
	uint8_t identify;
	uint8_t bytes[22];
	uint8_t cmd_valid;
	uint8_t pad[7];
};

struct ahc_transinfo {
	uint8_t protocol_version;
	uint8_t transport_version;
	uint8_t width;
	uint8_t period;
	uint8_t offset;
	uint8_t ppr_options;
};

struct ahc_initiator_tinfo {
	uint8_t scsirate;
	struct ahc_transinfo curr;
	struct ahc_transinfo goal;
	struct ahc_transinfo user;
};

struct ahc_tmode_tstate {
	struct ahc_tmode_lstate *enabled_luns[64];
	struct ahc_initiator_tinfo transinfo[16];
	uint16_t auto_negotiate;
	uint16_t ultraenb;
	uint16_t discenable;
	uint16_t tagenable;
};

struct ahc_syncrate {
	u_int sxfr_u2;
	u_int sxfr;
	uint8_t period;
	const char *rate;
};

struct ahc_phase_table_entry {
	uint8_t phase;
	uint8_t mesg_out;
	char *phasemsg;
};

struct seeprom_config {
	uint16_t device_flags[16];
	uint16_t bios_control;
	uint16_t adapter_control;
	uint16_t brtime_id;
	uint16_t max_targets;
	uint16_t res_1[10];
	uint16_t signature;
	uint16_t checksum;
};

enum {
	MSGLOOP_IN_PROG = 0,
	MSGLOOP_MSGCOMPLETE = 1,
	MSGLOOP_TERMINATED = 2,
};

struct ahc_platform_data {
	struct scsi_target *starget[16];
	spinlock_t spin_lock;
	u_int qfrozen;
	struct completion *eh_done;
	struct Scsi_Host *host;
	uint32_t irq;
	uint32_t bios_address;
	resource_size_t mem_busaddr;
};

struct cs {
	uint16_t begin;
	uint16_t end;
};

typedef enum {
	ROLE_UNKNOWN = 0,
	ROLE_INITIATOR = 1,
	ROLE_TARGET = 2,
} role_t;

struct ahc_devinfo {
	int our_scsiid;
	int target_offset;
	uint16_t target_mask;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
};

typedef enum {
	SEARCH_COMPLETE = 0,
	SEARCH_COUNT = 1,
	SEARCH_REMOVE = 2,
} ahc_search_action;

typedef enum {
	AHC_NEG_TO_GOAL = 0,
	AHC_NEG_IF_NON_ASYNC = 1,
	AHC_NEG_ALWAYS = 2,
} ahc_neg_type;

typedef enum {
	AHC_QUEUE_NONE = 0,
	AHC_QUEUE_BASIC = 1,
	AHC_QUEUE_TAGGED = 2,
} ahc_queue_alg;

typedef enum {
	AHC_DEV_FREEZE_TIL_EMPTY = 2,
	AHC_DEV_Q_BASIC = 16,
	AHC_DEV_Q_TAGGED = 32,
	AHC_DEV_PERIODIC_OTAG = 64,
} ahc_linux_dev_flags;

struct ahc_linux_device {
	int active;
	int openings;
	u_int qfrozen;
	u_long commands_issued;
	u_int tag_success_count;
	ahc_linux_dev_flags flags;
	u_int maxtags;
	u_int tags_on_last_queuefull;
	u_int last_queuefull_same_count;
	u_int commands_since_idle_or_otag;
};

struct ins_format1 {
	uint32_t immediate: 8;
	uint32_t source: 9;
	uint32_t destination: 9;
	uint32_t ret: 1;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format2 {
	uint32_t shift_control: 8;
	uint32_t source: 9;
	uint32_t destination: 9;
	uint32_t ret: 1;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format3 {
	uint32_t immediate: 8;
	uint32_t source: 9;
	uint32_t address: 10;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format4 {
	uint32_t opcode_ext: 8;
	uint32_t source: 9;
	uint32_t destination: 9;
	uint32_t ret: 1;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format5 {
	uint32_t opcode_ext: 8;
	uint32_t source: 9;
	uint32_t address: 10;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format6 {
	uint32_t page: 3;
	uint32_t opcode_ext: 5;
	uint32_t source: 9;
	uint32_t address: 10;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

union ins_formats {
	struct ins_format1 format1;
	struct ins_format2 format2;
	struct ins_format3 format3;
	struct ins_format4 format4;
	struct ins_format5 format5;
	struct ins_format6 format6;
	uint8_t bytes[4];
	uint32_t integer;
};

struct ahc_hard_error_entry {
	uint8_t errno;
	const char *errmesg;
};

typedef int ahc_patch_func_t(struct ahc_softc *);

struct patch {
	ahc_patch_func_t *patch_func;
	uint32_t begin: 10;
	uint32_t skip_instr: 10;
	uint32_t skip_patch: 12;
};

typedef enum {
	AHCMSG_1B = 0,
	AHCMSG_2B = 1,
	AHCMSG_EXT = 2,
} ahc_msgtype;

typedef enum {
	C46 = 6,
	C56_66 = 8,
} seeprom_chip_t;

struct seeprom_descriptor {
	struct ahc_softc *sd_ahc;
	u_int sd_control_offset;
	u_int sd_status_offset;
	u_int sd_dataout_offset;
	seeprom_chip_t sd_chip;
	uint16_t sd_MS;
	uint16_t sd_RDY;
	uint16_t sd_CS;
	uint16_t sd_CK;
	uint16_t sd_DO;
	uint16_t sd_DI;
};

struct seeprom_cmd {
	uint8_t len;
	uint8_t bits[11];
};

typedef int ahc_device_setup_t(struct ahc_softc *);

struct ahc_pci_identity {
	uint64_t full_id;
	uint64_t id_mask;
	const char *name;
	ahc_device_setup_t *setup;
};

enum {
	AHC_POWER_STATE_D0 = 0,
	AHC_POWER_STATE_D1 = 1,
	AHC_POWER_STATE_D2 = 2,
	AHC_POWER_STATE_D3 = 3,
};

typedef enum {
	AC_GETDEV_CHANGED = 2048,
	AC_INQ_CHANGED = 1024,
	AC_TRANSFER_NEG = 512,
	AC_LOST_DEVICE = 256,
	AC_FOUND_DEVICE = 128,
	AC_PATH_DEREGISTERED = 64,
	AC_PATH_REGISTERED = 32,
	AC_SENT_BDR = 16,
	AC_SCSI_AEN = 8,
	AC_UNSOL_RESEL = 2,
	AC_BUS_RESET = 1,
} ac_code;

typedef int bus_dma_filter_t(void *, dma_addr_t);

typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);

typedef struct {
	uint8_t tag_commands[16];
} adapter_tag_info_t;

typedef u16 u_int16_t;

struct scsi_status_iu_header {
	u_int8_t reserved[2];
	u_int8_t flags;
	u_int8_t status;
	u_int8_t sense_length[4];
	u_int8_t pkt_failures_length[4];
	u_int8_t pkt_failures[1];
};

typedef struct pci_dev *ahd_dev_softc_t;

typedef struct scsi_cmnd *ahd_io_ctx_t;

struct ahd_linux_dma_tag {
	bus_size_t alignment;
	bus_size_t boundary;
	bus_size_t maxsize;
};

typedef struct ahd_linux_dma_tag *bus_dma_tag_t___2;

struct ahd_reg_parse_entry {
	char *name;
	uint8_t value;
	uint8_t mask;
};

typedef struct ahd_reg_parse_entry ahd_reg_parse_entry_t;

typedef enum {
	AHD_NONE = 0,
	AHD_CHIPID_MASK = 255,
	AHD_AIC7901 = 1,
	AHD_AIC7902 = 2,
	AHD_AIC7901A = 3,
	AHD_PCI = 256,
	AHD_PCIX = 512,
	AHD_BUS_MASK = 3840,
} ahd_chip;

typedef enum {
	AHD_FENONE = 0,
	AHD_WIDE = 1,
	AHD_AIC79XXB_SLOWCRC = 2,
	AHD_MULTI_FUNC = 256,
	AHD_TARGETMODE = 4096,
	AHD_MULTIROLE = 8192,
	AHD_RTI = 16384,
	AHD_NEW_IOCELL_OPTS = 32768,
	AHD_NEW_DFCNTRL_OPTS = 65536,
	AHD_FAST_CDB_DELIVERY = 131072,
	AHD_REMOVABLE = 0,
	AHD_AIC7901_FE = 0,
	AHD_AIC7901A_FE = 0,
	AHD_AIC7902_FE = 256,
} ahd_feature;

typedef enum {
	AHD_BUGNONE = 0,
	AHD_SENT_SCB_UPDATE_BUG = 1,
	AHD_ABORT_LQI_BUG = 2,
	AHD_PKT_BITBUCKET_BUG = 4,
	AHD_LONG_SETIMO_BUG = 8,
	AHD_NLQICRC_DELAYED_BUG = 16,
	AHD_SCSIRST_BUG = 32,
	AHD_PCIX_CHIPRST_BUG = 64,
	AHD_PCIX_MMAPIO_BUG = 128,
	AHD_PCIX_SCBRAM_RD_BUG = 256,
	AHD_PCIX_BUG_MASK = 448,
	AHD_LQO_ATNO_BUG = 512,
	AHD_AUTOFLUSH_BUG = 1024,
	AHD_CLRLQO_AUTOCLR_BUG = 2048,
	AHD_PKTIZED_STATUS_BUG = 4096,
	AHD_PKT_LUN_BUG = 8192,
	AHD_NONPACKFIFO_BUG = 16384,
	AHD_MDFF_WSCBPTR_BUG = 32768,
	AHD_REG_SLOW_SETTLE_BUG = 65536,
	AHD_SET_MODE_BUG = 131072,
	AHD_BUSFREEREV_BUG = 262144,
	AHD_PACED_NEGTABLE_BUG = 524288,
	AHD_LQOOVERRUN_BUG = 1048576,
	AHD_INTCOLLISION_BUG = 2097152,
	AHD_EARLY_REQ_BUG = 4194304,
	AHD_FAINT_LED_BUG = 8388608,
} ahd_bug;

typedef enum {
	AHD_FNONE = 0,
	AHD_BOOT_CHANNEL = 1,
	AHD_USEDEFAULTS = 4,
	AHD_SEQUENCER_DEBUG = 8,
	AHD_RESET_BUS_A = 16,
	AHD_EXTENDED_TRANS_A = 32,
	AHD_TERM_ENB_A = 64,
	AHD_SPCHK_ENB_A = 128,
	AHD_STPWLEVEL_A = 256,
	AHD_INITIATORROLE = 512,
	AHD_TARGETROLE = 1024,
	AHD_RESOURCE_SHORTAGE = 2048,
	AHD_TQINFIFO_BLOCKED = 4096,
	AHD_INT50_SPEEDFLEX = 8192,
	AHD_BIOS_ENABLED = 16384,
	AHD_ALL_INTERRUPTS = 32768,
	AHD_39BIT_ADDRESSING = 65536,
	AHD_64BIT_ADDRESSING = 131072,
	AHD_CURRENT_SENSING = 262144,
	AHD_SCB_CONFIG_USED = 524288,
	AHD_HP_BOARD = 1048576,
	AHD_BUS_RESET_ACTIVE = 2097152,
	AHD_UPDATE_PEND_CMDS = 4194304,
	AHD_RUNNING_QOUTFIFO = 8388608,
	AHD_HAD_FIRST_SEL = 16777216,
} ahd_flag;

struct initiator_status {
	uint32_t residual_datacnt;
	uint32_t residual_sgptr;
	uint8_t scsi_status;
};

struct target_status {
	uint32_t residual_datacnt;
	uint32_t residual_sgptr;
	uint8_t scsi_status;
	uint8_t target_phases;
	uint8_t data_phase;
	uint8_t initiator_tag;
};

typedef uint32_t sense_addr_t;

union initiator_data {
	struct {
		uint64_t cdbptr;
		uint8_t cdblen;
	} cdb_from_host;
	uint8_t cdb[16];
	struct {
		uint8_t cdb[12];
		sense_addr_t sense_addr;
	} cdb_plus_saddr;
};

struct target_data___2 {
	uint32_t spare[2];
	uint8_t scsi_status;
	uint8_t target_phases;
	uint8_t data_phase;
	uint8_t initiator_tag;
};

struct hardware_scb___2 {
	union {
		union initiator_data idata;
		struct target_data___2 tdata;
		struct initiator_status istatus;
		struct target_status tstatus;
	} shared_data;
	uint16_t tag;
	uint8_t control;
	uint8_t scsiid;
	uint8_t lun;
	uint8_t task_attribute;
	uint8_t cdb_len;
	uint8_t task_management;
	uint64_t dataptr;
	uint32_t datacnt;
	uint32_t sgptr;
	uint32_t hscb_busaddr;
	uint32_t next_hscb_busaddr;
	uint8_t pkt_long_lun[8];
	uint8_t spare[8];
};

struct ahd_dma_seg {
	uint32_t addr;
	uint32_t len;
};

struct ahd_dma64_seg {
	uint64_t addr;
	uint32_t len;
	uint32_t pad;
};

struct map_node {
	bus_dmamap_t dmamap;
	dma_addr_t physaddr;
	uint8_t *vaddr;
	struct {
		struct map_node *sle_next;
	} links;
};

typedef enum {
	SCB_FLAG_NONE = 0,
	SCB_TRANSMISSION_ERROR___2 = 1,
	SCB_OTHERTCL_TIMEOUT___2 = 2,
	SCB_DEVICE_RESET___2 = 4,
	SCB_SENSE___2 = 8,
	SCB_CDB32_PTR___2 = 16,
	SCB_RECOVERY_SCB___2 = 32,
	SCB_AUTO_NEGOTIATE___2 = 64,
	SCB_NEGOTIATE___2 = 128,
	SCB_ABORT___2 = 256,
	SCB_ACTIVE___2 = 512,
	SCB_TARGET_IMMEDIATE___2 = 1024,
	SCB_PACKETIZED = 2048,
	SCB_EXPECT_PPR_BUSFREE = 4096,
	SCB_PKT_SENSE = 8192,
	SCB_EXTERNAL_RESET = 16384,
	SCB_ON_COL_LIST = 32768,
	SCB_SILENT___2 = 65536,
} scb_flag___2;

struct ahd_softc;

struct scb_platform_data___2;

struct scb___2 {
	struct hardware_scb___2 *hscb;
	union {
		struct {
			struct scb___2 *sle_next;
		} sle;
		struct {
			struct scb___2 *le_next;
			struct scb___2 **le_prev;
		} le;
		struct {
			struct scb___2 *tqe_next;
			struct scb___2 **tqe_prev;
		} tqe;
	} links;
	union {
		struct {
			struct scb___2 *sle_next;
		} sle;
		struct {
			struct scb___2 *le_next;
			struct scb___2 **le_prev;
		} le;
		struct {
			struct scb___2 *tqe_next;
			struct scb___2 **tqe_prev;
		} tqe;
	} links2;
	struct scb___2 *col_scb;
	ahd_io_ctx_t io_ctx;
	struct ahd_softc *ahd_softc;
	scb_flag___2 flags;
	struct scb_platform_data___2 *platform_data;
	struct map_node *hscb_map;
	struct map_node *sg_map;
	struct map_node *sense_map;
	void *sg_list;
	uint8_t *sense_data;
	dma_addr_t sg_list_busaddr;
	dma_addr_t sense_busaddr;
	u_int sg_count;
	u_int crc_retry_count;
};

struct scb_tailq___2 {
	struct scb___2 *tqh_first;
	struct scb___2 **tqh_last;
};

struct scb_list {
	struct scb___2 *lh_first;
};

struct scb_data___2 {
	struct scb_tailq___2 free_scbs;
	struct scb_list free_scb_lists[1024];
	struct scb_list any_dev_free_scb_list;
	struct scb___2 *scbindex[512];
	bus_dma_tag_t___2 hscb_dmat;
	bus_dma_tag_t___2 sg_dmat;
	bus_dma_tag_t___2 sense_dmat;
	struct {
		struct map_node *slh_first;
	} hscb_maps;
	struct {
		struct map_node *slh_first;
	} sg_maps;
	struct {
		struct map_node *slh_first;
	} sense_maps;
	int scbs_left;
	int sgs_left;
	int sense_left;
	uint16_t numscbs;
	uint16_t maxhscbs;
	uint8_t init_level;
};

typedef enum {
	AHD_MODE_DFF0 = 0,
	AHD_MODE_DFF1 = 1,
	AHD_MODE_CCHAN = 2,
	AHD_MODE_SCSI = 3,
	AHD_MODE_CFG = 4,
	AHD_MODE_UNKNOWN = 5,
} ahd_mode;

typedef void (*ahd_bus_intr_t)(struct ahd_softc *);

struct ahd_tmode_lstate;

typedef enum {
	MSG_FLAG_NONE = 0,
	MSG_FLAG_EXPECT_PPR_BUSFREE = 1,
	MSG_FLAG_IU_REQ_CHANGED = 2,
	MSG_FLAG_EXPECT_IDE_BUSFREE = 4,
	MSG_FLAG_EXPECT_QASREJ_BUSFREE = 8,
	MSG_FLAG_PACKETIZED = 16,
} ahd_msg_flags;

typedef enum {
	MSG_TYPE_NONE___2 = 0,
	MSG_TYPE_INITIATOR_MSGOUT___2 = 1,
	MSG_TYPE_INITIATOR_MSGIN___2 = 2,
	MSG_TYPE_TARGET_MSGOUT___2 = 3,
	MSG_TYPE_TARGET_MSGIN___2 = 4,
} ahd_msg_type;

struct ahd_suspend_channel_state {
	uint8_t scsiseq;
	uint8_t sxfrctl0;
	uint8_t sxfrctl1;
	uint8_t simode0;
	uint8_t simode1;
	uint8_t seltimer;
	uint8_t seqctl;
};

struct ahd_suspend_pci_state {
	uint32_t devconfig;
	uint8_t command;
	uint8_t csize_lattime;
};

struct ahd_suspend_state {
	struct ahd_suspend_channel_state channel[2];
	struct ahd_suspend_pci_state pci_state;
	uint8_t optionmode;
	uint8_t dscommand0;
	uint8_t dspcistatus;
	uint8_t crccontrol1;
	uint8_t scbbaddr;
	uint8_t dff_thrsh;
	uint8_t *scratch_ram;
	uint8_t *btt;
};

struct ahd_platform_data;

struct ahd_tmode_tstate;

struct ahd_completion;

struct ahd_softc {
	bus_space_tag_t tags[2];
	bus_space_handle_t bshs[2];
	struct scb_data___2 scb_data;
	struct hardware_scb___2 *next_queued_hscb;
	struct map_node *next_queued_hscb_map;
	struct {
		struct scb___2 *lh_first;
	} pending_scbs;
	ahd_mode dst_mode;
	ahd_mode src_mode;
	ahd_mode saved_dst_mode;
	ahd_mode saved_src_mode;
	struct ahd_platform_data *platform_data;
	ahd_dev_softc_t dev_softc;
	ahd_bus_intr_t bus_intr;
	struct ahd_tmode_tstate *enabled_targets[16];
	struct ahd_tmode_lstate *black_hole;
	struct ahd_tmode_lstate *pending_device;
	struct timer_list stat_timer;
	u_int cmdcmplt_bucket;
	uint32_t cmdcmplt_counts[4];
	uint32_t cmdcmplt_total;
	ahd_chip chip;
	ahd_feature features;
	ahd_bug bugs;
	ahd_flag flags;
	struct seeprom_config *seep_config;
	struct ahd_completion *qoutfifo;
	uint16_t qoutfifonext;
	uint16_t qoutfifonext_valid_tag;
	uint16_t qinfifonext;
	uint16_t qinfifo[512];
	uint16_t qfreeze_cnt;
	uint8_t unpause;
	uint8_t pause;
	struct cs *critical_sections;
	u_int num_critical_sections;
	uint8_t *overrun_buf;
	struct {
		struct ahd_softc *tqe_next;
		struct ahd_softc **tqe_prev;
	} links;
	char channel;
	uint8_t our_id;
	struct target_cmd *targetcmds;
	uint8_t tqinfifonext;
	uint8_t hs_mailbox;
	uint8_t send_msg_perror;
	ahd_msg_flags msg_flags;
	ahd_msg_type msg_type;
	uint8_t msgout_buf[12];
	uint8_t msgin_buf[12];
	u_int msgout_len;
	u_int msgout_index;
	u_int msgin_index;
	bus_dma_tag_t___2 parent_dmat;
	bus_dma_tag_t___2 shared_data_dmat;
	struct map_node shared_data_map;
	struct ahd_suspend_state suspend_state;
	u_int enabled_luns;
	u_int init_level;
	u_int pci_cachesize;
	uint8_t iocell_opts[4];
	u_int stack_size;
	uint16_t *saved_stack;
	const char *description;
	const char *bus_description;
	char *name;
	int unit;
	int seltime;
	u_int int_coalescing_timer;
	u_int int_coalescing_maxcmds;
	u_int int_coalescing_mincmds;
	u_int int_coalescing_threshold;
	u_int int_coalescing_stop_threshold;
	uint16_t user_discenable;
	uint16_t user_tagenable;
};

struct ahd_linux_device;

struct scb_platform_data___2 {
	struct ahd_linux_device *dev;
	dma_addr_t buf_busaddr;
	uint32_t xfer_len;
	uint32_t sense_resid;
};

struct ahd_transinfo {
	uint8_t protocol_version;
	uint8_t transport_version;
	uint8_t width;
	uint8_t period;
	uint8_t offset;
	uint8_t ppr_options;
};

struct ahd_initiator_tinfo {
	struct ahd_transinfo curr;
	struct ahd_transinfo goal;
	struct ahd_transinfo user;
};

struct ahd_tmode_tstate {
	struct ahd_tmode_lstate *enabled_luns[256];
	struct ahd_initiator_tinfo transinfo[16];
	uint16_t auto_negotiate;
	uint16_t discenable;
	uint16_t tagenable;
};

struct ahd_phase_table_entry {
	uint8_t phase;
	uint8_t mesg_out;
	const char *phasemsg;
};

struct vpd_config {
	uint8_t bios_flags;
	uint8_t reserved_1[21];
	uint8_t resource_type;
	uint8_t resource_len[2];
	uint8_t resource_data[8];
	uint8_t vpd_tag;
	uint16_t vpd_len;
	uint8_t vpd_keyword[2];
	uint8_t length;
	uint8_t revision;
	uint8_t device_flags;
	uint8_t termination_menus[2];
	uint8_t fifo_threshold;
	uint8_t end_tag;
	uint8_t vpd_checksum;
	uint16_t default_target_flags;
	uint16_t default_bios_flags;
	uint16_t default_ctrl_flags;
	uint8_t default_irq;
	uint8_t pci_lattime;
	uint8_t max_target;
	uint8_t boot_lun;
	uint16_t signature;
	uint8_t reserved_2;
	uint8_t checksum;
	uint8_t reserved_3[4];
};

typedef uint8_t ahd_mode_state;

struct ahd_completion {
	uint16_t tag;
	uint8_t sg_status;
	uint8_t valid_tag;
};

struct ahd_platform_data {
	struct scsi_target *starget[16];
	spinlock_t spin_lock;
	struct completion *eh_done;
	struct Scsi_Host *host;
	uint32_t irq;
	uint32_t bios_address;
	resource_size_t mem_busaddr;
};

struct ahd_devinfo {
	int our_scsiid;
	int target_offset;
	uint16_t target_mask;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
};

typedef enum {
	SEARCH_COMPLETE___2 = 0,
	SEARCH_COUNT___2 = 1,
	SEARCH_REMOVE___2 = 2,
	SEARCH_PRINT = 3,
} ahd_search_action;

typedef enum {
	AHD_NEG_TO_GOAL = 0,
	AHD_NEG_IF_NON_ASYNC = 1,
	AHD_NEG_ALWAYS = 2,
} ahd_neg_type;

typedef enum {
	AHD_QUEUE_NONE = 0,
	AHD_QUEUE_BASIC = 1,
	AHD_QUEUE_TAGGED = 2,
} ahd_queue_alg;

typedef enum {
	AHD_DEV_FREEZE_TIL_EMPTY = 2,
	AHD_DEV_Q_BASIC = 16,
	AHD_DEV_Q_TAGGED = 32,
	AHD_DEV_PERIODIC_OTAG = 64,
} ahd_linux_dev_flags;

struct ahd_linux_device {
	struct {
		struct ahd_linux_device *tqe_next;
		struct ahd_linux_device **tqe_prev;
	} links;
	int active;
	int openings;
	u_int qfrozen;
	u_long commands_issued;
	u_int tag_success_count;
	ahd_linux_dev_flags flags;
	struct timer_list timer;
	u_int maxtags;
	u_int tags_on_last_queuefull;
	u_int last_queuefull_same_count;
	u_int commands_since_idle_or_otag;
};

struct ahd_hard_error_entry {
	uint8_t errno;
	const char *errmesg;
};

typedef int ahd_patch_func_t(struct ahd_softc *);

struct patch___2 {
	ahd_patch_func_t *patch_func;
	uint32_t begin: 10;
	uint32_t skip_instr: 10;
	uint32_t skip_patch: 12;
};

typedef enum {
	AHDMSG_1B = 0,
	AHDMSG_2B = 1,
	AHDMSG_EXT = 2,
} ahd_msgtype;

typedef int ahd_device_setup_t(struct ahd_softc *);

struct ahd_pci_identity {
	uint64_t full_id;
	uint64_t id_mask;
	const char *name;
	ahd_device_setup_t *setup;
};

typedef struct {
	uint16_t tag_commands[16];
} adapter_tag_info_t___2;

struct ahd_linux_iocell_opts {
	uint8_t precomp;
	uint8_t slewrate;
	uint8_t amplitude;
};

typedef enum {
	AHD_POWER_STATE_D0 = 0,
	AHD_POWER_STATE_D1 = 1,
	AHD_POWER_STATE_D2 = 2,
	AHD_POWER_STATE_D3 = 3,
} ahd_power_state;

enum {
	AAC_ENABLE_INTERRUPT = 0,
	AAC_DISABLE_INTERRUPT = 1,
	AAC_ENABLE_MSIX = 2,
	AAC_DISABLE_MSIX = 3,
	AAC_CLEAR_AIF_BIT = 4,
	AAC_CLEAR_SYNC_BIT = 5,
	AAC_ENABLE_INTX = 6,
};

struct aac_hba_sgl {
	u32 addr_lo;
	u32 addr_hi;
	u32 len;
	u32 flags;
};

enum {
	HBA_IU_TYPE_SCSI_CMD_REQ = 64,
	HBA_IU_TYPE_SCSI_TM_REQ = 65,
	HBA_IU_TYPE_SATA_REQ = 66,
	HBA_IU_TYPE_RESP = 96,
	HBA_IU_TYPE_COALESCED_RESP = 97,
	HBA_IU_TYPE_INT_COALESCING_CFG_REQ = 112,
};

enum {
	HBA_RESP_SVCRES_TASK_COMPLETE = 0,
	HBA_RESP_SVCRES_FAILURE = 1,
	HBA_RESP_SVCRES_TMF_COMPLETE = 2,
	HBA_RESP_SVCRES_TMF_SUCCEEDED = 3,
	HBA_RESP_SVCRES_TMF_REJECTED = 4,
	HBA_RESP_SVCRES_TMF_LUN_INVALID = 5,
};

struct aac_hba_cmd_req {
	u8 iu_type;
	u8 byte1;
	u8 reply_qid;
	u8 reserved1;
	__le32 it_nexus;
	__le32 request_id;
	__le32 tweak_value_lo;
	u8 cdb[16];
	u8 lun[8];
	__le32 data_length;
	u8 attr_prio;
	u8 emb_data_desc_count;
	__le16 dek_index;
	__le32 error_ptr_lo;
	__le32 error_ptr_hi;
	__le32 error_length;
	__le32 tweak_value_hi;
	struct aac_hba_sgl sge[92];
};

struct aac_hba_tm_req {
	u8 iu_type;
	u8 reply_qid;
	u8 tmf;
	u8 reserved1;
	__le32 it_nexus;
	u8 lun[8];
	__le32 request_id;
	__le32 reserved2;
	__le32 managed_request_id;
	__le32 reserved3;
	__le32 error_ptr_lo;
	__le32 error_ptr_hi;
	__le32 error_length;
};

struct aac_hba_reset_req {
	u8 iu_type;
	u8 reset_type;
	u8 reply_qid;
	u8 reserved1;
	__le32 it_nexus;
	__le32 request_id;
	__le32 error_ptr_lo;
	__le32 error_ptr_hi;
	__le32 error_length;
};

struct aac_hba_resp {
	u8 iu_type;
	u8 reserved1[3];
	__le32 request_identifier;
	__le32 reserved2;
	u8 service_response;
	u8 status;
	u8 datapres;
	u8 sense_response_data_len;
	__le32 residual_count;
	u8 sense_response_buf[32];
};

struct aac_native_hba {
	union {
		struct aac_hba_cmd_req cmd;
		struct aac_hba_tm_req tmr;
		u8 cmd_bytes[1536];
	} cmd;
	union {
		struct aac_hba_resp err;
		u8 resp_bytes[512];
	} resp;
};

struct _ciss_lun {
	u8 tid[3];
	u8 bus;
	u8 level3[2];
	u8 level2[2];
	u8 node_ident[16];
};

struct aac_ciss_phys_luns_resp {
	u8 list_length[4];
	u8 resp_flag;
	u8 reserved[3];
	struct _ciss_lun lun[1];
};

struct aac_ciss_identify_pd {
	u8 scsi_bus;
	u8 scsi_id;
	u16 block_size;
	u32 total_blocks;
	u32 reserved_blocks;
	u8 model[40];
	u8 serial_number[40];
	u8 firmware_revision[8];
	u8 scsi_inquiry_bits;
	u8 compaq_drive_stamp;
	u8 last_failure_reason;
	u8 flags;
	u8 more_flags;
	u8 scsi_lun;
	u8 yet_more_flags;
	u8 even_more_flags;
	u32 spi_speed_rules;
	u8 phys_connector[2];
	u8 phys_box_on_bus;
	u8 phys_bay_in_box;
	u32 rpm;
	u8 device_type;
	u8 sata_version;
	u64 big_total_block_count;
	u64 ris_starting_lba;
	u32 ris_size;
	u8 wwid[20];
	u8 controller_phy_map[32];
	u16 phy_count;
	u8 phy_connected_dev_type[256];
	u8 phy_to_drive_bay_num[256];
	u16 phy_to_attached_dev_index[256];
	u8 box_index;
	u8 spitfire_support;
	u16 extra_physical_drive_flags;
	u8 negotiated_link_rate[256];
	u8 phy_to_phy_map[256];
	u8 redundant_path_present_map;
	u8 redundant_path_failure_map;
	u8 active_path_number;
	u16 alternate_paths_phys_connector[8];
	u8 alternate_paths_phys_box_on_port[8];
	u8 multi_lun_device_lun_count;
	u8 minimum_good_fw_revision[8];
	u8 unique_inquiry_bytes[20];
	u8 current_temperature_degreesC;
	u8 temperature_threshold_degreesC;
	u8 max_temperature_degreesC;
	u8 logical_blocks_per_phys_block_exp;
	u16 current_queue_depth_limit;
	u8 switch_name[10];
	u16 switch_port;
	u8 alternate_paths_switch_name[40];
	u8 alternate_paths_switch_port[8];
	u16 power_on_hours;
	u16 percent_endurance_used;
	u8 drive_authentication;
	u8 smart_carrier_authentication;
	u8 smart_carrier_app_fw_version;
	u8 smart_carrier_bootloader_fw_version;
	u8 SanitizeSecureEraseSupport;
	u8 DriveKeyFlags;
	u8 encryption_key_name[64];
	u32 misc_drive_flags;
	u16 dek_index;
	u16 drive_encryption_flags;
	u8 sanitize_maximum_time[6];
	u8 connector_info_mode;
	u8 connector_info_number[4];
	u8 long_connector_name[64];
	u8 device_unique_identifier[16];
	u8 padto_2K[17];
} __attribute__((packed));

struct diskparm {
	int heads;
	int sectors;
	int cylinders;
};

struct aac_entry {
	__le32 size;
	__le32 addr;
};

struct aac_qhdr {
	__le64 header_addr;
	__le32 *producer;
	__le32 *consumer;
};

struct aac_fibhdr {
	__le32 XferState;
	__le16 Command;
	u8 StructType;
	u8 Unused;
	__le16 Size;
	__le16 SenderSize;
	__le32 SenderFibAddress;
	union {
		__le32 ReceiverFibAddress;
		__le32 SenderFibAddressHigh;
		__le32 TimeStamp;
	} u;
	__le32 Handle;
	u32 Previous;
	u32 Next;
};

struct hw_fib {
	struct aac_fibhdr header;
	u8 data[480];
};

enum fib_xfer_state {
	HostOwned = 1,
	AdapterOwned = 2,
	FibInitialized = 4,
	FibEmpty = 8,
	AllocatedFromPool = 16,
	SentFromHost = 32,
	SentFromAdapter = 64,
	ResponseExpected = 128,
	NoResponseExpected = 256,
	AdapterProcessed = 512,
	HostProcessed = 1024,
	HighPriority = 2048,
	NormalPriority = 4096,
	Async = 8192,
	AsyncIo = 8192,
	PageFileIo = 16384,
	ShutdownRequest = 32768,
	LazyWrite = 65536,
	AdapterMicroFib = 131072,
	BIOSFibPath = 262144,
	FastResponseCapable = 524288,
	ApiFib = 1048576,
	NoMoreAifDataAvailable = 2097152,
};

struct _r7 {
	__le32 init_struct_revision;
	__le32 no_of_msix_vectors;
	__le32 fsrev;
	__le32 comm_header_address;
	__le32 fast_io_comm_area_address;
	__le32 adapter_fibs_physical_address;
	__le32 adapter_fibs_virtual_address;
	__le32 adapter_fibs_size;
	__le32 adapter_fib_align;
	__le32 printfbuf;
	__le32 printfbufsiz;
	__le32 host_phys_mem_pages;
	__le32 host_elapsed_seconds;
	__le32 init_flags;
	__le32 max_io_commands;
	__le32 max_io_size;
	__le32 max_fib_size;
	__le32 max_num_aif;
	__le32 host_rrq_addr_low;
	__le32 host_rrq_addr_high;
};

struct _rrq {
	__le32 host_addr_low;
	__le32 host_addr_high;
	__le16 msix_id;
	__le16 element_count;
	__le16 comp_thresh;
	__le16 unused;
};

struct _r8 {
	__le32 init_struct_revision;
	__le32 rr_queue_count;
	__le32 host_elapsed_seconds;
	__le32 init_flags;
	__le32 max_io_size;
	__le32 max_num_aif;
	__le32 reserved1;
	__le32 reserved2;
	struct _rrq rrq[1];
};

union aac_init {
	struct _r7 r7;
	struct _r8 r8;
};

struct aac_dev;

struct fib;

struct adapter_ops {
	void (*adapter_interrupt)(struct aac_dev *);
	void (*adapter_notify)(struct aac_dev *, u32);
	void (*adapter_disable_int)(struct aac_dev *);
	void (*adapter_enable_int)(struct aac_dev *);
	int (*adapter_sync_cmd)(struct aac_dev *, u32, u32, u32, u32, u32, u32, u32, u32 *, u32 *, u32 *, u32 *, u32 *);
	int (*adapter_check_health)(struct aac_dev *);
	int (*adapter_restart)(struct aac_dev *, int, u8);
	void (*adapter_start)(struct aac_dev *);
	int (*adapter_ioremap)(struct aac_dev *, u32);
	irq_handler_t adapter_intr;
	int (*adapter_deliver)(struct fib *);
	int (*adapter_bounds)(struct aac_dev *, struct scsi_cmnd *, u64);
	int (*adapter_read)(struct fib *, struct scsi_cmnd *, u64, u32);
	int (*adapter_write)(struct fib *, struct scsi_cmnd *, u64, u32, int);
	int (*adapter_scsi)(struct fib *, struct scsi_cmnd *);
	int (*adapter_comm)(struct aac_dev *, int);
};

struct aac_adapter_info {
	__le32 platform;
	__le32 cpu;
	__le32 subcpu;
	__le32 clock;
	__le32 execmem;
	__le32 buffermem;
	__le32 totalmem;
	__le32 kernelrev;
	__le32 kernelbuild;
	__le32 monitorrev;
	__le32 monitorbuild;
	__le32 hwrev;
	__le32 hwbuild;
	__le32 biosrev;
	__le32 biosbuild;
	__le32 cluster;
	__le32 clusterchannelmask;
	__le32 serial[2];
	__le32 battery;
	__le32 options;
	__le32 OEM;
};

struct aac_supplement_adapter_info {
	u8 adapter_type_text[18];
	u8 pad[2];
	__le32 flash_memory_byte_size;
	__le32 flash_image_id;
	__le32 max_number_ports;
	__le32 version;
	__le32 feature_bits;
	u8 slot_number;
	u8 reserved_pad0[3];
	u8 build_date[12];
	__le32 current_number_ports;
	struct {
		u8 assembly_pn[8];
		u8 fru_pn[8];
		u8 battery_fru_pn[8];
		u8 ec_version_string[8];
		u8 tsid[12];
	} vpd_info;
	__le32 flash_firmware_revision;
	__le32 flash_firmware_build;
	__le32 raid_type_morph_options;
	__le32 flash_firmware_boot_revision;
	__le32 flash_firmware_boot_build;
	u8 mfg_pcba_serial_no[12];
	u8 mfg_wwn_name[8];
	__le32 supported_options2;
	__le32 struct_expansion;
	__le32 feature_bits3;
	__le32 supported_performance_modes;
	u8 host_bus_type;
	u8 host_bus_width;
	u16 host_bus_speed;
	u8 max_rrc_drives;
	u8 max_disk_xtasks;
	u8 cpld_ver_loaded;
	u8 cpld_ver_in_flash;
	__le64 max_rrc_capacity;
	__le32 compiled_max_hist_log_level;
	u8 custom_board_name[12];
	u16 supported_cntlr_mode;
	u16 reserved_for_future16;
	__le32 supported_options3;
	__le16 virt_device_bus;
	__le16 virt_device_target;
	__le16 virt_device_lun;
	__le16 unused;
	__le32 reserved_for_future_growth[68];
};

struct aac_msix_ctx {
	int vector_no;
	struct aac_dev *dev;
};

struct aac_hba_map_info {
	__le32 rmw_nexus;
	u8 devtype;
	s8 reset_state;
	u16 qd_limit;
	u32 scan_counter;
	struct aac_ciss_identify_pd *safw_identify_resp;
};

struct aac_queue_block;

struct fsa_dev_info;

struct sa_registers;

struct rx_registers;

struct rkt_registers;

struct src_registers;

struct rx_inbound;

struct aac_dev {
	struct list_head entry;
	const char *name;
	int id;
	unsigned int max_fib_size;
	unsigned int sg_tablesize;
	unsigned int max_num_aif;
	unsigned int max_cmd_size;
	dma_addr_t hw_fib_pa;
	struct hw_fib *hw_fib_va;
	struct hw_fib *aif_base_va;
	struct fib *fibs;
	struct fib *free_fib;
	spinlock_t fib_lock;
	struct mutex ioctl_mutex;
	struct mutex scan_mutex;
	struct aac_queue_block *queues;
	struct list_head fib_list;
	struct adapter_ops a_ops;
	long unsigned int fsrev;
	resource_size_t base_start;
	resource_size_t dbg_base;
	resource_size_t base_size;
	resource_size_t dbg_size;
	union aac_init *init;
	dma_addr_t init_pa;
	__le32 *host_rrq;
	dma_addr_t host_rrq_pa;
	u32 host_rrq_idx[32];
	atomic_t rrq_outstanding[32];
	u32 fibs_pushed_no;
	struct pci_dev *pdev;
	void *printfbuf;
	void *comm_addr;
	dma_addr_t comm_phys;
	size_t comm_size;
	struct Scsi_Host *scsi_host_ptr;
	int maximum_num_containers;
	int maximum_num_physicals;
	int maximum_num_channels;
	struct fsa_dev_info *fsa_dev;
	struct task_struct *thread;
	struct delayed_work safw_rescan_work;
	struct delayed_work src_reinit_aif_worker;
	int cardtype;
	spinlock_t iq_lock;
	union {
		struct sa_registers *sa;
		struct rx_registers *rx;
		struct rkt_registers *rkt;
		struct {
			struct src_registers *bar0;
			char *bar1;
		} src;
	} regs;
	volatile void *base;
	volatile void *dbg_base_mapped;
	volatile struct rx_inbound *IndexRegs;
	u32 OIMR;
	u32 aif_thread;
	struct aac_adapter_info adapter_info;
	struct aac_supplement_adapter_info supplement_adapter_info;
	u8 nondasd_support;
	u8 jbod;
	u8 cache_protected;
	u8 dac_support;
	u8 needs_dac;
	u8 raid_scsi_mode;
	u8 comm_interface;
	u8 raw_io_interface;
	u8 raw_io_64;
	u8 printf_enabled;
	u8 in_reset;
	u8 in_soft_reset;
	u8 msi;
	u8 sa_firmware;
	int management_fib_count;
	spinlock_t manage_lock;
	spinlock_t sync_lock;
	int sync_mode;
	struct fib *sync_fib;
	struct list_head sync_fib_list;
	u32 doorbell_mask;
	u32 max_msix;
	u32 vector_cap;
	int msi_enabled;
	atomic_t msix_counter;
	u32 scan_counter;
	struct msix_entry msixentry[32];
	struct aac_msix_ctx aac_msix[32];
	struct aac_hba_map_info hba_map[1280];
	struct aac_ciss_phys_luns_resp *safw_phys_luns;
	u8 adapter_shutdown;
	u32 handle_pci_error;
	bool init_reset;
	u8 soft_reset_support;
};

typedef void (*fib_callback)(void *, struct fib *);

struct fib {
	void *next;
	s16 type;
	s16 size;
	struct aac_dev *dev;
	struct completion event_wait;
	spinlock_t event_lock;
	u32 done;
	fib_callback callback;
	void *callback_data;
	u32 flags;
	struct list_head fiblink;
	void *data;
	u32 vector_no;
	struct hw_fib *hw_fib_va;
	dma_addr_t hw_fib_pa;
	dma_addr_t hw_sgl_pa;
	dma_addr_t hw_error_pa;
	u32 hbacmd_size;
};

struct aac_driver_ident {
	int (*init)(struct aac_dev *);
	char *name;
	char *vname;
	char *model;
	u16 channels;
	int quirks;
};

struct aac_queue {
	u64 logical;
	struct aac_entry *base;
	struct aac_qhdr headers;
	u32 entries;
	wait_queue_head_t qfull;
	wait_queue_head_t cmdready;
	spinlock_t *lock;
	spinlock_t lockdata;
	struct list_head cmdq;
	atomic_t numpending;
	struct aac_dev *dev;
};

struct aac_queue_block {
	struct aac_queue queue[8];
};

struct sa_drawbridge_CSR {
	__le32 reserved[10];
	u8 LUT_Offset;
	u8 reserved1[3];
	__le32 LUT_Data;
	__le32 reserved2[26];
	__le16 PRICLEARIRQ;
	__le16 SECCLEARIRQ;
	__le16 PRISETIRQ;
	__le16 SECSETIRQ;
	__le16 PRICLEARIRQMASK;
	__le16 SECCLEARIRQMASK;
	__le16 PRISETIRQMASK;
	__le16 SECSETIRQMASK;
	__le32 MAILBOX0;
	__le32 MAILBOX1;
	__le32 MAILBOX2;
	__le32 MAILBOX3;
	__le32 MAILBOX4;
	__le32 MAILBOX5;
	__le32 MAILBOX6;
	__le32 MAILBOX7;
	__le32 ROM_Setup_Data;
	__le32 ROM_Control_Addr;
	__le32 reserved3[12];
	__le32 LUT[64];
};

struct sa_registers {
	struct sa_drawbridge_CSR SaDbCSR;
};

struct rx_mu_registers {
	__le32 ARSR;
	__le32 reserved0;
	__le32 AWR;
	__le32 reserved1;
	__le32 IMRx[2];
	__le32 OMRx[2];
	__le32 IDR;
	__le32 IISR;
	__le32 IIMR;
	__le32 ODR;
	__le32 OISR;
	__le32 OIMR;
	__le32 reserved2;
	__le32 reserved3;
	__le32 InboundQueue;
	__le32 OutboundQueue;
};

struct rx_inbound {
	__le32 Mailbox[8];
};

struct rx_registers {
	struct rx_mu_registers MUnit;
	__le32 reserved1[2];
	struct rx_inbound IndexRegs;
};

struct rkt_registers {
	struct rx_mu_registers MUnit;
	__le32 reserved1[1006];
	struct rx_inbound IndexRegs;
};

struct src_mu_registers {
	__le32 reserved0[6];
	__le32 IOAR[2];
	__le32 IDR;
	__le32 IISR;
	__le32 reserved1[3];
	__le32 OIMR;
	__le32 reserved2[25];
	__le32 ODR_R;
	__le32 ODR_C;
	__le32 reserved3[3];
	__le32 SCR0;
	__le32 reserved4[2];
	__le32 OMR;
	__le32 IQ_L;
	__le32 IQ_H;
	__le32 ODR_MSI;
	__le32 reserved5;
	__le32 IQN_L;
	__le32 IQN_H;
};

struct src_registers {
	struct src_mu_registers MUnit;
	union {
		struct {
			__le32 reserved1[130786];
			struct rx_inbound IndexRegs;
		} tupelo;
		struct {
			__le32 reserved1[970];
			struct rx_inbound IndexRegs;
		} denali;
	} u;
};

struct sense_data {
	u8 error_code;
	u8 valid: 1;
	u8 segment_number;
	u8 sense_key: 4;
	u8 reserved: 1;
	u8 ILI: 1;
	u8 EOM: 1;
	u8 filemark: 1;
	u8 information[4];
	u8 add_sense_len;
	u8 cmnd_info[4];
	u8 ASC;
	u8 ASCQ;
	u8 FRUC;
	u8 bit_ptr: 3;
	u8 BPV: 1;
	u8 reserved2: 2;
	u8 CD: 1;
	u8 SKSV: 1;
	u8 field_ptr[2];
};

struct fsa_dev_info {
	u64 last;
	u64 size;
	u32 type;
	u32 config_waiting_on;
	long unsigned int config_waiting_stamp;
	u16 queue_depth;
	u8 config_needed;
	u8 valid;
	u8 ro;
	u8 locked;
	u8 deleted;
	char devname[8];
	struct sense_data sense_data;
	u32 block_size;
	u8 identifier[16];
};

struct fib_ioctl {
	u32 fibctx;
	s32 wait;
	char *fib;
};

struct fib_count_data {
	int mlcnt;
	int llcnt;
	int ehcnt;
	int fwcnt;
	int krlcnt;
};

enum {
	HBA_RESP_STAT_IO_ERROR = 1,
	HBA_RESP_STAT_IO_ABORTED = 2,
	HBA_RESP_STAT_NO_PATH_TO_DEVICE = 3,
	HBA_RESP_STAT_INVALID_DEVICE = 4,
	HBA_RESP_STAT_HBAMODE_DISABLED = 14,
	HBA_RESP_STAT_UNDERRUN = 81,
	HBA_RESP_STAT_OVERRUN = 117,
};

struct sgentry {
	__le32 addr;
	__le32 count;
};

struct sgentry64 {
	__le32 addr[2];
	__le32 count;
};

struct sgentryraw {
	__le32 next;
	__le32 prev;
	__le32 addr[2];
	__le32 count;
	__le32 flags;
};

struct sge_ieee1212 {
	u32 addrLow;
	u32 addrHigh;
	u32 length;
	u32 flags;
};

struct sgmap {
	__le32 count;
	struct sgentry sg[1];
};

struct sgmap64 {
	__le32 count;
	struct sgentry64 sg[1];
};

struct sgmapraw {
	__le32 count;
	struct sgentryraw sg[1];
};

struct creation_info {
	u8 buildnum;
	u8 usec;
	u8 via;
	u8 year;
	__le32 date;
	__le32 serial[2];
};

struct aac_bus_info {
	__le32 Command;
	__le32 ObjType;
	__le32 MethodId;
	__le32 ObjectId;
	__le32 CtlCmd;
};

struct aac_bus_info_response {
	__le32 Status;
	__le32 ObjType;
	__le32 MethodId;
	__le32 ObjectId;
	__le32 CtlCmd;
	__le32 ProbeComplete;
	__le32 BusCount;
	__le32 TargetsPerBus;
	u8 InitiatorBusId[10];
	u8 BusValid[10];
};

struct aac_read {
	__le32 command;
	__le32 cid;
	__le32 block;
	__le32 count;
	struct sgmap sg;
};

struct aac_read64 {
	__le32 command;
	__le16 cid;
	__le16 sector_count;
	__le32 block;
	__le16 pad;
	__le16 flags;
	struct sgmap64 sg;
};

struct aac_read_reply {
	__le32 status;
	__le32 count;
};

struct aac_write {
	__le32 command;
	__le32 cid;
	__le32 block;
	__le32 count;
	__le32 stable;
	struct sgmap sg;
};

struct aac_write64 {
	__le32 command;
	__le16 cid;
	__le16 sector_count;
	__le32 block;
	__le16 pad;
	__le16 flags;
	struct sgmap64 sg;
};

struct aac_raw_io {
	__le32 block[2];
	__le32 count;
	__le16 cid;
	__le16 flags;
	__le16 bpTotal;
	__le16 bpComplete;
	struct sgmapraw sg;
};

struct aac_raw_io2 {
	__le32 blockLow;
	__le32 blockHigh;
	__le32 byteCount;
	__le16 cid;
	__le16 flags;
	__le32 sgeFirstSize;
	__le32 sgeNominalSize;
	u8 sgeCnt;
	u8 bpTotal;
	u8 bpComplete;
	u8 sgeFirstIndex;
	u8 unused[4];
	struct sge_ieee1212 sge[1];
};

struct aac_synchronize {
	__le32 command;
	__le32 type;
	__le32 cid;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 count;
};

struct aac_synchronize_reply {
	__le32 dummy0;
	__le32 dummy1;
	__le32 status;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	u8 data[16];
};

struct aac_power_management {
	__le32 command;
	__le32 type;
	__le32 sub;
	__le32 cid;
	__le32 parm;
};

struct aac_srb {
	__le32 function;
	__le32 channel;
	__le32 id;
	__le32 lun;
	__le32 timeout;
	__le32 flags;
	__le32 count;
	__le32 retry_limit;
	__le32 cdb_size;
	u8 cdb[16];
	struct sgmap sg;
};

struct aac_srb_reply {
	__le32 status;
	__le32 srb_status;
	__le32 scsi_status;
	__le32 data_xfer_length;
	__le32 sense_data_size;
	u8 sense_data[30];
};

struct aac_srb_unit {
	struct aac_srb srb;
	struct aac_srb_reply srb_reply;
};

struct aac_fsinfo {
	__le32 fsTotalSize;
	__le32 fsBlockSize;
	__le32 fsFragSize;
	__le32 fsMaxExtendSize;
	__le32 fsSpaceUnits;
	__le32 fsMaxNumFiles;
	__le32 fsNumFreeFiles;
	__le32 fsInodeDensity;
};

struct aac_blockdevinfo {
	__le32 block_size;
	__le32 logical_phys_map;
	u8 identifier[16];
};

union aac_contentinfo {
	struct aac_fsinfo filesys;
	struct aac_blockdevinfo bdevinfo;
};

struct aac_get_config_status {
	__le32 command;
	__le32 type;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	__le32 count;
};

struct aac_get_config_status_resp {
	__le32 response;
	__le32 dummy0;
	__le32 status;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	struct {
		__le32 action;
		__le16 flags;
		__le16 count;
	} data;
};

struct aac_commit_config {
	__le32 command;
	__le32 type;
};

struct aac_get_container_count {
	__le32 command;
	__le32 type;
};

struct aac_get_container_count_resp {
	__le32 response;
	__le32 dummy0;
	__le32 MaxContainers;
	__le32 ContainerSwitchEntries;
	__le32 MaxPartitions;
	__le32 MaxSimpleVolumes;
};

struct aac_mntent {
	__le32 oid;
	u8 name[16];
	struct creation_info create_info;
	__le32 capacity;
	__le32 vol;
	__le32 obj;
	__le32 state;
	union aac_contentinfo fileinfo;
	__le32 altoid;
	__le32 capacityhigh;
};

struct aac_query_mount {
	__le32 command;
	__le32 type;
	__le32 count;
};

struct aac_mount {
	__le32 status;
	__le32 type;
	__le32 count;
	struct aac_mntent mnt[1];
};

struct aac_get_name {
	__le32 command;
	__le32 type;
	__le32 cid;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 count;
};

struct aac_get_name_resp {
	__le32 dummy0;
	__le32 dummy1;
	__le32 status;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	u8 data[17];
};

struct aac_get_serial {
	__le32 command;
	__le32 type;
	__le32 cid;
};

struct aac_get_serial_resp {
	__le32 dummy0;
	__le32 dummy1;
	__le32 status;
	__le32 uid;
};

struct aac_query_disk {
	s32 cnum;
	s32 bus;
	s32 id;
	s32 lun;
	u32 valid;
	u32 locked;
	u32 deleted;
	s32 instance;
	s8 name[10];
	u32 unmapped;
};

struct aac_delete_disk {
	u32 disknum;
	u32 cnum;
};

typedef struct {
	struct {
		u8 data_length;
		u8 med_type;
		u8 dev_par;
		u8 bd_length;
	} hd;
	struct {
		u8 dens_code;
		u8 block_count[3];
		u8 reserved;
		u8 block_length[3];
	} bd;
	u8 mpc_buf[3];
} aac_modep_data;

typedef struct {
	struct {
		u8 data_length[2];
		u8 med_type;
		u8 dev_par;
		u8 rsrvd[2];
		u8 bd_length[2];
	} hd;
	struct {
		u8 dens_code;
		u8 block_count[3];
		u8 reserved;
		u8 block_length[3];
	} bd;
	u8 mpc_buf[3];
} aac_modep10_data;

struct inquiry_data {
	u8 inqd_pdt;
	u8 inqd_dtq;
	u8 inqd_ver;
	u8 inqd_rdf;
	u8 inqd_len;
	u8 inqd_pad1[2];
	u8 inqd_pad2;
	u8 inqd_vid[8];
	u8 inqd_pid[16];
	u8 inqd_prl[4];
};

struct tvpd_id_descriptor_type_1 {
	u8 codeset: 4;
	u8 reserved: 4;
	u8 identifiertype: 4;
	u8 reserved2: 4;
	u8 reserved3;
	u8 identifierlength;
	u8 venid[8];
	u8 productid[16];
	u8 serialnumber[8];
};

struct teu64id {
	u32 Serial;
	u8 reserved;
	u8 venid[3];
};

struct tvpd_id_descriptor_type_2 {
	u8 codeset: 4;
	u8 reserved: 4;
	u8 identifiertype: 4;
	u8 reserved2: 4;
	u8 reserved3;
	u8 identifierlength;
	struct teu64id eu64id;
};

struct tvpd_id_descriptor_type_3 {
	u8 codeset: 4;
	u8 reserved: 4;
	u8 identifiertype: 4;
	u8 reserved2: 4;
	u8 reserved3;
	u8 identifierlength;
	u8 Identifier[16];
};

struct tvpd_page83 {
	u8 DeviceType: 5;
	u8 DeviceTypeQualifier: 3;
	u8 PageCode;
	u8 reserved;
	u8 PageLength;
	struct tvpd_id_descriptor_type_1 type1;
	struct tvpd_id_descriptor_type_2 type2;
	struct tvpd_id_descriptor_type_3 type3;
};

struct scsi_inq {
	char vid[8];
	char pid[16];
	char prl[4];
};

struct user_sgentry {
	u32 addr;
	u32 count;
};

struct user_sgentry64 {
	u32 addr[2];
	u32 count;
};

struct user_sgmap {
	u32 count;
	struct user_sgentry sg[1];
};

struct user_sgmap64 {
	u32 count;
	struct user_sgentry64 sg[1];
};

struct aac_fib_context {
	s16 type;
	s16 size;
	u32 unique;
	ulong jiffies;
	struct list_head next;
	struct completion completion;
	int wait;
	long unsigned int count;
	struct list_head fib_list;
};

struct user_aac_srb {
	u32 function;
	u32 channel;
	u32 id;
	u32 lun;
	u32 timeout;
	u32 flags;
	u32 count;
	u32 retry_limit;
	u32 cdb_size;
	u8 cdb[16];
	struct user_sgmap sg;
};

struct revision {
	u32 compat;
	__le32 version;
	__le32 build;
};

struct aac_hba_info {
	u8 driver_name[50];
	u8 adapter_number;
	u8 system_io_bus_number;
	u8 device_number;
	u32 function_number;
	u32 vendor_id;
	u32 device_id;
	u32 sub_vendor_id;
	u32 sub_system_id;
	u32 mapped_base_address_size;
	u32 base_physical_address_high_part;
	u32 base_physical_address_low_part;
	u32 max_command_size;
	u32 max_fib_size;
	u32 max_scatter_gather_from_os;
	u32 max_scatter_gather_to_fw;
	u32 max_outstanding_fibs;
	u32 queue_start_threshold;
	u32 queue_dump_threshold;
	u32 max_io_size_queued;
	u32 outstanding_io;
	u32 firmware_build_number;
	u32 bios_build_number;
	u32 driver_build_number;
	u32 serial_number_high_part;
	u32 serial_number_low_part;
	u32 supported_options;
	u32 feature_bits;
	u32 currentnumber_ports;
	u8 new_comm_interface: 1;
	u8 new_commands_supported: 1;
	u8 disable_passthrough: 1;
	u8 expose_non_dasd: 1;
	u8 queue_allowed: 1;
	u8 bled_check_enabled: 1;
	u8 reserved1: 1;
	u8 reserted2: 1;
	u32 reserved3[10];
};

struct aac_pci_info {
	u32 bus;
	u32 slot;
};

struct aac_reset_iop {
	u8 reset_type;
};

enum aac_queue_types {
	HostNormCmdQueue = 0,
	HostHighCmdQueue = 1,
	AdapNormCmdQueue = 2,
	AdapHighCmdQueue = 3,
	HostNormRespQueue = 4,
	HostHighRespQueue = 5,
	AdapNormRespQueue = 6,
	AdapHighRespQueue = 7,
};

struct aac_close {
	__le32 command;
	__le32 cid;
};

struct aac_common {
	u32 irq_mod;
	u32 peak_fibs;
	u32 zero_fibs;
	u32 fib_timeouts;
};

enum aac_log_level {
	LOG_AAC_INIT = 10,
	LOG_AAC_INFORMATIONAL = 20,
	LOG_AAC_WARNING = 30,
	LOG_AAC_LOW_ERROR = 40,
	LOG_AAC_MEDIUM_ERROR = 50,
	LOG_AAC_HIGH_ERROR = 60,
	LOG_AAC_PANIC = 70,
	LOG_AAC_DEBUG = 80,
	LOG_AAC_WINDBG_PRINT = 90,
};

struct aac_pause {
	__le32 command;
	__le32 type;
	__le32 timeout;
	__le32 min;
	__le32 noRescan;
	__le32 parm3;
	__le32 parm4;
	__le32 count;
};

struct aac_aifcmd {
	__le32 command;
	__le32 seqnum;
	u8 data[1];
};

enum {
	NOTHING = 0,
	DELETE = 1,
	ADD = 2,
	CHANGE = 3,
};

struct POSTSTATUS {
	__le32 Post_Command;
	__le32 Post_Address;
};

typedef u32 u_int32_t;

struct aac_fib_xporthdr {
	__le64 HostAddress;
	__le32 Size;
	__le32 Handle;
	__le64 Reserved[2];
};

struct ssp_frame_hdr {
	u8 frame_type;
	u8 hashed_dest_addr[3];
	u8 _r_a;
	u8 hashed_src_addr[3];
	__be16 _r_b;
	u8 changing_data_ptr: 1;
	u8 retransmit: 1;
	u8 retry_data_frames: 1;
	u8 _r_c: 5;
	u8 num_fill_bytes: 2;
	u8 _r_d: 6;
	u32 _r_e;
	__be16 tag;
	__be16 tptt;
	__be32 data_offs;
};

struct ssp_command_iu {
	u8 lun[8];
	u8 _r_a;
	union {
		struct {
			u8 attr: 3;
			u8 prio: 4;
			u8 efb: 1;
		};
		u8 efb_prio_attr;
	};
	u8 _r_b;
	u8 _r_c: 2;
	u8 add_cdb_len: 6;
	u8 cdb[16];
	u8 add_cdb[0];
};

struct ssp_tmf_iu {
	u8 lun[8];
	u16 _r_a;
	u8 tmf;
	u8 _r_b;
	__be16 tag;
	u8 _r_c[14];
};

struct sg_el {
	__le64 bus_addr;
	__le32 size;
	__le16 _r;
	u8 next_sg_offs;
	u8 flags;
};

struct scb_header {
	__le64 next_scb;
	__le16 index;
	u8 opcode;
} __attribute__((packed));

struct initiate_ssp_task {
	u8 proto_conn_rate;
	__le32 total_xfer_len;
	struct ssp_frame_hdr ssp_frame;
	struct ssp_command_iu ssp_cmd;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 data_dir;
	u8 _r_a;
	u8 retry_count;
	u8 _r_b[5];
	struct sg_el sg_element[3];
} __attribute__((packed));

struct initiate_ata_task {
	u8 proto_conn_rate;
	__le32 total_xfer_len;
	struct host_to_dev_fis fis;
	__le32 data_offs;
	u8 atapi_packet[16];
	u8 _r_a[12];
	__le16 sister_scb;
	__le16 conn_handle;
	u8 ata_flags;
	u8 _r_b;
	u8 retry_count;
	u8 _r_c;
	u8 flags;
	u8 _r_d[3];
	struct sg_el sg_element[3];
} __attribute__((packed));

struct initiate_smp_task {
	u8 proto_conn_rate;
	u8 _r_a[40];
	struct sg_el smp_req;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 _r_c[8];
	struct sg_el smp_resp;
	u8 _r_d[32];
} __attribute__((packed));

struct control_phy {
	u8 phy_id;
	u8 sub_func;
	u8 func_mask;
	u8 speed_mask;
	u8 hot_plug_delay;
	u8 port_type;
	u8 flags;
	__le32 timeout_override;
	u8 link_reset_retries;
	u8 _r_a[47];
	__le16 conn_handle;
	u8 _r_b[56];
} __attribute__((packed));

struct control_ata_dev {
	u8 proto_conn_rate;
	__le32 _r_a;
	struct host_to_dev_fis fis;
	u8 _r_b[32];
	__le16 sister_scb;
	__le16 conn_handle;
	u8 ata_flags;
	u8 _r_c[55];
} __attribute__((packed));

struct empty_scb {
	u8 num_valid;
	__le32 _r_a;
	struct sg_el eb[7];
} __attribute__((packed));

struct initiate_link_adm {
	u8 phy_id;
	u8 sub_func;
	u8 _r_a[57];
	__le16 conn_handle;
	u8 _r_b[56];
} __attribute__((packed));

struct copy_memory {
	u8 _r_a;
	__le16 xfer_len;
	__le16 _r_b;
	__le64 src_busaddr;
	u8 src_ds;
	u8 _r_c[45];
	__le16 conn_handle;
	__le64 _r_d;
	__le64 dest_busaddr;
	u8 dest_ds;
	u8 _r_e[39];
} __attribute__((packed));

struct abort_task {
	u8 proto_conn_rate;
	__le32 _r_a;
	struct ssp_frame_hdr ssp_frame;
	struct ssp_tmf_iu ssp_task;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 flags;
	u8 _r_b;
	u8 retry_count;
	u8 _r_c[5];
	__le16 index;
	__le16 itnl_to;
	u8 _r_d[44];
} __attribute__((packed));

struct clear_nexus {
	u8 nexus;
	__le32 _r_a;
	u8 flags;
	u8 _r_b[3];
	u8 conn_mask;
	u8 _r_c[19];
	struct ssp_tmf_iu ssp_task;
	__le16 _r_d;
	__le16 conn_handle;
	__le64 _r_e;
	__le16 index;
	__le16 context;
	u8 _r_f[44];
} __attribute__((packed));

struct initiate_ssp_tmf {
	u8 proto_conn_rate;
	__le32 _r_a;
	struct ssp_frame_hdr ssp_frame;
	struct ssp_tmf_iu ssp_task;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 flags;
	u8 _r_b;
	u8 retry_count;
	u8 _r_c[5];
	__le16 index;
	__le16 itnl_to;
	u8 _r_d[44];
} __attribute__((packed));

struct scb___3 {
	struct scb_header header;
	union {
		struct initiate_ssp_task ssp_task;
		struct initiate_ata_task ata_task;
		struct initiate_smp_task smp_task;
		struct control_phy control_phy;
		struct control_ata_dev control_ata_dev;
		struct empty_scb escb;
		struct initiate_link_adm link_adm;
		struct copy_memory cp_mem;
		struct abort_task abort_task;
		struct clear_nexus clear_nexus;
		struct initiate_ssp_tmf ssp_tmf;
	};
} __attribute__((packed));

struct done_list_struct {
	__le16 index;
	u8 opcode;
	u8 status_block[4];
	u8 toggle;
};

struct asd_phy_desc;

struct asd_dma_tok;

struct asd_port;

struct asd_phy {
	struct asd_sas_phy sas_phy;
	struct asd_phy_desc *phy_desc;
	struct sas_identify_frame *identify_frame;
	struct asd_dma_tok *id_frm_tok;
	struct asd_port *asd_port;
	u8 frame_rcvd[1068];
};

struct asd_phy_desc {
	u8 sas_addr[8];
	u8 max_sas_lrate;
	u8 min_sas_lrate;
	u8 max_sata_lrate;
	u8 min_sata_lrate;
	u8 flags;
	u8 phy_control_0;
	u8 phy_control_1;
	u8 phy_control_2;
	u8 phy_control_3;
};

struct asd_dma_tok {
	void *vaddr;
	dma_addr_t dma_handle;
	size_t size;
};

struct asd_port {
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	u32 phy_mask;
	int num_phys;
};

struct asd_ha_addrspace {
	void *addr;
	long unsigned int start;
	long unsigned int len;
	long unsigned int flags;
	u32 swa_base;
	u32 swb_base;
	u32 swc_base;
};

struct bios_struct {
	int present;
	u8 maj;
	u8 min;
	u32 bld;
};

struct unit_element_struct {
	u16 num;
	u16 size;
	void *area;
};

struct flash_struct {
	u32 bar;
	int present;
	int wide;
	u8 manuf;
	u8 dev_id;
	u8 sec_prot;
	u8 method;
	u32 dir_offs;
};

struct hw_profile {
	struct bios_struct bios;
	struct unit_element_struct ue;
	struct flash_struct flash;
	u8 sas_addr[8];
	char pcba_sn[13];
	u8 enabled_phys;
	struct asd_phy_desc phy_desc[8];
	u32 max_scbs;
	struct asd_dma_tok *scb_ext;
	u32 max_ddbs;
	struct asd_dma_tok *ddb_ext;
	spinlock_t ddb_lock;
	void *ddb_bitmap;
	int num_phys;
	int max_phys;
	unsigned int addr_range;
	unsigned int port_name_base;
	unsigned int dev_name_base;
	unsigned int sata_name_base;
};

struct asd_ha_struct;

struct asd_ascb {
	struct list_head list;
	struct asd_ha_struct *ha;
	struct scb___3 *scb;
	struct asd_dma_tok dma_scb;
	struct asd_dma_tok *sg_arr;
	void (*tasklet_complete)(struct asd_ascb *, struct done_list_struct *);
	u8 uldd_timer: 1;
	struct timer_list timer;
	struct completion *completion;
	u8 tag_valid: 1;
	__be16 tag;
	int edb_index;
	int tc_index;
	void *uldd_task;
};

struct asd_seq_data {
	spinlock_t pend_q_lock;
	u16 scbpro;
	int pending;
	struct list_head pend_q;
	int can_queue;
	struct asd_dma_tok next_scb;
	spinlock_t tc_index_lock;
	void **tc_index_array;
	void *tc_index_bitmap;
	int tc_index_bitmap_bits;
	struct tasklet_struct dl_tasklet;
	struct done_list_struct *dl;
	struct asd_dma_tok *actual_dl;
	int dl_toggle;
	int dl_next;
	int num_edbs;
	struct asd_dma_tok **edb_arr;
	int num_escbs;
	struct asd_ascb **escb_arr;
};

struct asd_ha_struct {
	struct pci_dev *pcidev;
	const char *name;
	struct sas_ha_struct sas_ha;
	u8 revision_id;
	int iospace;
	spinlock_t iolock;
	struct asd_ha_addrspace io_handle[2];
	struct hw_profile hw_prof;
	struct asd_phy phys[8];
	spinlock_t asd_ports_lock;
	struct asd_port asd_ports[8];
	struct asd_sas_port ports[8];
	struct dma_pool___2 *scb_pool;
	struct asd_seq_data seq;
	u32 bios_status;
	const struct firmware *bios_image;
};

struct controller_id {
	u32 vendor;
	u32 device;
	u32 sub_vendor;
	u32 sub_device;
};

struct image_info {
	u32 ImageId;
	u32 ImageOffset;
	u32 ImageLength;
	u32 ImageChecksum;
	u32 ImageVersion;
};

struct bios_file_header {
	u8 signature[32];
	u32 checksum;
	u32 antidote;
	struct controller_id contrl_id;
	u32 filelen;
	u32 chunk_num;
	u32 total_chunks;
	u32 num_images;
	u32 build_num;
	struct image_info image_header;
};

struct flash_command {
	u8 command[8];
	int code;
};

struct error_bios {
	char *reason;
	int err_code;
};

struct asd_pcidev_struct {
	const char *name;
	int (*setup)(struct asd_ha_struct *);
};

enum {
	FLASH_METHOD_UNKNOWN = 0,
	FLASH_METHOD_A = 1,
	FLASH_METHOD_B = 2,
};

struct asd_ocm_dir_ent {
	u8 type;
	u8 offs[3];
	u8 _r1;
	u8 size[3];
};

struct asd_ocm_dir {
	char sig[2];
	u8 _r1[2];
	u8 major;
	u8 minor;
	u8 _r2;
	u8 num_de;
	struct asd_ocm_dir_ent entry[15];
};

struct asd_bios_chim_struct {
	char sig[4];
	u8 major;
	u8 minor;
	u8 bios_major;
	u8 bios_minor;
	__le32 bios_build;
	u8 flags;
	u8 pci_slot;
	__le16 ue_num;
	__le16 ue_size;
	u8 _r[14];
};

struct asd_flash_de {
	__le32 type;
	__le32 offs;
	__le32 pad_size;
	__le32 image_size;
	__le32 chksum;
	u8 _r[12];
	u8 version[32];
};

struct asd_flash_dir {
	u8 cookie[32];
	__le32 rev;
	__le32 chksum;
	__le32 chksum_antidote;
	__le32 bld;
	u8 bld_id[32];
	u8 ver_data[32];
	__le32 ae_mask;
	__le32 v_mask;
	__le32 oc_mask;
	u8 _r[20];
	struct asd_flash_de dir_entry[32];
};

struct asd_manuf_sec {
	char sig[2];
	u16 offs_next;
	u8 maj;
	u8 min;
	u16 chksum;
	u16 size;
	u8 _r[6];
	u8 sas_addr[8];
	u8 pcba_sn[12];
	u8 linked_list[0];
};

struct asd_manuf_phy_desc {
	u8 state;
	u8 phy_id;
	u16 _r;
	u8 phy_control_0;
	u8 phy_control_1;
	u8 phy_control_2;
	u8 phy_control_3;
};

struct asd_manuf_phy_param {
	char sig[2];
	u16 next;
	u8 maj;
	u8 min;
	u8 num_phy_desc;
	u8 phy_desc_size;
	u8 _r[3];
	u8 usage_model_id;
	u32 _r2;
	struct asd_manuf_phy_desc phy_desc[8];
};

struct asd_ms_sb_desc {
	u8 type;
	u8 node_desc_index;
	u8 conn_desc_index;
	u8 _recvd[0];
};

struct asd_ms_conn_desc {
	u8 type;
	u8 location;
	u8 num_sideband_desc;
	u8 size_sideband_desc;
	u32 _resvd;
	u8 name[16];
	struct asd_ms_sb_desc sb_desc[0];
};

struct asd_nd_phy_desc {
	u8 vp_attch_type;
	u8 attch_specific[0];
};

struct asd_ms_node_desc {
	u8 type;
	u8 num_phy_desc;
	u8 size_phy_desc;
	u8 _resvd;
	u8 name[16];
	struct asd_nd_phy_desc phy_desc[0];
};

struct asd_ms_conn_map {
	char sig[2];
	__le16 next;
	u8 maj;
	u8 min;
	__le16 cm_size;
	u8 num_conn;
	u8 conn_size;
	u8 num_nodes;
	u8 usage_model_id;
	u32 _resvd;
	struct asd_ms_conn_desc conn_desc[0];
	struct asd_ms_node_desc node_desc[0];
};

struct asd_ctrla_phy_entry {
	u8 sas_addr[8];
	u8 sas_link_rates;
	u8 flags;
	u8 sata_link_rates;
	u8 _r[5];
};

struct asd_ctrla_phy_settings {
	u8 id0;
	u8 _r;
	u16 next;
	u8 num_phys;
	u8 _r2[3];
	struct asd_ctrla_phy_entry phy_ent[8];
};

struct asd_ll_el {
	u8 id0;
	u8 id1;
	__le16 next;
	u8 something_here[0];
};

struct sequencer_file_header {
	u32 csum;
	u32 major;
	u32 minor;
	char version[16];
	u32 cseq_table_offset;
	u32 cseq_table_size;
	u32 lseq_table_offset;
	u32 lseq_table_size;
	u32 cseq_code_offset;
	u32 cseq_code_size;
	u32 lseq_code_offset;
	u32 lseq_code_size;
	u16 mode2_task;
	u16 cseq_idle_loop;
	u16 lseq_idle_loop;
} __attribute__((packed));

struct tasklet_completion_status {
	int dl_opcode;
	int tmf_state;
	u8 tag_valid: 1;
	__be16 tag;
};

enum clear_nexus_phase {
	NEXUS_PHASE_PRE = 0,
	NEXUS_PHASE_POST = 1,
	NEXUS_PHASE_RESUME = 2,
};

struct tc_resp_sb_struct {
	__le16 index_escb;
	u8 len_lsb;
	u8 flags;
};

struct ata_task_resp {
	u16 frame_len;
	u8 ending_fis[24];
};

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t log_drv;
	uint8_t sg_count;
	uint32_t lba;
	uint32_t sg_addr;
	uint16_t sector_count;
	uint8_t segment_4G;
	uint8_t enhanced_sg;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_IO_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint16_t reserved;
	uint32_t reserved2;
	uint32_t buffer_addr;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_LD_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reserved;
	uint8_t reserved2;
	uint32_t reserved3;
	uint32_t buffer_addr;
	uint32_t reserved4;
} IPS_IOCTL_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t channel;
	uint8_t reserved3;
	uint8_t reserved4;
	uint8_t reserved5;
	uint8_t reserved6;
	uint8_t reserved7;
	uint8_t reserved8;
	uint8_t reserved9;
	uint8_t reserved10;
	uint8_t reserved11;
	uint8_t reserved12;
	uint8_t reserved13;
	uint8_t reserved14;
	uint8_t adapter_flag;
} IPS_RESET_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint16_t reserved;
	uint32_t reserved2;
	uint32_t dcdb_address;
	uint16_t reserved3;
	uint8_t segment_4G;
	uint8_t enhanced_sg;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_DCDB_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t channel;
	uint8_t source_target;
	uint32_t reserved;
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_CS_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t log_drv;
	uint8_t control;
	uint32_t reserved;
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_US_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reserved;
	uint8_t state;
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t reserved4;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_FC_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reserved;
	uint8_t desc;
	uint32_t reserved2;
	uint32_t buffer_addr;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_STATUS_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t page;
	uint8_t write;
	uint32_t reserved;
	uint32_t buffer_addr;
	uint32_t reserved2;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_NVRAM_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint16_t reserved;
	uint32_t count;
	uint32_t buffer_addr;
	uint32_t reserved2;
} IPS_VERSION_INFO;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reset_count;
	uint8_t reset_type;
	uint8_t second;
	uint8_t minute;
	uint8_t hour;
	uint8_t day;
	uint8_t reserved1[4];
	uint8_t month;
	uint8_t yearH;
	uint8_t yearL;
	uint8_t reserved2;
} IPS_FFDC_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t type;
	uint8_t direction;
	uint32_t count;
	uint32_t buffer_addr;
	uint8_t total_packets;
	uint8_t packet_num;
	uint16_t reserved;
} IPS_FLASHFW_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t type;
	uint8_t direction;
	uint32_t count;
	uint32_t buffer_addr;
	uint32_t offset;
} IPS_FLASHBIOS_CMD;

typedef union {
	IPS_IO_CMD basic_io;
	IPS_LD_CMD logical_info;
	IPS_IOCTL_CMD ioctl_info;
	IPS_DCDB_CMD dcdb;
	IPS_CS_CMD config_sync;
	IPS_US_CMD unlock_stripe;
	IPS_FC_CMD flush_cache;
	IPS_STATUS_CMD status;
	IPS_NVRAM_CMD nvram;
	IPS_FFDC_CMD ffdc;
	IPS_FLASHFW_CMD flashfw;
	IPS_FLASHBIOS_CMD flashbios;
	IPS_VERSION_INFO version_info;
	IPS_RESET_CMD reset;
} IPS_HOST_COMMAND;

typedef struct {
	uint8_t logical_id;
	uint8_t reserved;
	uint8_t raid_level;
	uint8_t state;
	uint32_t sector_count;
} IPS_DRIVE_INFO;

typedef struct {
	uint8_t no_of_log_drive;
	uint8_t reserved[3];
	IPS_DRIVE_INFO drive_info[8];
} IPS_LD_INFO;

typedef struct {
	uint8_t device_address;
	uint8_t cmd_attribute;
	uint16_t transfer_length;
	uint32_t buffer_pointer;
	uint8_t cdb_length;
	uint8_t sense_length;
	uint8_t sg_count;
	uint8_t reserved;
	uint8_t scsi_cdb[12];
	uint8_t sense_info[64];
	uint8_t scsi_status;
	uint8_t reserved2[3];
} IPS_DCDB_TABLE;

typedef struct {
	uint8_t device_address;
	uint8_t cmd_attribute;
	uint8_t cdb_length;
	uint8_t reserved_for_LUN;
	uint32_t transfer_length;
	uint32_t buffer_pointer;
	uint16_t sg_count;
	uint8_t sense_length;
	uint8_t scsi_status;
	uint32_t reserved;
	uint8_t scsi_cdb[16];
	uint8_t sense_info[56];
} IPS_DCDB_TABLE_TAPE;

typedef union {
	struct {
		volatile uint8_t reserved;
		volatile uint8_t command_id;
		volatile uint8_t basic_status;
		volatile uint8_t extended_status;
	} fields;
	volatile uint32_t value;
} IPS_STATUS;

typedef union {
	struct {
		volatile uint8_t reserved;
		volatile uint8_t command_id;
		volatile uint8_t basic_status;
		volatile uint8_t extended_status;
	} fields;
	volatile uint32_t value;
} *PIPS_STATUS;

typedef struct {
	IPS_STATUS status[129];
	volatile PIPS_STATUS p_status_start;
	volatile PIPS_STATUS p_status_end;
	volatile PIPS_STATUS p_status_tail;
	volatile uint32_t hw_status_start;
	volatile uint32_t hw_status_tail;
} IPS_ADAPTER;

typedef struct {
	uint8_t ucLogDriveCount;
	uint8_t ucMiscFlag;
	uint8_t ucSLTFlag;
	uint8_t ucBSTFlag;
	uint8_t ucPwrChgCnt;
	uint8_t ucWrongAdrCnt;
	uint8_t ucUnidentCnt;
	uint8_t ucNVramDevChgCnt;
	uint8_t CodeBlkVersion[8];
	uint8_t BootBlkVersion[8];
	uint32_t ulDriveSize[8];
	uint8_t ucConcurrentCmdCount;
	uint8_t ucMaxPhysicalDevices;
	uint16_t usFlashRepgmCount;
	uint8_t ucDefunctDiskCount;
	uint8_t ucRebuildFlag;
	uint8_t ucOfflineLogDrvCount;
	uint8_t ucCriticalDrvCount;
	uint16_t usConfigUpdateCount;
	uint8_t ucBlkFlag;
	uint8_t reserved;
	uint16_t usAddrDeadDisk[64];
} IPS_ENQ;

typedef struct {
	uint8_t ucInitiator;
	uint8_t ucParameters;
	uint8_t ucMiscFlag;
	uint8_t ucState;
	uint32_t ulBlockCount;
	uint8_t ucDeviceId[28];
} IPS_DEVSTATE;

typedef struct {
	uint8_t ucChn;
	uint8_t ucTgt;
	uint16_t ucReserved;
	uint32_t ulStartSect;
	uint32_t ulNoOfSects;
} IPS_CHUNK;

typedef struct {
	uint16_t ucUserField;
	uint8_t ucState;
	uint8_t ucRaidCacheParam;
	uint8_t ucNoOfChunkUnits;
	uint8_t ucStripeSize;
	uint8_t ucParams;
	uint8_t ucReserved;
	uint32_t ulLogDrvSize;
	IPS_CHUNK chunk[16];
} IPS_LD;

typedef struct {
	uint8_t board_disc[8];
	uint8_t processor[8];
	uint8_t ucNoChanType;
	uint8_t ucNoHostIntType;
	uint8_t ucCompression;
	uint8_t ucNvramType;
	uint32_t ulNvramSize;
} IPS_HARDWARE;

typedef struct {
	uint8_t ucLogDriveCount;
	uint8_t ucDateD;
	uint8_t ucDateM;
	uint8_t ucDateY;
	uint8_t init_id[4];
	uint8_t host_id[12];
	uint8_t time_sign[8];
	uint32_t UserOpt;
	uint16_t user_field;
	uint8_t ucRebuildRate;
	uint8_t ucReserve;
	IPS_HARDWARE hardware_disc;
	IPS_LD logical_drive[8];
	IPS_DEVSTATE dev[64];
	uint8_t reserved[512];
} IPS_CONF;

typedef struct {
	uint32_t signature;
	uint8_t reserved1;
	uint8_t adapter_slot;
	uint16_t adapter_type;
	uint8_t ctrl_bios[8];
	uint8_t versioning;
	uint8_t version_mismatch;
	uint8_t reserved2;
	uint8_t operating_system;
	uint8_t driver_high[4];
	uint8_t driver_low[4];
	uint8_t BiosCompatibilityID[8];
	uint8_t ReservedForOS2[8];
	uint8_t bios_high[4];
	uint8_t bios_low[4];
	uint8_t adapter_order[16];
	uint8_t Filler[60];
} IPS_NVRAM_P5;

struct _IPS_SUBSYS {
	uint32_t param[128];
};

typedef struct _IPS_SUBSYS IPS_SUBSYS;

typedef struct {
	uint8_t DeviceType;
	uint8_t DeviceTypeQualifier;
	uint8_t Version;
	uint8_t ResponseDataFormat;
	uint8_t AdditionalLength;
	uint8_t Reserved;
	uint8_t Flags[2];
	uint8_t VendorId[8];
	uint8_t ProductId[16];
	uint8_t ProductRevisionLevel[4];
	uint8_t Reserved2;
} IPS_SCSI_INQ_DATA;

typedef struct {
	uint32_t lba;
	uint32_t len;
} IPS_SCSI_CAPACITY;

typedef struct {
	uint8_t ResponseCode;
	uint8_t SegmentNumber;
	uint8_t Flags;
	uint8_t Information[4];
	uint8_t AdditionalLength;
	uint8_t CommandSpecific[4];
	uint8_t AdditionalSenseCode;
	uint8_t AdditionalSenseCodeQual;
	uint8_t FRUCode;
	uint8_t SenseKeySpecific[3];
} IPS_SCSI_REQSEN;

typedef struct {
	uint8_t PageCode;
	uint8_t PageLength;
	uint16_t TracksPerZone;
	uint16_t AltSectorsPerZone;
	uint16_t AltTracksPerZone;
	uint16_t AltTracksPerVolume;
	uint16_t SectorsPerTrack;
	uint16_t BytesPerSector;
	uint16_t Interleave;
	uint16_t TrackSkew;
	uint16_t CylinderSkew;
	uint8_t flags;
	uint8_t reserved[3];
} IPS_SCSI_MODE_PAGE3;

typedef struct {
	uint8_t PageCode;
	uint8_t PageLength;
	uint16_t CylindersHigh;
	uint8_t CylindersLow;
	uint8_t Heads;
	uint16_t WritePrecompHigh;
	uint8_t WritePrecompLow;
	uint16_t ReducedWriteCurrentHigh;
	uint8_t ReducedWriteCurrentLow;
	uint16_t StepRate;
	uint16_t LandingZoneHigh;
	uint8_t LandingZoneLow;
	uint8_t flags;
	uint8_t RotationalOffset;
	uint8_t Reserved;
	uint16_t MediumRotationRate;
	uint8_t Reserved2[2];
} IPS_SCSI_MODE_PAGE4;

typedef struct {
	uint8_t PageCode;
	uint8_t PageLength;
	uint8_t flags;
	uint8_t RetentPrio;
	uint16_t DisPrefetchLen;
	uint16_t MinPrefetchLen;
	uint16_t MaxPrefetchLen;
	uint16_t MaxPrefetchCeiling;
} IPS_SCSI_MODE_PAGE8;

typedef struct {
	uint32_t NumberOfBlocks;
	uint8_t DensityCode;
	uint16_t BlockLengthHigh;
	uint8_t BlockLengthLow;
} IPS_SCSI_MODE_PAGE_BLKDESC;

typedef struct {
	uint8_t DataLength;
	uint8_t MediumType;
	uint8_t Reserved;
	uint8_t BlockDescLength;
} IPS_SCSI_MODE_PAGE_HEADER;

typedef struct {
	IPS_SCSI_MODE_PAGE_HEADER hdr;
	IPS_SCSI_MODE_PAGE_BLKDESC blkdesc;
	union {
		IPS_SCSI_MODE_PAGE3 pg3;
		IPS_SCSI_MODE_PAGE4 pg4;
		IPS_SCSI_MODE_PAGE8 pg8;
	} pdata;
} IPS_SCSI_MODE_PAGE_DATA;

struct ips_sglist {
	uint32_t address;
	uint32_t length;
};

typedef struct ips_sglist IPS_STD_SG_LIST;

struct ips_enh_sglist {
	uint32_t address_lo;
	uint32_t address_hi;
	uint32_t length;
	uint32_t reserved;
};

typedef struct ips_enh_sglist IPS_ENH_SG_LIST;

typedef union {
	void *list;
	IPS_STD_SG_LIST *std_list;
	IPS_ENH_SG_LIST *enh_list;
} IPS_SG_LIST;

typedef struct {
	char *option_name;
	int *option_flag;
	int option_value;
} IPS_OPTION;

struct ips_stat {
	uint32_t residue_len;
	void *scb_addr;
	uint8_t padding[4];
};

typedef struct ips_stat ips_stat_t;

struct ips_scb;

struct ips_scb_queue {
	struct ips_scb *head;
	struct ips_scb *tail;
	int count;
};

struct ips_ha;

typedef struct ips_ha ips_ha_t;

typedef void (*ips_scb_callback)(ips_ha_t *, struct ips_scb *);

struct ips_scb {
	IPS_HOST_COMMAND cmd;
	IPS_DCDB_TABLE dcdb;
	uint8_t target_id;
	uint8_t bus;
	uint8_t lun;
	uint8_t cdb[12];
	uint32_t scb_busaddr;
	uint32_t old_data_busaddr;
	uint32_t timeout;
	uint8_t basic_status;
	uint8_t extended_status;
	uint8_t breakup;
	uint8_t sg_break;
	uint32_t data_len;
	uint32_t sg_len;
	uint32_t flags;
	uint32_t op_code;
	IPS_SG_LIST sg_list;
	struct scsi_cmnd *scsi_cmd;
	struct ips_scb *q_next;
	ips_scb_callback callback;
	uint32_t sg_busaddr;
	int sg_count;
	dma_addr_t data_busaddr;
};

typedef struct ips_scb_queue ips_scb_queue_t;

struct ips_wait_queue {
	struct scsi_cmnd *head;
	struct scsi_cmnd *tail;
	int count;
};

typedef struct ips_wait_queue ips_wait_queue_entry_t;

struct ips_copp_wait_item {
	struct scsi_cmnd *scsi_cmd;
	struct ips_copp_wait_item *next;
};

typedef struct ips_copp_wait_item ips_copp_wait_item_t;

struct ips_copp_queue {
	struct ips_copp_wait_item *head;
	struct ips_copp_wait_item *tail;
	int count;
};

typedef struct ips_copp_queue ips_copp_queue_t;

typedef struct {
	int (*reset)(struct ips_ha *);
	int (*issue)(struct ips_ha *, struct ips_scb *);
	int (*isinit)(struct ips_ha *);
	int (*isintr)(struct ips_ha *);
	int (*init)(struct ips_ha *);
	int (*erasebios)(struct ips_ha *);
	int (*programbios)(struct ips_ha *, char *, uint32_t, uint32_t);
	int (*verifybios)(struct ips_ha *, char *, uint32_t, uint32_t);
	void (*statinit)(struct ips_ha *);
	int (*intr)(struct ips_ha *);
	void (*enableint)(struct ips_ha *);
	uint32_t (*statupd)(struct ips_ha *);
} ips_hw_func_t;

struct ips_ha {
	uint8_t ha_id[5];
	uint32_t dcdb_active[4];
	uint32_t io_addr;
	uint8_t ntargets;
	uint8_t nbus;
	uint8_t nlun;
	uint16_t ad_type;
	uint16_t host_num;
	uint32_t max_xfer;
	uint32_t max_cmds;
	uint32_t num_ioctl;
	ips_stat_t sp;
	struct ips_scb *scbs;
	struct ips_scb *scb_freelist;
	ips_wait_queue_entry_t scb_waitlist;
	ips_copp_queue_t copp_waitlist;
	ips_scb_queue_t scb_activelist;
	IPS_IO_CMD *dummy;
	IPS_ADAPTER *adapt;
	IPS_LD_INFO *logical_drive_info;
	dma_addr_t logical_drive_info_dma_addr;
	IPS_ENQ *enq;
	IPS_CONF *conf;
	IPS_NVRAM_P5 *nvram;
	IPS_SUBSYS *subsys;
	char *ioctl_data;
	uint32_t ioctl_datasize;
	uint32_t cmd_in_progress;
	int flags;
	uint8_t waitflag;
	uint8_t active;
	int ioctl_reset;
	uint16_t reset_count;
	time64_t last_ffdc;
	uint8_t slot_num;
	int ioctl_len;
	dma_addr_t ioctl_busaddr;
	uint8_t bios_version[8];
	uint32_t mem_addr;
	uint32_t io_len;
	uint32_t mem_len;
	char *mem_ptr;
	char *ioremap_ptr;
	ips_hw_func_t func;
	struct pci_dev *pcidev;
	char *flash_data;
	int flash_len;
	u32 flash_datasize;
	dma_addr_t flash_busaddr;
	dma_addr_t enq_busaddr;
	uint8_t requires_esl;
};

typedef struct ips_scb ips_scb_t;

struct ips_scb_pt {
	IPS_HOST_COMMAND cmd;
	IPS_DCDB_TABLE dcdb;
	uint8_t target_id;
	uint8_t bus;
	uint8_t lun;
	uint8_t cdb[12];
	uint32_t scb_busaddr;
	uint32_t data_busaddr;
	uint32_t timeout;
	uint8_t basic_status;
	uint8_t extended_status;
	uint16_t breakup;
	uint32_t data_len;
	uint32_t sg_len;
	uint32_t flags;
	uint32_t op_code;
	IPS_SG_LIST *sg_list;
	struct scsi_cmnd *scsi_cmd;
	struct ips_scb *q_next;
	ips_scb_callback callback;
};

typedef struct ips_scb_pt ips_scb_pt_t;

typedef struct {
	uint8_t CoppID[4];
	uint32_t CoppCmd;
	uint32_t PtBuffer;
	uint8_t *CmdBuffer;
	uint32_t CmdBSize;
	ips_scb_pt_t CoppCP;
	uint32_t TimeOut;
	uint8_t BasicStatus;
	uint8_t ExtendedStatus;
	uint8_t AdapterType;
	uint8_t reserved;
} ips_passthru_t;

struct sym_chip {
	u_short device_id;
	u_short revision_id;
	char *name;
	u_char burst_max;
	u_char offset_max;
	u_char nr_divisor;
	u_char lp_probe_bit;
	u_int features;
};

struct sym_tblmove {
	u32 size;
	u32 addr;
};

struct sym_tblsel {
	u_char sel_scntl4;
	u_char sel_sxfer;
	u_char sel_id;
	u_char sel_scntl3;
};

struct sym_quehead {
	struct sym_quehead *flink;
	struct sym_quehead *blink;
};

typedef struct sym_quehead SYM_QUEHEAD;

struct sym_slcb {
	u_short reqtags;
	u_short scdev_depth;
};

struct sym_shcb {
	int unit;
	char inst_name[16];
	char chip_name[8];
	struct Scsi_Host *host;
	void *ioaddr;
	void *ramaddr;
	struct timer_list timer;
	u_long lasttime;
	u_long settle_time;
	u_char settle_time_valid;
};

struct sym_hcb;

struct sym_data {
	struct sym_hcb *ncb;
	struct completion *io_reset;
	struct pci_dev *pdev;
};

struct sym_actscr {
	u32 start;
	u32 restart;
};

struct sym_ccbh {
	struct sym_actscr go;
	u32 savep;
	u32 lastp;
	u8 status[4];
};

struct sym_tcbh {
	u32 luntbl_sa;
	u32 lun0_sa;
	u_char uval;
	u_char sval;
	u_char filler1;
	u_char wval;
};

struct sym_lcbh {
	u32 resel_sa;
	u32 itl_task_sa;
	u32 itlq_tbl_sa;
};

struct sym_trans {
	u8 period;
	u8 offset;
	unsigned int width: 1;
	unsigned int iu: 1;
	unsigned int dt: 1;
	unsigned int qas: 1;
	unsigned int check_nego: 1;
	unsigned int renego: 2;
};

struct sym_lcb;

struct sym_ccb;

struct sym_tcb {
	struct sym_tcbh head;
	u32 *luntbl;
	int nlcb;
	struct sym_lcb *lun0p;
	struct sym_lcb **lunmp;
	struct sym_trans tgoal;
	struct sym_trans tprint;
	struct sym_ccb *nego_cp;
	u_char to_reset;
	unsigned char usrflags;
	unsigned char usr_period;
	unsigned char usr_width;
	short unsigned int usrtags;
	struct scsi_target *starget;
};

typedef struct device *m_pool_ident_t;

struct sym_fwa_ba {
	u32 start;
	u32 getjob_begin;
	u32 getjob_end;
	u32 select;
	u32 wf_sel_done;
	u32 send_ident;
	u32 dispatch;
	u32 init;
	u32 clrack;
	u32 complete_error;
	u32 done;
	u32 done_end;
	u32 idle;
	u32 ungetjob;
	u32 reselect;
	u32 resel_tag;
	u32 resel_dsa;
	u32 resel_no_tag;
	u32 data_in;
	u32 data_in2;
	u32 data_out;
	u32 data_out2;
	u32 pm0_data;
	u32 pm1_data;
};

struct sym_fwb_ba {
	u32 no_data;
	u32 sel_for_abort;
	u32 sel_for_abort_1;
	u32 msg_bad;
	u32 msg_weird;
	u32 wdtr_resp;
	u32 send_wdtr;
	u32 sdtr_resp;
	u32 send_sdtr;
	u32 ppr_resp;
	u32 send_ppr;
	u32 nego_bad_phase;
	u32 ident_break;
	u32 ident_break_atn;
	u32 sdata_in;
	u32 resel_bad_lun;
	u32 bad_i_t_l;
	u32 bad_i_t_l_q;
	u32 wsr_ma_helper;
	u32 start64;
	u32 pm_handle;
};

struct sym_fwz_ba {
	u32 snooptest;
	u32 snoopend;
};

struct sym_fw;

struct sym_hcb {
	struct sym_ccbh ccb_head;
	struct sym_tcbh tcb_head;
	struct sym_lcbh lcb_head;
	struct sym_actscr idletask;
	struct sym_actscr notask;
	struct sym_actscr bad_itl;
	struct sym_actscr bad_itlq;
	u32 idletask_ba;
	u32 notask_ba;
	u32 bad_itl_ba;
	u32 bad_itlq_ba;
	u32 *badluntbl;
	u32 badlun_sa;
	u32 hcb_ba;
	u32 scr_ram_seg;
	u_char sv_scntl0;
	u_char sv_scntl3;
	u_char sv_dmode;
	u_char sv_dcntl;
	u_char sv_ctest3;
	u_char sv_ctest4;
	u_char sv_ctest5;
	u_char sv_gpcntl;
	u_char sv_stest2;
	u_char sv_stest4;
	u_char sv_scntl4;
	u_char sv_stest1;
	u_char rv_scntl0;
	u_char rv_scntl3;
	u_char rv_dmode;
	u_char rv_dcntl;
	u_char rv_ctest3;
	u_char rv_ctest4;
	u_char rv_ctest5;
	u_char rv_stest2;
	u_char rv_ccntl0;
	u_char rv_ccntl1;
	u_char rv_scntl4;
	struct sym_tcb target[16];
	u32 *targtbl;
	u32 targtbl_ba;
	m_pool_ident_t bus_dmat;
	struct sym_shcb s;
	u32 mmio_ba;
	u32 ram_ba;
	u_char *scripta0;
	u_char *scriptb0;
	u_char *scriptz0;
	u32 scripta_ba;
	u32 scriptb_ba;
	u32 scriptz_ba;
	u_short scripta_sz;
	u_short scriptb_sz;
	u_short scriptz_sz;
	struct sym_fwa_ba fwa_bas;
	struct sym_fwb_ba fwb_bas;
	struct sym_fwz_ba fwz_bas;
	void (*fw_setup)(struct sym_hcb *, struct sym_fw *);
	void (*fw_patch)(struct Scsi_Host *);
	char *fw_name;
	u_int features;
	u_char myaddr;
	u_char maxburst;
	u_char maxwide;
	u_char minsync;
	u_char maxsync;
	u_char maxoffs;
	u_char minsync_dt;
	u_char maxsync_dt;
	u_char maxoffs_dt;
	u_char multiplier;
	u_char clock_divn;
	u32 clock_khz;
	u32 pciclk_khz;
	volatile u32 *squeue;
	u32 squeue_ba;
	u_short squeueput;
	u_short actccbs;
	u_short dqueueget;
	volatile u32 *dqueue;
	u32 dqueue_ba;
	u_char msgout[8];
	u_char msgin[8];
	u32 lastmsg;
	u32 scratch;
	u_char usrflags;
	u_char scsi_mode;
	u_char verbose;
	struct sym_ccb **ccbh;
	SYM_QUEHEAD free_ccbq;
	SYM_QUEHEAD busy_ccbq;
	SYM_QUEHEAD comp_ccbq;
	u_char abrt_msg[4];
	struct sym_tblmove abrt_tbl;
	struct sym_tblsel abrt_sel;
	u_char istat_sem;
	u_char use_dac;
};

struct sym_fwa_ofs {
	u_short start;
	u_short getjob_begin;
	u_short getjob_end;
	u_short select;
	u_short wf_sel_done;
	u_short send_ident;
	u_short dispatch;
	u_short init;
	u_short clrack;
	u_short complete_error;
	u_short done;
	u_short done_end;
	u_short idle;
	u_short ungetjob;
	u_short reselect;
	u_short resel_tag;
	u_short resel_dsa;
	u_short resel_no_tag;
	u_short data_in;
	u_short data_in2;
	u_short data_out;
	u_short data_out2;
	u_short pm0_data;
	u_short pm1_data;
};

struct sym_fwb_ofs {
	u_short no_data;
	u_short sel_for_abort;
	u_short sel_for_abort_1;
	u_short msg_bad;
	u_short msg_weird;
	u_short wdtr_resp;
	u_short send_wdtr;
	u_short sdtr_resp;
	u_short send_sdtr;
	u_short ppr_resp;
	u_short send_ppr;
	u_short nego_bad_phase;
	u_short ident_break;
	u_short ident_break_atn;
	u_short sdata_in;
	u_short resel_bad_lun;
	u_short bad_i_t_l;
	u_short bad_i_t_l_q;
	u_short wsr_ma_helper;
	u_short start64;
	u_short pm_handle;
};

struct sym_fwz_ofs {
	u_short snooptest;
	u_short snoopend;
};

struct sym_fw {
	char *name;
	u32 *a_base;
	int a_size;
	struct sym_fwa_ofs *a_ofs;
	u32 *b_base;
	int b_size;
	struct sym_fwb_ofs *b_ofs;
	u32 *z_base;
	int z_size;
	struct sym_fwz_ofs *z_ofs;
	void (*setup)(struct sym_hcb *, struct sym_fw *);
	void (*patch)(struct Scsi_Host *);
};

struct sym_lcb {
	struct sym_lcbh head;
	u32 *itlq_tbl;
	u_short busy_itlq;
	u_short busy_itl;
	u_short ia_tag;
	u_short if_tag;
	u_char *cb_tags;
	struct sym_slcb s;
	u_char tags_si;
	u_short tags_sum[2];
	u_short tags_since;
	u_char to_clear;
	u_char user_flags;
	u_char curr_flags;
};

struct sym_pmc {
	struct sym_tblmove sg;
	u32 ret;
};

struct sym_dsb {
	struct sym_ccbh head;
	struct sym_pmc pm0;
	struct sym_pmc pm1;
	struct sym_tblsel select;
	struct sym_tblmove smsg;
	struct sym_tblmove smsg_ext;
	struct sym_tblmove cmd;
	struct sym_tblmove sense;
	struct sym_tblmove wresid;
	struct sym_tblmove data[96];
};

struct sym_ccb {
	struct sym_dsb phys;
	struct scsi_cmnd *cmd;
	u8 cdb_buf[16];
	u8 sns_bbuf[32];
	int data_len;
	int segments;
	u8 order;
	unsigned char odd_byte_adjustment;
	u_char nego_status;
	u_char xerr_status;
	u32 extra_bytes;
	u_char scsi_smsg[12];
	u_char scsi_smsg2[12];
	u_char sensecmd[6];
	u_char sv_scsi_status;
	u_char sv_xerr_status;
	int sv_resid;
	u32 ccb_ba;
	u_short tag;
	u_char target;
	u_char lun;
	struct sym_ccb *link_ccbh;
	SYM_QUEHEAD link_ccbq;
	u32 startp;
	u32 goalp;
	int ext_sg;
	int ext_ofs;
	u_char to_abort;
	u_char tags_si;
};

struct sym_fw1a_scr {
	u32 start[11];
	u32 getjob_begin[4];
	u32 _sms_a10[5];
	u32 getjob_end[4];
	u32 _sms_a20[4];
	u32 select[6];
	u32 _sms_a30[5];
	u32 wf_sel_done[2];
	u32 send_ident[2];
	u32 select2[2];
	u32 command[2];
	u32 dispatch[28];
	u32 sel_no_cmd[10];
	u32 init[6];
	u32 clrack[4];
	u32 datai_done[11];
	u32 datai_done_wsr[20];
	u32 datao_done[11];
	u32 datao_done_wss[6];
	u32 datai_phase[5];
	u32 datao_phase[5];
	u32 msg_in[2];
	u32 msg_in2[10];
	u32 status[10];
	u32 complete[6];
	u32 complete2[8];
	u32 _sms_a40[12];
	u32 done[5];
	u32 _sms_a50[5];
	u32 _sms_a60[2];
	u32 done_end[4];
	u32 complete_error[5];
	u32 save_dp[11];
	u32 restore_dp[7];
	u32 disconnect[11];
	u32 disconnect2[5];
	u32 _sms_a65[3];
	u32 idle[2];
	u32 ungetjob[5];
	u32 reselect[2];
	u32 reselected[19];
	u32 _sms_a70[6];
	u32 _sms_a80[4];
	u32 reselected1[25];
	u32 _sms_a90[4];
	u32 resel_lun0[7];
	u32 _sms_a100[4];
	u32 resel_tag[8];
	u32 _sms_a110[13];
	u32 _sms_a120[2];
	u32 resel_go[4];
	u32 _sms_a130[7];
	u32 resel_dsa[2];
	u32 resel_dsa1[4];
	u32 _sms_a140[7];
	u32 resel_no_tag[4];
	u32 _sms_a145[7];
	u32 data_in[192];
	u32 data_in2[4];
	u32 data_out[192];
	u32 data_out2[4];
	u32 pm0_data[12];
	u32 pm0_data_out[6];
	u32 pm0_data_end[7];
	u32 pm_data_end[4];
	u32 _sms_a150[4];
	u32 pm1_data[12];
	u32 pm1_data_out[6];
	u32 pm1_data_end[9];
};

struct sym_fw1b_scr {
	u32 no_data[2];
	u32 sel_for_abort[16];
	u32 sel_for_abort_1[2];
	u32 msg_in_etc[12];
	u32 msg_received[5];
	u32 msg_weird_seen[5];
	u32 msg_extended[17];
	u32 _sms_b10[4];
	u32 msg_bad[6];
	u32 msg_weird[4];
	u32 msg_weird1[8];
	u32 wdtr_resp[6];
	u32 send_wdtr[4];
	u32 sdtr_resp[6];
	u32 send_sdtr[4];
	u32 ppr_resp[6];
	u32 send_ppr[4];
	u32 nego_bad_phase[4];
	u32 msg_out[4];
	u32 msg_out_done[4];
	u32 data_ovrun[3];
	u32 data_ovrun1[22];
	u32 data_ovrun2[8];
	u32 abort_resel[16];
	u32 resend_ident[4];
	u32 ident_break[4];
	u32 ident_break_atn[4];
	u32 sdata_in[6];
	u32 resel_bad_lun[4];
	u32 bad_i_t_l[4];
	u32 bad_i_t_l_q[4];
	u32 bad_status[7];
	u32 wsr_ma_helper[4];
	u32 zero[1];
	u32 scratch[1];
	u32 scratch1[1];
	u32 prev_done[1];
	u32 done_pos[1];
	u32 nextjob[1];
	u32 startpos[1];
	u32 targtbl[1];
};

struct sym_fw1z_scr {
	u32 snooptest[9];
	u32 snoopend[2];
};

struct sym_fw2a_scr {
	u32 start[14];
	u32 getjob_begin[4];
	u32 getjob_end[4];
	u32 select[4];
	u32 wf_sel_done[2];
	u32 sel_done[2];
	u32 send_ident[2];
	u32 select2[2];
	u32 command[2];
	u32 dispatch[28];
	u32 sel_no_cmd[10];
	u32 init[6];
	u32 clrack[4];
	u32 datai_done[10];
	u32 datai_done_wsr[20];
	u32 datao_done[10];
	u32 datao_done_wss[6];
	u32 datai_phase[4];
	u32 datao_phase[6];
	u32 msg_in[2];
	u32 msg_in2[10];
	u32 status[10];
	u32 complete[6];
	u32 complete2[12];
	u32 done[14];
	u32 done_end[2];
	u32 complete_error[4];
	u32 save_dp[12];
	u32 restore_dp[8];
	u32 disconnect[12];
	u32 idle[2];
	u32 ungetjob[4];
	u32 reselect[2];
	u32 reselected[22];
	u32 resel_scntl4[20];
	u32 resel_lun0[6];
	u32 resel_tag[16];
	u32 resel_dsa[2];
	u32 resel_dsa1[4];
	u32 resel_no_tag[6];
	u32 data_in[192];
	u32 data_in2[4];
	u32 data_out[192];
	u32 data_out2[4];
	u32 pm0_data[12];
	u32 pm0_data_out[6];
	u32 pm0_data_end[6];
	u32 pm1_data[12];
	u32 pm1_data_out[6];
	u32 pm1_data_end[6];
};

struct sym_fw2b_scr {
	u32 start64[2];
	u32 no_data[2];
	u32 sel_for_abort[16];
	u32 sel_for_abort_1[2];
	u32 msg_in_etc[12];
	u32 msg_received[4];
	u32 msg_weird_seen[4];
	u32 msg_extended[20];
	u32 msg_bad[6];
	u32 msg_weird[4];
	u32 msg_weird1[8];
	u32 wdtr_resp[6];
	u32 send_wdtr[4];
	u32 sdtr_resp[6];
	u32 send_sdtr[4];
	u32 ppr_resp[6];
	u32 send_ppr[4];
	u32 nego_bad_phase[4];
	u32 msg_out[4];
	u32 msg_out_done[4];
	u32 data_ovrun[2];
	u32 data_ovrun1[22];
	u32 data_ovrun2[8];
	u32 abort_resel[16];
	u32 resend_ident[4];
	u32 ident_break[4];
	u32 ident_break_atn[4];
	u32 sdata_in[6];
	u32 resel_bad_lun[4];
	u32 bad_i_t_l[4];
	u32 bad_i_t_l_q[4];
	u32 bad_status[6];
	u32 pm_handle[20];
	u32 pm_handle1[4];
	u32 pm_save[4];
	u32 pm0_save[12];
	u32 pm_save_end[4];
	u32 pm1_save[14];
	u32 pm_wsr_handle[38];
	u32 wsr_ma_helper[4];
	u32 zero[1];
	u32 scratch[1];
	u32 pm0_data_addr[1];
	u32 pm1_data_addr[1];
	u32 done_pos[1];
	u32 startpos[1];
	u32 targtbl[1];
};

struct sym_fw2z_scr {
	u32 snooptest[6];
	u32 snoopend[2];
};

struct sym_driver_setup {
	u_short max_tag;
	u_char burst_order;
	u_char scsi_led;
	u_char scsi_diff;
	u_char irq_mode;
	u_char scsi_bus_check;
	u_char host_id;
	u_char verbose;
	u_char settle_delay;
	u_char use_nvram;
	u_long excludes[8];
};

struct sym_nvram;

struct sym_device {
	struct pci_dev *pdev;
	long unsigned int mmio_base;
	long unsigned int ram_base;
	struct {
		void *ioaddr;
		void *ramaddr;
	} s;
	struct sym_chip chip;
	struct sym_nvram *nvram;
	u_char host_id;
};

struct Symbios_host {
	u_short type;
	u_short device_id;
	u_short vendor_id;
	u_char bus_nr;
	u_char device_fn;
	u_short word8;
	u_short flags;
	u_short io_port;
};

struct Symbios_target {
	u_char flags;
	u_char rsvd;
	u_char bus_width;
	u_char sync_offset;
	u_short sync_period;
	u_short timeout;
};

struct Symbios_scam {
	u_short id;
	u_short method;
	u_short status;
	u_char target_id;
	u_char rsvd;
};

struct Symbios_nvram {
	u_short type;
	u_short byte_count;
	u_short checksum;
	u_char v_major;
	u_char v_minor;
	u32 boot_crc;
	u_short flags;
	u_short flags1;
	u_short term_state;
	u_short rmvbl_flags;
	u_char host_id;
	u_char num_hba;
	u_char num_devices;
	u_char max_scam_devices;
	u_char num_valid_scam_devices;
	u_char flags2;
	struct Symbios_host host[4];
	struct Symbios_target target[16];
	struct Symbios_scam scam[4];
	u_char spare_devices[120];
	u_char trailer[6];
};

typedef struct Symbios_nvram Symbios_nvram;

struct Tekram_target {
	u_char flags;
	u_char sync_index;
	u_short word2;
};

struct Tekram_nvram {
	struct Tekram_target target[16];
	u_char host_id;
	u_char flags;
	u_char boot_delay_index;
	u_char max_tags_index;
	u_short flags1;
	u_short spare[29];
};

typedef struct Tekram_nvram Tekram_nvram;

struct pdc_initiator {
	int dummy;
};

struct sym_nvram {
	int type;
	union {
		Symbios_nvram Symbios;
		Tekram_nvram Tekram;
		struct pdc_initiator parisc;
	} data;
};

struct sym_ucmd {
	struct completion *eh_done;
};

struct sym_usrcmd {
	u_long target;
	u_long lun;
	u_long data;
	u_long cmd;
};

struct sym_m_link {
	struct sym_m_link *next;
};

typedef struct sym_m_link *m_link_p;

struct sym_m_vtob {
	struct sym_m_vtob *next;
	void *vaddr;
	dma_addr_t baddr;
};

typedef struct sym_m_vtob *m_vtob_p;

struct sym_m_pool {
	m_pool_ident_t dev_dmat;
	void * (*get_mem_cluster)(struct sym_m_pool *);
	void (*free_mem_cluster)(struct sym_m_pool *, void *);
	int nump;
	m_vtob_p vtob[32];
	struct sym_m_pool *next;
	struct sym_m_link h[9];
};

typedef struct sym_m_pool *m_pool_p;

typedef struct Symbios_target Symbios_target;

typedef char *__kernel_caddr_t;

typedef __kernel_caddr_t caddr_t;

struct mbox_out {
	u8 cmd;
	u8 cmdid;
	u16 numsectors;
	u32 lba;
	u32 xferaddr;
	u8 logdrv;
	u8 numsgelements;
	u8 resvd;
} __attribute__((packed));

struct mbox_in {
	volatile u8 busy;
	volatile u8 numstatus;
	volatile u8 status;
	volatile u8 completed[46];
	volatile u8 poll;
	volatile u8 ack;
};

typedef struct {
	struct mbox_out m_out;
	struct mbox_in m_in;
} __attribute__((packed)) mbox_t;

typedef struct {
	u32 xfer_segment_lo;
	u32 xfer_segment_hi;
	mbox_t mbox;
} __attribute__((packed)) mbox64_t;

typedef struct {
	u8 timeout: 3;
	u8 ars: 1;
	u8 reserved: 3;
	u8 islogical: 1;
	u8 logdrv;
	u8 channel;
	u8 target;
	u8 queuetag;
	u8 queueaction;
	u8 cdb[10];
	u8 cdblen;
	u8 reqsenselen;
	u8 reqsensearea[32];
	u8 numsgelements;
	u8 scsistatus;
	u32 dataxferaddr;
	u32 dataxferlen;
} mega_passthru;

typedef struct {
	u8 timeout: 3;
	u8 ars: 1;
	u8 rsvd1: 1;
	u8 cd_rom: 1;
	u8 rsvd2: 1;
	u8 islogical: 1;
	u8 logdrv;
	u8 channel;
	u8 target;
	u8 queuetag;
	u8 queueaction;
	u8 cdblen;
	u8 rsvd3;
	u8 cdb[16];
	u8 numsgelements;
	u8 status;
	u8 reqsenselen;
	u8 reqsensearea[32];
	u8 rsvd4;
	u32 dataxferaddr;
	u32 dataxferlen;
} mega_ext_passthru;

typedef struct {
	u64 address;
	u32 length;
} __attribute__((packed)) mega_sgl64;

typedef struct {
	u32 address;
	u32 length;
} mega_sglist;

typedef struct {
	int idx;
	u32 state;
	struct list_head list;
	u8 raw_mbox[66];
	u32 dma_type;
	u32 dma_direction;
	struct scsi_cmnd *cmd;
	dma_addr_t dma_h_bulkdata;
	dma_addr_t dma_h_sgdata;
	mega_sglist *sgl;
	mega_sgl64 *sgl64;
	dma_addr_t sgl_dma_addr;
	mega_passthru *pthru;
	dma_addr_t pthru_dma_addr;
	mega_ext_passthru *epthru;
	dma_addr_t epthru_dma_addr;
} scb_t;

typedef struct {
	u32 data_size;
	u32 config_signature;
	u8 fw_version[16];
	u8 bios_version[16];
	u8 product_name[80];
	u8 max_commands;
	u8 nchannels;
	u8 fc_loop_present;
	u8 mem_type;
	u32 signature;
	u16 dram_size;
	u16 subsysid;
	u16 subsysvid;
	u8 notify_counters;
	u8 pad1k[889];
} mega_product_info;

struct notify {
	u32 global_counter;
	u8 param_counter;
	u8 param_id;
	u16 param_val;
	u8 write_config_counter;
	u8 write_config_rsvd[3];
	u8 ldrv_op_counter;
	u8 ldrv_opid;
	u8 ldrv_opcmd;
	u8 ldrv_opstatus;
	u8 ldrv_state_counter;
	u8 ldrv_state_id;
	u8 ldrv_state_new;
	u8 ldrv_state_old;
	u8 pdrv_state_counter;
	u8 pdrv_state_id;
	u8 pdrv_state_new;
	u8 pdrv_state_old;
	u8 pdrv_fmt_counter;
	u8 pdrv_fmt_id;
	u8 pdrv_fmt_val;
	u8 pdrv_fmt_rsvd;
	u8 targ_xfer_counter;
	u8 targ_xfer_id;
	u8 targ_xfer_val;
	u8 targ_xfer_rsvd;
	u8 fcloop_id_chg_counter;
	u8 fcloopid_pdrvid;
	u8 fcloop_id0;
	u8 fcloop_id1;
	u8 fcloop_state_counter;
	u8 fcloop_state0;
	u8 fcloop_state1;
	u8 fcloop_state_rsvd;
};

typedef struct {
	u32 data_size;
	struct notify notify;
	u8 notify_rsvd[88];
	u8 rebuild_rate;
	u8 cache_flush_interval;
	u8 sense_alert;
	u8 drive_insert_count;
	u8 battery_status;
	u8 num_ldrv;
	u8 recon_state[5];
	u16 ldrv_op_status[5];
	u32 ldrv_size[40];
	u8 ldrv_prop[40];
	u8 ldrv_state[40];
	u8 pdrv_state[256];
	u16 pdrv_format[16];
	u8 targ_xfer[80];
	u8 pad1k[263];
} __attribute__((packed)) mega_inquiry3;

typedef struct {
	u8 max_commands;
	u8 rebuild_rate;
	u8 max_targ_per_chan;
	u8 nchannels;
	u8 fw_version[4];
	u16 age_of_flash;
	u8 chip_set_value;
	u8 dram_size;
	u8 cache_flush_interval;
	u8 bios_version[4];
	u8 board_type;
	u8 sense_alert;
	u8 write_config_count;
	u8 drive_inserted_count;
	u8 inserted_drive;
	u8 battery_status;
	u8 dec_fault_bus_info;
} mega_adp_info;

typedef struct {
	u8 num_ldrv;
	u8 rsvd[3];
	u32 ldrv_size[8];
	u8 ldrv_prop[8];
	u8 ldrv_state[8];
} mega_ldrv_info;

typedef struct {
	u8 pdrv_state[75];
	u8 rsvd;
} mega_pdrv_info;

typedef struct {
	mega_adp_info adapter_info;
	mega_ldrv_info logdrv_info;
	mega_pdrv_info pdrv_info;
} mraid_inquiry;

typedef struct {
	mraid_inquiry raid_inq;
	u16 phys_drv_format[5];
	u8 stack_attn;
	u8 modem_status;
	u8 rsvd[2];
} __attribute__((packed)) mraid_ext_inquiry;

typedef struct {
	u8 channel;
	u8 target;
} adp_device;

typedef struct {
	u32 start_blk;
	u32 num_blks;
	adp_device device[32];
} adp_span_40ld;

typedef struct {
	u32 start_blk;
	u32 num_blks;
	adp_device device[8];
} adp_span_8ld;

typedef struct {
	u8 span_depth;
	u8 level;
	u8 read_ahead;
	u8 stripe_sz;
	u8 status;
	u8 write_mode;
	u8 direct_io;
	u8 row_size;
} logdrv_param;

typedef struct {
	logdrv_param lparam;
	adp_span_40ld span[8];
} logdrv_40ld;

typedef struct {
	logdrv_param lparam;
	adp_span_8ld span[8];
} logdrv_8ld;

typedef struct {
	u8 type;
	u8 cur_status;
	u8 tag_depth;
	u8 sync_neg;
	u32 size;
} phys_drv;

typedef struct {
	u8 nlog_drives;
	u8 resvd[3];
	logdrv_40ld ldrv[40];
	phys_drv pdrv[75];
} disk_array_40ld;

typedef struct {
	u8 nlog_drives;
	u8 resvd[3];
	logdrv_8ld ldrv[8];
	phys_drv pdrv[75];
} disk_array_8ld;

struct uioctl_t {
	u32 inlen;
	u32 outlen;
	union {
		u8 fca[16];
		struct {
			u8 opcode;
			u8 subopcode;
			u16 adapno;
			u8 *buffer;
			u32 length;
		} __attribute__((packed)) fcs;
	} ui;
	u8 mbox[18];
	mega_passthru pthru;
	char *data;
} __attribute__((packed));

struct mcontroller {
	u64 base;
	u8 irq;
	u8 numldrv;
	u8 pcibus;
	u16 pcidev;
	u8 pcifun;
	u16 pciid;
	u16 pcivendor;
	u8 pcislot;
	u32 uid;
};

typedef struct {
	u8 cmd;
	u8 cmdid;
	u8 opcode;
	u8 subopcode;
	u32 lba;
	u32 xferaddr;
	u8 logdrv;
	u8 rsvd[3];
	u8 numstatus;
	u8 status;
} __attribute__((packed)) megacmd_t;

typedef struct {
	char signature[8];
	u32 opcode;
	u32 adapno;
	union {
		u8 __raw_mbox[18];
		void *__uaddr;
	} __ua;
	u32 xferlen;
	u32 flags;
} nitioctl_t;

struct private_bios_data {
	u8 geometry: 4;
	u8 unused: 4;
	u8 boot_drv;
	u8 rsvd[12];
	u16 cksum;
};

typedef struct {
	int this_id;
	u32 flag;
	long unsigned int base;
	void *mmio_base;
	mbox64_t *una_mbox64;
	dma_addr_t una_mbox64_dma;
	volatile mbox64_t *mbox64;
	volatile mbox_t *mbox;
	dma_addr_t mbox_dma;
	struct pci_dev *dev;
	struct list_head free_list;
	struct list_head pending_list;
	struct list_head completed_list;
	struct Scsi_Host *host;
	u8 *mega_buffer;
	dma_addr_t buf_dma_handle;
	mega_product_info product_info;
	u8 max_cmds;
	scb_t *scb_list;
	atomic_t pend_cmds;
	u8 numldrv;
	u8 fw_version[7];
	u8 bios_version[7];
	struct proc_dir_entry *controller_proc_dir_entry;
	int has_64bit_addr;
	int support_ext_cdb;
	int boot_ldrv_enabled;
	int boot_ldrv;
	int boot_pdrv_enabled;
	int boot_pdrv_ch;
	int boot_pdrv_tgt;
	int support_random_del;
	int read_ldidmap;
	atomic_t quiescent;
	spinlock_t lock;
	u8 logdrv_chan[9];
	int mega_ch_class;
	u8 sglen;
	scb_t int_scb;
	struct mutex int_mtx;
	int int_status;
	struct completion int_waitq;
	int has_cluster;
} adapter_t;

struct mega_hbas {
	int is_bios_enabled;
	adapter_t *hostdata_addr;
};

typedef s8 int8_t;

typedef struct {
	uint8_t cmd;
	uint8_t cmdid;
	uint16_t numsectors;
	uint32_t lba;
	uint32_t xferaddr;
	uint8_t logdrv;
	uint8_t numsge;
	uint8_t resvd;
	uint8_t busy;
	uint8_t numstatus;
	uint8_t status;
	uint8_t completed[46];
	uint8_t poll;
	uint8_t ack;
} __attribute__((packed)) mbox_t___2;

typedef struct {
	uint32_t xferaddr_lo;
	uint32_t xferaddr_hi;
	mbox_t___2 mbox32;
} __attribute__((packed)) mbox64_t___2;

typedef struct {
	uint8_t timeout: 3;
	uint8_t ars: 1;
	uint8_t reserved: 3;
	uint8_t islogical: 1;
	uint8_t logdrv;
	uint8_t channel;
	uint8_t target;
	uint8_t queuetag;
	uint8_t queueaction;
	uint8_t cdb[10];
	uint8_t cdblen;
	uint8_t reqsenselen;
	uint8_t reqsensearea[32];
	uint8_t numsge;
	uint8_t scsistatus;
	uint32_t dataxferaddr;
	uint32_t dataxferlen;
} mraid_passthru_t;

struct uioc {
	uint8_t signature[16];
	uint16_t mb_type;
	uint16_t app_type;
	uint32_t opcode;
	uint32_t adapno;
	uint64_t cmdbuf;
	uint32_t xferlen;
	uint32_t data_dir;
	int32_t status;
	uint8_t reserved[128];
	void *user_data;
	uint32_t user_data_len;
	uint32_t pad_for_64bit_align;
	mraid_passthru_t *user_pthru;
	mraid_passthru_t *pthru32;
	dma_addr_t pthru32_h;
	struct list_head list;
	void (*done)(struct uioc *);
	caddr_t buf_vaddr;
	dma_addr_t buf_paddr;
	int8_t pool_index;
	uint8_t free_buf;
	uint8_t timedout;
	long: 40;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} __attribute__((packed));

typedef struct uioc uioc_t;

struct uioc_timeout {
	struct timer_list timer;
	uioc_t *uioc;
};

struct mraid_hba_info {
	uint16_t pci_vendor_id;
	uint16_t pci_device_id;
	uint16_t subsys_vendor_id;
	uint16_t subsys_device_id;
	uint64_t baseport;
	uint8_t pci_bus;
	uint8_t pci_dev_fn;
	uint8_t pci_slot;
	uint8_t irq;
	uint32_t unique_id;
	uint32_t host_no;
	uint8_t num_ldrv;
	long: 24;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct mraid_hba_info mraid_hba_info_t;

struct mcontroller___2 {
	uint64_t base;
	uint8_t irq;
	uint8_t numldrv;
	uint8_t pcibus;
	uint16_t pcidev;
	uint8_t pcifun;
	uint16_t pciid;
	uint16_t pcivendor;
	uint8_t pcislot;
	uint32_t uid;
} __attribute__((packed));

typedef struct mcontroller___2 mcontroller_t;

struct mm_dmapool {
	caddr_t vaddr;
	dma_addr_t paddr;
	uint32_t buf_size;
	struct dma_pool___2 *handle;
	spinlock_t lock;
	uint8_t in_use;
};

typedef struct mm_dmapool mm_dmapool_t;

struct mraid_mmadp {
	uint32_t unique_id;
	uint32_t drvr_type;
	long unsigned int drvr_data;
	uint16_t timeout;
	uint8_t max_kioc;
	struct pci_dev *pdev;
	int (*issue_uioc)(long unsigned int, uioc_t *, uint32_t);
	uint32_t quiescent;
	struct list_head list;
	uioc_t *kioc_list;
	struct list_head kioc_pool;
	spinlock_t kioc_pool_lock;
	struct semaphore kioc_semaphore;
	mbox64_t___2 *mbox_list;
	struct dma_pool___2 *pthru_dma_pool;
	mm_dmapool_t dma_pool_list[5];
};

typedef struct mraid_mmadp mraid_mmadp_t;

struct mimd {
	uint32_t inlen;
	uint32_t outlen;
	union {
		uint8_t fca[16];
		struct {
			uint8_t opcode;
			uint8_t subopcode;
			uint16_t adapno;
			uint8_t *buffer;
			uint32_t length;
		} __attribute__((packed)) fcs;
	} ui;
	uint8_t mbox[18];
	mraid_passthru_t pthru;
	char *data;
} __attribute__((packed));

typedef struct mimd mimd_t;

typedef struct {
	caddr_t ccb;
	struct list_head list;
	long unsigned int gp;
	unsigned int sno;
	struct scsi_cmnd *scp;
	uint32_t state;
	uint32_t dma_direction;
	uint32_t dma_type;
	uint16_t dev_channel;
	uint16_t dev_target;
	uint32_t status;
} scb_t___2;

typedef struct {
	struct tasklet_struct dpc_h;
	struct pci_dev *pdev;
	struct Scsi_Host *host;
	spinlock_t lock;
	uint8_t quiescent;
	int outstanding_cmds;
	scb_t___2 *kscb_list;
	struct list_head kscb_pool;
	spinlock_t kscb_pool_lock;
	struct list_head pend_list;
	spinlock_t pend_list_lock;
	struct list_head completed_list;
	spinlock_t completed_list_lock;
	uint16_t sglen;
	int device_ids[1040];
	caddr_t raid_device;
	uint8_t max_channel;
	uint16_t max_target;
	uint8_t max_lun;
	uint32_t unique_id;
	int irq;
	uint8_t ito;
	caddr_t ibuf;
	dma_addr_t ibuf_dma_h;
	scb_t___2 *uscb_list;
	struct list_head uscb_pool;
	spinlock_t uscb_pool_lock;
	int max_cmds;
	uint8_t fw_version[16];
	uint8_t bios_version[16];
	uint8_t max_cdb_sz;
	uint8_t ha;
	uint16_t init_id;
	uint16_t max_sectors;
	uint16_t cmd_per_lun;
	atomic_t being_detached;
} adapter_t___2;

struct mraid_pci_blk {
	caddr_t vaddr;
	dma_addr_t dma_addr;
};

typedef struct {
	uint8_t timeout: 3;
	uint8_t ars: 1;
	uint8_t rsvd1: 1;
	uint8_t cd_rom: 1;
	uint8_t rsvd2: 1;
	uint8_t islogical: 1;
	uint8_t logdrv;
	uint8_t channel;
	uint8_t target;
	uint8_t queuetag;
	uint8_t queueaction;
	uint8_t cdblen;
	uint8_t rsvd3;
	uint8_t cdb[16];
	uint8_t numsge;
	uint8_t status;
	uint8_t reqsenselen;
	uint8_t reqsensearea[32];
	uint8_t rsvd4;
	uint32_t dataxferaddr;
	uint32_t dataxferlen;
} mraid_epassthru_t;

typedef struct {
	uint32_t data_size;
	uint32_t config_signature;
	uint8_t fw_version[16];
	uint8_t bios_version[16];
	uint8_t product_name[80];
	uint8_t max_commands;
	uint8_t nchannels;
	uint8_t fc_loop_present;
	uint8_t mem_type;
	uint32_t signature;
	uint16_t dram_size;
	uint16_t subsysid;
	uint16_t subsysvid;
	uint8_t notify_counters;
	uint8_t pad1k[889];
} mraid_pinfo_t;

typedef struct {
	uint32_t global_counter;
	uint8_t param_counter;
	uint8_t param_id;
	uint16_t param_val;
	uint8_t write_config_counter;
	uint8_t write_config_rsvd[3];
	uint8_t ldrv_op_counter;
	uint8_t ldrv_opid;
	uint8_t ldrv_opcmd;
	uint8_t ldrv_opstatus;
	uint8_t ldrv_state_counter;
	uint8_t ldrv_state_id;
	uint8_t ldrv_state_new;
	uint8_t ldrv_state_old;
	uint8_t pdrv_state_counter;
	uint8_t pdrv_state_id;
	uint8_t pdrv_state_new;
	uint8_t pdrv_state_old;
	uint8_t pdrv_fmt_counter;
	uint8_t pdrv_fmt_id;
	uint8_t pdrv_fmt_val;
	uint8_t pdrv_fmt_rsvd;
	uint8_t targ_xfer_counter;
	uint8_t targ_xfer_id;
	uint8_t targ_xfer_val;
	uint8_t targ_xfer_rsvd;
	uint8_t fcloop_id_chg_counter;
	uint8_t fcloopid_pdrvid;
	uint8_t fcloop_id0;
	uint8_t fcloop_id1;
	uint8_t fcloop_state_counter;
	uint8_t fcloop_state0;
	uint8_t fcloop_state1;
	uint8_t fcloop_state_rsvd;
} mraid_notify_t;

typedef struct {
	uint32_t data_size;
	mraid_notify_t notify;
	uint8_t notify_rsvd[88];
	uint8_t rebuild_rate;
	uint8_t cache_flush_int;
	uint8_t sense_alert;
	uint8_t drive_insert_count;
	uint8_t battery_status;
	uint8_t num_ldrv;
	uint8_t recon_state[5];
	uint16_t ldrv_op_status[5];
	uint32_t ldrv_size[40];
	uint8_t ldrv_prop[40];
	uint8_t ldrv_state[40];
	uint8_t pdrv_state[256];
	uint16_t pdrv_format[16];
	uint8_t targ_xfer[80];
	uint8_t pad1k[263];
} __attribute__((packed)) mraid_inquiry3_t;

typedef struct {
	uint64_t address;
	uint32_t length;
} __attribute__((packed)) mbox_sgl64;

typedef struct {
	uint32_t address;
	uint32_t length;
} mbox_sgl32;

typedef struct {
	uint8_t *raw_mbox;
	mbox_t___2 *mbox;
	mbox64_t___2 *mbox64;
	dma_addr_t mbox_dma_h;
	mbox_sgl64 *sgl64;
	mbox_sgl32 *sgl32;
	dma_addr_t sgl_dma_h;
	mraid_passthru_t *pthru;
	dma_addr_t pthru_dma_h;
	mraid_epassthru_t *epthru;
	dma_addr_t epthru_dma_h;
	dma_addr_t buf_dma_h;
} mbox_ccb_t;

typedef struct {
	mbox64_t___2 *una_mbox64;
	dma_addr_t una_mbox64_dma;
	mbox_t___2 *mbox;
	mbox64_t___2 *mbox64;
	dma_addr_t mbox_dma;
	spinlock_t mailbox_lock;
	long unsigned int baseport;
	void *baseaddr;
	struct mraid_pci_blk mbox_pool[128];
	struct dma_pool___2 *mbox_pool_handle;
	struct mraid_pci_blk epthru_pool[128];
	struct dma_pool___2 *epthru_pool_handle;
	struct mraid_pci_blk sg_pool[128];
	struct dma_pool___2 *sg_pool_handle;
	mbox_ccb_t ccb_list[128];
	mbox_ccb_t uccb_list[32];
	mbox64_t___2 umbox64[32];
	uint8_t pdrv_state[75];
	uint32_t last_disp;
	int hw_error;
	int fast_load;
	uint8_t channel_class;
	struct mutex sysfs_mtx;
	uioc_t *sysfs_uioc;
	mbox64_t___2 *sysfs_mbox64;
	caddr_t sysfs_buffer;
	dma_addr_t sysfs_buffer_dma;
	wait_queue_head_t sysfs_wait_q;
	int random_del_supported;
	uint16_t curr_ldmap[64];
} mraid_device_t;

struct TAG_twa_message_type {
	unsigned int code;
	char *text;
};

typedef struct TAG_twa_message_type twa_message_type;

struct TAG_TW_SG_Entry {
	dma_addr_t address;
	u32 length;
} __attribute__((packed));

typedef struct TAG_TW_SG_Entry TW_SG_Entry;

struct TW_Command {
	unsigned char opcode__sgloffset;
	unsigned char size;
	unsigned char request_id;
	unsigned char unit__hostid;
	unsigned char status;
	unsigned char flags;
	union {
		short unsigned int block_count;
		short unsigned int parameter_count;
	} byte6_offset;
	union {
		struct {
			u32 lba;
			TW_SG_Entry sgl[41];
			dma_addr_t padding;
		} __attribute__((packed)) io;
		struct {
			TW_SG_Entry sgl[41];
			u32 padding;
			dma_addr_t padding2;
		} param;
	} byte8_offset;
};

typedef struct TW_Command TW_Command;

struct TAG_TW_Command_Apache {
	unsigned char opcode__reserved;
	unsigned char unit;
	short unsigned int request_id__lunl;
	unsigned char status;
	unsigned char sgl_offset;
	short unsigned int sgl_entries__lunh;
	unsigned char cdb[16];
	TW_SG_Entry sg_list[72];
	unsigned char padding[8];
};

typedef struct TAG_TW_Command_Apache TW_Command_Apache;

struct TAG_TW_Command_Apache_Header {
	unsigned char sense_data[18];
	struct {
		char reserved[4];
		short unsigned int error;
		unsigned char padding;
		unsigned char severity__reserved;
	} status_block;
	unsigned char err_specific_desc[98];
	struct {
		unsigned char size_header;
		short unsigned int reserved;
		unsigned char size_sense;
	} __attribute__((packed)) header_desc;
};

typedef struct TAG_TW_Command_Apache_Header TW_Command_Apache_Header;

struct TAG_TW_Command_Full {
	TW_Command_Apache_Header header;
	union {
		TW_Command oldcommand;
		TW_Command_Apache newcommand;
	} command;
};

typedef struct TAG_TW_Command_Full TW_Command_Full;

struct TAG_TW_Initconnect {
	unsigned char opcode__reserved;
	unsigned char size;
	unsigned char request_id;
	unsigned char res2;
	unsigned char status;
	unsigned char flags;
	short unsigned int message_credits;
	u32 features;
	short unsigned int fw_srl;
	short unsigned int fw_arch_id;
	short unsigned int fw_branch;
	short unsigned int fw_build;
	u32 result;
};

typedef struct TAG_TW_Initconnect TW_Initconnect;

struct TAG_TW_Event {
	unsigned int sequence_id;
	unsigned int time_stamp_sec;
	short unsigned int aen_code;
	unsigned char severity;
	unsigned char retrieved;
	unsigned char repeat_count;
	unsigned char parameter_len;
	unsigned char parameter_data[98];
};

typedef struct TAG_TW_Event TW_Event;

struct TAG_TW_Ioctl_Driver_Command {
	unsigned int control_code;
	unsigned int status;
	unsigned int unique_id;
	unsigned int sequence_id;
	unsigned int os_specific;
	unsigned int buffer_length;
};

typedef struct TAG_TW_Ioctl_Driver_Command TW_Ioctl_Driver_Command;

struct TAG_TW_Ioctl_Apache {
	TW_Ioctl_Driver_Command driver_command;
	char padding[488];
	TW_Command_Full firmware_command;
	char data_buffer[1];
} __attribute__((packed));

typedef struct TAG_TW_Ioctl_Apache TW_Ioctl_Buf_Apache;

struct TAG_TW_Lock {
	long unsigned int timeout_msec;
	long unsigned int time_remaining_msec;
	long unsigned int force_flag;
};

typedef struct TAG_TW_Lock TW_Lock;

typedef struct {
	short unsigned int table_id;
	short unsigned int parameter_id;
	short unsigned int parameter_size_bytes;
	short unsigned int actual_parameter_size_bytes;
	unsigned char data[1];
} __attribute__((packed)) TW_Param_Apache;

union TAG_TW_Response_Queue {
	u32 response_id;
	u32 value;
};

typedef union TAG_TW_Response_Queue TW_Response_Queue;

struct TAG_TW_Compatibility_Info {
	char driver_version[32];
	short unsigned int working_srl;
	short unsigned int working_branch;
	short unsigned int working_build;
	short unsigned int driver_srl_high;
	short unsigned int driver_branch_high;
	short unsigned int driver_build_high;
	short unsigned int driver_srl_low;
	short unsigned int driver_branch_low;
	short unsigned int driver_build_low;
	short unsigned int fw_on_ctlr_srl;
	short unsigned int fw_on_ctlr_branch;
	short unsigned int fw_on_ctlr_build;
};

typedef struct TAG_TW_Compatibility_Info TW_Compatibility_Info;

struct TAG_TW_Device_Extension {
	u32 *base_addr;
	long unsigned int *generic_buffer_virt[256];
	dma_addr_t generic_buffer_phys[256];
	TW_Command_Full *command_packet_virt[256];
	dma_addr_t command_packet_phys[256];
	struct pci_dev *tw_pci_dev;
	struct scsi_cmnd *srb[256];
	unsigned char free_queue[256];
	unsigned char free_head;
	unsigned char free_tail;
	unsigned char pending_queue[256];
	unsigned char pending_head;
	unsigned char pending_tail;
	int state[256];
	unsigned int posted_request_count;
	unsigned int max_posted_request_count;
	unsigned int pending_request_count;
	unsigned int max_pending_request_count;
	unsigned int max_sgl_entries;
	unsigned int sgl_entries;
	unsigned int num_resets;
	unsigned int sector_count;
	unsigned int max_sector_count;
	unsigned int aen_count;
	int: 32;
	struct Scsi_Host *host;
	long int flags;
	int reset_print;
	int: 32;
	TW_Event *event_queue[256];
	unsigned char error_index;
	unsigned char event_queue_wrapped;
	short: 16;
	unsigned int error_sequence_id;
	int ioctl_sem_lock;
	int: 32;
	ktime_t ioctl_time;
	int chrdev_request_id;
	int: 32;
	wait_queue_head_t ioctl_wqueue;
	struct mutex ioctl_lock;
	char aen_clobber;
	TW_Compatibility_Info tw_compat_info;
	long: 56;
} __attribute__((packed));

typedef struct TAG_TW_Device_Extension TW_Device_Extension;

struct virtio_scsi_cmd_req {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_cmd_req_pi {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__virtio32 pi_bytesout;
	__virtio32 pi_bytesin;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_cmd_resp {
	__virtio32 sense_len;
	__virtio32 resid;
	__virtio16 status_qualifier;
	__u8 status;
	__u8 response;
	__u8 sense[96];
};

struct virtio_scsi_ctrl_tmf_req {
	__virtio32 type;
	__virtio32 subtype;
	__u8 lun[8];
	__virtio64 tag;
};

struct virtio_scsi_ctrl_tmf_resp {
	__u8 response;
};

struct virtio_scsi_ctrl_an_req {
	__virtio32 type;
	__u8 lun[8];
	__virtio32 event_requested;
};

struct virtio_scsi_ctrl_an_resp {
	__virtio32 event_actual;
	__u8 response;
} __attribute__((packed));

struct virtio_scsi_event {
	__virtio32 event;
	__u8 lun[8];
	__virtio32 reason;
};

struct virtio_scsi_config {
	__virtio32 num_queues;
	__virtio32 seg_max;
	__virtio32 max_sectors;
	__virtio32 cmd_per_lun;
	__virtio32 event_info_size;
	__virtio32 sense_size;
	__virtio32 cdb_size;
	__virtio16 max_channel;
	__virtio16 max_target;
	__virtio32 max_lun;
};

struct virtio_scsi_cmd {
	struct scsi_cmnd *sc;
	struct completion *comp;
	union {
		struct virtio_scsi_cmd_req cmd;
		struct virtio_scsi_cmd_req_pi cmd_pi;
		struct virtio_scsi_ctrl_tmf_req tmf;
		struct virtio_scsi_ctrl_an_req an;
	} req;
	union {
		struct virtio_scsi_cmd_resp cmd;
		struct virtio_scsi_ctrl_tmf_resp tmf;
		struct virtio_scsi_ctrl_an_resp an;
		struct virtio_scsi_event evt;
	} resp;
	long: 8;
	long: 64;
} __attribute__((packed));

struct virtio_scsi;

struct virtio_scsi_event_node {
	struct virtio_scsi *vscsi;
	struct virtio_scsi_event event;
	struct work_struct work;
};

struct virtio_scsi_vq {
	spinlock_t vq_lock;
	struct virtqueue *vq;
};

struct virtio_scsi {
	struct virtio_device *vdev;
	struct virtio_scsi_event_node event_list[8];
	u32 num_queues;
	struct hlist_node node;
	bool stop_events;
	struct virtio_scsi_vq ctrl_vq;
	struct virtio_scsi_vq event_vq;
	struct virtio_scsi_vq req_vqs[0];
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct opal_dev;

struct scsi_disk {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct device dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
};

enum {
	ATA_MSG_DRV = 1,
	ATA_MSG_INFO = 2,
	ATA_MSG_PROBE = 4,
	ATA_MSG_WARN = 8,
	ATA_MSG_MALLOC = 16,
	ATA_MSG_CTL = 32,
	ATA_MSG_INTR = 64,
	ATA_MSG_ERR = 128,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct ata_timing {
	short unsigned int mode;
	short unsigned int setup;
	short unsigned int act8b;
	short unsigned int rec8b;
	short unsigned int cyc8b;
	short unsigned int active;
	short unsigned int recover;
	short unsigned int dmack_hold;
	short unsigned int cycle;
	short unsigned int udma;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct trace_event_raw_ata_qc_issue {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = 2147483648,
};

struct ata_force_param {
	const char *name;
	u8 cbl;
	u8 spd_limit;
	long unsigned int xfer_mask;
	unsigned int horkage_on;
	unsigned int horkage_off;
	u16 lflags;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	long unsigned int horkage;
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = 2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const long unsigned int *timeouts;
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

struct ata_acpi_gtf {
	u8 tf[7];
};

struct ata_acpi_hotplug_context {
	struct acpi_hotplug_context hp;
	union {
		struct ata_port *ap;
		struct ata_device *dev;
	} data;
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_CLKS = 5,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DEV_ILCK = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_IS_MOBILE = 33554432,
	AHCI_HFLAG_SUSPEND_PHYS = 67108864,
	AHCI_HFLAG_IGN_NOTSUPP_POWER_ON = 134217728,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 8,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	long unsigned int saved_activity;
	long unsigned int activity;
	long unsigned int led_state;
	struct ata_link *link;
};

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[8];
	char *irq_desc;
};

struct ahci_host_priv {
	unsigned int flags;
	u32 force_port_map;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	u32 remapped_nvme;
	bool got_runtime_pm;
	struct clk *clks[5];
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

enum {
	AHCI_PCI_BAR_STA2X11 = 0,
	AHCI_PCI_BAR_CAVIUM = 0,
	AHCI_PCI_BAR_LOONGSON = 0,
	AHCI_PCI_BAR_ENMOTUS = 2,
	AHCI_PCI_BAR_CAVIUM_GEN5 = 4,
	AHCI_PCI_BAR_STANDARD = 5,
};

enum board_ids {
	board_ahci = 0,
	board_ahci_ign_iferr = 1,
	board_ahci_mobile = 2,
	board_ahci_nomsi = 3,
	board_ahci_noncq = 4,
	board_ahci_nosntf = 5,
	board_ahci_yes_fbs = 6,
	board_ahci_al = 7,
	board_ahci_avn = 8,
	board_ahci_mcp65 = 9,
	board_ahci_mcp77 = 10,
	board_ahci_mcp89 = 11,
	board_ahci_mv = 12,
	board_ahci_sb600 = 13,
	board_ahci_sb700 = 14,
	board_ahci_vt8251 = 15,
	board_ahci_pcs7 = 16,
	board_ahci_mcp_linux = 9,
	board_ahci_mcp67 = 9,
	board_ahci_mcp73 = 9,
	board_ahci_mcp79 = 10,
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

enum {
	PIIX_IOCFG = 84,
	ICH5_PMR = 144,
	ICH5_PCS = 146,
	PIIX_SIDPR_BAR = 5,
	PIIX_SIDPR_LEN = 16,
	PIIX_SIDPR_IDX = 0,
	PIIX_SIDPR_DATA = 4,
	PIIX_FLAG_CHECKINTR = 268435456,
	PIIX_FLAG_SIDPR = 536870912,
	PIIX_PATA_FLAGS = 1,
	PIIX_SATA_FLAGS = 268435458,
	PIIX_FLAG_PIO16 = 1073741824,
	PIIX_80C_PRI = 48,
	PIIX_80C_SEC = 192,
	P0 = 0,
	P1 = 1,
	P2 = 2,
	P3 = 3,
	IDE = 4294967295,
	NA = 4294967294,
	RV = 4294967293,
	PIIX_AHCI_DEVICE = 6,
	PIIX_HOST_BROKEN_SUSPEND = 16777216,
};

enum piix_controller_ids {
	piix_pata_mwdma = 0,
	piix_pata_33 = 1,
	ich_pata_33 = 2,
	ich_pata_66 = 3,
	ich_pata_100 = 4,
	ich_pata_100_nomwdma1 = 5,
	ich5_sata = 6,
	ich6_sata = 7,
	ich6m_sata = 8,
	ich8_sata = 9,
	ich8_2port_sata = 10,
	ich8m_apple_sata = 11,
	tolapai_sata = 12,
	piix_pata_vmw = 13,
	ich8_sata_snb = 14,
	ich8_2port_sata_snb = 15,
	ich8_2port_sata_byt = 16,
};

struct piix_map_db {
	const u32 mask;
	const u16 port_enable;
	const int map[0];
};

struct piix_host_priv {
	const int *map;
	u32 saved_iocfg;
	void *sidpr;
};

enum {
	NV_MMIO_BAR = 5,
	NV_PORTS = 2,
	NV_PIO_MASK = 31,
	NV_MWDMA_MASK = 7,
	NV_UDMA_MASK = 127,
	NV_PORT0_SCR_REG_OFFSET = 0,
	NV_PORT1_SCR_REG_OFFSET = 64,
	NV_INT_STATUS = 16,
	NV_INT_ENABLE = 17,
	NV_INT_STATUS_CK804 = 1088,
	NV_INT_ENABLE_CK804 = 1089,
	NV_INT_DEV = 1,
	NV_INT_PM = 2,
	NV_INT_ADDED = 4,
	NV_INT_REMOVED = 8,
	NV_INT_PORT_SHIFT = 4,
	NV_INT_ALL = 15,
	NV_INT_MASK = 13,
	NV_INT_CONFIG = 18,
	NV_INT_CONFIG_METHD = 1,
	NV_MCP_SATA_CFG_20 = 80,
	NV_MCP_SATA_CFG_20_SATA_SPACE_EN = 4,
	NV_MCP_SATA_CFG_20_PORT0_EN = 131072,
	NV_MCP_SATA_CFG_20_PORT1_EN = 65536,
	NV_MCP_SATA_CFG_20_PORT0_PWB_EN = 16384,
	NV_MCP_SATA_CFG_20_PORT1_PWB_EN = 4096,
	NV_ADMA_MAX_CPBS = 32,
	NV_ADMA_CPB_SZ = 128,
	NV_ADMA_APRD_SZ = 16,
	NV_ADMA_SGTBL_LEN = 56,
	NV_ADMA_SGTBL_TOTAL_LEN = 61,
	NV_ADMA_SGTBL_SZ = 896,
	NV_ADMA_PORT_PRIV_DMA_SZ = 32768,
	NV_ADMA_GEN = 1024,
	NV_ADMA_GEN_CTL = 0,
	NV_ADMA_NOTIFIER_CLEAR = 48,
	NV_ADMA_PORT = 1152,
	NV_ADMA_PORT_SIZE = 256,
	NV_ADMA_CTL = 64,
	NV_ADMA_CPB_COUNT = 66,
	NV_ADMA_NEXT_CPB_IDX = 67,
	NV_ADMA_STAT = 68,
	NV_ADMA_CPB_BASE_LOW = 72,
	NV_ADMA_CPB_BASE_HIGH = 76,
	NV_ADMA_APPEND = 80,
	NV_ADMA_NOTIFIER = 104,
	NV_ADMA_NOTIFIER_ERROR = 108,
	NV_ADMA_CTL_HOTPLUG_IEN = 1,
	NV_ADMA_CTL_CHANNEL_RESET = 32,
	NV_ADMA_CTL_GO = 128,
	NV_ADMA_CTL_AIEN = 256,
	NV_ADMA_CTL_READ_NON_COHERENT = 2048,
	NV_ADMA_CTL_WRITE_NON_COHERENT = 4096,
	NV_CPB_RESP_DONE = 1,
	NV_CPB_RESP_ATA_ERR = 8,
	NV_CPB_RESP_CMD_ERR = 16,
	NV_CPB_RESP_CPB_ERR = 128,
	NV_CPB_CTL_CPB_VALID = 1,
	NV_CPB_CTL_QUEUE = 2,
	NV_CPB_CTL_APRD_VALID = 4,
	NV_CPB_CTL_IEN = 8,
	NV_CPB_CTL_FPDMA = 16,
	NV_APRD_WRITE = 2,
	NV_APRD_END = 4,
	NV_APRD_CONT = 8,
	NV_ADMA_STAT_TIMEOUT = 1,
	NV_ADMA_STAT_HOTUNPLUG = 2,
	NV_ADMA_STAT_HOTPLUG = 4,
	NV_ADMA_STAT_CPBERR = 16,
	NV_ADMA_STAT_SERROR = 32,
	NV_ADMA_STAT_CMD_COMPLETE = 64,
	NV_ADMA_STAT_IDLE = 256,
	NV_ADMA_STAT_LEGACY = 512,
	NV_ADMA_STAT_STOPPED = 1024,
	NV_ADMA_STAT_DONE = 4096,
	NV_ADMA_STAT_ERR = 17,
	NV_ADMA_PORT_REGISTER_MODE = 1,
	NV_ADMA_ATAPI_SETUP_COMPLETE = 2,
	NV_CTL_MCP55 = 1024,
	NV_INT_STATUS_MCP55 = 1088,
	NV_INT_ENABLE_MCP55 = 1092,
	NV_NCQ_REG_MCP55 = 1096,
	NV_INT_ALL_MCP55 = 65535,
	NV_INT_PORT_SHIFT_MCP55 = 16,
	NV_INT_MASK_MCP55 = 65533,
	NV_CTL_PRI_SWNCQ = 2,
	NV_CTL_SEC_SWNCQ = 4,
	NV_SWNCQ_IRQ_DEV = 1,
	NV_SWNCQ_IRQ_PM = 2,
	NV_SWNCQ_IRQ_ADDED = 4,
	NV_SWNCQ_IRQ_REMOVED = 8,
	NV_SWNCQ_IRQ_BACKOUT = 16,
	NV_SWNCQ_IRQ_SDBFIS = 32,
	NV_SWNCQ_IRQ_DHREGFIS = 64,
	NV_SWNCQ_IRQ_DMASETUP = 128,
	NV_SWNCQ_IRQ_HOTPLUG = 12,
};

struct nv_adma_prd {
	__le64 addr;
	__le32 len;
	u8 flags;
	u8 packet_len;
	__le16 reserved;
};

enum nv_adma_regbits {
	CMDEND = 32768,
	WNB = 16384,
	IGN = 8192,
	CS1n = 4096,
	DA2 = 1024,
	DA1 = 512,
	DA0 = 256,
};

struct nv_adma_cpb {
	u8 resp_flags;
	u8 reserved1;
	u8 ctl_flags;
	u8 len;
	u8 tag;
	u8 next_cpb_idx;
	__le16 reserved2;
	__le16 tf[12];
	struct nv_adma_prd aprd[5];
	__le64 next_aprd;
	__le64 reserved3;
};

struct nv_adma_port_priv {
	struct nv_adma_cpb *cpb;
	dma_addr_t cpb_dma;
	struct nv_adma_prd *aprd;
	dma_addr_t aprd_dma;
	void *ctl_block;
	void *gen_block;
	void *notifier_clear_block;
	u64 adma_dma_mask;
	u8 flags;
	int last_issue_ncq;
};

struct nv_host_priv {
	long unsigned int type;
};

struct defer_queue {
	u32 defer_bits;
	unsigned int head;
	unsigned int tail;
	unsigned int tag[32];
};

enum ncq_saw_flag_list {
	ncq_saw_d2h = 1,
	ncq_saw_dmas = 2,
	ncq_saw_sdb = 4,
	ncq_saw_backout = 8,
};

struct nv_swncq_port_priv {
	struct ata_bmdma_prd *prd;
	dma_addr_t prd_dma;
	void *sactive_block;
	void *irq_block;
	void *tag_block;
	u32 qc_active;
	unsigned int last_issue_tag;
	struct defer_queue defer_queue;
	u32 dhfis_bits;
	u32 dmafis_bits;
	u32 sdbfis_bits;
	unsigned int ncq_flags;
};

enum nv_host_type {
	GENERIC = 0,
	NFORCE2 = 1,
	NFORCE3 = 1,
	CK804 = 2,
	ADMA = 3,
	MCP5x = 4,
	SWNCQ = 5,
};

struct nv_pi_priv {
	irq_handler_t irq_handler;
	struct scsi_host_template *sht;
};

enum {
	SIL_MMIO_BAR = 5,
	SIL_FLAG_NO_SATA_IRQ = 268435456,
	SIL_FLAG_RERR_ON_DMA_ACT = 536870912,
	SIL_FLAG_MOD15WRITE = 1073741824,
	SIL_DFL_PORT_FLAGS = 2,
	sil_3112 = 0,
	sil_3112_no_sata_irq = 1,
	sil_3512 = 2,
	sil_3114 = 3,
	SIL_SYSCFG = 72,
	SIL_MASK_IDE0_INT = 4194304,
	SIL_MASK_IDE1_INT = 8388608,
	SIL_MASK_IDE2_INT = 16777216,
	SIL_MASK_IDE3_INT = 33554432,
	SIL_MASK_2PORT = 12582912,
	SIL_MASK_4PORT = 62914560,
	SIL_INTR_STEERING = 2,
	SIL_DMA_ENABLE = 1,
	SIL_DMA_RDWR = 8,
	SIL_DMA_SATA_IRQ = 16,
	SIL_DMA_ACTIVE = 65536,
	SIL_DMA_ERROR = 131072,
	SIL_DMA_COMPLETE = 262144,
	SIL_DMA_N_SATA_IRQ = 64,
	SIL_DMA_N_ACTIVE = 16777216,
	SIL_DMA_N_ERROR = 33554432,
	SIL_DMA_N_COMPLETE = 67108864,
	SIL_SIEN_N = 65536,
	SIL_QUIRK_MOD15WRITE = 1,
	SIL_QUIRK_UDMA5MAX = 2,
};

struct sil_drivelist {
	const char *product;
	unsigned int quirk;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mdio_if_info {
	int prtad;
	u32 mmds;
	unsigned int mode_support;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int, u16);
	int (*mdio_write)(struct net_device *, int, int, u16, u16);
};

struct devprobe2 {
	struct net_device * (*probe)(int);
	int status;
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETDEV_FEATURE_COUNT = 59,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_DEV_ZEROCOPY = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_SHARED_FRAG = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	__ETHTOOL_MSG_KERNEL_CNT = 30,
	ETHTOOL_MSG_KERNEL_MAX = 29,
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[28];
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info {
	void (*callback)(struct ubuf_info *, bool);
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	refcount_t refcnt;
	struct mmpin mmp;
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	long unsigned int last_probe;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 2;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
	atomic_t fib_rt_uncache;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_node *subtree;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

enum {
	IFLA_TUN_UNSPEC = 0,
	IFLA_TUN_OWNER = 1,
	IFLA_TUN_GROUP = 2,
	IFLA_TUN_TYPE = 3,
	IFLA_TUN_PI = 4,
	IFLA_TUN_VNET_HDR = 5,
	IFLA_TUN_PERSIST = 6,
	IFLA_TUN_MULTI_QUEUE = 7,
	IFLA_TUN_NUM_QUEUES = 8,
	IFLA_TUN_NUM_DISABLED_QUEUES = 9,
	__IFLA_TUN_MAX = 10,
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	int defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	int poll_owner;
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct rps_sock_flow_table {
	u32 mask;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct tun_pi {
	__u16 flags;
	__be16 proto;
};

struct tun_filter {
	__u16 flags;
	__u16 count;
	__u8 addr[0];
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct tun_msg_ctl {
	short unsigned int type;
	short unsigned int num;
	void *ptr;
};

struct tun_xdp_hdr {
	int buflen;
	struct virtio_net_hdr gso;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__u32 nh_tclassid;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	int fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	atomic_t upper_bound;
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool mpath;
	bool fdb_nh;
	bool has_v4;
	struct nh_grp_entry nh_entries[0];
};

struct tap_filter {
	unsigned int count;
	u32 mask[2];
	unsigned char addr[48];
};

struct tun_struct;

struct tun_file {
	struct sock sk;
	long: 64;
	long: 64;
	struct socket socket;
	struct tun_struct *tun;
	struct fasync_struct *fasync;
	unsigned int flags;
	union {
		u16 queue_index;
		unsigned int ifindex;
	};
	struct napi_struct napi;
	bool napi_enabled;
	bool napi_frags_enabled;
	struct mutex napi_mutex;
	struct list_head next;
	struct tun_struct *detached;
	struct ptr_ring tx_ring;
	struct xdp_rxq_info xdp_rxq;
};

struct tun_prog;

struct tun_struct {
	struct tun_file *tfiles[256];
	unsigned int numqueues;
	unsigned int flags;
	kuid_t owner;
	kgid_t group;
	struct net_device *dev;
	netdev_features_t set_features;
	int align;
	int vnet_hdr_sz;
	int sndbuf;
	struct tap_filter txflt;
	struct sock_fprog fprog;
	bool filter_attached;
	u32 msg_enable;
	spinlock_t lock;
	struct hlist_head flows[1024];
	struct timer_list flow_gc_timer;
	long unsigned int ageing_time;
	unsigned int numdisabled;
	struct list_head disabled;
	void *security;
	u32 flow_count;
	u32 rx_batched;
	atomic_long_t rx_frame_errors;
	struct bpf_prog *xdp_prog;
	struct tun_prog *steering_prog;
	struct tun_prog *filter_prog;
	struct ethtool_link_ksettings link_ksettings;
};

struct tun_page {
	struct page *page;
	int count;
};

struct tun_flow_entry {
	struct hlist_node hash_link;
	struct callback_head rcu;
	struct tun_struct *tun;
	u32 rxhash;
	u32 rps_rxhash;
	int queue_index;
	long: 32;
	long: 64;
	long unsigned int updated;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tun_prog {
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct veth {
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_COUNT = 16,
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	__XFRMA_MAX = 32,
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	__IFLA_MAX = 56,
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_state_offload {
	struct net_device *dev;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	unsigned int num_exthdrs;
	u8 flags;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_replay;

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	const struct xfrm_replay *repl;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_state_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
};

struct xfrm_policy_walk_entry {
	struct list_head all;
	u8 dead;
};

struct xfrm_policy_queue {
	struct sk_buff_head hold_queue;
	struct timer_list hold_timer;
	long unsigned int timeout;
};

struct xfrm_tmpl {
	struct xfrm_id id;
	xfrm_address_t saddr;
	short unsigned int encap_family;
	u32 reqid;
	u8 mode;
	u8 share;
	u8 optional;
	u8 allalgs;
	u32 aalgos;
	u32 ealgos;
	u32 calgos;
};

struct xfrm_policy {
	possible_net_t xp_net;
	struct hlist_node bydst;
	struct hlist_node byidx;
	rwlock_t lock;
	refcount_t refcnt;
	u32 pos;
	struct timer_list timer;
	atomic_t genid;
	u32 priority;
	u32 index;
	u32 if_id;
	struct xfrm_mark mark;
	struct xfrm_selector selector;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_policy_walk_entry walk;
	struct xfrm_policy_queue polq;
	bool bydst_reinsert;
	u8 type;
	u8 action;
	u8 flags;
	u8 xfrm_nr;
	u16 family;
	struct xfrm_sec_ctx *security;
	struct xfrm_tmpl xfrm_vec[6];
	struct hlist_node bydst_inexact_list;
	struct callback_head rcu;
};

struct xfrm_replay {
	void (*advance)(struct xfrm_state *, __be32);
	int (*check)(struct xfrm_state *, struct sk_buff *, __be32);
	int (*recheck)(struct xfrm_state *, struct sk_buff *, __be32);
	void (*notify)(struct xfrm_state *, int);
	int (*overflow)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_type {
	char *description;
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
	int (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **);
};

struct xfrm_type_offload {
	char *description;
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

enum {
	VETH_INFO_UNSPEC = 0,
	VETH_INFO_PEER = 1,
	__VETH_INFO_MAX = 2,
};

struct veth_stats {
	u64 rx_drops;
	u64 xdp_packets;
	u64 xdp_bytes;
	u64 xdp_redirect;
	u64 xdp_drops;
	u64 xdp_tx;
	u64 xdp_tx_err;
	u64 peer_tq_xdp_xmit;
	u64 peer_tq_xdp_xmit_err;
};

struct veth_rq_stats {
	struct veth_stats vs;
	struct u64_stats_sync syncp;
};

struct veth_rq {
	struct napi_struct xdp_napi;
	struct net_device *dev;
	struct bpf_prog *xdp_prog;
	struct xdp_mem_info xdp_mem;
	struct veth_rq_stats stats;
	bool rx_notify_masked;
	long: 56;
	long: 64;
	long: 64;
	struct ptr_ring xdp_ring;
	struct xdp_rxq_info xdp_rxq;
};

struct veth_priv {
	struct net_device *peer;
	atomic64_t dropped;
	struct bpf_prog *_xdp_prog;
	struct veth_rq *rq;
	unsigned int requested_headroom;
};

struct veth_xdp_tx_bq {
	struct xdp_frame *q[16];
	unsigned int count;
};

struct veth_q_stat_desc {
	char desc[32];
	size_t offset;
};

struct netdev_hw_addr {
	struct list_head list;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct {
		u16 recursion;
		u8 more;
	} xmit;
	int: 32;
	unsigned int input_queue_head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	long: 64;
};

struct virtio_net_config {
	__u8 mac[6];
	__virtio16 status;
	__virtio16 max_virtqueue_pairs;
	__virtio16 mtu;
	__le32 speed;
	__u8 duplex;
	__u8 rss_max_key_size;
	__le16 rss_max_indirection_table_length;
	__le32 supported_hash_types;
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

typedef __u8 virtio_net_ctrl_ack;

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct failover {
	struct list_head list;
	struct net_device *failover_dev;
	struct failover_ops *ops;
};

struct ewma_pkt_len {
	long unsigned int internal;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 xdp_tx;
	u64 xdp_tx_drops;
	u64 kicks;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 drops;
	u64 xdp_packets;
	u64 xdp_tx;
	u64 xdp_redirects;
	u64 xdp_drops;
	u64 kicks;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[40];
	struct virtnet_sq_stats stats;
	struct napi_struct napi;
};

struct receive_queue {
	struct virtqueue *vq;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct virtnet_rq_stats stats;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[40];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
	struct virtio_net_ctrl_mq mq;
	u8 promisc;
	u8 allmulti;
	__virtio16 vid;
	__virtio64 offloads;
};

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool big_packets;
	bool mergeable_rx_bufs;
	bool has_cvq;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	struct work_struct config_work;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	long unsigned int guest_offloads;
	long unsigned int guest_offloads_capable;
	struct failover *failover;
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	__NDA_MAX = 15,
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

enum {
	IFLA_VXLAN_UNSPEC = 0,
	IFLA_VXLAN_ID = 1,
	IFLA_VXLAN_GROUP = 2,
	IFLA_VXLAN_LINK = 3,
	IFLA_VXLAN_LOCAL = 4,
	IFLA_VXLAN_TTL = 5,
	IFLA_VXLAN_TOS = 6,
	IFLA_VXLAN_LEARNING = 7,
	IFLA_VXLAN_AGEING = 8,
	IFLA_VXLAN_LIMIT = 9,
	IFLA_VXLAN_PORT_RANGE = 10,
	IFLA_VXLAN_PROXY = 11,
	IFLA_VXLAN_RSC = 12,
	IFLA_VXLAN_L2MISS = 13,
	IFLA_VXLAN_L3MISS = 14,
	IFLA_VXLAN_PORT = 15,
	IFLA_VXLAN_GROUP6 = 16,
	IFLA_VXLAN_LOCAL6 = 17,
	IFLA_VXLAN_UDP_CSUM = 18,
	IFLA_VXLAN_UDP_ZERO_CSUM6_TX = 19,
	IFLA_VXLAN_UDP_ZERO_CSUM6_RX = 20,
	IFLA_VXLAN_REMCSUM_TX = 21,
	IFLA_VXLAN_REMCSUM_RX = 22,
	IFLA_VXLAN_GBP = 23,
	IFLA_VXLAN_REMCSUM_NOPARTIAL = 24,
	IFLA_VXLAN_COLLECT_METADATA = 25,
	IFLA_VXLAN_LABEL = 26,
	IFLA_VXLAN_GPE = 27,
	IFLA_VXLAN_TTL_INHERIT = 28,
	IFLA_VXLAN_DF = 29,
	__IFLA_VXLAN_MAX = 30,
};

struct ifla_vxlan_port_range {
	__be16 low;
	__be16 high;
};

enum ifla_vxlan_df {
	VXLAN_DF_UNSET = 0,
	VXLAN_DF_SET = 1,
	VXLAN_DF_INHERIT = 2,
	__VXLAN_DF_END = 3,
	VXLAN_DF_MAX = 2,
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 gro_remcsum_start;
	long unsigned int age;
	u16 proto;
	u8 same_flow: 1;
	u8 encap_mark: 1;
	u8 csum_valid: 1;
	u8 csum_cnt: 3;
	u8 free: 2;
	u8 is_ipv6: 1;
	u8 is_fou: 1;
	u8 is_atomic: 1;
	u8 recursion_counter: 4;
	u8 is_flist: 1;
	__wsum csum;
	struct sk_buff *last;
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

struct gro_remcsum {
	int offset;
	__wsum delta;
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	__RTNLGRP_MAX = 34,
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

struct ip_sf_socklist;

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct fib6_result;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	void (*xfrm6_local_rxpmtu)(struct sk_buff *, u32);
	int (*xfrm6_udp_encap_rcv)(struct sock *, struct sk_buff *);
	int (*xfrm6_rcv_encap)(struct sk_buff *, int, __be32, int);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u8 weight;
	u32 id;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	bool is_grp;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
	};
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
	long: 64;
};

struct udp_port_cfg {
	u8 family;
	union {
		struct in_addr local_ip;
		struct in6_addr local_ip6;
	};
	union {
		struct in_addr peer_ip;
		struct in6_addr peer_ip6;
	};
	__be16 local_udp_port;
	__be16 peer_udp_port;
	int bind_ifindex;
	unsigned int use_udp_checksums: 1;
	unsigned int use_udp6_tx_checksums: 1;
	unsigned int use_udp6_rx_checksums: 1;
	unsigned int ipv6_v6only: 1;
};

typedef int (*udp_tunnel_encap_rcv_t)(struct sock *, struct sk_buff *);

typedef int (*udp_tunnel_encap_err_lookup_t)(struct sock *, struct sk_buff *);

typedef void (*udp_tunnel_encap_destroy_t)(struct sock *);

typedef struct sk_buff * (*udp_tunnel_gro_receive_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef int (*udp_tunnel_gro_complete_t)(struct sock *, struct sk_buff *, int);

struct udp_tunnel_sock_cfg {
	void *sk_user_data;
	__u8 encap_type;
	udp_tunnel_encap_rcv_t encap_rcv;
	udp_tunnel_encap_err_lookup_t encap_err_lookup;
	udp_tunnel_encap_destroy_t encap_destroy;
	udp_tunnel_gro_receive_t gro_receive;
	udp_tunnel_gro_complete_t gro_complete;
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
	} u;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct vxlanhdr {
	__be32 vx_flags;
	__be32 vx_vni;
};

struct vxlanhdr_gbp {
	u8 vx_flags;
	u8 reserved_flags1: 3;
	u8 policy_applied: 1;
	u8 reserved_flags2: 2;
	u8 dont_learn: 1;
	u8 reserved_flags3: 1;
	__be16 policy_id;
	__be32 vx_vni;
};

struct vxlanhdr_gpe {
	u8 oam_flag: 1;
	u8 reserved_flags1: 1;
	u8 np_applied: 1;
	u8 instance_applied: 1;
	u8 version: 2;
	u8 reserved_flags2: 2;
	u8 reserved_flags3;
	u8 reserved_flags4;
	u8 next_protocol;
	__be32 vx_vni;
};

struct vxlan_metadata {
	u32 gbp;
};

struct vxlan_sock {
	struct hlist_node hlist;
	struct socket *sock;
	struct hlist_head vni_list[1024];
	refcount_t refcnt;
	u32 flags;
};

union vxlan_addr {
	struct sockaddr_in sin;
	struct sockaddr_in6 sin6;
	struct sockaddr sa;
};

struct vxlan_rdst {
	union vxlan_addr remote_ip;
	__be16 remote_port;
	u8 offloaded: 1;
	__be32 remote_vni;
	u32 remote_ifindex;
	struct net_device *remote_dev;
	struct list_head list;
	struct callback_head rcu;
	struct dst_cache dst_cache;
};

struct vxlan_config {
	union vxlan_addr remote_ip;
	union vxlan_addr saddr;
	__be32 vni;
	int remote_ifindex;
	int mtu;
	__be16 dst_port;
	u16 port_min;
	u16 port_max;
	u8 tos;
	u8 ttl;
	__be32 label;
	u32 flags;
	long unsigned int age_interval;
	unsigned int addrmax;
	bool no_share;
	enum ifla_vxlan_df df;
};

struct vxlan_dev;

struct vxlan_dev_node {
	struct hlist_node hlist;
	struct vxlan_dev *vxlan;
};

struct vxlan_dev {
	struct vxlan_dev_node hlist4;
	struct vxlan_dev_node hlist6;
	struct list_head next;
	struct vxlan_sock *vn4_sock;
	struct vxlan_sock *vn6_sock;
	struct net_device *dev;
	struct net *net;
	struct vxlan_rdst default_dst;
	struct timer_list age_timer;
	spinlock_t hash_lock[256];
	unsigned int addrcnt;
	struct gro_cells gro_cells;
	struct vxlan_config cfg;
	struct hlist_head fdb_head[256];
};

struct switchdev_notifier_vxlan_fdb_info {
	struct switchdev_notifier_info info;
	union vxlan_addr remote_ip;
	__be16 remote_port;
	__be32 remote_vni;
	u32 remote_ifindex;
	u8 eth_addr[6];
	__be32 vni;
	bool offloaded;
	bool added_by_user;
};

struct vxlan_net {
	struct list_head vxlan_list;
	struct hlist_head sock_list[256];
	spinlock_t sock_lock;
	struct notifier_block nexthop_notifier_block;
};

struct vxlan_fdb {
	struct hlist_node hlist;
	struct callback_head rcu;
	long unsigned int updated;
	long unsigned int used;
	struct list_head remotes;
	u8 eth_addr[6];
	u16 state;
	__be32 vni;
	u16 flags;
	struct list_head nh_list;
	struct nexthop *nh;
	struct vxlan_dev *vdev;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

typedef enum {
	e1000_undefined = 0,
	e1000_82542_rev2_0 = 1,
	e1000_82542_rev2_1 = 2,
	e1000_82543 = 3,
	e1000_82544 = 4,
	e1000_82540 = 5,
	e1000_82545 = 6,
	e1000_82545_rev_3 = 7,
	e1000_82546 = 8,
	e1000_ce4100 = 9,
	e1000_82546_rev_3 = 10,
	e1000_82541 = 11,
	e1000_82541_rev_2 = 12,
	e1000_82547 = 13,
	e1000_82547_rev_2 = 14,
	e1000_num_macs = 15,
} e1000_mac_type;

typedef enum {
	e1000_eeprom_uninitialized = 0,
	e1000_eeprom_spi = 1,
	e1000_eeprom_microwire = 2,
	e1000_eeprom_flash = 3,
	e1000_eeprom_none = 4,
	e1000_num_eeprom_types = 5,
} e1000_eeprom_type;

typedef enum {
	e1000_media_type_copper = 0,
	e1000_media_type_fiber = 1,
	e1000_media_type_internal_serdes = 2,
	e1000_num_media_types = 3,
} e1000_media_type;

enum {
	e1000_10_half = 0,
	e1000_10_full = 1,
	e1000_100_half = 2,
	e1000_100_full = 3,
};

typedef enum {
	E1000_FC_NONE = 0,
	E1000_FC_RX_PAUSE = 1,
	E1000_FC_TX_PAUSE = 2,
	E1000_FC_FULL = 3,
	E1000_FC_DEFAULT = 255,
} e1000_fc_type;

struct e1000_shadow_ram {
	u16 eeprom_word;
	bool modified;
};

typedef enum {
	e1000_bus_type_unknown = 0,
	e1000_bus_type_pci = 1,
	e1000_bus_type_pcix = 2,
	e1000_bus_type_reserved = 3,
} e1000_bus_type;

typedef enum {
	e1000_bus_speed_unknown = 0,
	e1000_bus_speed_33 = 1,
	e1000_bus_speed_66 = 2,
	e1000_bus_speed_100 = 3,
	e1000_bus_speed_120 = 4,
	e1000_bus_speed_133 = 5,
	e1000_bus_speed_reserved = 6,
} e1000_bus_speed;

typedef enum {
	e1000_bus_width_unknown = 0,
	e1000_bus_width_32 = 1,
	e1000_bus_width_64 = 2,
	e1000_bus_width_reserved = 3,
} e1000_bus_width;

typedef enum {
	e1000_cable_length_50 = 0,
	e1000_cable_length_50_80 = 1,
	e1000_cable_length_80_110 = 2,
	e1000_cable_length_110_140 = 3,
	e1000_cable_length_140 = 4,
	e1000_cable_length_undefined = 255,
} e1000_cable_length;

typedef enum {
	e1000_10bt_ext_dist_enable_normal = 0,
	e1000_10bt_ext_dist_enable_lower = 1,
	e1000_10bt_ext_dist_enable_undefined = 255,
} e1000_10bt_ext_dist_enable;

typedef enum {
	e1000_rev_polarity_normal = 0,
	e1000_rev_polarity_reversed = 1,
	e1000_rev_polarity_undefined = 255,
} e1000_rev_polarity;

typedef enum {
	e1000_downshift_normal = 0,
	e1000_downshift_activated = 1,
	e1000_downshift_undefined = 255,
} e1000_downshift;

typedef enum {
	e1000_smart_speed_default = 0,
	e1000_smart_speed_on = 1,
	e1000_smart_speed_off = 2,
} e1000_smart_speed;

typedef enum {
	e1000_polarity_reversal_enabled = 0,
	e1000_polarity_reversal_disabled = 1,
	e1000_polarity_reversal_undefined = 255,
} e1000_polarity_reversal;

typedef enum {
	e1000_auto_x_mode_manual_mdi = 0,
	e1000_auto_x_mode_manual_mdix = 1,
	e1000_auto_x_mode_auto1 = 2,
	e1000_auto_x_mode_auto2 = 3,
	e1000_auto_x_mode_undefined = 255,
} e1000_auto_x_mode;

typedef enum {
	e1000_1000t_rx_status_not_ok = 0,
	e1000_1000t_rx_status_ok = 1,
	e1000_1000t_rx_status_undefined = 255,
} e1000_1000t_rx_status;

typedef enum {
	e1000_phy_m88 = 0,
	e1000_phy_igp = 1,
	e1000_phy_8211 = 2,
	e1000_phy_8201 = 3,
	e1000_phy_undefined = 255,
} e1000_phy_type;

typedef enum {
	e1000_ms_hw_default = 0,
	e1000_ms_force_master = 1,
	e1000_ms_force_slave = 2,
	e1000_ms_auto = 3,
} e1000_ms_type;

typedef enum {
	e1000_ffe_config_enabled = 0,
	e1000_ffe_config_active = 1,
	e1000_ffe_config_blocked = 2,
} e1000_ffe_config;

typedef enum {
	e1000_dsp_config_disabled = 0,
	e1000_dsp_config_enabled = 1,
	e1000_dsp_config_activated = 2,
	e1000_dsp_config_undefined = 255,
} e1000_dsp_config;

struct e1000_phy_info {
	e1000_cable_length cable_length;
	e1000_10bt_ext_dist_enable extended_10bt_distance;
	e1000_rev_polarity cable_polarity;
	e1000_downshift downshift;
	e1000_polarity_reversal polarity_correction;
	e1000_auto_x_mode mdix_mode;
	e1000_1000t_rx_status local_rx;
	e1000_1000t_rx_status remote_rx;
};

struct e1000_phy_stats {
	u32 idle_errors;
	u32 receive_errors;
};

struct e1000_eeprom_info {
	e1000_eeprom_type type;
	u16 word_size;
	u16 opcode_bits;
	u16 address_bits;
	u16 delay_usec;
	u16 page_size;
};

struct e1000_host_mng_dhcp_cookie {
	u32 signature;
	u8 status;
	u8 reserved0;
	u16 vlan_id;
	u32 reserved1;
	u16 reserved2;
	u8 reserved3;
	u8 checksum;
};

struct e1000_rx_desc {
	__le64 buffer_addr;
	__le16 length;
	__le16 csum;
	u8 status;
	u8 errors;
	__le16 special;
};

struct e1000_tx_desc {
	__le64 buffer_addr;
	union {
		__le32 data;
		struct {
			__le16 length;
			u8 cso;
			u8 cmd;
		} flags;
	} lower;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 css;
			__le16 special;
		} fields;
	} upper;
};

struct e1000_context_desc {
	union {
		__le32 ip_config;
		struct {
			u8 ipcss;
			u8 ipcso;
			__le16 ipcse;
		} ip_fields;
	} lower_setup;
	union {
		__le32 tcp_config;
		struct {
			u8 tucss;
			u8 tucso;
			__le16 tucse;
		} tcp_fields;
	} upper_setup;
	__le32 cmd_and_length;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 hdr_len;
			__le16 mss;
		} fields;
	} tcp_seg_setup;
};

struct e1000_hw_stats {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 txerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorcl;
	u64 gorch;
	u64 gotcl;
	u64 gotch;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rlerrc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 torl;
	u64 torh;
	u64 totl;
	u64 toth;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

struct e1000_hw {
	u8 *hw_addr;
	u8 *flash_address;
	void *ce4100_gbe_mdio_base_virt;
	e1000_mac_type mac_type;
	e1000_phy_type phy_type;
	u32 phy_init_script;
	e1000_media_type media_type;
	void *back;
	struct e1000_shadow_ram *eeprom_shadow_ram;
	u32 flash_bank_size;
	u32 flash_base_addr;
	e1000_fc_type fc;
	e1000_bus_speed bus_speed;
	e1000_bus_width bus_width;
	e1000_bus_type bus_type;
	struct e1000_eeprom_info eeprom;
	e1000_ms_type master_slave;
	e1000_ms_type original_master_slave;
	e1000_ffe_config ffe_config_state;
	u32 asf_firmware_present;
	u32 eeprom_semaphore_present;
	long unsigned int io_base;
	u32 phy_id;
	u32 phy_revision;
	u32 phy_addr;
	u32 original_fc;
	u32 txcw;
	u32 autoneg_failed;
	u32 max_frame_size;
	u32 min_frame_size;
	u32 mc_filter_type;
	u32 num_mc_addrs;
	u32 collision_delta;
	u32 tx_packet_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	bool tx_pkt_filtering;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	u16 phy_spd_default;
	u16 autoneg_advertised;
	u16 pci_cmd_word;
	u16 fc_high_water;
	u16 fc_low_water;
	u16 fc_pause_time;
	u16 current_ifs_val;
	u16 ifs_min_val;
	u16 ifs_max_val;
	u16 ifs_step_size;
	u16 ifs_ratio;
	u16 device_id;
	u16 vendor_id;
	u16 subsystem_id;
	u16 subsystem_vendor_id;
	u8 revision_id;
	u8 autoneg;
	u8 mdix;
	u8 forced_speed_duplex;
	u8 wait_autoneg_complete;
	u8 dma_fairness;
	u8 mac_addr[6];
	u8 perm_mac_addr[6];
	bool disable_polarity_correction;
	bool speed_downgraded;
	e1000_smart_speed smart_speed;
	e1000_dsp_config dsp_config_state;
	bool get_link_status;
	bool serdes_has_link;
	bool tbi_compatibility_en;
	bool tbi_compatibility_on;
	bool laa_is_present;
	bool phy_reset_disable;
	bool initialize_hw_bits_disable;
	bool fc_send_xon;
	bool fc_strict_ieee;
	bool report_tx_early;
	bool adaptive_ifs;
	bool ifs_params_forced;
	bool in_ifs_mode;
	bool mng_reg_access_disabled;
	bool leave_av_bit_off;
	bool bad_tx_carr_stats_fd;
	bool has_smbus;
};

struct e1000_tx_buffer {
	struct sk_buff *skb;
	dma_addr_t dma;
	long unsigned int time_stamp;
	u16 length;
	u16 next_to_watch;
	bool mapped_as_page;
	short unsigned int segs;
	unsigned int bytecount;
};

struct e1000_rx_buffer {
	union {
		struct page *page;
		u8 *data;
	} rxbuf;
	dma_addr_t dma;
};

struct e1000_tx_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct e1000_tx_buffer *buffer_info;
	u16 tdh;
	u16 tdt;
	bool last_tx_tso;
};

struct e1000_rx_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct e1000_rx_buffer *buffer_info;
	struct sk_buff *rx_skb_top;
	int cpu;
	u16 rdh;
	u16 rdt;
};

struct e1000_adapter {
	long unsigned int active_vlans[64];
	u16 mng_vlan_id;
	u32 bd_number;
	u32 rx_buffer_len;
	u32 wol;
	u32 smartspeed;
	u32 en_mng_pt;
	u16 link_speed;
	u16 link_duplex;
	spinlock_t stats_lock;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	u8 fc_autoneg;
	struct e1000_tx_ring *tx_ring;
	unsigned int restart_queue;
	u32 txd_cmd;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	u32 gotcl;
	u64 gotcl_old;
	u64 tpt_old;
	u64 colc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u8 tx_timeout_factor;
	atomic_t tx_fifo_stall;
	bool pcix_82544;
	bool detect_tx_hung;
	bool dump_buffers;
	bool (*clean_rx)(struct e1000_adapter *, struct e1000_rx_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_adapter *, struct e1000_rx_ring *, int);
	struct e1000_rx_ring *rx_ring;
	struct napi_struct napi;
	int num_tx_queues;
	int num_rx_queues;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u32 alloc_rx_buff_failed;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	bool rx_csum;
	u32 gorcl;
	u64 gorcl_old;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw hw;
	struct e1000_hw_stats stats;
	struct e1000_phy_info phy_info;
	struct e1000_phy_stats phy_stats;
	u32 test_icr;
	struct e1000_tx_ring test_tx_ring;
	struct e1000_rx_ring test_rx_ring;
	int msg_enable;
	bool tso_force;
	bool smart_power_down;
	bool quad_port_a;
	long unsigned int flags;
	u32 eeprom_wol;
	int bars;
	int need_ioport;
	bool discarding;
	struct work_struct reset_task;
	struct delayed_work watchdog_task;
	struct delayed_work fifo_stall_task;
	struct delayed_work phy_info_task;
};

enum e1000_state_t {
	__E1000_TESTING = 0,
	__E1000_RESETTING = 1,
	__E1000_DOWN = 2,
	__E1000_DISABLED = 3,
};

enum latency_range {
	lowest_latency = 0,
	low_latency = 1,
	bulk_latency = 2,
	latency_invalid = 255,
};

struct my_u {
	__le64 a;
	__le64 b;
};

enum {
	e1000_igp_cable_length_10 = 10,
	e1000_igp_cable_length_20 = 20,
	e1000_igp_cable_length_30 = 30,
	e1000_igp_cable_length_40 = 40,
	e1000_igp_cable_length_50 = 50,
	e1000_igp_cable_length_60 = 60,
	e1000_igp_cable_length_70 = 70,
	e1000_igp_cable_length_80 = 80,
	e1000_igp_cable_length_90 = 90,
	e1000_igp_cable_length_100 = 100,
	e1000_igp_cable_length_110 = 110,
	e1000_igp_cable_length_115 = 115,
	e1000_igp_cable_length_120 = 120,
	e1000_igp_cable_length_130 = 130,
	e1000_igp_cable_length_140 = 140,
	e1000_igp_cable_length_150 = 150,
	e1000_igp_cable_length_160 = 160,
	e1000_igp_cable_length_170 = 170,
	e1000_igp_cable_length_180 = 180,
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

enum {
	NETDEV_STATS = 0,
	E1000_STATS = 1,
};

struct e1000_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

struct e1000_opt_list {
	int i;
	char *str;
};

struct e1000_option {
	enum {
		enable_option = 0,
		range_option = 1,
		list_option = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			const struct e1000_opt_list *p;
		} l;
	} arg;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum macvlan_mode {
	MACVLAN_MODE_PRIVATE = 1,
	MACVLAN_MODE_VEPA = 2,
	MACVLAN_MODE_BRIDGE = 4,
	MACVLAN_MODE_PASSTHRU = 8,
	MACVLAN_MODE_SOURCE = 16,
};

enum {
	TC_MQPRIO_HW_OFFLOAD_NONE = 0,
	TC_MQPRIO_HW_OFFLOAD_TCS = 1,
	__TC_MQPRIO_HW_OFFLOAD_MAX = 2,
};

struct tc_mqprio_qopt {
	__u8 num_tc;
	__u8 prio_tc_map[16];
	__u8 hw;
	__u16 count[16];
	__u16 offset[16];
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct tc_u32_key {
	__be32 mask;
	__be32 val;
	int off;
	int offmask;
};

struct tc_u32_sel {
	unsigned char flags;
	unsigned char offshift;
	unsigned char nkeys;
	__be16 offmask;
	__u16 off;
	short int offoff;
	short int hoff;
	__be32 hmask;
	struct tc_u32_key keys[0];
};

struct xdp_umem;

struct xsk_queue;

struct xdp_buff_xsk;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	u32 heads_cnt;
	u16 queue_id;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct vlan_ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct vlan_pcpu_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_multicast;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

struct macvlan_port;

struct netpoll;

struct macvlan_dev {
	struct net_device *dev;
	struct list_head list;
	struct hlist_node hlist;
	struct macvlan_port *port;
	struct net_device *lowerdev;
	void *accel_priv;
	struct vlan_pcpu_stats *pcpu_stats;
	long unsigned int mc_filter[4];
	netdev_features_t set_features;
	enum macvlan_mode mode;
	u16 flags;
	unsigned int macaddr_count;
	struct netpoll *netpoll;
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	__IFLA_BRIDGE_MAX = 6,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_packed tcfa_bstats;
	struct gnet_stats_basic_packed tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_basic_cpu *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
};

typedef void (*tc_action_priv_destructor)(void *);

struct psample_group;

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, int, int, bool, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	int action;
	int police;
};

struct tc_cls_u32_knode {
	struct tcf_exts *exts;
	struct tcf_result *res;
	struct tc_u32_sel *sel;
	u32 handle;
	u32 val;
	u32 mask;
	u32 link_handle;
	u8 fshift;
};

struct tc_cls_u32_hnode {
	u32 handle;
	u32 prio;
	unsigned int divisor;
};

enum tc_clsu32_command {
	TC_CLSU32_NEW_KNODE = 0,
	TC_CLSU32_REPLACE_KNODE = 1,
	TC_CLSU32_DELETE_KNODE = 2,
	TC_CLSU32_NEW_HNODE = 3,
	TC_CLSU32_REPLACE_HNODE = 4,
	TC_CLSU32_DELETE_HNODE = 5,
};

struct tc_cls_u32_offload {
	struct flow_cls_common_offload common;
	enum tc_clsu32_command command;
	union {
		struct tc_cls_u32_knode knode;
		struct tc_cls_u32_hnode hnode;
	};
};

struct tcf_gact {
	struct tc_action common;
	u16 tcfg_ptype;
	u16 tcfg_pval;
	int tcfg_paction;
	atomic_t packets;
};

struct tcf_mirred {
	struct tc_action common;
	int tcfm_eaction;
	bool tcfm_mac_header_xmit;
	struct net_device *tcfm_dev;
	struct list_head tcfm_list;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	bool unaligned;
	u64 orig_addr;
	struct list_head free_list_node;
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct ptp_clock_info {
	struct module *owner;
	char name[16];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjfreq)(struct ptp_clock_info *, s32);
	int (*adjphase)(struct ptp_clock_info *, s32);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct ixgbe_thermal_diode_data {
	u8 location;
	u8 temp;
	u8 caution_thresh;
	u8 max_op_thresh;
};

struct ixgbe_thermal_sensor_data {
	struct ixgbe_thermal_diode_data sensor[3];
};

struct ixgbe_nvm_version {
	u32 etk_id;
	u8 nvm_major;
	u16 nvm_minor;
	u8 nvm_id;
	bool oem_valid;
	u8 oem_major;
	u8 oem_minor;
	u16 oem_release;
	bool or_valid;
	u8 or_major;
	u16 or_build;
	u8 or_patch;
};

enum {
	PBA_STRATEGY_EQUAL = 0,
	PBA_STRATEGY_WEIGHTED = 1,
};

enum ixgbe_fdir_pballoc_type {
	IXGBE_FDIR_PBALLOC_NONE = 0,
	IXGBE_FDIR_PBALLOC_64K = 1,
	IXGBE_FDIR_PBALLOC_128K = 2,
	IXGBE_FDIR_PBALLOC_256K = 3,
};

union ixgbe_adv_tx_desc {
	struct {
		__le64 buffer_addr;
		__le32 cmd_type_len;
		__le32 olinfo_status;
	} read;
	struct {
		__le64 rsvd;
		__le32 nxtseq_seed;
		__le32 status;
	} wb;
};

union ixgbe_adv_rx_desc {
	struct {
		__le64 pkt_addr;
		__le64 hdr_addr;
	} read;
	struct {
		struct {
			union {
				__le32 data;
				struct {
					__le16 pkt_info;
					__le16 hdr_info;
				} hs_rss;
			} lo_dword;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

typedef u32 ixgbe_autoneg_advertised;

typedef u32 ixgbe_link_speed;

enum ixgbe_atr_flow_type {
	IXGBE_ATR_FLOW_TYPE_IPV4 = 0,
	IXGBE_ATR_FLOW_TYPE_UDPV4 = 1,
	IXGBE_ATR_FLOW_TYPE_TCPV4 = 2,
	IXGBE_ATR_FLOW_TYPE_SCTPV4 = 3,
	IXGBE_ATR_FLOW_TYPE_IPV6 = 4,
	IXGBE_ATR_FLOW_TYPE_UDPV6 = 5,
	IXGBE_ATR_FLOW_TYPE_TCPV6 = 6,
	IXGBE_ATR_FLOW_TYPE_SCTPV6 = 7,
};

union ixgbe_atr_input {
	struct {
		u8 vm_pool;
		u8 flow_type;
		__be16 vlan_id;
		__be32 dst_ip[4];
		__be32 src_ip[4];
		__be16 src_port;
		__be16 dst_port;
		__be16 flex_bytes;
		__be16 bkt_hash;
	} formatted;
	__be32 dword_stream[11];
};

union ixgbe_atr_hash_dword {
	struct {
		u8 vm_pool;
		u8 flow_type;
		__be16 vlan_id;
	} formatted;
	__be32 ip;
	struct {
		__be16 src;
		__be16 dst;
	} port;
	__be16 flex_bytes;
	__be32 dword;
};

enum ixgbe_mvals {
	IXGBE_EEC_IDX = 0,
	IXGBE_FLA_IDX = 1,
	IXGBE_GRC_IDX = 2,
	IXGBE_FACTPS_IDX = 3,
	IXGBE_SWSM_IDX = 4,
	IXGBE_SWFW_SYNC_IDX = 5,
	IXGBE_FWSM_IDX = 6,
	IXGBE_SDP0_GPIEN_IDX = 7,
	IXGBE_SDP1_GPIEN_IDX = 8,
	IXGBE_SDP2_GPIEN_IDX = 9,
	IXGBE_EICR_GPI_SDP0_IDX = 10,
	IXGBE_EICR_GPI_SDP1_IDX = 11,
	IXGBE_EICR_GPI_SDP2_IDX = 12,
	IXGBE_CIAA_IDX = 13,
	IXGBE_CIAD_IDX = 14,
	IXGBE_I2C_CLK_IN_IDX = 15,
	IXGBE_I2C_CLK_OUT_IDX = 16,
	IXGBE_I2C_DATA_IN_IDX = 17,
	IXGBE_I2C_DATA_OUT_IDX = 18,
	IXGBE_I2C_DATA_OE_N_EN_IDX = 19,
	IXGBE_I2C_BB_EN_IDX = 20,
	IXGBE_I2C_CLK_OE_N_EN_IDX = 21,
	IXGBE_I2CCTL_IDX = 22,
	IXGBE_MVALS_IDX_LIMIT = 23,
};

enum ixgbe_eeprom_type {
	ixgbe_eeprom_uninitialized = 0,
	ixgbe_eeprom_spi = 1,
	ixgbe_flash = 2,
	ixgbe_eeprom_none = 3,
};

enum ixgbe_mac_type {
	ixgbe_mac_unknown = 0,
	ixgbe_mac_82598EB = 1,
	ixgbe_mac_82599EB = 2,
	ixgbe_mac_X540 = 3,
	ixgbe_mac_X550 = 4,
	ixgbe_mac_X550EM_x = 5,
	ixgbe_mac_x550em_a = 6,
	ixgbe_num_macs = 7,
};

enum ixgbe_phy_type {
	ixgbe_phy_unknown = 0,
	ixgbe_phy_none = 1,
	ixgbe_phy_tn = 2,
	ixgbe_phy_aq = 3,
	ixgbe_phy_x550em_kr = 4,
	ixgbe_phy_x550em_kx4 = 5,
	ixgbe_phy_x550em_xfi = 6,
	ixgbe_phy_x550em_ext_t = 7,
	ixgbe_phy_ext_1g_t = 8,
	ixgbe_phy_cu_unknown = 9,
	ixgbe_phy_qt = 10,
	ixgbe_phy_xaui = 11,
	ixgbe_phy_nl = 12,
	ixgbe_phy_sfp_passive_tyco = 13,
	ixgbe_phy_sfp_passive_unknown = 14,
	ixgbe_phy_sfp_active_unknown = 15,
	ixgbe_phy_sfp_avago = 16,
	ixgbe_phy_sfp_ftl = 17,
	ixgbe_phy_sfp_ftl_active = 18,
	ixgbe_phy_sfp_unknown = 19,
	ixgbe_phy_sfp_intel = 20,
	ixgbe_phy_qsfp_passive_unknown = 21,
	ixgbe_phy_qsfp_active_unknown = 22,
	ixgbe_phy_qsfp_intel = 23,
	ixgbe_phy_qsfp_unknown = 24,
	ixgbe_phy_sfp_unsupported = 25,
	ixgbe_phy_sgmii = 26,
	ixgbe_phy_fw = 27,
	ixgbe_phy_generic = 28,
};

enum ixgbe_sfp_type {
	ixgbe_sfp_type_da_cu = 0,
	ixgbe_sfp_type_sr = 1,
	ixgbe_sfp_type_lr = 2,
	ixgbe_sfp_type_da_cu_core0 = 3,
	ixgbe_sfp_type_da_cu_core1 = 4,
	ixgbe_sfp_type_srlr_core0 = 5,
	ixgbe_sfp_type_srlr_core1 = 6,
	ixgbe_sfp_type_da_act_lmt_core0 = 7,
	ixgbe_sfp_type_da_act_lmt_core1 = 8,
	ixgbe_sfp_type_1g_cu_core0 = 9,
	ixgbe_sfp_type_1g_cu_core1 = 10,
	ixgbe_sfp_type_1g_sx_core0 = 11,
	ixgbe_sfp_type_1g_sx_core1 = 12,
	ixgbe_sfp_type_1g_lx_core0 = 13,
	ixgbe_sfp_type_1g_lx_core1 = 14,
	ixgbe_sfp_type_not_present = 65534,
	ixgbe_sfp_type_unknown = 65535,
};

enum ixgbe_media_type {
	ixgbe_media_type_unknown = 0,
	ixgbe_media_type_fiber = 1,
	ixgbe_media_type_fiber_qsfp = 2,
	ixgbe_media_type_fiber_lco = 3,
	ixgbe_media_type_copper = 4,
	ixgbe_media_type_backplane = 5,
	ixgbe_media_type_cx4 = 6,
	ixgbe_media_type_virtual = 7,
};

enum ixgbe_fc_mode {
	ixgbe_fc_none = 0,
	ixgbe_fc_rx_pause = 1,
	ixgbe_fc_tx_pause = 2,
	ixgbe_fc_full = 3,
	ixgbe_fc_default = 4,
};

enum ixgbe_smart_speed {
	ixgbe_smart_speed_auto = 0,
	ixgbe_smart_speed_on = 1,
	ixgbe_smart_speed_off = 2,
};

enum ixgbe_bus_type {
	ixgbe_bus_type_unknown = 0,
	ixgbe_bus_type_pci_express = 1,
	ixgbe_bus_type_internal = 2,
	ixgbe_bus_type_reserved = 3,
};

enum ixgbe_bus_speed {
	ixgbe_bus_speed_unknown = 0,
	ixgbe_bus_speed_33 = 33,
	ixgbe_bus_speed_66 = 66,
	ixgbe_bus_speed_100 = 100,
	ixgbe_bus_speed_120 = 120,
	ixgbe_bus_speed_133 = 133,
	ixgbe_bus_speed_2500 = 2500,
	ixgbe_bus_speed_5000 = 5000,
	ixgbe_bus_speed_8000 = 8000,
	ixgbe_bus_speed_reserved = 8001,
};

enum ixgbe_bus_width {
	ixgbe_bus_width_unknown = 0,
	ixgbe_bus_width_pcie_x1 = 1,
	ixgbe_bus_width_pcie_x2 = 2,
	ixgbe_bus_width_pcie_x4 = 4,
	ixgbe_bus_width_pcie_x8 = 8,
	ixgbe_bus_width_32 = 32,
	ixgbe_bus_width_64 = 64,
	ixgbe_bus_width_reserved = 65,
};

struct ixgbe_addr_filter_info {
	u32 num_mc_addrs;
	u32 rar_used_count;
	u32 mta_in_use;
	u32 overflow_promisc;
	bool uc_set_promisc;
	bool user_set_promisc;
};

struct ixgbe_bus_info {
	enum ixgbe_bus_speed speed;
	enum ixgbe_bus_width width;
	enum ixgbe_bus_type type;
	u8 func;
	u8 lan_id;
	u8 instance_id;
};

struct ixgbe_fc_info {
	u32 high_water[8];
	u32 low_water[8];
	u16 pause_time;
	bool send_xon;
	bool strict_ieee;
	bool disable_fc_autoneg;
	bool fc_was_autonegged;
	enum ixgbe_fc_mode current_mode;
	enum ixgbe_fc_mode requested_mode;
};

struct ixgbe_hw_stats {
	u64 crcerrs;
	u64 illerrc;
	u64 errbc;
	u64 mspdc;
	u64 mpctotal;
	u64 mpc[8];
	u64 mlfc;
	u64 mrfc;
	u64 rlec;
	u64 lxontxc;
	u64 lxonrxc;
	u64 lxofftxc;
	u64 lxoffrxc;
	u64 pxontxc[8];
	u64 pxonrxc[8];
	u64 pxofftxc[8];
	u64 pxoffrxc[8];
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc[8];
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mngprc;
	u64 mngpdc;
	u64 mngptc;
	u64 tor;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 xec;
	u64 rqsmr[16];
	u64 tqsmr[8];
	u64 qprc[16];
	u64 qptc[16];
	u64 qbrc[16];
	u64 qbtc[16];
	u64 qprdc[16];
	u64 pxon2offc[8];
	u64 fdirustat_add;
	u64 fdirustat_remove;
	u64 fdirfstat_fadd;
	u64 fdirfstat_fremove;
	u64 fdirmatch;
	u64 fdirmiss;
	u64 fccrc;
	u64 fcoerpdc;
	u64 fcoeprc;
	u64 fcoeptc;
	u64 fcoedwrc;
	u64 fcoedwtc;
	u64 fcoe_noddp;
	u64 fcoe_noddp_ext_buff;
	u64 b2ospc;
	u64 b2ogprc;
	u64 o2bgptc;
	u64 o2bspc;
};

struct ixgbe_hw;

struct ixgbe_mac_operations {
	s32 (*init_hw)(struct ixgbe_hw *);
	s32 (*reset_hw)(struct ixgbe_hw *);
	s32 (*start_hw)(struct ixgbe_hw *);
	s32 (*clear_hw_cntrs)(struct ixgbe_hw *);
	enum ixgbe_media_type (*get_media_type)(struct ixgbe_hw *);
	s32 (*get_mac_addr)(struct ixgbe_hw *, u8 *);
	s32 (*get_san_mac_addr)(struct ixgbe_hw *, u8 *);
	s32 (*get_device_caps)(struct ixgbe_hw *, u16 *);
	s32 (*get_wwn_prefix)(struct ixgbe_hw *, u16 *, u16 *);
	s32 (*stop_adapter)(struct ixgbe_hw *);
	s32 (*get_bus_info)(struct ixgbe_hw *);
	void (*set_lan_id)(struct ixgbe_hw *);
	s32 (*read_analog_reg8)(struct ixgbe_hw *, u32, u8 *);
	s32 (*write_analog_reg8)(struct ixgbe_hw *, u32, u8);
	s32 (*setup_sfp)(struct ixgbe_hw *);
	s32 (*disable_rx_buff)(struct ixgbe_hw *);
	s32 (*enable_rx_buff)(struct ixgbe_hw *);
	s32 (*enable_rx_dma)(struct ixgbe_hw *, u32);
	s32 (*acquire_swfw_sync)(struct ixgbe_hw *, u32);
	void (*release_swfw_sync)(struct ixgbe_hw *, u32);
	void (*init_swfw_sync)(struct ixgbe_hw *);
	s32 (*prot_autoc_read)(struct ixgbe_hw *, bool *, u32 *);
	s32 (*prot_autoc_write)(struct ixgbe_hw *, u32, bool);
	void (*disable_tx_laser)(struct ixgbe_hw *);
	void (*enable_tx_laser)(struct ixgbe_hw *);
	void (*flap_tx_laser)(struct ixgbe_hw *);
	void (*stop_link_on_d3)(struct ixgbe_hw *);
	s32 (*setup_link)(struct ixgbe_hw *, ixgbe_link_speed, bool);
	s32 (*setup_mac_link)(struct ixgbe_hw *, ixgbe_link_speed, bool);
	s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool);
	s32 (*get_link_capabilities)(struct ixgbe_hw *, ixgbe_link_speed *, bool *);
	void (*set_rate_select_speed)(struct ixgbe_hw *, ixgbe_link_speed);
	void (*set_rxpba)(struct ixgbe_hw *, int, u32, int);
	s32 (*led_on)(struct ixgbe_hw *, u32);
	s32 (*led_off)(struct ixgbe_hw *, u32);
	s32 (*blink_led_start)(struct ixgbe_hw *, u32);
	s32 (*blink_led_stop)(struct ixgbe_hw *, u32);
	s32 (*init_led_link_act)(struct ixgbe_hw *);
	s32 (*set_rar)(struct ixgbe_hw *, u32, u8 *, u32, u32);
	s32 (*clear_rar)(struct ixgbe_hw *, u32);
	s32 (*set_vmdq)(struct ixgbe_hw *, u32, u32);
	s32 (*set_vmdq_san_mac)(struct ixgbe_hw *, u32);
	s32 (*clear_vmdq)(struct ixgbe_hw *, u32, u32);
	s32 (*init_rx_addrs)(struct ixgbe_hw *);
	s32 (*update_mc_addr_list)(struct ixgbe_hw *, struct net_device *);
	s32 (*enable_mc)(struct ixgbe_hw *);
	s32 (*disable_mc)(struct ixgbe_hw *);
	s32 (*clear_vfta)(struct ixgbe_hw *);
	s32 (*set_vfta)(struct ixgbe_hw *, u32, u32, bool, bool);
	s32 (*init_uta_tables)(struct ixgbe_hw *);
	void (*set_mac_anti_spoofing)(struct ixgbe_hw *, bool, int);
	void (*set_vlan_anti_spoofing)(struct ixgbe_hw *, bool, int);
	s32 (*fc_enable)(struct ixgbe_hw *);
	s32 (*setup_fc)(struct ixgbe_hw *);
	void (*fc_autoneg)(struct ixgbe_hw *);
	s32 (*set_fw_drv_ver)(struct ixgbe_hw *, u8, u8, u8, u8, u16, const char *);
	s32 (*get_thermal_sensor_data)(struct ixgbe_hw *);
	s32 (*init_thermal_sensor_thresh)(struct ixgbe_hw *);
	bool (*fw_recovery_mode)(struct ixgbe_hw *);
	void (*disable_rx)(struct ixgbe_hw *);
	void (*enable_rx)(struct ixgbe_hw *);
	void (*set_source_address_pruning)(struct ixgbe_hw *, bool, unsigned int);
	void (*set_ethertype_anti_spoofing)(struct ixgbe_hw *, bool, int);
	s32 (*dmac_config)(struct ixgbe_hw *);
	s32 (*dmac_update_tcs)(struct ixgbe_hw *);
	s32 (*dmac_config_tcs)(struct ixgbe_hw *);
	s32 (*read_iosf_sb_reg)(struct ixgbe_hw *, u32, u32, u32 *);
	s32 (*write_iosf_sb_reg)(struct ixgbe_hw *, u32, u32, u32);
};

struct ixgbe_mac_info {
	struct ixgbe_mac_operations ops;
	enum ixgbe_mac_type type;
	u8 addr[6];
	u8 perm_addr[6];
	u8 san_addr[6];
	u16 wwnn_prefix;
	u16 wwpn_prefix;
	u16 max_msix_vectors;
	u32 mta_shadow[128];
	s32 mc_filter_type;
	u32 mcft_size;
	u32 vft_size;
	u32 num_rar_entries;
	u32 rar_highwater;
	u32 rx_pb_size;
	u32 max_tx_queues;
	u32 max_rx_queues;
	u32 orig_autoc;
	u32 orig_autoc2;
	bool orig_link_settings_stored;
	bool autotry_restart;
	u8 flags;
	u8 san_mac_rar_index;
	struct ixgbe_thermal_sensor_data thermal_sensor_data;
	bool set_lben;
	u8 led_link_act;
};

struct ixgbe_phy_operations {
	s32 (*identify)(struct ixgbe_hw *);
	s32 (*identify_sfp)(struct ixgbe_hw *);
	s32 (*init)(struct ixgbe_hw *);
	s32 (*reset)(struct ixgbe_hw *);
	s32 (*read_reg)(struct ixgbe_hw *, u32, u32, u16 *);
	s32 (*write_reg)(struct ixgbe_hw *, u32, u32, u16);
	s32 (*read_reg_mdi)(struct ixgbe_hw *, u32, u32, u16 *);
	s32 (*write_reg_mdi)(struct ixgbe_hw *, u32, u32, u16);
	s32 (*setup_link)(struct ixgbe_hw *);
	s32 (*setup_internal_link)(struct ixgbe_hw *);
	s32 (*setup_link_speed)(struct ixgbe_hw *, ixgbe_link_speed, bool);
	s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *);
	s32 (*read_i2c_byte)(struct ixgbe_hw *, u8, u8, u8 *);
	s32 (*write_i2c_byte)(struct ixgbe_hw *, u8, u8, u8);
	s32 (*read_i2c_sff8472)(struct ixgbe_hw *, u8, u8 *);
	s32 (*read_i2c_eeprom)(struct ixgbe_hw *, u8, u8 *);
	s32 (*write_i2c_eeprom)(struct ixgbe_hw *, u8, u8);
	s32 (*check_overtemp)(struct ixgbe_hw *);
	s32 (*set_phy_power)(struct ixgbe_hw *, bool);
	s32 (*enter_lplu)(struct ixgbe_hw *);
	s32 (*handle_lasi)(struct ixgbe_hw *);
	s32 (*read_i2c_byte_unlocked)(struct ixgbe_hw *, u8, u8, u8 *);
	s32 (*write_i2c_byte_unlocked)(struct ixgbe_hw *, u8, u8, u8);
};

struct ixgbe_phy_info {
	struct ixgbe_phy_operations ops;
	struct mdio_if_info mdio;
	enum ixgbe_phy_type type;
	u32 id;
	enum ixgbe_sfp_type sfp_type;
	bool sfp_setup_needed;
	u32 revision;
	enum ixgbe_media_type media_type;
	u32 phy_semaphore_mask;
	bool reset_disable;
	ixgbe_autoneg_advertised autoneg_advertised;
	ixgbe_link_speed speeds_supported;
	ixgbe_link_speed eee_speeds_supported;
	ixgbe_link_speed eee_speeds_advertised;
	enum ixgbe_smart_speed smart_speed;
	bool smart_speed_active;
	bool multispeed_fiber;
	bool reset_if_overtemp;
	bool qsfp_shared_i2c_bus;
	u32 nw_mng_if_sel;
};

struct ixgbe_link_operations {
	s32 (*read_link)(struct ixgbe_hw *, u8, u16, u16 *);
	s32 (*read_link_unlocked)(struct ixgbe_hw *, u8, u16, u16 *);
	s32 (*write_link)(struct ixgbe_hw *, u8, u16, u16);
	s32 (*write_link_unlocked)(struct ixgbe_hw *, u8, u16, u16);
};

struct ixgbe_link_info {
	struct ixgbe_link_operations ops;
	u8 addr;
};

struct ixgbe_eeprom_operations {
	s32 (*init_params)(struct ixgbe_hw *);
	s32 (*read)(struct ixgbe_hw *, u16, u16 *);
	s32 (*read_buffer)(struct ixgbe_hw *, u16, u16, u16 *);
	s32 (*write)(struct ixgbe_hw *, u16, u16);
	s32 (*write_buffer)(struct ixgbe_hw *, u16, u16, u16 *);
	s32 (*validate_checksum)(struct ixgbe_hw *, u16 *);
	s32 (*update_checksum)(struct ixgbe_hw *);
	s32 (*calc_checksum)(struct ixgbe_hw *);
};

struct ixgbe_eeprom_info {
	struct ixgbe_eeprom_operations ops;
	enum ixgbe_eeprom_type type;
	u32 semaphore_delay;
	u16 word_size;
	u16 address_bits;
	u16 word_page_size;
	u16 ctrl_word_3;
};

struct ixgbe_mbx_stats {
	u32 msgs_tx;
	u32 msgs_rx;
	u32 acks;
	u32 reqs;
	u32 rsts;
};

struct ixgbe_mbx_operations;

struct ixgbe_mbx_info {
	const struct ixgbe_mbx_operations *ops;
	struct ixgbe_mbx_stats stats;
	u32 timeout;
	u32 usec_delay;
	u32 v2p_mailbox;
	u16 size;
};

struct ixgbe_hw {
	u8 *hw_addr;
	void *back;
	struct ixgbe_mac_info mac;
	struct ixgbe_addr_filter_info addr_ctrl;
	struct ixgbe_fc_info fc;
	struct ixgbe_phy_info phy;
	struct ixgbe_link_info link;
	struct ixgbe_eeprom_info eeprom;
	struct ixgbe_bus_info bus;
	struct ixgbe_mbx_info mbx;
	const u32 *mvals;
	u16 device_id;
	u16 vendor_id;
	u16 subsystem_device_id;
	u16 subsystem_vendor_id;
	u8 revision_id;
	bool adapter_stopped;
	bool force_full_reset;
	bool allow_unsupported_sfp;
	bool wol_enabled;
	bool need_crosstalk_fix;
};

struct ixgbe_mbx_operations {
	s32 (*init_params)(struct ixgbe_hw *);
	s32 (*read)(struct ixgbe_hw *, u32 *, u16, u16);
	s32 (*write)(struct ixgbe_hw *, u32 *, u16, u16);
	s32 (*read_posted)(struct ixgbe_hw *, u32 *, u16, u16);
	s32 (*write_posted)(struct ixgbe_hw *, u32 *, u16, u16);
	s32 (*check_for_msg)(struct ixgbe_hw *, u16);
	s32 (*check_for_ack)(struct ixgbe_hw *, u16);
	s32 (*check_for_rst)(struct ixgbe_hw *, u16);
};

struct ixgbe_info {
	enum ixgbe_mac_type mac;
	s32 (*get_invariants)(struct ixgbe_hw *);
	const struct ixgbe_mac_operations *mac_ops;
	const struct ixgbe_eeprom_operations *eeprom_ops;
	const struct ixgbe_phy_operations *phy_ops;
	const struct ixgbe_mbx_operations *mbx_ops;
	const struct ixgbe_link_operations *link_ops;
	const u32 *mvals;
};

enum strict_prio_type {
	prio_none = 0,
	prio_group = 1,
	prio_link = 2,
};

struct dcb_support {
	u32 capabilities;
	u8 traffic_classes;
	u8 pfc_traffic_classes;
};

struct tc_bw_alloc {
	u8 bwg_id;
	u8 bwg_percent;
	u8 link_percent;
	u8 up_to_tc_bitmap;
	u16 data_credits_refill;
	u16 data_credits_max;
	enum strict_prio_type prio_type;
};

enum dcb_pfc_type {
	pfc_disabled = 0,
	pfc_enabled_full = 1,
	pfc_enabled_tx = 2,
	pfc_enabled_rx = 3,
};

struct tc_configuration {
	struct tc_bw_alloc path[2];
	enum dcb_pfc_type dcb_pfc;
	u16 desc_credits_max;
	u8 tc;
};

struct dcb_num_tcs {
	u8 pg_tcs;
	u8 pfc_tcs;
};

struct ixgbe_dcb_config {
	struct dcb_support support;
	struct dcb_num_tcs num_tcs;
	struct tc_configuration tc_config[8];
	u8 bw_percentage[16];
	bool pfc_mode_enable;
	u32 dcb_cfg_version;
	u32 link_speed;
};

struct ixgbe_ipsec_tx_data {
	u32 flags;
	u16 trailer_len;
	u16 sa_idx;
};

enum ixgbe_tx_flags {
	IXGBE_TX_FLAGS_HW_VLAN = 1,
	IXGBE_TX_FLAGS_TSO = 2,
	IXGBE_TX_FLAGS_TSTAMP = 4,
	IXGBE_TX_FLAGS_CC = 8,
	IXGBE_TX_FLAGS_IPV4 = 16,
	IXGBE_TX_FLAGS_CSUM = 32,
	IXGBE_TX_FLAGS_IPSEC = 64,
	IXGBE_TX_FLAGS_SW_VLAN = 128,
	IXGBE_TX_FLAGS_FCOE = 256,
};

struct vf_data_storage {
	struct pci_dev *vfdev;
	unsigned char vf_mac_addresses[6];
	u16 vf_mc_hashes[30];
	u16 num_vf_mc_hashes;
	bool clear_to_send;
	bool pf_set_mac;
	u16 pf_vlan;
	u16 pf_qos;
	u16 tx_rate;
	u8 spoofchk_enabled;
	bool rss_query_enabled;
	u8 trusted;
	int xcast_mode;
	unsigned int vf_api;
};

struct vf_macvlans {
	struct list_head l;
	int vf;
	bool free;
	bool is_macvlan;
	u8 vf_macvlan[6];
};

struct ixgbe_tx_buffer {
	union ixgbe_adv_tx_desc *next_to_watch;
	long unsigned int time_stamp;
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdpf;
	};
	unsigned int bytecount;
	short unsigned int gso_segs;
	__be16 protocol;
	dma_addr_t dma;
	__u32 len;
	u32 tx_flags;
};

struct ixgbe_rx_buffer {
	union {
		struct {
			struct sk_buff *skb;
			dma_addr_t dma;
			struct page *page;
			__u32 page_offset;
			__u16 pagecnt_bias;
		};
		struct {
			bool discard;
			struct xdp_buff *xdp;
		};
	};
};

struct ixgbe_queue_stats {
	u64 packets;
	u64 bytes;
};

struct ixgbe_tx_queue_stats {
	u64 restart_queue;
	u64 tx_busy;
	u64 tx_done_old;
};

struct ixgbe_rx_queue_stats {
	u64 rsc_count;
	u64 rsc_flush;
	u64 non_eop_descs;
	u64 alloc_rx_page;
	u64 alloc_rx_page_failed;
	u64 alloc_rx_buff_failed;
	u64 csum_err;
};

enum ixgbe_ring_state_t {
	__IXGBE_RX_3K_BUFFER = 0,
	__IXGBE_RX_BUILD_SKB_ENABLED = 1,
	__IXGBE_RX_RSC_ENABLED = 2,
	__IXGBE_RX_CSUM_UDP_ZERO_ERR = 3,
	__IXGBE_RX_FCOE = 4,
	__IXGBE_TX_FDIR_INIT_DONE = 5,
	__IXGBE_TX_XPS_INIT_DONE = 6,
	__IXGBE_TX_DETECT_HANG = 7,
	__IXGBE_HANG_CHECK_ARMED = 8,
	__IXGBE_TX_XDP_RING = 9,
	__IXGBE_TX_DISABLED = 10,
};

struct ixgbe_fwd_adapter {
	long unsigned int active_vlans[64];
	struct net_device *netdev;
	unsigned int tx_base_queue;
	unsigned int rx_base_queue;
	int pool;
};

struct ixgbe_q_vector;

struct ixgbe_ring {
	struct ixgbe_ring *next;
	struct ixgbe_q_vector *q_vector;
	struct net_device *netdev;
	struct bpf_prog *xdp_prog;
	struct device *dev;
	void *desc;
	union {
		struct ixgbe_tx_buffer *tx_buffer_info;
		struct ixgbe_rx_buffer *rx_buffer_info;
	};
	long unsigned int state;
	u8 *tail;
	dma_addr_t dma;
	unsigned int size;
	u16 count;
	u8 queue_index;
	u8 reg_idx;
	u16 next_to_use;
	u16 next_to_clean;
	long unsigned int last_rx_timestamp;
	union {
		u16 next_to_alloc;
		struct {
			u8 atr_sample_rate;
			u8 atr_count;
		};
	};
	u8 dcb_tc;
	struct ixgbe_queue_stats stats;
	struct u64_stats_sync syncp;
	union {
		struct ixgbe_tx_queue_stats tx_stats;
		struct ixgbe_rx_queue_stats rx_stats;
	};
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct xsk_buff_pool *xsk_pool;
	u16 ring_idx;
	u16 rx_buf_len;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ixgbe_ring_container {
	struct ixgbe_ring *ring;
	long unsigned int next_update;
	unsigned int total_bytes;
	unsigned int total_packets;
	u16 work_limit;
	u8 count;
	u8 itr;
};

struct ixgbe_adapter;

struct ixgbe_q_vector {
	struct ixgbe_adapter *adapter;
	int cpu;
	u16 v_idx;
	u16 itr;
	struct ixgbe_ring_container rx;
	struct ixgbe_ring_container tx;
	struct napi_struct napi;
	cpumask_t affinity_mask;
	int numa_node;
	struct callback_head rcu;
	char name[25];
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ixgbe_ring ring[0];
};

enum ixgbe_ring_f_enum {
	RING_F_NONE = 0,
	RING_F_VMDQ = 1,
	RING_F_RSS = 2,
	RING_F_FDIR = 3,
	RING_F_ARRAY_SIZE = 4,
};

struct ixgbe_ring_feature {
	u16 limit;
	u16 indices;
	u16 mask;
	u16 offset;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ptp_clock;

struct ixgbe_mac_addr;

struct hwmon_buff;

struct ixgbe_jump_table;

struct ixgbe_adapter {
	long unsigned int active_vlans[64];
	struct net_device *netdev;
	struct bpf_prog *xdp_prog;
	struct pci_dev *pdev;
	struct mii_bus *mii_bus;
	long unsigned int state;
	u32 flags;
	u32 flags2;
	int num_tx_queues;
	u16 tx_itr_setting;
	u16 tx_work_limit;
	u64 tx_ipsec;
	int num_rx_queues;
	u16 rx_itr_setting;
	u64 rx_ipsec;
	__be16 vxlan_port;
	__be16 geneve_port;
	int num_xdp_queues;
	struct ixgbe_ring *xdp_ring[64];
	long unsigned int *af_xdp_zc_qps;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ixgbe_ring *tx_ring[64];
	u64 restart_queue;
	u64 lsc_int;
	u32 tx_timeout_count;
	struct ixgbe_ring *rx_ring[64];
	int num_rx_pools;
	int num_rx_queues_per_pool;
	u64 hw_csum_rx_error;
	u64 hw_rx_no_dma_resources;
	u64 rsc_total_count;
	u64 rsc_total_flush;
	u64 non_eop_descs;
	u32 alloc_rx_page;
	u32 alloc_rx_page_failed;
	u32 alloc_rx_buff_failed;
	struct ixgbe_q_vector *q_vector[64];
	struct ieee_pfc *ixgbe_ieee_pfc;
	struct ieee_ets *ixgbe_ieee_ets;
	struct ixgbe_dcb_config dcb_cfg;
	struct ixgbe_dcb_config temp_dcb_cfg;
	u8 hw_tcs;
	u8 dcb_set_bitmap;
	u8 dcbx_cap;
	enum ixgbe_fc_mode last_lfc_mode;
	int num_q_vectors;
	int max_q_vectors;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ixgbe_ring_feature ring_feature[4];
	struct msix_entry *msix_entries;
	u32 test_icr;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ixgbe_ring test_tx_ring;
	struct ixgbe_ring test_rx_ring;
	struct ixgbe_hw hw;
	u16 msg_enable;
	struct ixgbe_hw_stats stats;
	u64 tx_busy;
	unsigned int tx_ring_count;
	unsigned int xdp_ring_count;
	unsigned int rx_ring_count;
	u32 link_speed;
	bool link_up;
	long unsigned int sfp_poll_time;
	long unsigned int link_check_timeout;
	struct timer_list service_timer;
	struct work_struct service_task;
	struct hlist_head fdir_filter_list;
	long unsigned int fdir_overflow;
	union ixgbe_atr_input fdir_mask;
	int fdir_filter_count;
	u32 fdir_pballoc;
	u32 atr_sample_rate;
	spinlock_t fdir_perfect_lock;
	u8 *io_addr;
	u32 wol;
	u16 bridge_mode;
	char eeprom_id[32];
	u16 eeprom_cap;
	u32 interrupt_event;
	u32 led_reg;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	struct work_struct ptp_tx_work;
	struct sk_buff *ptp_tx_skb;
	struct hwtstamp_config tstamp_config;
	long unsigned int ptp_tx_start;
	long unsigned int last_overflow_check;
	long unsigned int last_rx_ptp_check;
	long unsigned int last_rx_timestamp;
	spinlock_t tmreg_lock;
	struct cyclecounter hw_cc;
	struct timecounter hw_tc;
	u32 base_incval;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	u32 rx_hwtstamp_cleared;
	void (*ptp_setup_sdp)(struct ixgbe_adapter *);
	long unsigned int active_vfs[1];
	unsigned int num_vfs;
	struct vf_data_storage *vfinfo;
	int vf_rate_link_speed;
	struct vf_macvlans vf_mvs;
	struct vf_macvlans *mv_list;
	u32 timer_event_accumulator;
	u32 vferr_refcount;
	struct ixgbe_mac_addr *mac_table;
	struct kobject *info_kobj;
	struct hwmon_buff *ixgbe_hwmon_buff;
	struct dentry *ixgbe_dbg_adapter;
	u8 default_up;
	long unsigned int fwd_bitmask[1];
	struct ixgbe_jump_table *jump_tables[10];
	long unsigned int tables;
	u8 rss_indir_tbl[512];
	u32 *rss_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct hwmon_attr {
	struct device_attribute dev_attr;
	struct ixgbe_hw *hw;
	struct ixgbe_thermal_diode_data *sensor;
	char name[12];
};

struct hwmon_buff {
	struct attribute_group group;
	const struct attribute_group *groups[2];
	struct attribute *attrs[13];
	struct hwmon_attr hwmon_list[12];
	unsigned int n_hwmon;
};

struct ixgbe_mac_addr {
	u8 addr[6];
	u16 pool;
	u16 state;
};

struct ixgbe_mat_field;

struct ixgbe_fdir_filter;

struct ixgbe_jump_table {
	struct ixgbe_mat_field *mat;
	struct ixgbe_fdir_filter *input;
	union ixgbe_atr_input *mask;
	u32 link_hdl;
	long unsigned int child_loc_map[32];
};

struct ixgbe_fdir_filter {
	struct hlist_node fdir_node;
	union ixgbe_atr_input filter;
	u16 sw_idx;
	u64 action;
};

enum ixgbe_state_t {
	__IXGBE_TESTING = 0,
	__IXGBE_RESETTING = 1,
	__IXGBE_DOWN = 2,
	__IXGBE_DISABLED = 3,
	__IXGBE_REMOVING = 4,
	__IXGBE_SERVICE_SCHED = 5,
	__IXGBE_SERVICE_INITED = 6,
	__IXGBE_IN_SFP_INIT = 7,
	__IXGBE_PTP_RUNNING = 8,
	__IXGBE_PTP_TX_IN_PROGRESS = 9,
	__IXGBE_RESET_REQUESTED = 10,
};

struct ixgbe_cb {
	union {
		struct sk_buff *head;
		struct sk_buff *tail;
	};
	dma_addr_t dma;
	u16 append_cnt;
	bool page_released;
};

enum ixgbe_boards {
	board_82598 = 0,
	board_82599 = 1,
	board_X540 = 2,
	board_X550 = 3,
	board_X550EM_x = 4,
	board_x550em_x_fw = 5,
	board_x550em_a = 6,
	board_x550em_a_fw = 7,
};

struct ixgbe_mat_field {
	unsigned int off;
	int (*val)(struct ixgbe_fdir_filter *, union ixgbe_atr_input *, u32, u32);
	unsigned int type;
};

struct ixgbe_nexthdr {
	unsigned int o;
	u32 s;
	u32 m;
	unsigned int off;
	u32 val;
	u32 mask;
	struct ixgbe_mat_field *jump;
};

struct ixgbe_reg_info {
	u32 ofs;
	char *name;
};

struct upper_walk_data {
	struct ixgbe_adapter *adapter;
	u64 action;
	int ifindex;
	u8 queue;
};

struct my_u0 {
	u64 a;
	u64 b;
};

struct ixgbe_hic_hdr {
	u8 cmd;
	u8 buf_len;
	union {
		u8 cmd_resv;
		u8 ret_status;
	} cmd_or_resp;
	u8 checksum;
};

struct ixgbe_hic_drv_info {
	struct ixgbe_hic_hdr hdr;
	u8 port_num;
	u8 ver_sub;
	u8 ver_build;
	u8 ver_min;
	u8 ver_maj;
	u8 pad;
	u16 pad2;
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_LAST = 16384,
	SOF_TIMESTAMPING_MASK = 32767,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

enum {
	NETDEV_STATS___2 = 0,
	IXGBE_STATS = 1,
};

struct ixgbe_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

struct ixgbe_reg_test {
	u16 reg;
	u8 array_len;
	u8 test_type;
	u32 mask;
	u32 write;
};

enum ixgbe_pfvf_api_rev {
	ixgbe_mbox_api_10 = 0,
	ixgbe_mbox_api_20 = 1,
	ixgbe_mbox_api_11 = 2,
	ixgbe_mbox_api_12 = 3,
	ixgbe_mbox_api_13 = 4,
	ixgbe_mbox_api_14 = 5,
	ixgbe_mbox_api_unknown = 6,
};

enum ixgbevf_xcast_modes {
	IXGBEVF_XCAST_MODE_NONE = 0,
	IXGBEVF_XCAST_MODE_MULTI = 1,
	IXGBEVF_XCAST_MODE_ALLMULTI = 2,
	IXGBEVF_XCAST_MODE_PROMISC = 3,
};

struct ixgbe_hic_hdr2_req {
	u8 cmd;
	u8 buf_lenh;
	u8 buf_lenl;
	u8 checksum;
};

struct ixgbe_hic_hdr2_rsp {
	u8 cmd;
	u8 buf_lenl;
	u8 buf_lenh_status;
	u8 checksum;
};

union ixgbe_hic_hdr2 {
	struct ixgbe_hic_hdr2_req req;
	struct ixgbe_hic_hdr2_rsp rsp;
};

struct ixgbe_hic_drv_info2 {
	struct ixgbe_hic_hdr hdr;
	u8 port_num;
	u8 ver_sub;
	u8 ver_build;
	u8 ver_min;
	u8 ver_maj;
	char driver_string[39];
};

struct ixgbe_hic_read_shadow_ram {
	union ixgbe_hic_hdr2 hdr;
	u32 address;
	u16 length;
	u16 pad2;
	u16 data;
	u16 pad3;
};

struct ixgbe_hic_write_shadow_ram {
	union ixgbe_hic_hdr2 hdr;
	__be32 address;
	__be16 length;
	u16 pad2;
	u16 data;
	u16 pad3;
};

struct ixgbe_hic_disable_rxen {
	struct ixgbe_hic_hdr hdr;
	u8 port_number;
	u8 pad2;
	u16 pad3;
};

struct ixgbe_hic_phy_token_req {
	struct ixgbe_hic_hdr hdr;
	u8 port_number;
	u8 command_type;
	u16 pad;
};

struct ixgbe_hic_internal_phy_req {
	struct ixgbe_hic_hdr hdr;
	u8 port_number;
	u8 command_type;
	__be16 address;
	u16 rsv1;
	__be32 write_data;
	u16 pad;
} __attribute__((packed));

struct ixgbe_hic_internal_phy_resp {
	struct ixgbe_hic_hdr hdr;
	__be32 read_data;
};

struct ixgbe_hic_phy_activity_req {
	struct ixgbe_hic_hdr hdr;
	u8 port_number;
	u8 pad;
	__le16 activity_id;
	__be32 data[4];
};

struct ixgbe_hic_phy_activity_resp {
	struct ixgbe_hic_hdr hdr;
	__be32 data[4];
};

struct ixgbe_adv_tx_context_desc {
	__le32 vlan_macip_lens;
	__le32 fceof_saidx;
	__le32 type_tucmd_mlhl;
	__le32 mss_l4len_idx;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_PPS = 2,
	PTP_CLOCK_PPSUSR = 3,
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		struct pps_event_time pps_times;
	};
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

enum dcbnl_pfc_up_attrs {
	DCB_PFC_UP_ATTR_UNDEFINED = 0,
	DCB_PFC_UP_ATTR_0 = 1,
	DCB_PFC_UP_ATTR_1 = 2,
	DCB_PFC_UP_ATTR_2 = 3,
	DCB_PFC_UP_ATTR_3 = 4,
	DCB_PFC_UP_ATTR_4 = 5,
	DCB_PFC_UP_ATTR_5 = 6,
	DCB_PFC_UP_ATTR_6 = 7,
	DCB_PFC_UP_ATTR_7 = 8,
	DCB_PFC_UP_ATTR_ALL = 9,
	__DCB_PFC_UP_ATTR_ENUM_MAX = 10,
	DCB_PFC_UP_ATTR_MAX = 9,
};

enum dcbnl_pg_attrs {
	DCB_PG_ATTR_UNDEFINED = 0,
	DCB_PG_ATTR_TC_0 = 1,
	DCB_PG_ATTR_TC_1 = 2,
	DCB_PG_ATTR_TC_2 = 3,
	DCB_PG_ATTR_TC_3 = 4,
	DCB_PG_ATTR_TC_4 = 5,
	DCB_PG_ATTR_TC_5 = 6,
	DCB_PG_ATTR_TC_6 = 7,
	DCB_PG_ATTR_TC_7 = 8,
	DCB_PG_ATTR_TC_MAX = 9,
	DCB_PG_ATTR_TC_ALL = 10,
	DCB_PG_ATTR_BW_ID_0 = 11,
	DCB_PG_ATTR_BW_ID_1 = 12,
	DCB_PG_ATTR_BW_ID_2 = 13,
	DCB_PG_ATTR_BW_ID_3 = 14,
	DCB_PG_ATTR_BW_ID_4 = 15,
	DCB_PG_ATTR_BW_ID_5 = 16,
	DCB_PG_ATTR_BW_ID_6 = 17,
	DCB_PG_ATTR_BW_ID_7 = 18,
	DCB_PG_ATTR_BW_ID_MAX = 19,
	DCB_PG_ATTR_BW_ID_ALL = 20,
	__DCB_PG_ATTR_ENUM_MAX = 21,
	DCB_PG_ATTR_MAX = 20,
};

enum dcbnl_cap_attrs {
	DCB_CAP_ATTR_UNDEFINED = 0,
	DCB_CAP_ATTR_ALL = 1,
	DCB_CAP_ATTR_PG = 2,
	DCB_CAP_ATTR_PFC = 3,
	DCB_CAP_ATTR_UP2TC = 4,
	DCB_CAP_ATTR_PG_TCS = 5,
	DCB_CAP_ATTR_PFC_TCS = 6,
	DCB_CAP_ATTR_GSP = 7,
	DCB_CAP_ATTR_BCN = 8,
	DCB_CAP_ATTR_DCBX = 9,
	__DCB_CAP_ATTR_ENUM_MAX = 10,
	DCB_CAP_ATTR_MAX = 9,
};

enum dcbnl_numtcs_attrs {
	DCB_NUMTCS_ATTR_UNDEFINED = 0,
	DCB_NUMTCS_ATTR_ALL = 1,
	DCB_NUMTCS_ATTR_PG = 2,
	DCB_NUMTCS_ATTR_PFC = 3,
	__DCB_NUMTCS_ATTR_ENUM_MAX = 4,
	DCB_NUMTCS_ATTR_MAX = 3,
};

enum dcb_general_attr_values {
	DCB_ATTR_VALUE_UNDEFINED = 255,
};

typedef enum {
	ixgb_mac_unknown = 0,
	ixgb_82597 = 1,
	ixgb_num_macs = 2,
} ixgb_mac_type;

typedef enum {
	ixgb_phy_type_unknown = 0,
	ixgb_phy_type_g6005 = 1,
	ixgb_phy_type_g6104 = 2,
	ixgb_phy_type_txn17201 = 3,
	ixgb_phy_type_txn17401 = 4,
	ixgb_phy_type_bcm = 5,
} ixgb_phy_type;

typedef enum {
	ixgb_fc_none = 0,
	ixgb_fc_rx_pause = 1,
	ixgb_fc_tx_pause = 2,
	ixgb_fc_full = 3,
	ixgb_fc_default = 255,
} ixgb_fc_type;

typedef enum {
	ixgb_bus_type_unknown = 0,
	ixgb_bus_type_pci = 1,
	ixgb_bus_type_pcix = 2,
} ixgb_bus_type;

typedef enum {
	ixgb_bus_speed_unknown = 0,
	ixgb_bus_speed_33 = 1,
	ixgb_bus_speed_66 = 2,
	ixgb_bus_speed_100 = 3,
	ixgb_bus_speed_133 = 4,
	ixgb_bus_speed_reserved = 5,
} ixgb_bus_speed;

typedef enum {
	ixgb_bus_width_unknown = 0,
	ixgb_bus_width_32 = 1,
	ixgb_bus_width_64 = 2,
} ixgb_bus_width;

struct ixgb_rx_desc {
	__le64 buff_addr;
	__le16 length;
	__le16 reserved;
	u8 status;
	u8 errors;
	__le16 special;
};

struct ixgb_tx_desc {
	__le64 buff_addr;
	__le32 cmd_type_len;
	u8 status;
	u8 popts;
	__le16 vlan;
};

struct ixgb_context_desc {
	u8 ipcss;
	u8 ipcso;
	__le16 ipcse;
	u8 tucss;
	u8 tucso;
	__le16 tucse;
	__le32 cmd_type_len;
	u8 status;
	u8 hdr_len;
	__le16 mss;
};

struct ixgb_fc {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	bool send_xon;
	ixgb_fc_type type;
};

struct ixgb_bus {
	ixgb_bus_speed speed;
	ixgb_bus_width width;
	ixgb_bus_type type;
};

struct ixgb_hw {
	u8 *hw_addr;
	void *back;
	struct ixgb_fc fc;
	struct ixgb_bus bus;
	u32 phy_id;
	u32 phy_addr;
	ixgb_mac_type mac_type;
	ixgb_phy_type phy_type;
	u32 max_frame_size;
	u32 mc_filter_type;
	u32 num_mc_addrs;
	u8 curr_mac_addr[6];
	u32 num_tx_desc;
	u32 num_rx_desc;
	u32 rx_buffer_size;
	bool link_up;
	bool adapter_stopped;
	u16 device_id;
	u16 vendor_id;
	u8 revision_id;
	u16 subsystem_vendor_id;
	u16 subsystem_id;
	u32 bar0;
	u32 bar1;
	u32 bar2;
	u32 bar3;
	u16 pci_cmd_word;
	__le16 eeprom[64];
	long unsigned int io_base;
	u32 lastLFC;
	u32 lastRFC;
};

struct ixgb_hw_stats {
	u64 tprl;
	u64 tprh;
	u64 gprcl;
	u64 gprch;
	u64 bprcl;
	u64 bprch;
	u64 mprcl;
	u64 mprch;
	u64 uprcl;
	u64 uprch;
	u64 vprcl;
	u64 vprch;
	u64 jprcl;
	u64 jprch;
	u64 gorcl;
	u64 gorch;
	u64 torl;
	u64 torh;
	u64 rnbc;
	u64 ruc;
	u64 roc;
	u64 rlec;
	u64 crcerrs;
	u64 icbc;
	u64 ecbc;
	u64 mpc;
	u64 tptl;
	u64 tpth;
	u64 gptcl;
	u64 gptch;
	u64 bptcl;
	u64 bptch;
	u64 mptcl;
	u64 mptch;
	u64 uptcl;
	u64 uptch;
	u64 vptcl;
	u64 vptch;
	u64 jptcl;
	u64 jptch;
	u64 gotcl;
	u64 gotch;
	u64 totl;
	u64 toth;
	u64 dc;
	u64 plt64c;
	u64 tsctc;
	u64 tsctfc;
	u64 ibic;
	u64 rfc;
	u64 lfc;
	u64 pfrc;
	u64 pftc;
	u64 mcfrc;
	u64 mcftc;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 rjc;
};

struct ixgb_buffer {
	struct sk_buff *skb;
	dma_addr_t dma;
	long unsigned int time_stamp;
	u16 length;
	u16 next_to_watch;
	u16 mapped_as_page;
};

struct ixgb_desc_ring {
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	unsigned int next_to_use;
	unsigned int next_to_clean;
	struct ixgb_buffer *buffer_info;
};

struct ixgb_adapter {
	struct timer_list watchdog_timer;
	long unsigned int active_vlans[64];
	u32 bd_number;
	u32 rx_buffer_len;
	u32 part_num;
	u16 link_speed;
	u16 link_duplex;
	struct work_struct tx_timeout_task;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ixgb_desc_ring tx_ring;
	unsigned int restart_queue;
	long unsigned int timeo_start;
	u32 tx_cmd_type;
	u64 hw_csum_tx_good;
	u64 hw_csum_tx_error;
	u32 tx_int_delay;
	u32 tx_timeout_count;
	bool tx_int_delay_enable;
	bool detect_tx_hung;
	struct ixgb_desc_ring rx_ring;
	u64 hw_csum_rx_error;
	u64 hw_csum_rx_good;
	u32 rx_int_delay;
	bool rx_csum;
	struct napi_struct napi;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct ixgb_hw hw;
	u16 msg_enable;
	struct ixgb_hw_stats stats;
	u32 alloc_rx_buff_failed;
	bool have_msi;
	long unsigned int flags;
};

enum ixgb_state_t {
	__IXGB_DOWN = 0,
};

typedef enum {
	ixgb_xpak_vendor_intel = 0,
	ixgb_xpak_vendor_infineon = 1,
} ixgb_xpak_vendor;

struct ixgb_ee_map_type {
	u8 mac_addr[6];
	__le16 compatibility;
	__le16 reserved1[4];
	__le32 pba_number;
	__le16 init_ctrl_reg_1;
	__le16 subsystem_id;
	__le16 subvendor_id;
	__le16 device_id;
	__le16 vendor_id;
	__le16 init_ctrl_reg_2;
	__le16 oem_reserved[16];
	__le16 swdpins_reg;
	__le16 circuit_ctrl_reg;
	u8 d3_power;
	u8 d0_power;
	__le16 reserved2[28];
	__le16 checksum;
};

enum {
	NETDEV_STATS___3 = 0,
	IXGB_STATS = 1,
};

struct ixgb_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

struct ixgb_opt_list {
	int i;
	const char *str;
};

struct ixgb_option {
	enum {
		enable_option___2 = 0,
		range_option___2 = 1,
		list_option___2 = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			const struct ixgb_opt_list *p;
		} l;
	} arg;
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
	};
};

struct devlink;

struct devlink_port {
	struct list_head list;
	struct list_head param_list;
	struct list_head region_list;
	struct devlink *devlink;
	unsigned int index;
	bool registered;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct mutex reporters_lock;
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	struct list_head list;
	struct list_head port_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	const struct devlink_ops *ops;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	u8 reload_failed: 1;
	u8 reload_enabled: 1;
	u8 registered: 1;
	long: 61;
	long: 64;
	long: 64;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_sb_pool_info;

struct devlink_info_req;

struct devlink_flash_update_params;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_trap_policer;

struct devlink_ops {
	u32 supported_flash_update_params;
	long unsigned int reload_actions;
	long unsigned int reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, unsigned int, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_function_hw_addr_get)(struct devlink *, struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_function_hw_addr_set)(struct devlink *, struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

struct devlink_flash_update_params {
	const char *file_name;
	const char *component;
	u32 overwrite_mask;
};

struct devlink_trap_policer {
	u32 id;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

enum {
	MLX4_MAX_PORTS = 2,
	MLX4_MAX_PORT_PKEYS = 128,
	MLX4_MAX_PORT_GIDS = 128,
};

enum {
	MLX4_BOARD_ID_LEN = 64,
};

enum {
	MLX4_MAX_NUM_PF = 16,
	MLX4_MAX_NUM_VF = 126,
	MLX4_MAX_NUM_VF_P_PORT = 64,
	MLX4_MFUNC_MAX = 128,
	MLX4_MAX_EQ_NUM = 1024,
	MLX4_MFUNC_EQ_NUM = 4,
	MLX4_MFUNC_MAX_EQES = 8,
	MLX4_MFUNC_EQE_MASK = 7,
};

enum {
	MLX4_BMME_FLAG_WIN_TYPE_2B = 2,
	MLX4_BMME_FLAG_LOCAL_INV = 64,
	MLX4_BMME_FLAG_REMOTE_INV = 128,
	MLX4_BMME_FLAG_TYPE_2_WIN = 512,
	MLX4_BMME_FLAG_RESERVED_LKEY = 1024,
	MLX4_BMME_FLAG_FAST_REG_WR = 2048,
	MLX4_BMME_FLAG_ROCE_V1_V2 = 524288,
	MLX4_BMME_FLAG_PORT_REMAP = 16777216,
	MLX4_BMME_FLAG_VSD_INIT2RTR = 268435456,
};

enum slave_port_state {
	SLAVE_PORT_DOWN = 0,
	SLAVE_PENDING_UP = 1,
	SLAVE_PORT_UP = 2,
};

enum mlx4_qp_region {
	MLX4_QP_REGION_FW = 0,
	MLX4_QP_REGION_RSS_RAW_ETH = 1,
	MLX4_QP_REGION_BOTTOM = 1,
	MLX4_QP_REGION_ETH_ADDR = 2,
	MLX4_QP_REGION_FC_ADDR = 3,
	MLX4_QP_REGION_FC_EXCH = 4,
	MLX4_NUM_QP_REGION = 5,
};

enum mlx4_port_type {
	MLX4_PORT_TYPE_NONE = 0,
	MLX4_PORT_TYPE_IB = 1,
	MLX4_PORT_TYPE_ETH = 2,
	MLX4_PORT_TYPE_AUTO = 3,
};

enum mlx4_steer_type {
	MLX4_MC_STEER = 0,
	MLX4_UC_STEER = 1,
	MLX4_NUM_STEERS = 2,
};

struct mlx4_rate_limit_caps {
	u16 num_rates;
	u8 min_unit;
	u16 min_val;
	u8 max_unit;
	u16 max_val;
};

struct mlx4_phys_caps {
	u32 gid_phys_table_len[3];
	u32 pkey_phys_table_len[3];
	u32 num_phys_eqs;
	u32 base_sqpn;
	u32 base_proxy_sqpn;
	u32 base_tunnel_sqpn;
};

struct mlx4_spec_qps {
	u32 qp0_qkey;
	u32 qp0_proxy;
	u32 qp0_tunnel;
	u32 qp1_proxy;
	u32 qp1_tunnel;
};

struct mlx4_caps {
	u64 fw_ver;
	u32 function;
	int num_ports;
	int vl_cap[3];
	int ib_mtu_cap[3];
	__be32 ib_port_def_cap[3];
	u64 def_mac[3];
	int eth_mtu_cap[3];
	int gid_table_len[3];
	int pkey_table_len[3];
	int trans_type[3];
	int vendor_oui[3];
	int wavelength[3];
	u64 trans_code[3];
	int local_ca_ack_delay;
	int num_uars;
	u32 uar_page_size;
	int bf_reg_size;
	int bf_regs_per_page;
	int max_sq_sg;
	int max_rq_sg;
	int num_qps;
	int max_wqes;
	int max_sq_desc_sz;
	int max_rq_desc_sz;
	int max_qp_init_rdma;
	int max_qp_dest_rdma;
	int max_tc_eth;
	struct mlx4_spec_qps *spec_qps;
	int num_srqs;
	int max_srq_wqes;
	int max_srq_sge;
	int reserved_srqs;
	int num_cqs;
	int max_cqes;
	int reserved_cqs;
	int num_sys_eqs;
	int num_eqs;
	int reserved_eqs;
	int num_comp_vectors;
	int num_mpts;
	int num_mtts;
	int fmr_reserved_mtts;
	int reserved_mtts;
	int reserved_mrws;
	int reserved_uars;
	int num_mgms;
	int num_amgms;
	int reserved_mcgs;
	int num_qp_per_mgm;
	int steering_mode;
	int dmfs_high_steer_mode;
	int fs_log_max_ucast_qp_range_size;
	int num_pds;
	int reserved_pds;
	int max_xrcds;
	int reserved_xrcds;
	int mtt_entry_sz;
	u32 max_msg_sz;
	u32 page_size_cap;
	u64 flags;
	u64 flags2;
	u32 bmme_flags;
	u32 reserved_lkey;
	u16 stat_rate_support;
	u8 port_width_cap[3];
	int max_gso_sz;
	int max_rss_tbl_sz;
	int reserved_qps_cnt[5];
	int reserved_qps;
	int reserved_qps_base[5];
	int log_num_macs;
	int log_num_vlans;
	enum mlx4_port_type port_type[3];
	u8 supported_type[3];
	u8 suggested_type[3];
	u8 default_sense[3];
	u32 port_mask[3];
	enum mlx4_port_type possible_type[3];
	u32 max_counters;
	u8 port_ib_mtu[3];
	u16 sqp_demux;
	u32 eqe_size;
	u32 cqe_size;
	u8 eqe_factor;
	u32 userspace_caps;
	u32 function_caps;
	u16 hca_core_clock;
	u64 phys_port_id[3];
	int tunnel_offload_mode;
	u8 rx_checksum_flags_port[3];
	u8 phv_bit[3];
	u8 alloc_res_qp_mask;
	u32 dmfs_high_rate_qpn_base;
	u32 dmfs_high_rate_qpn_range;
	u32 vf_caps;
	bool wol_port[3];
	struct mlx4_rate_limit_caps rl_caps;
	u32 health_buffer_addrs;
};

struct mlx4_buf_list {
	void *buf;
	dma_addr_t map;
};

struct mlx4_buf {
	struct mlx4_buf_list direct;
	struct mlx4_buf_list *page_list;
	int nbufs;
	int npages;
	int page_shift;
};

struct mlx4_mtt {
	u32 offset;
	int order;
	int page_shift;
};

enum {
	MLX4_DB_PER_PAGE = 1024,
};

struct mlx4_db_pgdir {
	struct list_head list;
	long unsigned int order0[16];
	long unsigned int order1[8];
	long unsigned int *bits[2];
	__be32 *db_page;
	dma_addr_t db_dma;
};

struct mlx4_ib_user_db_page;

struct mlx4_db {
	__be32 *db;
	union {
		struct mlx4_db_pgdir *pgdir;
		struct mlx4_ib_user_db_page *user_page;
	} u;
	dma_addr_t dma;
	int index;
	int order;
};

struct mlx4_hwq_resources {
	struct mlx4_db db;
	struct mlx4_mtt mtt;
	struct mlx4_buf buf;
};

struct mlx4_uar {
	long unsigned int pfn;
	int index;
	struct list_head bf_list;
	unsigned int free_bf_bmap;
	void *map;
	void *bf_map;
};

struct mlx4_quotas {
	int qp;
	int cq;
	int srq;
	int mpt;
	int mtt;
	int counter;
	int xrcd;
};

struct mlx4_vf_dev {
	u8 min_port;
	u8 n_ports;
};

struct devlink_region;

struct mlx4_fw_crdump {
	bool snapshot_enable;
	struct devlink_region *region_crspace;
	struct devlink_region *region_fw_health;
};

enum mlx4_pci_status {
	MLX4_PCI_STATUS_DISABLED = 0,
	MLX4_PCI_STATUS_ENABLED = 1,
};

struct mlx4_dev;

struct mlx4_dev_persistent {
	struct pci_dev *pdev;
	struct mlx4_dev *dev;
	int nvfs[3];
	int num_vfs;
	enum mlx4_port_type curr_port_type[3];
	enum mlx4_port_type curr_port_poss_type[3];
	struct work_struct catas_work;
	struct workqueue_struct *catas_wq;
	struct mutex device_state_mutex;
	u8 state;
	struct mutex interface_state_mutex;
	u8 interface_state;
	struct mutex pci_status_mutex;
	enum mlx4_pci_status pci_status;
	struct mlx4_fw_crdump crdump;
};

struct mlx4_dev {
	struct mlx4_dev_persistent *persist;
	long unsigned int flags;
	long unsigned int num_slaves;
	struct mlx4_caps caps;
	struct mlx4_phys_caps phys_caps;
	struct mlx4_quotas quotas;
	struct xarray qp_table_tree;
	u8 rev_id;
	u8 port_random_macs;
	char board_id[64];
	int numa_node;
	int oper_log_mgm_entry_size;
	u64 regid_promisc_array[3];
	u64 regid_allmulti_array[3];
	struct mlx4_vf_dev *dev_vfs;
	u8 uar_page_shift;
};

struct mlx4_eqe {
	u8 reserved1;
	u8 type;
	u8 reserved2;
	u8 subtype;
	union {
		u32 raw[6];
		struct {
			__be32 cqn;
		} comp;
		struct {
			u16 reserved1;
			__be16 token;
			u32 reserved2;
			u8 reserved3[3];
			u8 status;
			__be64 out_param;
		} __attribute__((packed)) cmd;
		struct {
			__be32 qpn;
		} qp;
		struct {
			__be32 srqn;
		} srq;
		struct {
			__be32 cqn;
			u32 reserved1;
			u8 reserved2[3];
			u8 syndrome;
		} cq_err;
		struct {
			u32 reserved1[2];
			__be32 port;
		} port_change;
		struct {
			u32 reserved;
			u32 bit_vec[4];
		} comm_channel_arm;
		struct {
			u8 port;
			u8 reserved[3];
			__be64 mac;
		} __attribute__((packed)) mac_update;
		struct {
			__be32 slave_id;
		} flr_event;
		struct {
			__be16 current_temperature;
			__be16 warning_threshold;
		} warming;
		struct {
			u8 reserved[3];
			u8 port;
			union {
				struct {
					__be16 mstr_sm_lid;
					__be16 port_lid;
					__be32 changed_attr;
					u8 reserved[3];
					u8 mstr_sm_sl;
					__be64 gid_prefix;
				} __attribute__((packed)) port_info;
				struct {
					__be32 block_ptr;
					__be32 tbl_entries_mask;
				} tbl_change_info;
				struct {
					u8 sl2vl_table[8];
				} sl2vl_tbl_change_info;
			} params;
		} __attribute__((packed)) port_mgmt_change;
		struct {
			u8 reserved[3];
			u8 port;
			u32 reserved1[5];
		} bad_cable;
	} event;
	u8 slave_id;
	u8 reserved3[2];
	u8 owner;
} __attribute__((packed));

struct mlx4_active_ports {
	long unsigned int ports[1];
};

struct mlx4_port_map {
	u8 port1;
	u8 port2;
};

enum {
	MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE = 10,
	MLX4_MIN_MGM_LOG_ENTRY_SIZE = 7,
	MLX4_MAX_MGM_LOG_ENTRY_SIZE = 12,
	MLX4_MAX_QP_PER_MGM = 1016,
};

enum {
	MLX4_CMPT_TYPE_QP = 0,
	MLX4_CMPT_TYPE_SRQ = 1,
	MLX4_CMPT_TYPE_CQ = 2,
	MLX4_CMPT_TYPE_EQ = 3,
	MLX4_CMPT_NUM_TYPE = 4,
};

enum mlx4_resource {
	RES_QP = 0,
	RES_CQ = 1,
	RES_SRQ = 2,
	RES_XRCD = 3,
	RES_MPT = 4,
	RES_MTT = 5,
	RES_MAC = 6,
	RES_VLAN = 7,
	RES_NPORT_ID = 8,
	RES_COUNTER = 9,
	RES_FS_RULE = 10,
	RES_EQ = 11,
	MLX4_NUM_OF_RESOURCE_TYPE = 12,
};

struct mlx4_vhcr_cmd {
	__be64 in_param;
	__be32 in_modifier;
	u32 reserved1;
	__be64 out_param;
	__be16 token;
	u16 reserved;
	u8 status;
	u8 flags;
	__be16 opcode;
};

struct mlx4_bitmap {
	u32 last;
	u32 top;
	u32 max;
	u32 reserved_top;
	u32 mask;
	u32 avail;
	u32 effective_len;
	spinlock_t lock;
	long unsigned int *table;
};

struct mlx4_buddy {
	long unsigned int **bits;
	unsigned int *num_free;
	u32 max_order;
	spinlock_t lock;
};

struct mlx4_icm;

struct mlx4_icm_table {
	u64 virt;
	int num_icm;
	u32 num_obj;
	int obj_size;
	int lowmem;
	int coherent;
	struct mutex mutex;
	struct mlx4_icm **icm;
};

struct mlx4_eq_tasklet {
	struct list_head list;
	struct list_head process_list;
	struct tasklet_struct task;
	spinlock_t lock;
};

struct mlx4_eq {
	struct mlx4_dev *dev;
	void *doorbell;
	int eqn;
	u32 cons_index;
	u16 irq;
	u16 have_irq;
	int nent;
	struct mlx4_buf_list *page_list;
	struct mlx4_mtt mtt;
	struct mlx4_eq_tasklet tasklet_ctx;
	struct mlx4_active_ports actv_ports;
	u32 ref_count;
	cpumask_var_t affinity_mask;
};

struct mlx4_slave_eqe {
	u8 type;
	u8 port;
	u32 param;
};

struct mlx4_slave_event_eq_info {
	int eqn;
	u16 token;
};

struct mlx4_fw {
	u64 clr_int_base;
	u64 catas_offset;
	u64 comm_base;
	u64 clock_offset;
	struct mlx4_icm *fw_icm;
	struct mlx4_icm *aux_icm;
	u32 catas_size;
	u16 fw_pages;
	u8 clr_int_bar;
	u8 catas_bar;
	u8 comm_bar;
	u8 clock_bar;
};

struct mlx4_comm {
	u32 slave_write;
	u32 slave_read;
};

struct mlx4_vlan_fltr {
	__be32 entry[128];
};

struct mlx4_slave_state {
	u8 comm_toggle;
	u8 last_cmd;
	u8 init_port_mask;
	bool active;
	bool old_vlan_api;
	bool vst_qinq_supported;
	u8 function;
	dma_addr_t vhcr_dma;
	u16 user_mtu[3];
	u16 mtu[3];
	__be32 ib_cap_mask[3];
	struct mlx4_slave_eqe eq[8];
	struct list_head mcast_filters[3];
	struct mlx4_vlan_fltr *vlan_filter[3];
	struct mlx4_slave_event_eq_info event_eq[64];
	u16 eq_pi;
	u16 eq_ci;
	spinlock_t lock;
	u8 is_slave_going_down;
	u32 cookie;
	enum slave_port_state port_state[3];
};

struct mlx4_vport_state {
	u64 mac;
	u16 default_vlan;
	u8 default_qos;
	__be16 vlan_proto;
	u32 tx_rate;
	bool spoofchk;
	u32 link_state;
	u8 qos_vport;
	__be64 guid;
};

struct mlx4_vf_admin_state {
	struct mlx4_vport_state vport[3];
	u8 enable_smi[3];
};

struct mlx4_vport_oper_state {
	struct mlx4_vport_state state;
	int mac_idx;
	int vlan_idx;
};

struct mlx4_vf_oper_state {
	struct mlx4_vport_oper_state vport[3];
	u8 smi_enabled[3];
};

struct slave_list {
	struct mutex mutex;
	struct list_head res_list[12];
};

struct resource_allocator {
	spinlock_t alloc_lock;
	union {
		unsigned int res_reserved;
		unsigned int res_port_rsvd[2];
	};
	union {
		int res_free;
		int res_port_free[2];
	};
	int *quota;
	int *allocated;
	int *guaranteed;
};

struct mlx4_resource_tracker {
	spinlock_t lock;
	struct rb_root res_tree[12];
	struct slave_list *slave_list;
	struct resource_allocator res_alloc[12];
};

struct mlx4_slave_event_eq {
	u32 eqn;
	u32 cons;
	u32 prod;
	spinlock_t event_lock;
	struct mlx4_eqe event_eqe[128];
};

struct mlx4_qos_manager {
	int num_of_qos_vfs;
	long unsigned int priority_bm[1];
};

struct mlx4_master_qp0_state {
	int proxy_qp0_active;
	int qp0_active;
	int port_active;
};

struct mlx4_mfunc_master_ctx {
	struct mlx4_slave_state *slave_state;
	struct mlx4_vf_admin_state *vf_admin;
	struct mlx4_vf_oper_state *vf_oper;
	struct mlx4_master_qp0_state qp0_state[3];
	int init_port_ref[3];
	u16 max_mtu[3];
	u16 max_user_mtu[3];
	u8 pptx;
	u8 pprx;
	int disable_mcast_ref[3];
	struct mlx4_resource_tracker res_tracker;
	struct workqueue_struct *comm_wq;
	struct work_struct comm_work;
	struct work_struct slave_event_work;
	struct work_struct slave_flr_event_work;
	spinlock_t slave_state_lock;
	__be32 comm_arm_bit_vector[4];
	struct mlx4_eqe cmd_eqe;
	struct mlx4_slave_event_eq slave_eq;
	struct mutex gen_eqe_mutex[128];
	struct mlx4_qos_manager qos_ctl[3];
};

struct mlx4_mfunc {
	struct mlx4_comm *comm;
	struct mlx4_vhcr_cmd *vhcr;
	dma_addr_t vhcr_dma;
	struct mlx4_mfunc_master_ctx master;
};

struct mlx4_cmd_context;

struct mlx4_cmd {
	struct dma_pool___2 *pool;
	void *hcr;
	struct mutex slave_cmd_mutex;
	struct semaphore poll_sem;
	struct semaphore event_sem;
	struct rw_semaphore switch_sem;
	int max_cmds;
	spinlock_t context_lock;
	int free_head;
	struct mlx4_cmd_context *context;
	u16 token_mask;
	u8 use_events;
	u8 toggle;
	u8 comm_toggle;
	u8 initialized;
};

struct mlx4_uar_table {
	struct mlx4_bitmap bitmap;
};

struct mlx4_mr_table {
	struct mlx4_bitmap mpt_bitmap;
	struct mlx4_buddy mtt_buddy;
	u64 mtt_base;
	u64 mpt_base;
	struct mlx4_icm_table mtt_table;
	struct mlx4_icm_table dmpt_table;
};

struct mlx4_cq_table {
	struct mlx4_bitmap bitmap;
	spinlock_t lock;
	struct xarray tree;
	struct mlx4_icm_table table;
	struct mlx4_icm_table cmpt_table;
};

struct mlx4_eq_table {
	struct mlx4_bitmap bitmap;
	char *irq_names;
	void *clr_int;
	void **uar_map;
	u32 clr_mask;
	struct mlx4_eq *eq;
	struct mlx4_icm_table table;
	struct mlx4_icm_table cmpt_table;
	int have_irq;
	u8 inta_pin;
};

struct mlx4_srq_table {
	struct mlx4_bitmap bitmap;
	spinlock_t lock;
	struct xarray tree;
	struct mlx4_icm_table table;
	struct mlx4_icm_table cmpt_table;
};

struct mlx4_zone_allocator;

struct mlx4_qp_table {
	struct mlx4_bitmap *bitmap_gen;
	struct mlx4_zone_allocator *zones;
	u32 zones_uids[3];
	u32 rdmarc_base;
	int rdmarc_shift;
	spinlock_t lock;
	struct mlx4_icm_table qp_table;
	struct mlx4_icm_table auxc_table;
	struct mlx4_icm_table altc_table;
	struct mlx4_icm_table rdmarc_table;
	struct mlx4_icm_table cmpt_table;
};

struct mlx4_mcg_table {
	struct mutex mutex;
	struct mlx4_bitmap bitmap;
	struct mlx4_icm_table table;
};

struct mlx4_catas_err {
	u32 *map;
	struct timer_list timer;
	struct list_head list;
};

struct mlx4_mac_table {
	__be64 entries[128];
	int refs[128];
	bool is_dup[128];
	struct mutex mutex;
	int total;
	int max;
};

struct mlx4_vlan_table {
	__be32 entries[128];
	int refs[128];
	int is_dup[128];
	struct mutex mutex;
	int total;
	int max;
};

struct mlx4_roce_gid_entry {
	u8 raw[16];
};

struct mlx4_roce_gid_table {
	struct mlx4_roce_gid_entry roce_gids[128];
	struct mutex mutex;
};

struct mlx4_port_info {
	struct mlx4_dev *dev;
	int port;
	char dev_name[16];
	struct device_attribute port_attr;
	enum mlx4_port_type tmp_type;
	char dev_mtu_name[16];
	struct device_attribute port_mtu_attr;
	struct mlx4_mac_table mac_table;
	struct mlx4_vlan_table vlan_table;
	struct mlx4_roce_gid_table gid_table;
	int base_qpn;
	struct cpu_rmap *rmap;
	struct devlink_port devlink_port;
};

struct mlx4_sense {
	struct mlx4_dev *dev;
	u8 do_sense_port[3];
	u8 sense_allowed[3];
	struct delayed_work sense_poll;
};

struct mlx4_msix_ctl {
	long unsigned int pool_bm[2];
	struct mutex pool_lock;
};

struct mlx4_steer;

struct io_mapping;

struct mlx4_priv {
	struct mlx4_dev dev;
	struct list_head dev_list;
	struct list_head ctx_list;
	spinlock_t ctx_lock;
	int pci_dev_data;
	int removed;
	struct list_head pgdir_list;
	struct mutex pgdir_mutex;
	struct mlx4_fw fw;
	struct mlx4_cmd cmd;
	struct mlx4_mfunc mfunc;
	struct mlx4_bitmap pd_bitmap;
	struct mlx4_bitmap xrcd_bitmap;
	struct mlx4_uar_table uar_table;
	struct mlx4_mr_table mr_table;
	struct mlx4_cq_table cq_table;
	struct mlx4_eq_table eq_table;
	struct mlx4_srq_table srq_table;
	struct mlx4_qp_table qp_table;
	struct mlx4_mcg_table mcg_table;
	struct mlx4_bitmap counters_bitmap;
	int def_counter[2];
	struct mlx4_catas_err catas_err;
	void *clr_base;
	struct mlx4_uar driver_uar;
	void *kar;
	struct mlx4_port_info port[3];
	struct mlx4_sense sense;
	struct mutex port_mutex;
	struct mlx4_msix_ctl msix_ctl;
	struct mlx4_steer *steer;
	struct list_head bf_list;
	struct mutex bf_mutex;
	struct io_mapping *bf_mapping;
	void *clock_mapping;
	int reserved_mtts;
	int fs_hash_mode;
	u8 virt2phys_pkey[32768];
	struct mlx4_port_map v2p;
	struct mutex bond_mutex;
	__be64 slave_node_guids[128];
	atomic_t opreq_count;
	struct work_struct opreq_task;
};

enum mlx4_qp_table_zones {
	MLX4_QP_TABLE_ZONE_GENERAL = 0,
	MLX4_QP_TABLE_ZONE_RSS = 1,
	MLX4_QP_TABLE_ZONE_RAW_ETH = 2,
	MLX4_QP_TABLE_ZONE_NUM = 3,
};

enum mlx4_zone_alloc_flags {
	MLX4_ZONE_ALLOC_FLAGS_NO_OVERLAP = 1,
};

struct mlx4_zone_allocator {
	struct list_head entries;
	struct list_head prios;
	u32 last_uid;
	u32 mask;
	spinlock_t lock;
	enum mlx4_zone_alloc_flags flags;
};

struct mlx4_steer {
	struct list_head promisc_qps[2];
	struct list_head steer_entries[2];
};

enum {
	MLX4_NO_RR = 0,
	MLX4_USE_RR = 1,
};

enum mlx4_zone_flags {
	MLX4_ZONE_ALLOW_ALLOC_FROM_LOWER_PRIO = 1,
	MLX4_ZONE_ALLOW_ALLOC_FROM_EQ_PRIO = 2,
	MLX4_ZONE_FALLBACK_TO_HIGHER_PRIO = 4,
	MLX4_ZONE_USE_RR = 8,
};

struct mlx4_zone_entry {
	struct list_head list;
	struct list_head prio_list;
	u32 uid;
	struct mlx4_zone_allocator *allocator;
	struct mlx4_bitmap *bitmap;
	int use_rr;
	int priority;
	int offset;
	enum mlx4_zone_flags flags;
};

enum {
	MLX4_FLAG_MSI_X = 1,
	MLX4_FLAG_OLD_PORT_CMDS = 2,
	MLX4_FLAG_MASTER = 4,
	MLX4_FLAG_SLAVE = 8,
	MLX4_FLAG_SRIOV = 16,
	MLX4_FLAG_OLD_REG_MAC = 64,
	MLX4_FLAG_BONDED = 128,
	MLX4_FLAG_SECURE_HOST = 256,
};

enum {
	MLX4_VF_CAP_FLAG_RESET = 1,
};

enum {
	MLX4_DEVICE_STATE_UP = 1,
	MLX4_DEVICE_STATE_INTERNAL_ERROR = 2,
};

enum {
	MLX4_INTERFACE_STATE_UP = 1,
	MLX4_INTERFACE_STATE_DELETION = 2,
	MLX4_INTERFACE_STATE_NOWAIT = 4,
};

enum mlx4_dev_event {
	MLX4_DEV_EVENT_CATASTROPHIC_ERROR = 0,
	MLX4_DEV_EVENT_PORT_UP = 1,
	MLX4_DEV_EVENT_PORT_DOWN = 2,
	MLX4_DEV_EVENT_PORT_REINIT = 3,
	MLX4_DEV_EVENT_PORT_MGMT_CHANGE = 4,
	MLX4_DEV_EVENT_SLAVE_INIT = 5,
	MLX4_DEV_EVENT_SLAVE_SHUTDOWN = 6,
};

enum {
	MLX4_HCR_BASE = 525952,
	MLX4_HCR_SIZE = 28,
	MLX4_CLR_INT_SIZE = 8,
	MLX4_SLAVE_COMM_BASE = 0,
	MLX4_COMM_PAGESIZE = 4096,
	MLX4_CLOCK_SIZE = 8,
	MLX4_COMM_CHAN_CAPS = 8,
	MLX4_COMM_CHAN_FLAGS = 12,
};

enum {
	MLX4_CATAS_POLL_INTERVAL = 5000,
};

enum {
	IFLA_VF_LINK_STATE_AUTO = 0,
	IFLA_VF_LINK_STATE_ENABLE = 1,
	IFLA_VF_LINK_STATE_DISABLE = 2,
	__IFLA_VF_LINK_STATE_MAX = 3,
};

enum {
	MLX4_DEV_CAP_FLAG2_RSS = 1,
	MLX4_DEV_CAP_FLAG2_RSS_TOP = 2,
	MLX4_DEV_CAP_FLAG2_RSS_XOR = 4,
	MLX4_DEV_CAP_FLAG2_FS_EN = 8,
	MLX4_DEV_CAP_FLAG2_REASSIGN_MAC_EN = 16,
	MLX4_DEV_CAP_FLAG2_TS = 32,
	MLX4_DEV_CAP_FLAG2_VLAN_CONTROL = 64,
	MLX4_DEV_CAP_FLAG2_FSM = 128,
	MLX4_DEV_CAP_FLAG2_UPDATE_QP = 256,
	MLX4_DEV_CAP_FLAG2_DMFS_IPOIB = 512,
	MLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS = 1024,
	MLX4_DEV_CAP_FLAG2_MAD_DEMUX = 2048,
	MLX4_DEV_CAP_FLAG2_CQE_STRIDE = 4096,
	MLX4_DEV_CAP_FLAG2_EQE_STRIDE = 8192,
	MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL = 16384,
	MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP = 32768,
	MLX4_DEV_CAP_FLAG2_CONFIG_DEV = 65536,
	MLX4_DEV_CAP_FLAG2_SYS_EQS = 131072,
	MLX4_DEV_CAP_FLAG2_80_VFS = 262144,
	MLX4_DEV_CAP_FLAG2_FS_A0 = 524288,
	MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT = 1048576,
	MLX4_DEV_CAP_FLAG2_PORT_REMAP = 2097152,
	MLX4_DEV_CAP_FLAG2_QCN = 4194304,
	MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT = 8388608,
	MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN = 16777216,
	MLX4_DEV_CAP_FLAG2_QOS_VPP = 33554432,
	MLX4_DEV_CAP_FLAG2_ETS_CFG = 67108864,
	MLX4_DEV_CAP_FLAG2_PORT_BEACON = 134217728,
	MLX4_DEV_CAP_FLAG2_IGNORE_FCS = 268435456,
	MLX4_DEV_CAP_FLAG2_PHV_EN = 536870912,
	MLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN = 1073741824,
	MLX4_DEV_CAP_FLAG2_UPDATE_QP_SRC_CHECK_LB = 2147483648,
	MLX4_DEV_CAP_FLAG2_LB_SRC_CHK = 0,
	MLX4_DEV_CAP_FLAG2_ROCE_V1_V2 = 0,
	MLX4_DEV_CAP_FLAG2_DMFS_UC_MC_SNIFFER = 0,
	MLX4_DEV_CAP_FLAG2_DIAG_PER_PORT = 0,
	MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP = 0,
	MLX4_DEV_CAP_FLAG2_SL_TO_VL_CHANGE_EVENT = 0,
	MLX4_DEV_CAP_FLAG2_USER_MAC_EN = 0,
	MLX4_DEV_CAP_FLAG2_DRIVER_VERSION_TO_FW = 0,
	MLX4_DEV_CAP_FLAG2_SW_CQ_INIT = 0,
};

enum mlx4_event {
	MLX4_EVENT_TYPE_COMP = 0,
	MLX4_EVENT_TYPE_PATH_MIG = 1,
	MLX4_EVENT_TYPE_COMM_EST = 2,
	MLX4_EVENT_TYPE_SQ_DRAINED = 3,
	MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE = 19,
	MLX4_EVENT_TYPE_SRQ_LIMIT = 20,
	MLX4_EVENT_TYPE_CQ_ERROR = 4,
	MLX4_EVENT_TYPE_WQ_CATAS_ERROR = 5,
	MLX4_EVENT_TYPE_EEC_CATAS_ERROR = 6,
	MLX4_EVENT_TYPE_PATH_MIG_FAILED = 7,
	MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR = 16,
	MLX4_EVENT_TYPE_WQ_ACCESS_ERROR = 17,
	MLX4_EVENT_TYPE_SRQ_CATAS_ERROR = 18,
	MLX4_EVENT_TYPE_LOCAL_CATAS_ERROR = 8,
	MLX4_EVENT_TYPE_PORT_CHANGE = 9,
	MLX4_EVENT_TYPE_EQ_OVERFLOW = 15,
	MLX4_EVENT_TYPE_ECC_DETECT = 14,
	MLX4_EVENT_TYPE_CMD = 10,
	MLX4_EVENT_TYPE_VEP_UPDATE = 25,
	MLX4_EVENT_TYPE_COMM_CHANNEL = 24,
	MLX4_EVENT_TYPE_OP_REQUIRED = 26,
	MLX4_EVENT_TYPE_FATAL_WARNING = 27,
	MLX4_EVENT_TYPE_FLR_EVENT = 28,
	MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT = 29,
	MLX4_EVENT_TYPE_RECOVERABLE_ERROR_EVENT = 62,
	MLX4_EVENT_TYPE_NONE = 255,
};

enum {
	MLX4_PORT_CHANGE_SUBTYPE_DOWN = 1,
	MLX4_PORT_CHANGE_SUBTYPE_ACTIVE = 4,
};

struct mlx4_counter {
	u8 reserved1[3];
	u8 counter_mode;
	__be32 num_ifc;
	u32 reserved2[2];
	__be64 rx_frames;
	__be64 rx_bytes;
	__be64 tx_frames;
	__be64 tx_bytes;
};

struct mlx4_slaves_pport {
	long unsigned int slaves[2];
};

enum {
	MLX4_CMD_SYS_EN = 1,
	MLX4_CMD_SYS_DIS = 2,
	MLX4_CMD_MAP_FA = 4095,
	MLX4_CMD_UNMAP_FA = 4094,
	MLX4_CMD_RUN_FW = 4086,
	MLX4_CMD_MOD_STAT_CFG = 52,
	MLX4_CMD_QUERY_DEV_CAP = 3,
	MLX4_CMD_QUERY_FW = 4,
	MLX4_CMD_ENABLE_LAM = 4088,
	MLX4_CMD_DISABLE_LAM = 4087,
	MLX4_CMD_QUERY_DDR = 5,
	MLX4_CMD_QUERY_ADAPTER = 6,
	MLX4_CMD_INIT_HCA = 7,
	MLX4_CMD_CLOSE_HCA = 8,
	MLX4_CMD_INIT_PORT = 9,
	MLX4_CMD_CLOSE_PORT = 10,
	MLX4_CMD_QUERY_HCA = 11,
	MLX4_CMD_QUERY_PORT = 67,
	MLX4_CMD_SENSE_PORT = 77,
	MLX4_CMD_HW_HEALTH_CHECK = 80,
	MLX4_CMD_SET_PORT = 12,
	MLX4_CMD_SET_NODE = 90,
	MLX4_CMD_QUERY_FUNC = 86,
	MLX4_CMD_ACCESS_DDR = 46,
	MLX4_CMD_MAP_ICM = 4090,
	MLX4_CMD_UNMAP_ICM = 4089,
	MLX4_CMD_MAP_ICM_AUX = 4092,
	MLX4_CMD_UNMAP_ICM_AUX = 4091,
	MLX4_CMD_SET_ICM_SIZE = 4093,
	MLX4_CMD_ACCESS_REG = 59,
	MLX4_CMD_ALLOCATE_VPP = 128,
	MLX4_CMD_SET_VPORT_QOS = 129,
	MLX4_CMD_INFORM_FLR_DONE = 91,
	MLX4_CMD_VIRT_PORT_MAP = 92,
	MLX4_CMD_GET_OP_REQ = 89,
	MLX4_CMD_SW2HW_MPT = 13,
	MLX4_CMD_QUERY_MPT = 14,
	MLX4_CMD_HW2SW_MPT = 15,
	MLX4_CMD_READ_MTT = 16,
	MLX4_CMD_WRITE_MTT = 17,
	MLX4_CMD_SYNC_TPT = 47,
	MLX4_CMD_MAP_EQ = 18,
	MLX4_CMD_SW2HW_EQ = 19,
	MLX4_CMD_HW2SW_EQ = 20,
	MLX4_CMD_QUERY_EQ = 21,
	MLX4_CMD_SW2HW_CQ = 22,
	MLX4_CMD_HW2SW_CQ = 23,
	MLX4_CMD_QUERY_CQ = 24,
	MLX4_CMD_MODIFY_CQ = 44,
	MLX4_CMD_SW2HW_SRQ = 53,
	MLX4_CMD_HW2SW_SRQ = 54,
	MLX4_CMD_QUERY_SRQ = 55,
	MLX4_CMD_ARM_SRQ = 64,
	MLX4_CMD_RST2INIT_QP = 25,
	MLX4_CMD_INIT2RTR_QP = 26,
	MLX4_CMD_RTR2RTS_QP = 27,
	MLX4_CMD_RTS2RTS_QP = 28,
	MLX4_CMD_SQERR2RTS_QP = 29,
	MLX4_CMD_2ERR_QP = 30,
	MLX4_CMD_RTS2SQD_QP = 31,
	MLX4_CMD_SQD2SQD_QP = 56,
	MLX4_CMD_SQD2RTS_QP = 32,
	MLX4_CMD_2RST_QP = 33,
	MLX4_CMD_QUERY_QP = 34,
	MLX4_CMD_INIT2INIT_QP = 45,
	MLX4_CMD_SUSPEND_QP = 50,
	MLX4_CMD_UNSUSPEND_QP = 51,
	MLX4_CMD_UPDATE_QP = 97,
	MLX4_CMD_CONF_SPECIAL_QP = 35,
	MLX4_CMD_MAD_IFC = 36,
	MLX4_CMD_MAD_DEMUX = 515,
	MLX4_CMD_READ_MCG = 37,
	MLX4_CMD_WRITE_MCG = 38,
	MLX4_CMD_MGID_HASH = 39,
	MLX4_CMD_DIAG_RPRT = 48,
	MLX4_CMD_NOP = 49,
	MLX4_CMD_CONFIG_DEV = 58,
	MLX4_CMD_ACCESS_MEM = 46,
	MLX4_CMD_SET_VEP = 82,
	MLX4_CMD_SET_VLAN_FLTR = 71,
	MLX4_CMD_SET_MCAST_FLTR = 72,
	MLX4_CMD_DUMP_ETH_STATS = 73,
	MLX4_CMD_ARM_COMM_CHANNEL = 87,
	MLX4_CMD_GEN_EQE = 88,
	MLX4_CMD_ALLOC_RES = 3840,
	MLX4_CMD_FREE_RES = 3841,
	MLX4_CMD_MCAST_ATTACH = 3845,
	MLX4_CMD_UCAST_ATTACH = 3846,
	MLX4_CMD_PROMISC = 3848,
	MLX4_CMD_QUERY_FUNC_CAP = 3850,
	MLX4_CMD_QP_ATTACH = 3851,
	MLX4_CMD_QUERY_DEBUG_MSG = 42,
	MLX4_CMD_SET_DEBUG_MSG = 43,
	MLX4_CMD_QUERY_IF_STAT = 84,
	MLX4_CMD_SET_IF_STAT = 85,
	MLX4_QP_FLOW_STEERING_ATTACH = 101,
	MLX4_QP_FLOW_STEERING_DETACH = 102,
	MLX4_FLOW_STEERING_IB_UC_QP_RANGE = 100,
	MLX4_CMD_CONGESTION_CTRL_OPCODE = 104,
};

enum {
	MLX4_CMD_TIME_CLASS_A = 60000,
	MLX4_CMD_TIME_CLASS_B = 60000,
	MLX4_CMD_TIME_CLASS_C = 60000,
};

enum {
	MLX4_MAILBOX_SIZE = 4096,
	MLX4_ACCESS_MEM_ALIGN = 256,
};

enum {
	MLX4_SET_PORT_IB_OPCODE = 0,
	MLX4_SET_PORT_ETH_OPCODE = 1,
	MLX4_SET_PORT_BEACON_OPCODE = 4,
};

enum {
	MLX4_CMD_WRAPPED = 0,
	MLX4_CMD_NATIVE = 1,
};

struct mlx4_cmd_mailbox {
	void *buf;
	dma_addr_t dma;
};

enum {
	IB_USER_MAD_USER_RMPP = 1,
};

enum {
	IB_MGMT_MAD_HDR = 24,
	IB_MGMT_MAD_DATA = 232,
	IB_MGMT_RMPP_HDR = 36,
	IB_MGMT_RMPP_DATA = 220,
	IB_MGMT_VENDOR_HDR = 40,
	IB_MGMT_VENDOR_DATA = 216,
	IB_MGMT_SA_HDR = 56,
	IB_MGMT_SA_DATA = 200,
	IB_MGMT_DEVICE_HDR = 64,
	IB_MGMT_DEVICE_DATA = 192,
	IB_MGMT_MAD_SIZE = 256,
	OPA_MGMT_MAD_DATA = 2024,
	OPA_MGMT_RMPP_DATA = 2012,
	OPA_MGMT_MAD_SIZE = 2048,
};

struct ib_smp {
	u8 base_version;
	u8 mgmt_class;
	u8 class_version;
	u8 method;
	__be16 status;
	u8 hop_ptr;
	u8 hop_cnt;
	__be64 tid;
	__be16 attr_id;
	__be16 resv;
	__be32 attr_mod;
	__be64 mkey;
	__be16 dr_slid;
	__be16 dr_dlid;
	u8 reserved[28];
	u8 data[64];
	u8 initial_path[64];
	u8 return_path[64];
};

struct mlx4_vport_qos_param {
	u32 bw_share;
	u32 max_avg_bw;
	u8 enable;
};

enum {
	MLX4_COMM_CMD_RESET = 0,
	MLX4_COMM_CMD_VHCR0 = 1,
	MLX4_COMM_CMD_VHCR1 = 2,
	MLX4_COMM_CMD_VHCR2 = 3,
	MLX4_COMM_CMD_VHCR_EN = 4,
	MLX4_COMM_CMD_VHCR_POST = 5,
	MLX4_COMM_CMD_FLR = 254,
};

enum {
	MLX4_VF_SMI_DISABLED = 0,
	MLX4_VF_SMI_ENABLED = 1,
};

struct mlx4_vhcr {
	u64 in_param;
	u64 out_param;
	u32 in_modifier;
	u32 errno;
	u16 op;
	u16 token;
	u8 op_modifier;
	u8 e_bit;
};

struct mlx4_cmd_info {
	u16 opcode;
	bool has_inbox;
	bool has_outbox;
	bool out_is_imm;
	bool encode_slave_id;
	int (*verify)(struct mlx4_dev *, int, struct mlx4_vhcr *, struct mlx4_cmd_mailbox *);
	int (*wrapper)(struct mlx4_dev *, int, struct mlx4_vhcr *, struct mlx4_cmd_mailbox *, struct mlx4_cmd_mailbox *, struct mlx4_cmd_info *);
};

struct mlx4_icm {
	struct list_head chunk_list;
	int refcount;
};

struct mlx4_cmd_context {
	struct completion done;
	int result;
	int next;
	u64 out_param;
	u16 token;
	u8 fw_status;
};

enum {
	MLX4_VF_IMMED_VLAN_FLAG_VLAN = 1,
	MLX4_VF_IMMED_VLAN_FLAG_QOS = 2,
	MLX4_VF_IMMED_VLAN_FLAG_LINK_DISABLE = 4,
};

struct mlx4_vf_immed_vlan_work {
	struct work_struct work;
	struct mlx4_priv *priv;
	int flags;
	int slave;
	int vlan_ix;
	int orig_vlan_ix;
	u8 port;
	u8 qos;
	u8 qos_vport;
	u16 vlan_id;
	u16 orig_vlan_id;
	__be16 vlan_proto;
};

enum {
	MLX4_CMD_CLEANUP_STRUCT = 1,
	MLX4_CMD_CLEANUP_POOL = 2,
	MLX4_CMD_CLEANUP_HCR = 4,
	MLX4_CMD_CLEANUP_VHCR = 8,
	MLX4_CMD_CLEANUP_ALL = 15,
};

enum {
	CMD_STAT_OK = 0,
	CMD_STAT_INTERNAL_ERR = 1,
	CMD_STAT_BAD_OP = 2,
	CMD_STAT_BAD_PARAM = 3,
	CMD_STAT_BAD_SYS_STATE = 4,
	CMD_STAT_BAD_RESOURCE = 5,
	CMD_STAT_RESOURCE_BUSY = 6,
	CMD_STAT_EXCEED_LIM = 8,
	CMD_STAT_BAD_RES_STATE = 9,
	CMD_STAT_BAD_INDEX = 10,
	CMD_STAT_BAD_NVMEM = 11,
	CMD_STAT_ICM_ERROR = 12,
	CMD_STAT_BAD_QP_STATE = 16,
	CMD_STAT_BAD_SEG_PARAM = 32,
	CMD_STAT_REG_BOUND = 33,
	CMD_STAT_LAM_NOT_PRE = 34,
	CMD_STAT_BAD_PKT = 48,
	CMD_STAT_BAD_SIZE = 64,
	CMD_STAT_MULTI_FUNC_REQ = 80,
};

enum {
	HCR_IN_PARAM_OFFSET = 0,
	HCR_IN_MODIFIER_OFFSET = 8,
	HCR_OUT_PARAM_OFFSET = 12,
	HCR_TOKEN_OFFSET = 20,
	HCR_STATUS_OFFSET = 24,
	HCR_OPMOD_SHIFT = 12,
	HCR_T_BIT = 21,
	HCR_E_BIT = 22,
	HCR_GO_BIT = 23,
};

enum {
	GO_BIT_TIMEOUT_MSECS = 10000,
};

struct mlx4_cq {
	void (*comp)(struct mlx4_cq *);
	void (*event)(struct mlx4_cq *, enum mlx4_event);
	struct mlx4_uar *uar;
	u32 cons_index;
	u16 irq;
	__be32 *set_ci_db;
	__be32 *arm_db;
	int arm_sn;
	int cqn;
	unsigned int vector;
	refcount_t refcount;
	struct completion free;
	struct {
		struct list_head list;
		void (*comp)(struct mlx4_cq *);
		void *priv;
	} tasklet_ctx;
	int reset_notify_added;
	struct list_head reset_notify;
	u8 usage;
};

enum mlx4_alloc_mode {
	RES_OP_RESERVE = 0,
	RES_OP_RESERVE_AND_MAP = 1,
	RES_OP_MAP_ICM = 2,
};

struct mlx4_cq_context {
	__be32 flags;
	u16 reserved1[3];
	__be16 page_offset;
	__be32 logsize_usrpage;
	__be16 cq_period;
	__be16 cq_max_count;
	u8 reserved2[3];
	u8 comp_eqn;
	u8 log_page_size;
	u8 reserved3[2];
	u8 mtt_base_addr_h;
	__be32 mtt_base_addr_l;
	__be32 last_notified_index;
	__be32 solicit_producer_index;
	__be32 consumer_index;
	__be32 producer_index;
	u32 reserved4[2];
	__be64 db_rec_addr;
};

enum {
	MLX4_ICM_PAGE_SHIFT = 12,
	MLX4_ICM_PAGE_SIZE = 4096,
};

enum {
	MLX4_DEV_CAP_FLAG_RC = 1,
	MLX4_DEV_CAP_FLAG_UC = 2,
	MLX4_DEV_CAP_FLAG_UD = 4,
	MLX4_DEV_CAP_FLAG_XRC = 8,
	MLX4_DEV_CAP_FLAG_SRQ = 64,
	MLX4_DEV_CAP_FLAG_IPOIB_CSUM = 128,
	MLX4_DEV_CAP_FLAG_BAD_PKEY_CNTR = 256,
	MLX4_DEV_CAP_FLAG_BAD_QKEY_CNTR = 512,
	MLX4_DEV_CAP_FLAG_DPDP = 4096,
	MLX4_DEV_CAP_FLAG_BLH = 32768,
	MLX4_DEV_CAP_FLAG_MEM_WINDOW = 65536,
	MLX4_DEV_CAP_FLAG_APM = 131072,
	MLX4_DEV_CAP_FLAG_ATOMIC = 262144,
	MLX4_DEV_CAP_FLAG_RAW_MCAST = 524288,
	MLX4_DEV_CAP_FLAG_UD_AV_PORT = 1048576,
	MLX4_DEV_CAP_FLAG_UD_MCAST = 2097152,
	MLX4_DEV_CAP_FLAG_IBOE = 1073741824,
	MLX4_DEV_CAP_FLAG_UC_LOOPBACK = 0,
	MLX4_DEV_CAP_FLAG_FCS_KEEP = 0,
	MLX4_DEV_CAP_FLAG_WOL_PORT1 = 0,
	MLX4_DEV_CAP_FLAG_WOL_PORT2 = 0,
	MLX4_DEV_CAP_FLAG_UDP_RSS = 0,
	MLX4_DEV_CAP_FLAG_VEP_UC_STEER = 0,
	MLX4_DEV_CAP_FLAG_VEP_MC_STEER = 0,
	MLX4_DEV_CAP_FLAG_COUNTERS = 0,
	MLX4_DEV_CAP_FLAG_RSS_IP_FRAG = 0,
	MLX4_DEV_CAP_FLAG_SET_ETH_SCHED = 0,
	MLX4_DEV_CAP_FLAG_SENSE_SUPPORT = 0,
	MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV = 0,
	MLX4_DEV_CAP_FLAG_64B_EQE = 0,
	MLX4_DEV_CAP_FLAG_64B_CQE = 0,
};

enum {
	MLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_BAD_CABLE = 1,
	MLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_UNSUPPORTED_CABLE = 2,
};

enum {
	MLX4_FATAL_WARNING_SUBTYPE_WARMING = 0,
};

enum slave_port_gen_event {
	SLAVE_PORT_GEN_EVENT_DOWN = 0,
	SLAVE_PORT_GEN_EVENT_UP = 1,
	SLAVE_PORT_GEN_EVENT_NONE = 2,
};

enum slave_port_state_event {
	MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN = 0,
	MLX4_PORT_STATE_DEV_EVENT_PORT_UP = 1,
	MLX4_PORT_STATE_IB_PORT_STATE_EVENT_GID_VALID = 2,
	MLX4_PORT_STATE_IB_EVENT_GID_INVALID = 3,
};

enum {
	MLX4_DEV_PMC_SUBTYPE_GUID_INFO = 20,
	MLX4_DEV_PMC_SUBTYPE_PORT_INFO = 21,
	MLX4_DEV_PMC_SUBTYPE_PKEY_TABLE = 22,
	MLX4_DEV_PMC_SUBTYPE_SL_TO_VL_MAP = 23,
};

struct mlx4_eq_context {
	__be32 flags;
	u16 reserved1[3];
	__be16 page_offset;
	u8 log_eq_size;
	u8 reserved2[4];
	u8 eq_period;
	u8 reserved3;
	u8 eq_max_count;
	u8 reserved4[3];
	u8 intr;
	u8 log_page_size;
	u8 reserved5[2];
	u8 mtt_base_addr_h;
	__be32 mtt_base_addr_l;
	u32 reserved6[2];
	__be32 consumer_index;
	__be32 producer_index;
	u32 reserved7[4];
};

struct mlx4_port_cap {
	u8 link_state;
	u8 supported_port_types;
	u8 suggested_type;
	u8 default_sense;
	u8 log_max_macs;
	u8 log_max_vlans;
	int ib_mtu;
	int max_port_width;
	int max_vl;
	int max_tc_eth;
	int max_gids;
	int max_pkeys;
	u64 def_mac;
	u16 eth_mtu;
	int trans_type;
	int vendor_oui;
	u16 wavelength;
	u64 trans_code;
	u8 dmfs_optimized_state;
};

enum {
	MLX4_IRQNAME_SIZE = 32,
};

enum {
	MLX4_NUM_ASYNC_EQE = 256,
	MLX4_NUM_SPARE_EQE = 128,
	MLX4_EQ_ENTRY_SIZE = 32,
};

enum {
	MLX4_STEERING_MODE_A0 = 0,
	MLX4_STEERING_MODE_B0 = 1,
	MLX4_STEERING_MODE_DEVICE_MANAGED = 2,
};

enum {
	MLX4_STEERING_DMFS_A0_DEFAULT = 0,
	MLX4_STEERING_DMFS_A0_DYNAMIC = 1,
	MLX4_STEERING_DMFS_A0_STATIC = 2,
	MLX4_STEERING_DMFS_A0_DISABLE = 3,
	MLX4_STEERING_DMFS_A0_NOT_SUPPORTED = 4,
};

enum {
	MLX4_QUERY_FUNC_FLAGS_BF_RES_QP = 1,
	MLX4_QUERY_FUNC_FLAGS_A0_RES_QP = 2,
};

enum {
	MLX4_DEV_CAP_64B_EQE_ENABLED = 1,
	MLX4_DEV_CAP_64B_CQE_ENABLED = 2,
	MLX4_DEV_CAP_CQE_STRIDE_ENABLED = 4,
	MLX4_DEV_CAP_EQE_STRIDE_ENABLED = 8,
};

enum {
	MLX4_FLAG_PORT_REMAP = 16777216,
	MLX4_FLAG_ROCE_V1_V2 = 524288,
};

struct mlx4_qp {
	void (*event)(struct mlx4_qp *, enum mlx4_event);
	int qpn;
	refcount_t refcount;
	struct completion free;
	u8 usage;
};

enum mlx4_access_reg_method {
	MLX4_ACCESS_REG_QUERY = 1,
	MLX4_ACCESS_REG_WRITE = 2,
};

struct mlx4_ptys_reg {
	u8 flags;
	u8 local_port;
	u8 resrvd2;
	u8 proto_mask;
	__be32 resrvd3[2];
	__be32 eth_proto_cap;
	__be16 ib_width_cap;
	__be16 ib_speed_cap;
	__be32 resrvd4;
	__be32 eth_proto_admin;
	__be16 ib_width_admin;
	__be16 ib_speed_admin;
	__be32 resrvd5;
	__be32 eth_proto_oper;
	__be16 ib_width_oper;
	__be16 ib_speed_oper;
	__be32 resrvd6;
	__be32 eth_proto_lp_adv;
};

enum {
	MLX4_GET_PORT_VIRT2PHY = 0,
	MLX4_SET_PORT_VIRT2PHY = 1,
};

enum {
	MLX4_SET_PORT_GENERAL = 0,
	MLX4_SET_PORT_RQP_CALC = 1,
	MLX4_SET_PORT_MAC_TABLE = 2,
	MLX4_SET_PORT_VLAN_TABLE = 3,
	MLX4_SET_PORT_PRIO_MAP = 4,
	MLX4_SET_PORT_GID_TABLE = 5,
	MLX4_SET_PORT_PRIO2TC = 8,
	MLX4_SET_PORT_SCHEDULER = 9,
	MLX4_SET_PORT_VXLAN = 11,
	MLX4_SET_PORT_ROCE_ADDR = 13,
};

enum {
	MLX4_CMD_MAD_DEMUX_CONFIG = 0,
	MLX4_CMD_MAD_DEMUX_QUERY_STATE = 1,
	MLX4_CMD_MAD_DEMUX_QUERY_RESTR = 2,
};

enum mlx4_rx_csum_mode {
	MLX4_RX_CSUM_MODE_VAL_NON_TCP_UDP = 1,
	MLX4_RX_CSUM_MODE_L4 = 2,
	MLX4_RX_CSUM_MODE_IP_OK_IP_NON_TCP_UDP = 4,
	MLX4_RX_CSUM_MODE_MULTI_VLAN = 8,
};

struct mlx4_config_dev_params {
	u16 vxlan_udp_dport;
	u8 rx_csum_flags_port_1;
	u8 rx_csum_flags_port_2;
};

enum {
	MLX4_USER_DEV_CAP_LARGE_CQE = 1,
};

struct mlx4_mgm {
	__be32 next_gid_index;
	__be32 members_count;
	u32 reserved[2];
	u8 gid[16];
	__be32 qp[1016];
};

struct mlx4_set_port_general_context {
	u16 reserved1;
	u8 flags2;
	u8 flags;
	union {
		u8 ignore_fcs;
		u8 roce_mode;
	};
	u8 reserved2;
	__be16 mtu;
	u8 pptx;
	u8 pfctx;
	u16 reserved3;
	u8 pprx;
	u8 pfcrx;
	u16 reserved4;
	u32 reserved5;
	u8 phv_en;
	u8 reserved6[5];
	__be16 user_mtu;
	u16 reserved7;
	u8 user_mac[6];
};

struct mlx4_icm_buf {
	void *addr;
	size_t size;
	dma_addr_t dma_addr;
};

struct mlx4_icm_chunk {
	struct list_head list;
	int npages;
	int nsg;
	bool coherent;
	union {
		struct scatterlist sg[7];
		struct mlx4_icm_buf buf[7];
	};
};

struct mlx4_icm_iter {
	struct mlx4_icm *icm;
	struct mlx4_icm_chunk *chunk;
	int page_idx;
};

struct mlx4_mod_stat_cfg {
	u8 log_pg_sz;
	u8 log_pg_sz_m;
};

struct mlx4_dev_cap {
	int max_srq_sz;
	int max_qp_sz;
	int reserved_qps;
	int max_qps;
	int reserved_srqs;
	int max_srqs;
	int max_cq_sz;
	int reserved_cqs;
	int max_cqs;
	int max_mpts;
	int reserved_eqs;
	int max_eqs;
	int num_sys_eqs;
	int reserved_mtts;
	int reserved_mrws;
	int max_requester_per_qp;
	int max_responder_per_qp;
	int max_rdma_global;
	int local_ca_ack_delay;
	int num_ports;
	u32 max_msg_sz;
	u16 stat_rate_support;
	int fs_log_max_ucast_qp_range_size;
	int fs_max_num_qp_per_entry;
	u64 flags;
	u64 flags2;
	int reserved_uars;
	int uar_size;
	int min_page_sz;
	int bf_reg_size;
	int bf_regs_per_page;
	int max_sq_sg;
	int max_sq_desc_sz;
	int max_rq_sg;
	int max_rq_desc_sz;
	int max_qp_per_mcg;
	int reserved_mgms;
	int max_mcgs;
	int reserved_pds;
	int max_pds;
	int reserved_xrcds;
	int max_xrcds;
	int qpc_entry_sz;
	int rdmarc_entry_sz;
	int altc_entry_sz;
	int aux_entry_sz;
	int srq_entry_sz;
	int cqc_entry_sz;
	int eqc_entry_sz;
	int dmpt_entry_sz;
	int cmpt_entry_sz;
	int mtt_entry_sz;
	int resize_srq;
	u32 bmme_flags;
	u32 reserved_lkey;
	u64 max_icm_sz;
	int max_gso_sz;
	int max_rss_tbl_sz;
	u32 max_counters;
	u32 dmfs_high_rate_qpn_base;
	u32 dmfs_high_rate_qpn_range;
	struct mlx4_rate_limit_caps rl_caps;
	u32 health_buffer_addrs;
	struct mlx4_port_cap port_cap[3];
	bool wol_port[3];
};

struct mlx4_func_cap {
	u8 num_ports;
	u8 flags;
	u32 pf_context_behaviour;
	int qp_quota;
	int cq_quota;
	int srq_quota;
	int mpt_quota;
	int mtt_quota;
	int max_eq;
	int reserved_eq;
	int mcg_quota;
	struct mlx4_spec_qps spec_qps;
	u32 reserved_lkey;
	u8 physical_port;
	u8 flags0;
	u8 flags1;
	u64 phys_port_id;
	u32 extra_flags;
};

struct mlx4_func {
	int bus;
	int device;
	int function;
	int physical_function;
	int rsvd_eqs;
	int max_eq;
	int rsvd_uars;
};

struct mlx4_adapter {
	char board_id[64];
	u8 inta_pin;
};

struct mlx4_init_hca_param {
	u64 qpc_base;
	u64 rdmarc_base;
	u64 auxc_base;
	u64 altc_base;
	u64 srqc_base;
	u64 cqc_base;
	u64 eqc_base;
	u64 mc_base;
	u64 dmpt_base;
	u64 cmpt_base;
	u64 mtt_base;
	u64 global_caps;
	u16 log_mc_entry_sz;
	u16 log_mc_hash_sz;
	u16 hca_core_clock;
	u8 log_num_qps;
	u8 log_num_srqs;
	u8 log_num_cqs;
	u8 log_num_eqs;
	u16 num_sys_eqs;
	u8 log_rd_per_qp;
	u8 log_mc_table_sz;
	u8 log_mpt_sz;
	u8 log_uar_sz;
	u8 mw_enabled;
	u8 uar_page_sz;
	u8 steering_mode;
	u8 dmfs_high_steer_mode;
	u64 dev_cap_enabled;
	u16 cqe_size;
	u16 eqe_size;
	u8 rss_ip_frags;
	u8 phv_check_en;
};

enum {
	MLX4_COMMAND_INTERFACE_MIN_REV = 2,
	MLX4_COMMAND_INTERFACE_MAX_REV = 3,
	MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS = 3,
};

struct mlx4_config_dev {
	__be32 update_flags;
	__be32 rsvd1[3];
	__be16 vxlan_udp_dport;
	__be16 rsvd2;
	__be16 roce_v2_entropy;
	__be16 roce_v2_udp_dport;
	__be32 roce_flags;
	__be32 rsvd4[25];
	__be16 rsvd5;
	u8 rsvd6;
	u8 rx_checksum_val;
};

enum {
	ADD_TO_MCG = 38,
};

enum mlx4_access_reg_masks {
	MLX4_ACCESS_REG_STATUS_MASK = 127,
	MLX4_ACCESS_REG_METHOD_MASK = 127,
	MLX4_ACCESS_REG_LEN_MASK = 2047,
};

struct mlx4_access_reg {
	__be16 constant1;
	u8 status;
	u8 resrvd1;
	__be16 reg_id;
	u8 method;
	u8 constant2;
	__be32 resrvd2[2];
	__be16 len_const;
	__be16 resrvd3;
	u8 reg_data[4076];
};

enum mlx4_reg_id {
	MLX4_REG_ID_PTYS = 20484,
};

enum {
	MLX4_ALLOCATE_VPP_ALLOCATE = 0,
	MLX4_ALLOCATE_VPP_QUERY = 1,
};

enum {
	MLX4_SET_VPORT_QOS_SET = 0,
	MLX4_SET_VPORT_QOS_QUERY = 1,
};

struct mlx4_set_port_prio2tc_context {
	u8 prio2tc[4];
};

struct mlx4_port_scheduler_tc_cfg_be {
	__be16 pg;
	__be16 bw_precentage;
	__be16 max_bw_units;
	__be16 max_bw_value;
};

struct mlx4_set_port_scheduler_context {
	struct mlx4_port_scheduler_tc_cfg_be tc[8];
};

struct mlx4_alloc_vpp_param {
	__be32 available_vpp;
	__be32 vpp_p_up[8];
};

struct mlx4_prio_qos_param {
	__be32 bw_share;
	__be32 max_avg_bw;
	__be32 reserved;
	__be32 enable;
	__be32 reserved1[4];
};

struct mlx4_set_vport_context {
	__be32 reserved[8];
	struct mlx4_prio_qos_param qos_p_up[8];
};

enum {
	MLX4_ICM_ALLOC_SIZE = 262144,
	MLX4_TABLE_CHUNK_SIZE = 262144,
};

enum mlx4_protocol {
	MLX4_PROT_IB_IPV6 = 0,
	MLX4_PROT_ETH = 1,
	MLX4_PROT_IB_IPV4 = 2,
	MLX4_PROT_FCOE = 3,
};

enum {
	MLX4_INTFF_BONDING = 1,
};

struct mlx4_interface {
	void * (*add)(struct mlx4_dev *);
	void (*remove)(struct mlx4_dev *, void *);
	void (*event)(struct mlx4_dev *, void *, enum mlx4_dev_event, long unsigned int);
	void * (*get_dev)(struct mlx4_dev *, void *, u8);
	void (*activate)(struct mlx4_dev *, void *);
	struct list_head list;
	enum mlx4_protocol protocol;
	int flags;
};

struct mlx4_device_context {
	struct list_head list;
	struct list_head bond_list;
	struct mlx4_interface *intf;
	void *context;
};

struct io_mapping {
	resource_size_t base;
	long unsigned int size;
	pgprot_t prot;
	void *iomem;
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	long unsigned int supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 11,
	DEVLINK_PARAM_GENERIC_ID_MAX = 10,
};

enum {
	MLX4_TUNNEL_OFFLOAD_MODE_NONE = 0,
	MLX4_TUNNEL_OFFLOAD_MODE_VXLAN = 1,
};

enum {
	MLX4_RESERVE_A0_QP = 64,
	MLX4_RESERVE_ETH_BF_QP = 128,
};

enum {
	MLX4_FUNC_CAP_64B_EQE_CQE = 1,
	MLX4_FUNC_CAP_EQE_CQE_STRIDE = 2,
	MLX4_FUNC_CAP_DMFS_A0_STATIC = 4,
};

enum mlx4_resource_usage {
	MLX4_RES_USAGE_NONE = 0,
	MLX4_RES_USAGE_DRIVER = 1,
	MLX4_RES_USAGE_USER_VERBS = 2,
};

enum {
	MLX4_NUM_FEXCH = 65536,
};

struct mlx4_clock_params {
	u64 offset;
	u8 bar;
	u8 size;
};

enum {
	MLX4_DOMAIN_UVERBS = 4096,
	MLX4_DOMAIN_ETHTOOL = 8192,
	MLX4_DOMAIN_RFS = 12288,
	MLX4_DOMAIN_NIC = 20480,
};

struct mlx4_net_trans_rule_hw_ctrl {
	__be16 prio;
	u8 type;
	u8 flags;
	u8 rsvd1;
	u8 funcid;
	u8 vep;
	u8 port;
	__be32 qpn;
	__be32 rsvd2;
};

struct mlx4_net_trans_rule_hw_ib {
	u8 size;
	u8 rsvd1;
	__be16 id;
	u32 rsvd2;
	__be32 l3_qpn;
	__be32 qpn_mask;
	u8 dst_gid[16];
	u8 dst_gid_msk[16];
};

struct mlx4_net_trans_rule_hw_eth {
	u8 size;
	u8 rsvd;
	__be16 id;
	u8 rsvd1[6];
	u8 dst_mac[6];
	u16 rsvd2;
	u8 dst_mac_msk[6];
	u16 rsvd3;
	u8 src_mac[6];
	u16 rsvd4;
	u8 src_mac_msk[6];
	u8 rsvd5;
	u8 ether_type_enable;
	__be16 ether_type;
	__be16 vlan_tag_msk;
	__be16 vlan_tag;
};

struct mlx4_net_trans_rule_hw_tcp_udp {
	u8 size;
	u8 rsvd;
	__be16 id;
	__be16 rsvd1[3];
	__be16 dst_port;
	__be16 rsvd2;
	__be16 dst_port_msk;
	__be16 rsvd3;
	__be16 src_port;
	__be16 rsvd4;
	__be16 src_port_msk;
};

struct mlx4_net_trans_rule_hw_ipv4 {
	u8 size;
	u8 rsvd;
	__be16 id;
	__be32 rsvd1;
	__be32 dst_ip;
	__be32 dst_ip_msk;
	__be32 src_ip;
	__be32 src_ip_msk;
};

struct mlx4_net_trans_rule_hw_vxlan {
	u8 size;
	u8 rsvd;
	__be16 id;
	__be32 rsvd1;
	__be32 vni;
	__be32 vni_mask;
};

struct _rule_hw {
	union {
		struct {
			u8 size;
			u8 rsvd;
			__be16 id;
		};
		struct mlx4_net_trans_rule_hw_eth eth;
		struct mlx4_net_trans_rule_hw_ib ib;
		struct mlx4_net_trans_rule_hw_ipv4 ipv4;
		struct mlx4_net_trans_rule_hw_tcp_udp tcp_udp;
		struct mlx4_net_trans_rule_hw_vxlan vxlan;
	};
};

enum {
	MLX4_NUM_PDS = 32768,
};

enum {
	MLX4_CMPT_SHIFT = 24,
	MLX4_NUM_CMPTS = 67108864,
};

enum mlx4_res_tracker_free_type {
	RES_TR_FREE_ALL = 0,
	RES_TR_FREE_SLAVES_ONLY = 1,
	RES_TR_FREE_STRUCTS_ONLY = 2,
};

struct mlx4_profile {
	int num_qp;
	int rdmarc_per_qp;
	int num_srq;
	int num_cq;
	int num_mcg;
	int num_mpt;
	unsigned int num_mtt;
};

struct mlx4_promisc_qp {
	struct list_head list;
	u32 qpn;
};

struct mlx4_steer_index {
	struct list_head list;
	unsigned int index;
	struct list_head duplicates;
};

enum {
	MLX4_PCI_DEV_IS_VF = 1,
	MLX4_PCI_DEV_FORCE_SENSE_PORT = 2,
};

enum mlx4_devlink_param_id {
	MLX4_DEVLINK_PARAM_ID_BASE = 10,
	MLX4_DEVLINK_PARAM_ID_ENABLE_64B_CQE_EQE = 11,
	MLX4_DEVLINK_PARAM_ID_ENABLE_4K_UAR = 12,
};

enum {
	MLX4_QUERY_FUNC_NUM_SYS_EQS = 1,
};

enum ibta_mtu {
	IB_MTU_256___2 = 1,
	IB_MTU_512___2 = 2,
	IB_MTU_1024___2 = 3,
	IB_MTU_2048___2 = 4,
	IB_MTU_4096___2 = 5,
};

enum {
	MLX4_DEV_CAP_CHECK_NUM_VFS_ABOVE_64 = 4294967295,
};

enum mlx4_net_trans_rule_id {
	MLX4_NET_TRANS_RULE_ID_ETH = 0,
	MLX4_NET_TRANS_RULE_ID_IB = 1,
	MLX4_NET_TRANS_RULE_ID_IPV6 = 2,
	MLX4_NET_TRANS_RULE_ID_IPV4 = 3,
	MLX4_NET_TRANS_RULE_ID_TCP = 4,
	MLX4_NET_TRANS_RULE_ID_UDP = 5,
	MLX4_NET_TRANS_RULE_ID_VXLAN = 6,
	MLX4_NET_TRANS_RULE_NUM = 7,
};

enum mlx4_net_trans_promisc_mode {
	MLX4_FS_REGULAR = 1,
	MLX4_FS_ALL_DEFAULT = 2,
	MLX4_FS_MC_DEFAULT = 3,
	MLX4_FS_MIRROR_RX_PORT = 4,
	MLX4_FS_MIRROR_SX_PORT = 5,
	MLX4_FS_UC_SNIFFER = 6,
	MLX4_FS_MC_SNIFFER = 7,
	MLX4_FS_MODE_NUM = 8,
};

struct mlx4_spec_eth {
	u8 dst_mac[6];
	u8 dst_mac_msk[6];
	u8 src_mac[6];
	u8 src_mac_msk[6];
	u8 ether_type_enable;
	__be16 ether_type;
	__be16 vlan_id_msk;
	__be16 vlan_id;
};

struct mlx4_spec_tcp_udp {
	__be16 dst_port;
	__be16 dst_port_msk;
	__be16 src_port;
	__be16 src_port_msk;
};

struct mlx4_spec_ipv4 {
	__be32 dst_ip;
	__be32 dst_ip_msk;
	__be32 src_ip;
	__be32 src_ip_msk;
};

struct mlx4_spec_ib {
	__be32 l3_qpn;
	__be32 qpn_msk;
	u8 dst_gid[16];
	u8 dst_gid_msk[16];
};

struct mlx4_spec_vxlan {
	__be32 vni;
	__be32 vni_mask;
};

struct mlx4_spec_list {
	struct list_head list;
	enum mlx4_net_trans_rule_id id;
	union {
		struct mlx4_spec_eth eth;
		struct mlx4_spec_ib ib;
		struct mlx4_spec_ipv4 ipv4;
		struct mlx4_spec_tcp_udp tcp_udp;
		struct mlx4_spec_vxlan vxlan;
	};
};

enum mlx4_net_trans_hw_rule_queue {
	MLX4_NET_TRANS_Q_FIFO = 0,
	MLX4_NET_TRANS_Q_LIFO = 1,
};

struct mlx4_net_trans_rule {
	struct list_head list;
	enum mlx4_net_trans_hw_rule_queue queue_mode;
	bool exclusive;
	bool allow_loopback;
	enum mlx4_net_trans_promisc_mode promisc_mode;
	u8 port;
	u16 priority;
	u32 qpn;
};

enum {
	MLX4_PERM_LOCAL_READ = 1024,
	MLX4_PERM_LOCAL_WRITE = 2048,
	MLX4_PERM_REMOTE_READ = 4096,
	MLX4_PERM_REMOTE_WRITE = 8192,
	MLX4_PERM_ATOMIC = 16384,
	MLX4_PERM_BIND_MW = 32768,
	MLX4_PERM_MASK = 64512,
};

enum {
	MLX4_MTT_FLAG_PRESENT = 1,
};

struct mlx4_mr {
	struct mlx4_mtt mtt;
	u64 iova;
	u64 size;
	u32 key;
	u32 pd;
	u32 access;
	int enabled;
};

enum mlx4_mw_type {
	MLX4_MW_TYPE_1 = 1,
	MLX4_MW_TYPE_2 = 2,
};

struct mlx4_mw {
	u32 key;
	u32 pd;
	enum mlx4_mw_type type;
	int enabled;
};

enum mlx4_mpt_state {
	MLX4_MPT_DISABLED = 0,
	MLX4_MPT_EN_HW = 1,
	MLX4_MPT_EN_SW = 2,
};

struct mlx4_mpt_entry {
	__be32 flags;
	__be32 qpn;
	__be32 key;
	__be32 pd_flags;
	__be64 start;
	__be64 length;
	__be32 lkey;
	__be32 win_cnt;
	u8 reserved1[3];
	u8 mtt_rep;
	__be64 mtt_addr;
	__be32 mtt_sz;
	__be32 entity_size;
	__be32 first_byte_offset;
} __attribute__((packed));

struct mlx4_bf {
	unsigned int offset;
	int buf_size;
	struct mlx4_uar *uar;
	void *reg;
};

enum {
	MLX4_NUM_RESERVED_UARS = 8,
};

enum {
	MLX4_PORT_CAP_IS_SM = 2,
	MLX4_PORT_CAP_DEV_MGMT_SUP = 524288,
};

enum mlx4_special_vlan_idx {
	MLX4_NO_VLAN_IDX = 0,
	MLX4_VLAN_MISS_IDX = 1,
	MLX4_VLAN_REGULAR = 2,
};

struct mlx4_mad_ifc {
	u8 base_version;
	u8 mgmt_class;
	u8 class_version;
	u8 method;
	__be16 status;
	__be16 class_specific;
	__be64 tid;
	__be16 attr_id;
	__be16 resv;
	__be32 attr_mod;
	__be64 mkey;
	__be16 dr_slid;
	__be16 dr_dlid;
	u8 reserved[28];
	u8 data[192];
};

enum {
	MCAST_DIRECT_ONLY = 0,
	MCAST_DIRECT = 1,
	MCAST_DEFAULT = 2,
};

struct mlx4_set_port_rqp_calc_context {
	__be32 base_qpn;
	u8 rererved;
	u8 n_mac;
	u8 n_vlan;
	u8 n_prio;
	u8 reserved2[3];
	u8 mac_miss;
	u8 intra_no_vlan;
	u8 no_vlan;
	u8 intra_vlan_miss;
	u8 vlan_miss;
	u8 reserved3[3];
	u8 no_vlan_prio;
	__be32 promisc;
	__be32 mcast;
};

enum {
	MLX4_SET_PORT_VL_CAP = 4,
	MLX4_SET_PORT_MTU_CAP = 12,
	MLX4_CHANGE_PORT_PKEY_TBL_SZ = 20,
	MLX4_CHANGE_PORT_VL_CAP = 21,
	MLX4_CHANGE_PORT_MTU_CAP = 22,
};

enum {
	VXLAN_ENABLE_MODIFY = 128,
	VXLAN_STEERING_MODIFY = 64,
	VXLAN_ENABLE = 128,
};

struct mlx4_set_port_vxlan_context {
	u32 reserved1;
	u8 modify_flags;
	u8 reserved2;
	u8 enable_flags;
	u8 steering;
};

struct mlx4_cable_info {
	u8 i2c_addr;
	u8 page_num;
	__be16 dev_mem_address;
	__be16 reserved1;
	__be16 size;
	__be32 reserved2[2];
	u8 data[48];
};

enum cable_info_err {
	CABLE_INF_INV_PORT = 1,
	CABLE_INF_OP_NOSUP = 2,
	CABLE_INF_NOT_CONN = 3,
	CABLE_INF_NO_EEPRM = 4,
	CABLE_INF_PAGE_ERR = 5,
	CABLE_INF_INV_ADDR = 6,
	CABLE_INF_I2C_ADDR = 7,
	CABLE_INF_QSFP_VIO = 8,
	CABLE_INF_I2C_BUSY = 9,
};

enum {
	MLX4_RES_QP = 0,
	MLX4_RES_RDMARC = 1,
	MLX4_RES_ALTC = 2,
	MLX4_RES_AUXC = 3,
	MLX4_RES_SRQ = 4,
	MLX4_RES_CQ = 5,
	MLX4_RES_EQ = 6,
	MLX4_RES_DMPT = 7,
	MLX4_RES_CMPT = 8,
	MLX4_RES_MTT = 9,
	MLX4_RES_MCG = 10,
	MLX4_RES_NUM = 11,
};

struct mlx4_resource___2 {
	u64 size;
	u64 start;
	int type;
	u32 num;
	int log_num;
};

enum mlx4_qp_optpar {
	MLX4_QP_OPTPAR_ALT_ADDR_PATH = 1,
	MLX4_QP_OPTPAR_RRE = 2,
	MLX4_QP_OPTPAR_RAE = 4,
	MLX4_QP_OPTPAR_RWE = 8,
	MLX4_QP_OPTPAR_PKEY_INDEX = 16,
	MLX4_QP_OPTPAR_Q_KEY = 32,
	MLX4_QP_OPTPAR_RNR_TIMEOUT = 64,
	MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH = 128,
	MLX4_QP_OPTPAR_SRA_MAX = 256,
	MLX4_QP_OPTPAR_RRA_MAX = 512,
	MLX4_QP_OPTPAR_PM_STATE = 1024,
	MLX4_QP_OPTPAR_RETRY_COUNT = 4096,
	MLX4_QP_OPTPAR_RNR_RETRY = 8192,
	MLX4_QP_OPTPAR_ACK_TIMEOUT = 16384,
	MLX4_QP_OPTPAR_SCHED_QUEUE = 65536,
	MLX4_QP_OPTPAR_COUNTER_INDEX = 1048576,
	MLX4_QP_OPTPAR_VLAN_STRIPPING = 2097152,
};

enum mlx4_qp_state {
	MLX4_QP_STATE_RST = 0,
	MLX4_QP_STATE_INIT = 1,
	MLX4_QP_STATE_RTR = 2,
	MLX4_QP_STATE_RTS = 3,
	MLX4_QP_STATE_SQER = 4,
	MLX4_QP_STATE_SQD = 5,
	MLX4_QP_STATE_ERR = 6,
	MLX4_QP_STATE_SQ_DRAINING = 7,
	MLX4_QP_NUM_STATE = 8,
};

enum {
	MLX4_QP_BIT_SRE = 32768,
	MLX4_QP_BIT_SWE = 16384,
	MLX4_QP_BIT_SAE = 8192,
	MLX4_QP_BIT_RRE = 32768,
	MLX4_QP_BIT_RWE = 16384,
	MLX4_QP_BIT_RAE = 8192,
	MLX4_QP_BIT_FPP = 8,
	MLX4_QP_BIT_RIC = 16,
};

struct mlx4_qp_path {
	u8 fl;
	union {
		u8 vlan_control;
		u8 control;
	};
	u8 disable_pkey_check;
	u8 pkey_index;
	u8 counter_index;
	u8 grh_mylmc;
	__be16 rlid;
	u8 ackto;
	u8 mgid_index;
	u8 static_rate;
	u8 hop_limit;
	__be32 tclass_flowlabel;
	u8 rgid[16];
	u8 sched_queue;
	u8 vlan_index;
	u8 feup;
	u8 fvl_rx;
	u8 reserved4[2];
	u8 dmac[6];
};

enum {
	MLX4_FL_CV = 64,
	MLX4_FL_SV = 32,
	MLX4_FL_ETH_HIDE_CQE_VLAN = 4,
	MLX4_FL_ETH_SRC_CHECK_MC_LB = 2,
	MLX4_FL_ETH_SRC_CHECK_UC_LB = 1,
};

struct mlx4_qp_context {
	__be32 flags;
	__be32 pd;
	u8 mtu_msgmax;
	u8 rq_size_stride;
	u8 sq_size_stride;
	u8 rlkey_roce_mode;
	__be32 usr_page;
	__be32 local_qpn;
	__be32 remote_qpn;
	struct mlx4_qp_path pri_path;
	struct mlx4_qp_path alt_path;
	__be32 params1;
	u32 reserved1;
	__be32 next_send_psn;
	__be32 cqn_send;
	__be16 roce_entropy;
	__be16 reserved2[3];
	__be32 last_acked_psn;
	__be32 ssn;
	__be32 params2;
	__be32 rnr_nextrecvpsn;
	__be32 xrcd;
	__be32 cqn_recv;
	__be64 db_rec_addr;
	__be32 qkey;
	__be32 srqn;
	__be32 msn;
	__be16 rq_wqe_counter;
	__be16 sq_wqe_counter;
	u32 reserved3;
	__be16 rate_limit_params;
	u8 reserved4;
	u8 qos_vport;
	__be32 param3;
	__be32 nummmcpeers_basemkey;
	u8 log_page_size;
	u8 reserved5[2];
	u8 mtt_base_addr_h;
	__be32 mtt_base_addr_l;
	u32 reserved6[10];
};

struct mlx4_update_qp_context {
	__be64 qp_mask;
	__be64 primary_addr_path_mask;
	__be64 secondary_addr_path_mask;
	u64 reserved1;
	struct mlx4_qp_context qp_context;
	u64 reserved2[58];
};

enum {
	MLX4_UPD_QP_MASK_PM_STATE = 32,
	MLX4_UPD_QP_MASK_VSD = 33,
	MLX4_UPD_QP_MASK_QOS_VPP = 34,
	MLX4_UPD_QP_MASK_RATE_LIMIT = 35,
};

enum {
	MLX4_UPD_QP_PATH_MASK_PKEY_INDEX = 32,
	MLX4_UPD_QP_PATH_MASK_FSM = 33,
	MLX4_UPD_QP_PATH_MASK_MAC_INDEX = 34,
	MLX4_UPD_QP_PATH_MASK_FVL = 35,
	MLX4_UPD_QP_PATH_MASK_CV = 36,
	MLX4_UPD_QP_PATH_MASK_VLAN_INDEX = 37,
	MLX4_UPD_QP_PATH_MASK_ETH_HIDE_CQE_VLAN = 38,
	MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_UNTAGGED = 39,
	MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_1P = 40,
	MLX4_UPD_QP_PATH_MASK_ETH_TX_BLOCK_TAGGED = 41,
	MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_UNTAGGED = 42,
	MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_1P = 43,
	MLX4_UPD_QP_PATH_MASK_ETH_RX_BLOCK_TAGGED = 44,
	MLX4_UPD_QP_PATH_MASK_FEUP = 45,
	MLX4_UPD_QP_PATH_MASK_SCHED_QUEUE = 46,
	MLX4_UPD_QP_PATH_MASK_IF_COUNTER_INDEX = 47,
	MLX4_UPD_QP_PATH_MASK_FVL_RX = 48,
	MLX4_UPD_QP_PATH_MASK_ETH_SRC_CHECK_UC_LB = 50,
	MLX4_UPD_QP_PATH_MASK_ETH_SRC_CHECK_MC_LB = 51,
	MLX4_UPD_QP_PATH_MASK_SV = 54,
};

enum {
	MLX4_STRIP_VLAN = 1073741824,
};

enum mlx4_update_qp_attr {
	MLX4_UPDATE_QP_SMAC = 1,
	MLX4_UPDATE_QP_VSD = 2,
	MLX4_UPDATE_QP_RATE_LIMIT = 4,
	MLX4_UPDATE_QP_QOS_VPORT = 8,
	MLX4_UPDATE_QP_ETH_SRC_CHECK_MC_LB = 16,
	MLX4_UPDATE_QP_SUPPORTED_ATTRS = 31,
};

enum mlx4_update_qp_params_flags {
	MLX4_UPDATE_QP_PARAMS_FLAGS_ETH_CHECK_MC_LB = 1,
	MLX4_UPDATE_QP_PARAMS_FLAGS_VSD_ENABLE = 2,
};

struct mlx4_update_qp_params {
	u8 smac_index;
	u8 qos_vport;
	u32 flags;
	u16 rate_unit;
	u16 rate_val;
};

struct mlx4_srq {
	void (*event)(struct mlx4_srq *, enum mlx4_event);
	int srqn;
	int max;
	int max_gs;
	int wqe_shift;
	refcount_t refcount;
	struct completion free;
};

struct mlx4_srq_context {
	__be32 state_logsize_srqn;
	u8 logstride;
	u8 reserved1;
	__be16 xrcd;
	__be32 pg_offset_cqn;
	u32 reserved2;
	u8 log_page_size;
	u8 reserved3[2];
	u8 mtt_base_addr_h;
	__be32 mtt_base_addr_l;
	__be32 pd;
	__be16 limit_watermark;
	__be16 wqe_cnt;
	u16 reserved4;
	__be16 wqe_counter;
	u32 reserved5;
	__be64 db_rec_addr;
};

enum {
	MLX4_QP_ST_RC = 0,
	MLX4_QP_ST_UC = 1,
	MLX4_QP_ST_RD = 2,
	MLX4_QP_ST_UD = 3,
	MLX4_QP_ST_XRC = 6,
	MLX4_QP_ST_MLX = 7,
};

enum {
	MLX4_RSS_HASH_XOR = 0,
	MLX4_RSS_HASH_TOP = 1,
	MLX4_RSS_UDP_IPV6 = 1,
	MLX4_RSS_UDP_IPV4 = 2,
	MLX4_RSS_TCP_IPV6 = 4,
	MLX4_RSS_IPV6 = 8,
	MLX4_RSS_TCP_IPV4 = 16,
	MLX4_RSS_IPV4 = 32,
	MLX4_RSS_BY_OUTER_HEADERS = 0,
	MLX4_RSS_BY_INNER_HEADERS = 128,
	MLX4_RSS_BY_INNER_HEADERS_IPONLY = 192,
	MLX4_RSS_OFFSET_IN_QPC_PRI_PATH = 36,
	MLX4_RSS_QPC_FLAG_OFFSET = 13,
};

enum {
	MLX4_CTRL_ETH_SRC_CHECK_IF_COUNTER = 128,
};

enum {
	MLX4_VLAN_CTRL_ETH_TX_BLOCK_TAGGED = 64,
	MLX4_VLAN_CTRL_ETH_TX_BLOCK_PRIO_TAGGED = 32,
	MLX4_VLAN_CTRL_ETH_TX_BLOCK_UNTAGGED = 16,
	MLX4_VLAN_CTRL_ETH_RX_BLOCK_TAGGED = 4,
	MLX4_VLAN_CTRL_ETH_RX_BLOCK_PRIO_TAGGED = 2,
	MLX4_VLAN_CTRL_ETH_RX_BLOCK_UNTAGGED = 1,
};

enum {
	MLX4_FEUP_FORCE_ETH_UP = 64,
	MLX4_FSM_FORCE_ETH_SRC_MAC = 32,
	MLX4_FVL_FORCE_ETH_VLAN = 8,
};

enum {
	MLX4_FVL_RX_FORCE_ETH_VLAN = 1,
};

struct mac_res {
	struct list_head list;
	u64 mac;
	int ref_count;
	u8 smac_index;
	u8 port;
};

struct vlan_res {
	struct list_head list;
	u16 vlan;
	int ref_count;
	int vlan_index;
	u8 port;
};

struct res_common {
	struct list_head list;
	struct rb_node node;
	u64 res_id;
	int owner;
	int state;
	int from_state;
	int to_state;
	int removing;
	const char *func_name;
};

enum {
	RES_ANY_BUSY = 1,
};

struct res_gid {
	struct list_head list;
	u8 gid[16];
	enum mlx4_protocol prot;
	enum mlx4_steer_type steer;
	u64 reg_id;
};

enum res_qp_states {
	RES_QP_BUSY = 1,
	RES_QP_RESERVED = 2,
	RES_QP_MAPPED = 3,
	RES_QP_HW = 4,
};

struct res_mtt;

struct res_cq;

struct res_srq;

struct res_qp {
	struct res_common com;
	struct res_mtt *mtt;
	struct res_cq *rcq;
	struct res_cq *scq;
	struct res_srq *srq;
	struct list_head mcg_list;
	spinlock_t mcg_spl;
	int local_qpn;
	atomic_t ref_count;
	u32 qpc_flags;
	u8 sched_queue;
	__be32 param3;
	u8 vlan_control;
	u8 fvl_rx;
	u8 pri_path_fl;
	u8 vlan_index;
	u8 feup;
};

struct res_mtt {
	struct res_common com;
	int order;
	atomic_t ref_count;
};

struct res_cq {
	struct res_common com;
	struct res_mtt *mtt;
	atomic_t ref_count;
};

struct res_srq {
	struct res_common com;
	struct res_mtt *mtt;
	struct res_cq *cq;
	atomic_t ref_count;
};

enum res_mtt_states {
	RES_MTT_BUSY = 1,
	RES_MTT_ALLOCATED = 2,
};

enum res_mpt_states {
	RES_MPT_BUSY = 1,
	RES_MPT_RESERVED = 2,
	RES_MPT_MAPPED = 3,
	RES_MPT_HW = 4,
};

struct res_mpt {
	struct res_common com;
	struct res_mtt *mtt;
	int key;
};

enum res_eq_states {
	RES_EQ_BUSY = 1,
	RES_EQ_RESERVED = 2,
	RES_EQ_HW = 3,
};

struct res_eq {
	struct res_common com;
	struct res_mtt *mtt;
};

enum res_cq_states {
	RES_CQ_BUSY = 1,
	RES_CQ_ALLOCATED = 2,
	RES_CQ_HW = 3,
};

enum res_srq_states {
	RES_SRQ_BUSY = 1,
	RES_SRQ_ALLOCATED = 2,
	RES_SRQ_HW = 3,
};

enum res_counter_states {
	RES_COUNTER_BUSY = 1,
	RES_COUNTER_ALLOCATED = 2,
};

struct res_counter {
	struct res_common com;
	int port;
};

enum res_xrcdn_states {
	RES_XRCD_BUSY = 1,
	RES_XRCD_ALLOCATED = 2,
};

struct res_xrcdn {
	struct res_common com;
	int port;
};

enum res_fs_rule_states {
	RES_FS_RULE_BUSY = 1,
	RES_FS_RULE_ALLOCATED = 2,
};

struct res_fs_rule {
	struct res_common com;
	int qpn;
	void *mirr_mbox;
	u32 mirr_mbox_size;
	struct list_head mirr_list;
	u64 mirr_rule_id;
};

enum qp_transition {
	QP_TRANS_INIT2RTR = 0,
	QP_TRANS_RTR2RTS = 1,
	QP_TRANS_RTS2RTS = 2,
	QP_TRANS_SQERR2RTS = 3,
	QP_TRANS_SQD2SQD = 4,
	QP_TRANS_SQD2RTS = 5,
};

struct devlink_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

enum dcbnl_cndd_states {
	DCB_CNDD_RESET = 0,
	DCB_CNDD_EDGE = 1,
	DCB_CNDD_INTERIOR = 2,
	DCB_CNDD_INTERIOR_READY = 3,
};

enum {
	MLX4_WQE_CTRL_NEC = 536870912,
	MLX4_WQE_CTRL_IIP = 268435456,
	MLX4_WQE_CTRL_ILP = 134217728,
	MLX4_WQE_CTRL_FENCE = 64,
	MLX4_WQE_CTRL_CQ_UPDATE = 12,
	MLX4_WQE_CTRL_SOLICITED = 2,
	MLX4_WQE_CTRL_IP_CSUM = 16,
	MLX4_WQE_CTRL_TCP_UDP_CSUM = 32,
	MLX4_WQE_CTRL_INS_CVLAN = 64,
	MLX4_WQE_CTRL_INS_SVLAN = 128,
	MLX4_WQE_CTRL_STRONG_ORDER = 128,
	MLX4_WQE_CTRL_FORCE_LOOPBACK = 1,
};

struct mlx4_cqe {
	__be32 vlan_my_qpn;
	__be32 immed_rss_invalid;
	__be32 g_mlpath_rqpn;
	__be16 sl_vid;
	union {
		struct {
			__be16 rlid;
			__be16 status;
			u8 ipv6_ext_mask;
			u8 badfcs_enc;
		};
		u8 smac[6];
	};
	__be32 byte_cnt;
	__be16 wqe_index;
	__be16 checksum;
	u8 reserved[3];
	u8 owner_sr_opcode;
};

struct mlx4_en_stat_out_mbox {
	__be64 R64_prio_0;
	__be64 R64_prio_1;
	__be64 R64_prio_2;
	__be64 R64_prio_3;
	__be64 R64_prio_4;
	__be64 R64_prio_5;
	__be64 R64_prio_6;
	__be64 R64_prio_7;
	__be64 R64_novlan;
	__be64 R127_prio_0;
	__be64 R127_prio_1;
	__be64 R127_prio_2;
	__be64 R127_prio_3;
	__be64 R127_prio_4;
	__be64 R127_prio_5;
	__be64 R127_prio_6;
	__be64 R127_prio_7;
	__be64 R127_novlan;
	__be64 R255_prio_0;
	__be64 R255_prio_1;
	__be64 R255_prio_2;
	__be64 R255_prio_3;
	__be64 R255_prio_4;
	__be64 R255_prio_5;
	__be64 R255_prio_6;
	__be64 R255_prio_7;
	__be64 R255_novlan;
	__be64 R511_prio_0;
	__be64 R511_prio_1;
	__be64 R511_prio_2;
	__be64 R511_prio_3;
	__be64 R511_prio_4;
	__be64 R511_prio_5;
	__be64 R511_prio_6;
	__be64 R511_prio_7;
	__be64 R511_novlan;
	__be64 R1023_prio_0;
	__be64 R1023_prio_1;
	__be64 R1023_prio_2;
	__be64 R1023_prio_3;
	__be64 R1023_prio_4;
	__be64 R1023_prio_5;
	__be64 R1023_prio_6;
	__be64 R1023_prio_7;
	__be64 R1023_novlan;
	__be64 R1518_prio_0;
	__be64 R1518_prio_1;
	__be64 R1518_prio_2;
	__be64 R1518_prio_3;
	__be64 R1518_prio_4;
	__be64 R1518_prio_5;
	__be64 R1518_prio_6;
	__be64 R1518_prio_7;
	__be64 R1518_novlan;
	__be64 R1522_prio_0;
	__be64 R1522_prio_1;
	__be64 R1522_prio_2;
	__be64 R1522_prio_3;
	__be64 R1522_prio_4;
	__be64 R1522_prio_5;
	__be64 R1522_prio_6;
	__be64 R1522_prio_7;
	__be64 R1522_novlan;
	__be64 R1548_prio_0;
	__be64 R1548_prio_1;
	__be64 R1548_prio_2;
	__be64 R1548_prio_3;
	__be64 R1548_prio_4;
	__be64 R1548_prio_5;
	__be64 R1548_prio_6;
	__be64 R1548_prio_7;
	__be64 R1548_novlan;
	__be64 R2MTU_prio_0;
	__be64 R2MTU_prio_1;
	__be64 R2MTU_prio_2;
	__be64 R2MTU_prio_3;
	__be64 R2MTU_prio_4;
	__be64 R2MTU_prio_5;
	__be64 R2MTU_prio_6;
	__be64 R2MTU_prio_7;
	__be64 R2MTU_novlan;
	__be64 RGIANT_prio_0;
	__be64 RGIANT_prio_1;
	__be64 RGIANT_prio_2;
	__be64 RGIANT_prio_3;
	__be64 RGIANT_prio_4;
	__be64 RGIANT_prio_5;
	__be64 RGIANT_prio_6;
	__be64 RGIANT_prio_7;
	__be64 RGIANT_novlan;
	__be64 RBCAST_prio_0;
	__be64 RBCAST_prio_1;
	__be64 RBCAST_prio_2;
	__be64 RBCAST_prio_3;
	__be64 RBCAST_prio_4;
	__be64 RBCAST_prio_5;
	__be64 RBCAST_prio_6;
	__be64 RBCAST_prio_7;
	__be64 RBCAST_novlan;
	__be64 MCAST_prio_0;
	__be64 MCAST_prio_1;
	__be64 MCAST_prio_2;
	__be64 MCAST_prio_3;
	__be64 MCAST_prio_4;
	__be64 MCAST_prio_5;
	__be64 MCAST_prio_6;
	__be64 MCAST_prio_7;
	__be64 MCAST_novlan;
	__be64 RTOTG_prio_0;
	__be64 RTOTG_prio_1;
	__be64 RTOTG_prio_2;
	__be64 RTOTG_prio_3;
	__be64 RTOTG_prio_4;
	__be64 RTOTG_prio_5;
	__be64 RTOTG_prio_6;
	__be64 RTOTG_prio_7;
	__be64 RTOTG_novlan;
	__be64 RTTLOCT_prio_0;
	__be64 RTTLOCT_NOFRM_prio_0;
	__be64 ROCT_prio_0;
	__be64 RTTLOCT_prio_1;
	__be64 RTTLOCT_NOFRM_prio_1;
	__be64 ROCT_prio_1;
	__be64 RTTLOCT_prio_2;
	__be64 RTTLOCT_NOFRM_prio_2;
	__be64 ROCT_prio_2;
	__be64 RTTLOCT_prio_3;
	__be64 RTTLOCT_NOFRM_prio_3;
	__be64 ROCT_prio_3;
	__be64 RTTLOCT_prio_4;
	__be64 RTTLOCT_NOFRM_prio_4;
	__be64 ROCT_prio_4;
	__be64 RTTLOCT_prio_5;
	__be64 RTTLOCT_NOFRM_prio_5;
	__be64 ROCT_prio_5;
	__be64 RTTLOCT_prio_6;
	__be64 RTTLOCT_NOFRM_prio_6;
	__be64 ROCT_prio_6;
	__be64 RTTLOCT_prio_7;
	__be64 RTTLOCT_NOFRM_prio_7;
	__be64 ROCT_prio_7;
	__be64 RTTLOCT_novlan;
	__be64 RTTLOCT_NOFRM_novlan;
	__be64 ROCT_novlan;
	__be64 RTOT_prio_0;
	__be64 R1Q_prio_0;
	__be64 reserved1;
	__be64 RTOT_prio_1;
	__be64 R1Q_prio_1;
	__be64 reserved2;
	__be64 RTOT_prio_2;
	__be64 R1Q_prio_2;
	__be64 reserved3;
	__be64 RTOT_prio_3;
	__be64 R1Q_prio_3;
	__be64 reserved4;
	__be64 RTOT_prio_4;
	__be64 R1Q_prio_4;
	__be64 reserved5;
	__be64 RTOT_prio_5;
	__be64 R1Q_prio_5;
	__be64 reserved6;
	__be64 RTOT_prio_6;
	__be64 R1Q_prio_6;
	__be64 reserved7;
	__be64 RTOT_prio_7;
	__be64 R1Q_prio_7;
	__be64 reserved8;
	__be64 RTOT_novlan;
	__be64 R1Q_novlan;
	__be64 reserved9;
	__be64 RCNTL;
	__be64 reserved10;
	__be64 reserved11;
	__be64 reserved12;
	__be64 RInRangeLengthErr;
	__be64 ROutRangeLengthErr;
	__be64 RFrmTooLong;
	__be64 PCS;
	__be64 T64_prio_0;
	__be64 T64_prio_1;
	__be64 T64_prio_2;
	__be64 T64_prio_3;
	__be64 T64_prio_4;
	__be64 T64_prio_5;
	__be64 T64_prio_6;
	__be64 T64_prio_7;
	__be64 T64_novlan;
	__be64 T64_loopbk;
	__be64 T127_prio_0;
	__be64 T127_prio_1;
	__be64 T127_prio_2;
	__be64 T127_prio_3;
	__be64 T127_prio_4;
	__be64 T127_prio_5;
	__be64 T127_prio_6;
	__be64 T127_prio_7;
	__be64 T127_novlan;
	__be64 T127_loopbk;
	__be64 T255_prio_0;
	__be64 T255_prio_1;
	__be64 T255_prio_2;
	__be64 T255_prio_3;
	__be64 T255_prio_4;
	__be64 T255_prio_5;
	__be64 T255_prio_6;
	__be64 T255_prio_7;
	__be64 T255_novlan;
	__be64 T255_loopbk;
	__be64 T511_prio_0;
	__be64 T511_prio_1;
	__be64 T511_prio_2;
	__be64 T511_prio_3;
	__be64 T511_prio_4;
	__be64 T511_prio_5;
	__be64 T511_prio_6;
	__be64 T511_prio_7;
	__be64 T511_novlan;
	__be64 T511_loopbk;
	__be64 T1023_prio_0;
	__be64 T1023_prio_1;
	__be64 T1023_prio_2;
	__be64 T1023_prio_3;
	__be64 T1023_prio_4;
	__be64 T1023_prio_5;
	__be64 T1023_prio_6;
	__be64 T1023_prio_7;
	__be64 T1023_novlan;
	__be64 T1023_loopbk;
	__be64 T1518_prio_0;
	__be64 T1518_prio_1;
	__be64 T1518_prio_2;
	__be64 T1518_prio_3;
	__be64 T1518_prio_4;
	__be64 T1518_prio_5;
	__be64 T1518_prio_6;
	__be64 T1518_prio_7;
	__be64 T1518_novlan;
	__be64 T1518_loopbk;
	__be64 T1522_prio_0;
	__be64 T1522_prio_1;
	__be64 T1522_prio_2;
	__be64 T1522_prio_3;
	__be64 T1522_prio_4;
	__be64 T1522_prio_5;
	__be64 T1522_prio_6;
	__be64 T1522_prio_7;
	__be64 T1522_novlan;
	__be64 T1522_loopbk;
	__be64 T1548_prio_0;
	__be64 T1548_prio_1;
	__be64 T1548_prio_2;
	__be64 T1548_prio_3;
	__be64 T1548_prio_4;
	__be64 T1548_prio_5;
	__be64 T1548_prio_6;
	__be64 T1548_prio_7;
	__be64 T1548_novlan;
	__be64 T1548_loopbk;
	__be64 T2MTU_prio_0;
	__be64 T2MTU_prio_1;
	__be64 T2MTU_prio_2;
	__be64 T2MTU_prio_3;
	__be64 T2MTU_prio_4;
	__be64 T2MTU_prio_5;
	__be64 T2MTU_prio_6;
	__be64 T2MTU_prio_7;
	__be64 T2MTU_novlan;
	__be64 T2MTU_loopbk;
	__be64 TGIANT_prio_0;
	__be64 TGIANT_prio_1;
	__be64 TGIANT_prio_2;
	__be64 TGIANT_prio_3;
	__be64 TGIANT_prio_4;
	__be64 TGIANT_prio_5;
	__be64 TGIANT_prio_6;
	__be64 TGIANT_prio_7;
	__be64 TGIANT_novlan;
	__be64 TGIANT_loopbk;
	__be64 TBCAST_prio_0;
	__be64 TBCAST_prio_1;
	__be64 TBCAST_prio_2;
	__be64 TBCAST_prio_3;
	__be64 TBCAST_prio_4;
	__be64 TBCAST_prio_5;
	__be64 TBCAST_prio_6;
	__be64 TBCAST_prio_7;
	__be64 TBCAST_novlan;
	__be64 TBCAST_loopbk;
	__be64 TMCAST_prio_0;
	__be64 TMCAST_prio_1;
	__be64 TMCAST_prio_2;
	__be64 TMCAST_prio_3;
	__be64 TMCAST_prio_4;
	__be64 TMCAST_prio_5;
	__be64 TMCAST_prio_6;
	__be64 TMCAST_prio_7;
	__be64 TMCAST_novlan;
	__be64 TMCAST_loopbk;
	__be64 TTOTG_prio_0;
	__be64 TTOTG_prio_1;
	__be64 TTOTG_prio_2;
	__be64 TTOTG_prio_3;
	__be64 TTOTG_prio_4;
	__be64 TTOTG_prio_5;
	__be64 TTOTG_prio_6;
	__be64 TTOTG_prio_7;
	__be64 TTOTG_novlan;
	__be64 TTOTG_loopbk;
	__be64 TTTLOCT_prio_0;
	__be64 TTTLOCT_NOFRM_prio_0;
	__be64 TOCT_prio_0;
	__be64 TTTLOCT_prio_1;
	__be64 TTTLOCT_NOFRM_prio_1;
	__be64 TOCT_prio_1;
	__be64 TTTLOCT_prio_2;
	__be64 TTTLOCT_NOFRM_prio_2;
	__be64 TOCT_prio_2;
	__be64 TTTLOCT_prio_3;
	__be64 TTTLOCT_NOFRM_prio_3;
	__be64 TOCT_prio_3;
	__be64 TTTLOCT_prio_4;
	__be64 TTTLOCT_NOFRM_prio_4;
	__be64 TOCT_prio_4;
	__be64 TTTLOCT_prio_5;
	__be64 TTTLOCT_NOFRM_prio_5;
	__be64 TOCT_prio_5;
	__be64 TTTLOCT_prio_6;
	__be64 TTTLOCT_NOFRM_prio_6;
	__be64 TOCT_prio_6;
	__be64 TTTLOCT_prio_7;
	__be64 TTTLOCT_NOFRM_prio_7;
	__be64 TOCT_prio_7;
	__be64 TTTLOCT_novlan;
	__be64 TTTLOCT_NOFRM_novlan;
	__be64 TOCT_novlan;
	__be64 TTTLOCT_loopbk;
	__be64 TTTLOCT_NOFRM_loopbk;
	__be64 TOCT_loopbk;
	__be64 TTOT_prio_0;
	__be64 T1Q_prio_0;
	__be64 reserved13;
	__be64 TTOT_prio_1;
	__be64 T1Q_prio_1;
	__be64 reserved14;
	__be64 TTOT_prio_2;
	__be64 T1Q_prio_2;
	__be64 reserved15;
	__be64 TTOT_prio_3;
	__be64 T1Q_prio_3;
	__be64 reserved16;
	__be64 TTOT_prio_4;
	__be64 T1Q_prio_4;
	__be64 reserved17;
	__be64 TTOT_prio_5;
	__be64 T1Q_prio_5;
	__be64 reserved18;
	__be64 TTOT_prio_6;
	__be64 T1Q_prio_6;
	__be64 reserved19;
	__be64 TTOT_prio_7;
	__be64 T1Q_prio_7;
	__be64 reserved20;
	__be64 TTOT_novlan;
	__be64 T1Q_novlan;
	__be64 reserved21;
	__be64 TTOT_loopbk;
	__be64 T1Q_loopbk;
	__be64 reserved22;
	__be32 RJBBR;
	__be32 RCRC;
	__be32 RRUNT;
	__be32 RSHORT;
	__be32 RDROP;
	__be32 RdropOvflw;
	__be32 RdropLength;
	__be32 RTOTFRMS;
	__be32 TDROP;
};

struct mlx4_en_pkt_stats {
	long unsigned int rx_multicast_packets;
	long unsigned int rx_broadcast_packets;
	long unsigned int rx_jabbers;
	long unsigned int rx_in_range_length_error;
	long unsigned int rx_out_range_length_error;
	long unsigned int tx_multicast_packets;
	long unsigned int tx_broadcast_packets;
	long unsigned int rx_prio[18];
	long unsigned int tx_prio[18];
};

struct mlx4_en_counter_stats {
	long unsigned int rx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_packets;
	long unsigned int tx_bytes;
};

struct mlx4_en_port_stats {
	long unsigned int tso_packets;
	long unsigned int xmit_more;
	long unsigned int queue_stopped;
	long unsigned int wake_queue;
	long unsigned int tx_timeout;
	long unsigned int rx_alloc_pages;
	long unsigned int rx_chksum_good;
	long unsigned int rx_chksum_none;
	long unsigned int rx_chksum_complete;
	long unsigned int tx_chksum_offload;
};

struct mlx4_en_perf_stats {
	u32 tx_poll;
	u64 tx_pktsz_avg;
	u32 inflight_avg;
	u16 tx_coal_avg;
	u16 rx_coal_avg;
	u32 napi_quota;
};

struct mlx4_en_xdp_stats {
	long unsigned int rx_xdp_drop;
	long unsigned int rx_xdp_tx;
	long unsigned int rx_xdp_tx_full;
};

struct mlx4_en_phy_stats {
	long unsigned int rx_packets_phy;
	long unsigned int rx_bytes_phy;
	long unsigned int tx_packets_phy;
	long unsigned int tx_bytes_phy;
};

struct mlx4_en_flow_stats_rx {
	u64 rx_pause;
	u64 rx_pause_duration;
	u64 rx_pause_transition;
};

struct mlx4_en_flow_stats_tx {
	u64 tx_pause;
	u64 tx_pause_duration;
	u64 tx_pause_transition;
};

enum {
	MAX_INLINE = 104,
	MAX_BF = 256,
	MIN_PKT_LEN = 17,
};

enum cq_type {
	TX = 0,
	TX_XDP = 1,
	RX = 2,
};

struct mlx4_en_tx_info {
	union {
		struct sk_buff *skb;
		struct page *page;
	};
	dma_addr_t map0_dma;
	u32 map0_byte_count;
	u32 nr_txbb;
	u32 nr_bytes;
	u8 linear;
	u8 data_offset;
	u8 inl;
	u8 ts_requested;
	u8 nr_maps;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
};

struct mlx4_en_page_cache {
	u32 index;
	struct {
		struct page *page;
		dma_addr_t dma;
	} buf[128];
};

struct mlx4_en_priv;

struct mlx4_en_rx_ring;

struct mlx4_en_tx_ring {
	u32 last_nr_txbb;
	u32 cons;
	long unsigned int wake_queue;
	struct netdev_queue *tx_queue;
	u32 (*free_tx_desc)(struct mlx4_en_priv *, struct mlx4_en_tx_ring *, int, u64, int);
	struct mlx4_en_rx_ring *recycle_ring;
	long: 64;
	long: 64;
	long: 64;
	u32 prod;
	unsigned int tx_dropped;
	long unsigned int bytes;
	long unsigned int packets;
	long unsigned int tx_csum;
	long unsigned int tso_packets;
	long unsigned int xmit_more;
	struct mlx4_bf bf;
	__be32 doorbell_qpn;
	__be32 mr_key;
	u32 size;
	u32 size_mask;
	u32 full_size;
	u32 buf_size;
	void *buf;
	struct mlx4_en_tx_info *tx_info;
	int qpn;
	u8 queue_index;
	bool bf_enabled;
	bool bf_alloced;
	u8 hwtstamp_tx_type;
	u8 *bounce_buf;
	long unsigned int queue_stopped;
	struct mlx4_hwq_resources sp_wqres;
	struct mlx4_qp sp_qp;
	struct mlx4_qp_context sp_context;
	cpumask_t sp_affinity_mask;
	enum mlx4_qp_state sp_qp_state;
	u16 sp_stride;
	u16 sp_cqn;
	long: 64;
};

struct mlx4_en_port_state {
	int link_state;
	int link_speed;
	int transceiver;
	u32 flags;
};

struct ethtool_flow_id {
	struct list_head list;
	struct ethtool_rx_flow_spec flow_spec;
	u64 id;
};

struct mlx4_en_rss_map {
	int base_qpn;
	struct mlx4_qp qps[128];
	enum mlx4_qp_state state[128];
	struct mlx4_qp *indir_qp;
	enum mlx4_qp_state indir_state;
};

struct mlx4_en_frag_info {
	u16 frag_size;
	u32 frag_stride;
};

struct mlx4_en_stats_bitmap {
	long unsigned int bitmap[3];
	struct mutex mutex;
};

struct mlx4_en_cee_config {
	bool pfc_state;
	enum dcb_pfc_type dcb_pfc[8];
};

struct mlx4_en_dev;

struct mlx4_en_port_profile;

struct mlx4_en_cq;

struct mlx4_en_priv {
	struct mlx4_en_dev *mdev;
	struct mlx4_en_port_profile *prof;
	struct net_device *dev;
	long unsigned int active_vlans[64];
	struct mlx4_en_port_state port_state;
	spinlock_t stats_lock;
	struct ethtool_flow_id ethtool_rules[256];
	struct list_head ethtool_list;
	long unsigned int last_moder_packets[128];
	long unsigned int last_moder_tx_packets;
	long unsigned int last_moder_bytes[128];
	long unsigned int last_moder_jiffies;
	int last_moder_time[128];
	u16 rx_usecs;
	u16 rx_frames;
	u16 tx_usecs;
	u16 tx_frames;
	u32 pkt_rate_low;
	u16 rx_usecs_low;
	u32 pkt_rate_high;
	u16 rx_usecs_high;
	u32 sample_interval;
	u32 adaptive_rx_coal;
	u32 msg_enable;
	u32 loopback_ok;
	u32 validate_loopback;
	struct mlx4_hwq_resources res;
	int link_state;
	int last_link_state;
	bool port_up;
	int port;
	int registered;
	int allocated;
	int stride;
	unsigned char current_mac[8];
	int mac_index;
	unsigned int max_mtu;
	int base_qpn;
	int cqe_factor;
	int cqe_size;
	struct mlx4_en_rss_map rss_map;
	__be32 ctrl_flags;
	u32 flags;
	u8 num_tx_rings_p_up;
	u32 tx_work_limit;
	u32 tx_ring_num[2];
	u32 rx_ring_num;
	u32 rx_skb_size;
	struct mlx4_en_frag_info frag_info[4];
	u8 num_frags;
	u8 log_rx_info;
	u8 dma_dir;
	u16 rx_headroom;
	struct mlx4_en_tx_ring **tx_ring[2];
	struct mlx4_en_rx_ring *rx_ring[128];
	struct mlx4_en_cq **tx_cq[2];
	struct mlx4_en_cq *rx_cq[128];
	struct mlx4_qp drop_qp;
	struct work_struct rx_mode_task;
	struct work_struct watchdog_task;
	struct work_struct linkstate_task;
	struct delayed_work stats_task;
	struct delayed_work service_task;
	struct mlx4_en_perf_stats pstats;
	struct mlx4_en_pkt_stats pkstats;
	struct mlx4_en_counter_stats pf_stats;
	struct mlx4_en_flow_stats_rx rx_priority_flowstats[8];
	struct mlx4_en_flow_stats_tx tx_priority_flowstats[8];
	struct mlx4_en_flow_stats_rx rx_flowstats;
	struct mlx4_en_flow_stats_tx tx_flowstats;
	struct mlx4_en_port_stats port_stats;
	struct mlx4_en_xdp_stats xdp_stats;
	struct mlx4_en_phy_stats phy_stats;
	struct mlx4_en_stats_bitmap stats_bitmap;
	struct list_head mc_list;
	struct list_head curr_list;
	u64 broadcast_id;
	struct mlx4_en_stat_out_mbox hw_stats;
	int vids[128];
	bool wol;
	struct device *ddev;
	struct hlist_head mac_hash[256];
	struct hwtstamp_config hwtstamp_config;
	u32 counter_index;
	struct ieee_ets ets;
	u16 maxrate[8];
	enum dcbnl_cndd_states cndd_state[8];
	struct mlx4_en_cee_config cee_config;
	u8 dcbx_cap;
	spinlock_t filters_lock;
	int last_filter_id;
	struct list_head filters;
	struct hlist_head filter_hash[16];
	u64 tunnel_reg_id;
	__be16 vxlan_port;
	u32 pflags;
	u8 rss_key[40];
	u8 rss_hash_fn;
};

struct mlx4_en_rx_ring {
	struct mlx4_hwq_resources wqres;
	u32 size;
	u32 actual_size;
	u32 size_mask;
	u16 stride;
	u16 log_stride;
	u16 cqn;
	u32 prod;
	u32 cons;
	u32 buf_size;
	u8 fcs_del;
	void *buf;
	void *rx_info;
	struct bpf_prog *xdp_prog;
	struct mlx4_en_page_cache page_cache;
	long unsigned int bytes;
	long unsigned int packets;
	long unsigned int csum_ok;
	long unsigned int csum_none;
	long unsigned int csum_complete;
	long unsigned int rx_alloc_pages;
	long unsigned int xdp_drop;
	long unsigned int xdp_tx;
	long unsigned int xdp_tx_full;
	long unsigned int dropped;
	int hwtstamp_rx_filter;
	cpumask_var_t affinity_mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct mlx4_en_cq {
	struct mlx4_cq mcq;
	struct mlx4_hwq_resources wqres;
	int ring;
	struct net_device *dev;
	union {
		struct napi_struct napi;
		bool xdp_busy;
	};
	int size;
	int buf_size;
	int vector;
	enum cq_type type;
	u16 moder_time;
	u16 moder_cnt;
	struct mlx4_cqe *buf;
	struct irq_desc *irq_desc;
};

struct mlx4_en_port_profile {
	u32 flags;
	u32 tx_ring_num[2];
	u32 rx_ring_num;
	u32 tx_ring_size;
	u32 rx_ring_size;
	u8 num_tx_rings_p_up;
	u8 rx_pause;
	u8 rx_ppp;
	u8 tx_pause;
	u8 tx_ppp;
	u8 num_up;
	int rss_rings;
	int inline_thold;
	struct hwtstamp_config hwtstamp_config;
};

struct mlx4_en_profile {
	int udp_rss;
	u8 rss_mask;
	u32 active_ports;
	u32 small_pkt_int;
	u8 no_reset;
	u8 max_num_tx_rings_p_up;
	struct mlx4_en_port_profile prof[3];
};

struct mlx4_en_dev {
	struct mlx4_dev *dev;
	struct pci_dev *pdev;
	struct mutex state_lock;
	struct net_device *pndev[3];
	struct net_device *upper[3];
	u32 port_cnt;
	bool device_up;
	struct mlx4_en_profile profile;
	u32 LSO_support;
	struct workqueue_struct *workqueue;
	struct device *dma_device;
	void *uar_map;
	struct mlx4_uar priv_uar;
	struct mlx4_mr mr;
	u32 priv_pdn;
	spinlock_t uar_lock;
	u8 mac_removed[3];
	u32 nominal_c_mult;
	struct cyclecounter cycles;
	seqlock_t clock_lock;
	struct timecounter clock;
	long unsigned int last_overflow_check;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct notifier_block nb;
};

enum {
	MLX4_EN_FLAG_PROMISC = 1,
	MLX4_EN_FLAG_MC_PROMISC = 2,
	MLX4_EN_FLAG_ENABLE_HW_LOOPBACK = 4,
	MLX4_EN_FLAG_RX_FILTER_NEEDED = 8,
	MLX4_EN_FLAG_FORCE_PROMISC = 16,
	MLX4_EN_FLAG_RX_CSUM_NON_TCP_UDP = 32,
	MLX4_EN_FLAG_DCB_ENABLED = 64,
};

enum {
	MLX4_OPCODE_NOP = 0,
	MLX4_OPCODE_SEND_INVAL = 1,
	MLX4_OPCODE_RDMA_WRITE = 8,
	MLX4_OPCODE_RDMA_WRITE_IMM = 9,
	MLX4_OPCODE_SEND = 10,
	MLX4_OPCODE_SEND_IMM = 11,
	MLX4_OPCODE_LSO = 14,
	MLX4_OPCODE_RDMA_READ = 16,
	MLX4_OPCODE_ATOMIC_CS = 17,
	MLX4_OPCODE_ATOMIC_FA = 18,
	MLX4_OPCODE_MASKED_ATOMIC_CS = 20,
	MLX4_OPCODE_MASKED_ATOMIC_FA = 21,
	MLX4_OPCODE_BIND_MW = 24,
	MLX4_OPCODE_FMR = 25,
	MLX4_OPCODE_LOCAL_INVAL = 27,
	MLX4_OPCODE_CONFIG_CMD = 31,
	MLX4_RECV_OPCODE_RDMA_WRITE_IMM = 0,
	MLX4_RECV_OPCODE_SEND = 1,
	MLX4_RECV_OPCODE_SEND_IMM = 2,
	MLX4_RECV_OPCODE_SEND_INVAL = 3,
	MLX4_CQE_OPCODE_ERROR = 30,
	MLX4_CQE_OPCODE_RESIZE = 22,
};

struct mlx4_err_cqe {
	__be32 my_qpn;
	u32 reserved1[5];
	__be16 wqe_index;
	u8 vendor_err_syndrome;
	u8 syndrome;
	u8 reserved2[3];
	u8 owner_sr_opcode;
};

enum {
	MLX4_CQE_OWNER_MASK = 128,
	MLX4_CQE_IS_SEND_MASK = 64,
	MLX4_CQE_OPCODE_MASK = 31,
};

union mlx4_wqe_qpn_vlan {
	struct {
		__be16 vlan_tag;
		u8 ins_vlan;
		u8 fence_size;
	};
	__be32 bf_qpn;
};

struct mlx4_wqe_ctrl_seg {
	__be32 owner_opcode;
	union mlx4_wqe_qpn_vlan qpn_vlan;
	union {
		__be32 srcrb_flags;
		__be16 srcrb_flags16[2];
	};
	__be32 imm;
};

struct mlx4_wqe_lso_seg {
	__be32 mss_hdr_size;
	__be32 header[0];
};

struct mlx4_wqe_data_seg {
	__be32 byte_count;
	__be32 lkey;
	__be64 addr;
};

enum {
	MLX4_INLINE_ALIGN = 64,
	MLX4_INLINE_SEG = 2147483648,
};

struct mlx4_wqe_inline_seg {
	__be32 byte_count;
};

struct mlx4_en_tx_desc {
	struct mlx4_wqe_ctrl_seg ctrl;
	union {
		struct mlx4_wqe_data_seg data;
		struct mlx4_wqe_lso_seg lso;
		struct mlx4_wqe_inline_seg inl;
	};
};

struct mlx4_en_rx_alloc {
	struct page *page;
	dma_addr_t dma;
	u32 page_offset;
};

enum {
	MLX4_CQE_L2_TUNNEL_IPOK = 2147483648,
	MLX4_CQE_CVLAN_PRESENT_MASK = 536870912,
	MLX4_CQE_SVLAN_PRESENT_MASK = 1073741824,
	MLX4_CQE_L2_TUNNEL = 134217728,
	MLX4_CQE_L2_TUNNEL_CSUM = 67108864,
	MLX4_CQE_L2_TUNNEL_IPV4 = 33554432,
	MLX4_CQE_QPN_MASK = 16777215,
	MLX4_CQE_VID_MASK = 4095,
};

enum {
	MLX4_CQE_STATUS_IPV4 = 64,
	MLX4_CQE_STATUS_IPV4F = 128,
	MLX4_CQE_STATUS_IPV6 = 256,
	MLX4_CQE_STATUS_IPV4OPT = 512,
	MLX4_CQE_STATUS_TCP = 1024,
	MLX4_CQE_STATUS_UDP = 2048,
	MLX4_CQE_STATUS_IPOK = 4096,
};

enum {
	MLX4_CQE_LLC = 1,
	MLX4_CQE_SNAP = 2,
	MLX4_CQE_BAD_FCS = 16,
};

struct mlx4_rss_context {
	__be32 base_qpn;
	__be32 default_qpn;
	u16 reserved;
	u8 hash_fn;
	u8 flags;
	__be32 rss_key[10];
	__be32 base_qpn_udp;
};

struct mlx4_en_rx_desc {
	struct mlx4_wqe_data_seg data[0];
};

struct mlx4_mac_entry {
	struct hlist_node hlist;
	unsigned char mac[8];
	u64 reg_id;
	struct callback_head rcu;
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	__ETHTOOL_TUNABLE_COUNT = 4,
};

enum mlx4_module_id {
	MLX4_MODULE_ID_SFP = 3,
	MLX4_MODULE_ID_QSFP = 12,
	MLX4_MODULE_ID_QSFP_PLUS = 13,
	MLX4_MODULE_ID_QSFP28 = 17,
};

enum mlx4_ptys_proto {
	MLX4_PTYS_IB = 1,
	MLX4_PTYS_EN = 4,
};

enum mlx4_ptys_flags {
	MLX4_PTYS_AN_DISABLE_CAP = 32,
	MLX4_PTYS_AN_DISABLE_ADMIN = 64,
};

enum mlx4_link_mode {
	MLX4_1000BASE_CX_SGMII = 0,
	MLX4_1000BASE_KX = 1,
	MLX4_10GBASE_CX4 = 2,
	MLX4_10GBASE_KX4 = 3,
	MLX4_10GBASE_KR = 4,
	MLX4_20GBASE_KR2 = 5,
	MLX4_40GBASE_CR4 = 6,
	MLX4_40GBASE_KR4 = 7,
	MLX4_56GBASE_KR4 = 8,
	MLX4_10GBASE_CR = 12,
	MLX4_10GBASE_SR = 13,
	MLX4_40GBASE_SR4 = 15,
	MLX4_56GBASE_CR4 = 17,
	MLX4_56GBASE_SR4 = 18,
	MLX4_100BASE_TX = 24,
	MLX4_1000BASE_T = 25,
	MLX4_10GBASE_T = 26,
};

enum mlx4_en_port_flag {
	MLX4_EN_PORT_ANC = 1,
	MLX4_EN_PORT_ANE = 2,
};

enum mlx4_en_wol {
	MLX4_EN_WOL_MAGIC = 0,
	MLX4_EN_WOL_ENABLED = 0,
};

struct bitmap_iterator {
	long unsigned int *stats_bitmap;
	unsigned int count;
	unsigned int iterator;
	bool advance_array;
};

enum ethtool_report {
	SUPPORTED___2 = 0,
	ADVERTISED = 1,
};

struct ptys2ethtool_config {
	long unsigned int supported[2];
	long unsigned int advertised[2];
	u32 speed;
};

struct mlx4_set_vlan_fltr_mbox {
	__be32 entry[128];
};

enum {
	MLX4_EN_100M_SPEED = 4,
	MLX4_EN_10G_SPEED_XAUI = 0,
	MLX4_EN_10G_SPEED_XFI = 1,
	MLX4_EN_1G_SPEED = 2,
	MLX4_EN_20G_SPEED = 8,
	MLX4_EN_40G_SPEED = 64,
	MLX4_EN_56G_SPEED = 32,
	MLX4_EN_OTHER_SPEED = 15,
};

struct mlx4_en_query_port_context {
	u8 link_up;
	u8 autoneg;
	__be16 mtu;
	u8 reserved2;
	u8 link_speed;
	u16 reserved3[5];
	__be64 mac;
	u8 transceiver;
};

struct mlx4_en_stat_out_flow_control_mbox {
	__be64 rx_pause;
	__be64 rx_pause_duration;
	__be64 rx_pause_transition;
	__be64 tx_pause;
	__be64 tx_pause_duration;
	__be64 tx_pause_transition;
	__be64 reserved[2];
};

enum {
	MLX4_DUMP_ETH_STATS_FLOW_CONTROL = 4096,
};

enum {
	MLX4_CQ_DB_REQ_NOT_SOL = 16777216,
	MLX4_CQ_DB_REQ_NOT = 33554432,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

enum {
	MLX4_QP_RATE_LIMIT_NONE = 0,
	MLX4_QP_RATE_LIMIT_KBS = 1,
	MLX4_QP_RATE_LIMIT_MBS = 2,
	MLX4_QP_RATE_LIMIT_GBS = 3,
};

enum {
	VXLAN_STEER_BY_OUTER_MAC = 1,
	VXLAN_STEER_BY_OUTER_VLAN = 2,
	VXLAN_STEER_BY_VSID_VNI = 4,
	VXLAN_STEER_BY_INNER_MAC = 8,
	VXLAN_STEER_BY_INNER_VLAN = 16,
};

enum {
	MLX4_MCAST_CONFIG = 0,
	MLX4_MCAST_DISABLE = 1,
	MLX4_MCAST_ENABLE = 2,
};

enum mlx4_en_mclist_act {
	MCLIST_NONE = 0,
	MCLIST_REM = 1,
	MCLIST_ADD = 2,
};

struct mlx4_en_mc_list {
	struct list_head list;
	enum mlx4_en_mclist_act action;
	u8 addr[6];
	u64 reg_id;
	u64 tunnel_reg_id;
};

struct mlx4_en_filter {
	struct list_head next;
	struct work_struct work;
	u8 ip_proto;
	__be32 src_ip;
	__be32 dst_ip;
	__be16 src_port;
	__be16 dst_port;
	int rxq_index;
	struct mlx4_en_priv *priv;
	u32 flow_id;
	int id;
	u64 reg_id;
	u8 activated;
	struct hlist_node filter_chain;
};

struct mlx4_en_bond {
	struct work_struct work;
	struct mlx4_en_priv *priv;
	int is_bonded;
	struct mlx4_port_map port_map;
};

struct mlx4_ts_cqe {
	__be32 vlan_my_qpn;
	__be32 immed_rss_invalid;
	__be32 g_mlpath_rqpn;
	__be32 timestamp_hi;
	__be16 status;
	u8 ipv6_ext_mask;
	u8 badfcs_enc;
	__be32 byte_cnt;
	__be16 wqe_index;
	__be16 checksum;
	u8 reserved;
	__be16 timestamp_lo;
	u8 owner_sr_opcode;
} __attribute__((packed));

enum mlx4_en_congestion_control_algorithm {
	MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT = 0,
};

enum mlx4_en_congestion_control_opmod {
	MLX4_CONGESTION_CONTROL_GET_PARAMS = 0,
	MLX4_CONGESTION_CONTROL_GET_STATISTICS = 1,
	MLX4_CONGESTION_CONTROL_SET_PARAMS = 4,
};

enum {
	MLX4_CEE_STATE_DOWN = 0,
	MLX4_CEE_STATE_UP = 1,
};

struct mlx4_congestion_control_mb_prio_802_1_qau_params {
	__be32 modify_enable_high;
	__be32 modify_enable_low;
	__be32 reserved1;
	__be32 extended_enable;
	__be32 rppp_max_rps;
	__be32 rpg_time_reset;
	__be32 rpg_byte_reset;
	__be32 rpg_threshold;
	__be32 rpg_max_rate;
	__be32 rpg_ai_rate;
	__be32 rpg_hai_rate;
	__be32 rpg_gd;
	__be32 rpg_min_dec_fac;
	__be32 rpg_min_rate;
	__be32 max_time_rise;
	__be32 max_byte_rise;
	__be32 max_qdelta;
	__be32 min_qoffset;
	__be32 gd_coefficient;
	__be32 reserved2[5];
	__be32 cp_sample_base;
	__be32 reserved3[39];
};

struct mlx4_congestion_control_mb_prio_802_1_qau_statistics {
	__be64 rppp_rp_centiseconds;
	__be32 reserved1;
	__be32 ignored_cnm;
	__be32 rppp_created_rps;
	__be32 estimated_total_rate;
	__be32 max_active_rate_limiter_index;
	__be32 dropped_cnms_busy_fw;
	__be32 reserved2;
	__be32 cnms_handled_successfully;
	__be32 min_total_limiters_rate;
	__be32 max_total_limiters_rate;
	__be32 reserved3[4];
};

struct nfp_cpp_explicit_command {
	u32 cpp_id;
	u16 data_ref;
	u8 data_master;
	u8 len;
	u8 byte_mask;
	u8 signal_master;
	u8 signal_ref;
	u8 posted;
	u8 siga;
	u8 sigb;
	s8 siga_mode;
	s8 sigb_mode;
};

struct nfp_cpp;

struct nfp_cpp_area;

struct nfp_cpp_explicit;

struct nfp_cpp_operations {
	size_t area_priv_size;
	struct module *owner;
	int (*init)(struct nfp_cpp *);
	void (*free)(struct nfp_cpp *);
	int (*read_serial)(struct device *, u8 *);
	int (*get_interface)(struct device *);
	int (*area_init)(struct nfp_cpp_area *, u32, long long unsigned int, long unsigned int);
	void (*area_cleanup)(struct nfp_cpp_area *);
	int (*area_acquire)(struct nfp_cpp_area *);
	void (*area_release)(struct nfp_cpp_area *);
	struct resource * (*area_resource)(struct nfp_cpp_area *);
	phys_addr_t (*area_phys)(struct nfp_cpp_area *);
	void * (*area_iomem)(struct nfp_cpp_area *);
	int (*area_read)(struct nfp_cpp_area *, void *, long unsigned int, unsigned int);
	int (*area_write)(struct nfp_cpp_area *, const void *, long unsigned int, unsigned int);
	size_t explicit_priv_size;
	int (*explicit_acquire)(struct nfp_cpp_explicit *);
	void (*explicit_release)(struct nfp_cpp_explicit *);
	int (*explicit_put)(struct nfp_cpp_explicit *, const void *, size_t);
	int (*explicit_get)(struct nfp_cpp_explicit *, void *, size_t);
	int (*explicit_do)(struct nfp_cpp_explicit *, const struct nfp_cpp_explicit_command *, u64);
};

struct nfp6000_pcie;

struct nfp_bar {
	struct nfp6000_pcie *nfp;
	u32 barcfg;
	u64 base;
	u64 mask;
	u32 bitsize;
	int index;
	atomic_t refcnt;
	void *iomem;
	struct resource *resource;
};

struct nfp6000_pcie {
	struct pci_dev *pdev;
	struct device *dev;
	spinlock_t bar_lock;
	int bars;
	struct nfp_bar bar[24];
	wait_queue_head_t bar_waiters;
	struct {
		void *csr;
		void *em;
		void *expl[4];
	} iomem;
	struct {
		struct mutex mutex;
		u8 master_id;
		u8 signal_ref;
		void *data;
		struct {
			void *addr;
			int bitsize;
			int free[4];
		} group[4];
	} expl;
};

struct nfp6000_area_priv {
	atomic_t refcnt;
	struct nfp_bar *bar;
	u32 bar_offset;
	u32 target;
	u32 action;
	u32 token;
	u64 offset;
	struct {
		int read;
		int write;
		int bar;
	} width;
	size_t size;
	void *iomem;
	phys_addr_t phys;
	struct resource resource;
};

struct nfp6000_explicit_priv {
	struct nfp6000_pcie *nfp;
	struct {
		int group;
		int area;
	} bar;
	int bitsize;
	void *data;
	void *addr;
};

struct nfp_cpp {
	struct device dev;
	void *priv;
	u32 model;
	u16 interface;
	u8 serial[6];
	const struct nfp_cpp_operations *op;
	struct list_head resource_list;
	rwlock_t resource_lock;
	wait_queue_head_t waitq;
	u32 imb_cat_table[16];
	unsigned int mu_locality_lsb;
	struct mutex area_cache_mutex;
	struct list_head area_cache_list;
};

struct nfp_cpp_resource {
	struct list_head list;
	const char *name;
	u32 cpp_id;
	u64 start;
	u64 end;
};

struct nfp_cpp_area {
	struct nfp_cpp *cpp;
	struct kref kref;
	atomic_t refcount;
	struct mutex mutex;
	long long unsigned int offset;
	long unsigned int size;
	struct nfp_cpp_resource resource;
	void *iomem;
};

struct nfp_cpp_explicit {
	struct nfp_cpp *cpp;
	struct nfp_cpp_explicit_command cmd;
};

enum nfp_cpp_explicit_signal_mode {
	NFP_SIGNAL_NONE = 0,
	NFP_SIGNAL_PUSH = 1,
	NFP_SIGNAL_PUSH_OPTIONAL = 4294967295,
	NFP_SIGNAL_PULL = 2,
	NFP_SIGNAL_PULL_OPTIONAL = 4294967294,
};

struct nfp_cpp_area_cache {
	struct list_head entry;
	u32 id;
	u64 addr;
	u32 size;
	struct nfp_cpp_area *area;
};

struct nfp_hwinfo {
	u8 start[0];
	__le32 version;
	__le32 size;
	__le32 limit;
	__le32 resv;
	char data[0];
};

struct nfp_resource;

struct nfp_mip {
	__le32 signature;
	__le32 mip_version;
	__le32 mip_size;
	__le32 first_entry;
	__le32 version;
	__le32 buildnum;
	__le32 buildtime;
	__le32 loadtime;
	__le32 symtab_addr;
	__le32 symtab_size;
	__le32 strtab_addr;
	__le32 strtab_size;
	char name[16];
	char toolchain[32];
};

struct nfp_nffw_info;

struct nfp_cpp_mutex {
	struct nfp_cpp *cpp;
	int target;
	u16 depth;
	long long unsigned int address;
	u32 key;
};

struct nffw_meinfo {
	__le32 ctxmask__fwid__meid;
};

struct nffw_fwinfo {
	__le32 loaded__mu_da__mip_off_hi;
	__le32 mip_cppid;
	__le32 mip_offset_lo;
};

struct nfp_nffw_info_v1 {
	struct nffw_meinfo meinfo[120];
	struct nffw_fwinfo fwinfo[120];
};

struct nfp_nffw_info_v2 {
	struct nffw_meinfo meinfo[200];
	struct nffw_fwinfo fwinfo[200];
};

struct nfp_nffw_info_data {
	__le32 flags[2];
	union {
		struct nfp_nffw_info_v1 v1;
		struct nfp_nffw_info_v2 v2;
	} info;
};

struct nfp_nffw_info___2 {
	struct nfp_cpp *cpp;
	struct nfp_resource *res;
	struct nfp_nffw_info_data fwinf;
};

enum nfp_nsp_versions {
	NFP_VERSIONS_BSP = 0,
	NFP_VERSIONS_CPLD = 1,
	NFP_VERSIONS_APP = 2,
	NFP_VERSIONS_BUNDLE = 3,
	NFP_VERSIONS_UNDI = 4,
	NFP_VERSIONS_NCSI = 5,
	NFP_VERSIONS_CFGR = 6,
};

enum nfp_nsp_cmd {
	SPCODE_NOOP = 0,
	SPCODE_SOFT_RESET = 1,
	SPCODE_FW_DEFAULT = 2,
	SPCODE_PHY_INIT = 3,
	SPCODE_MAC_INIT = 4,
	SPCODE_PHY_RXADAPT = 5,
	SPCODE_FW_LOAD = 6,
	SPCODE_ETH_RESCAN = 7,
	SPCODE_ETH_CONTROL = 8,
	SPCODE_NSP_WRITE_FLASH = 11,
	SPCODE_NSP_SENSORS = 12,
	SPCODE_NSP_IDENTIFY = 13,
	SPCODE_FW_STORED = 16,
	SPCODE_HWINFO_LOOKUP = 17,
	SPCODE_HWINFO_SET = 18,
	SPCODE_FW_LOADED = 19,
	SPCODE_VERSIONS = 21,
	SPCODE_READ_SFF_EEPROM = 22,
};

struct nfp_nsp_dma_buf {
	__le32 chunk_cnt;
	__le32 reserved[3];
	struct {
		__le32 size;
		__le32 reserved;
		__le64 addr;
	} descs[0];
};

struct nfp_nsp {
	struct nfp_cpp *cpp;
	struct nfp_resource *res;
	struct {
		u16 major;
		u16 minor;
	} ver;
	bool modified;
	unsigned int idx;
	void *entries;
};

struct nfp_nsp_command_arg {
	u16 code;
	bool dma;
	unsigned int timeout_sec;
	u32 option;
	u64 buf;
	void (*error_cb)(struct nfp_nsp *, u32);
	bool error_quiet;
};

struct nfp_nsp_command_buf_arg {
	struct nfp_nsp_command_arg arg;
	const void *in_buf;
	unsigned int in_size;
	void *out_buf;
	unsigned int out_size;
};

struct eeprom_buf {
	u8 metalen;
	__le16 length;
	__le16 offset;
	__le16 readlen;
	u8 eth_index;
	u8 data[0];
} __attribute__((packed));

struct nfp_nsp_identify {
	char version[40];
	u8 flags;
	u8 br_primary;
	u8 br_secondary;
	u8 br_nsp;
	u16 primary;
	u16 secondary;
	u16 nsp;
	u64 sensor_mask;
};

enum nfp_nsp_sensor_id {
	NFP_SENSOR_CHIP_TEMPERATURE = 0,
	NFP_SENSOR_ASSEMBLY_POWER = 1,
	NFP_SENSOR_ASSEMBLY_12V_POWER = 2,
	NFP_SENSOR_ASSEMBLY_3V3_POWER = 3,
};

struct nsp_identify {
	u8 version[40];
	u8 flags;
	u8 br_primary;
	u8 br_secondary;
	u8 br_nsp;
	__le16 primary;
	__le16 secondary;
	__le16 nsp;
	u8 reserved[6];
	__le64 sensor_mask;
};

struct nfp_sensors {
	__le32 chip_temp;
	__le32 assembly_power;
	__le32 assembly_12v_power;
	__le32 assembly_3v3_power;
};

struct nfp_nsp___2;

enum nfp_eth_interface {
	NFP_INTERFACE_NONE = 0,
	NFP_INTERFACE_SFP = 1,
	NFP_INTERFACE_SFPP = 10,
	NFP_INTERFACE_SFP28 = 28,
	NFP_INTERFACE_QSFP = 40,
	NFP_INTERFACE_RJ45 = 45,
	NFP_INTERFACE_CXP = 100,
	NFP_INTERFACE_QSFP28 = 112,
};

enum nfp_eth_media {
	NFP_MEDIA_DAC_PASSIVE = 0,
	NFP_MEDIA_DAC_ACTIVE = 1,
	NFP_MEDIA_FIBRE = 2,
};

enum nfp_eth_aneg {
	NFP_ANEG_AUTO = 0,
	NFP_ANEG_SEARCH = 1,
	NFP_ANEG_25G_CONSORTIUM = 2,
	NFP_ANEG_25G_IEEE = 3,
	NFP_ANEG_DISABLED = 4,
};

enum nfp_eth_fec {
	NFP_FEC_AUTO_BIT = 0,
	NFP_FEC_BASER_BIT = 1,
	NFP_FEC_REED_SOLOMON_BIT = 2,
	NFP_FEC_DISABLED_BIT = 3,
};

struct nfp_eth_table_port {
	unsigned int eth_index;
	unsigned int index;
	unsigned int nbi;
	unsigned int base;
	unsigned int lanes;
	unsigned int speed;
	unsigned int interface;
	enum nfp_eth_media media;
	enum nfp_eth_fec fec;
	enum nfp_eth_aneg aneg;
	u8 mac_addr[6];
	u8 label_port;
	u8 label_subport;
	bool enabled;
	bool tx_enabled;
	bool rx_enabled;
	bool override_changed;
	u8 port_type;
	unsigned int port_lanes;
	bool is_split;
	unsigned int fec_modes_supported;
};

struct nfp_eth_table {
	unsigned int count;
	unsigned int max_index;
	struct nfp_eth_table_port ports[0];
};

enum nfp_eth_raw {
	NSP_ETH_RAW_PORT = 0,
	NSP_ETH_RAW_STATE = 1,
	NSP_ETH_RAW_MAC = 2,
	NSP_ETH_RAW_CONTROL = 3,
	NSP_ETH_NUM_RAW = 4,
};

enum nfp_eth_rate {
	RATE_INVALID = 0,
	RATE_10M = 1,
	RATE_100M = 2,
	RATE_1G = 3,
	RATE_10G = 4,
	RATE_25G = 5,
};

union eth_table_entry {
	struct {
		__le64 port;
		__le64 state;
		u8 mac_addr[6];
		u8 resv[2];
		__le64 control;
	};
	__le64 raw[4];
};

struct nfp_resource_entry_mutex {
	u32 owner;
	u32 key;
};

struct nfp_resource_entry_region {
	u8 name[8];
	u8 reserved[5];
	u8 cpp_action;
	u8 cpp_token;
	u8 cpp_target;
	u32 page_offset;
	u32 page_size;
};

struct nfp_resource_entry {
	struct nfp_resource_entry_mutex mutex;
	struct nfp_resource_entry_region region;
};

struct nfp_cpp_mutex___2;

struct nfp_resource___2 {
	char name[9];
	u32 cpp_id;
	u64 addr;
	u64 size;
	struct nfp_cpp_mutex___2 *mutex;
};

enum nfp_rtsym_type {
	NFP_RTSYM_TYPE_NONE = 0,
	NFP_RTSYM_TYPE_OBJECT = 1,
	NFP_RTSYM_TYPE_FUNCTION = 2,
	NFP_RTSYM_TYPE_ABS = 3,
};

struct nfp_rtsym {
	const char *name;
	u64 addr;
	u64 size;
	enum nfp_rtsym_type type;
	int target;
	int domain;
};

struct nfp_rtsym_entry {
	u8 type;
	u8 target;
	u8 island;
	u8 addr_hi;
	__le32 addr_lo;
	__le16 name;
	u8 menum;
	u8 size_hi;
	__le32 size_lo;
};

struct nfp_rtsym_table {
	struct nfp_cpp *cpp;
	int num;
	char *strtab;
	struct nfp_rtsym symtab[0];
};

struct nfp_mip___2;

enum nfp_ccm_type {
	NFP_CCM_TYPE_BPF_MAP_ALLOC = 1,
	NFP_CCM_TYPE_BPF_MAP_FREE = 2,
	NFP_CCM_TYPE_BPF_MAP_LOOKUP = 3,
	NFP_CCM_TYPE_BPF_MAP_UPDATE = 4,
	NFP_CCM_TYPE_BPF_MAP_DELETE = 5,
	NFP_CCM_TYPE_BPF_MAP_GETNEXT = 6,
	NFP_CCM_TYPE_BPF_MAP_GETFIRST = 7,
	NFP_CCM_TYPE_BPF_BPF_EVENT = 8,
	NFP_CCM_TYPE_CRYPTO_RESET = 9,
	NFP_CCM_TYPE_CRYPTO_ADD = 10,
	NFP_CCM_TYPE_CRYPTO_DEL = 11,
	NFP_CCM_TYPE_CRYPTO_UPDATE = 12,
	NFP_CCM_TYPE_CRYPTO_RESYNC = 13,
	__NFP_CCM_TYPE_MAX = 14,
};

struct nfp_ccm_hdr {
	union {
		struct {
			u8 type;
			u8 ver;
			__be16 tag;
		};
		__be32 raw;
	};
};

struct nfp_app;

struct nfp_ccm {
	struct nfp_app *app;
	long unsigned int tag_allocator[1024];
	u16 tag_alloc_next;
	u16 tag_alloc_last;
	struct sk_buff_head replies;
	wait_queue_head_t wq;
};

struct nfp_pf;

struct nfp_net;

struct nfp_reprs;

struct nfp_app_type;

struct nfp_app {
	struct pci_dev *pdev;
	struct nfp_pf *pf;
	struct nfp_cpp *cpp;
	struct nfp_net *ctrl;
	struct nfp_reprs *reprs[3];
	const struct nfp_app_type *type;
	unsigned int ctrl_mtu;
	struct notifier_block netdev_nb;
	void *priv;
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

enum devlink_eswitch_mode {
	DEVLINK_ESWITCH_MODE_LEGACY = 0,
	DEVLINK_ESWITCH_MODE_SWITCHDEV = 1,
};

struct nfp_reprs {
	unsigned int num_reprs;
	struct net_device *reprs[0];
};

struct nfp_repr_pcpu_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	u64 tx_drops;
	struct u64_stats_sync syncp;
};

struct nfp_port;

struct nfp_repr {
	struct net_device *netdev;
	struct metadata_dst *dst;
	struct nfp_port *port;
	struct nfp_app *app;
	struct nfp_repr_pcpu_stats *stats;
	void *app_priv;
};

enum nfp_app_id {
	NFP_APP_CORE_NIC = 1,
	NFP_APP_BPF_NIC = 2,
	NFP_APP_FLOWER_NIC = 3,
	NFP_APP_ACTIVE_BUFFER_MGMT_NIC = 4,
};

struct nfp_app_type {
	enum nfp_app_id id;
	const char *name;
	u32 ctrl_cap_mask;
	bool ctrl_has_meta;
	int (*init)(struct nfp_app *);
	void (*clean)(struct nfp_app *);
	const char * (*extra_cap)(struct nfp_app *, struct nfp_net *);
	int (*ndo_init)(struct nfp_app *, struct net_device *);
	void (*ndo_uninit)(struct nfp_app *, struct net_device *);
	int (*vnic_alloc)(struct nfp_app *, struct nfp_net *, unsigned int);
	void (*vnic_free)(struct nfp_app *, struct nfp_net *);
	int (*vnic_init)(struct nfp_app *, struct nfp_net *);
	void (*vnic_clean)(struct nfp_app *, struct nfp_net *);
	int (*repr_init)(struct nfp_app *, struct net_device *);
	void (*repr_preclean)(struct nfp_app *, struct net_device *);
	void (*repr_clean)(struct nfp_app *, struct net_device *);
	int (*repr_open)(struct nfp_app *, struct nfp_repr *);
	int (*repr_stop)(struct nfp_app *, struct nfp_repr *);
	int (*check_mtu)(struct nfp_app *, struct net_device *, int);
	int (*repr_change_mtu)(struct nfp_app *, struct net_device *, int);
	u64 * (*port_get_stats)(struct nfp_app *, struct nfp_port *, u64 *);
	int (*port_get_stats_count)(struct nfp_app *, struct nfp_port *);
	u8 * (*port_get_stats_strings)(struct nfp_app *, struct nfp_port *, u8 *);
	int (*start)(struct nfp_app *);
	void (*stop)(struct nfp_app *);
	int (*netdev_event)(struct nfp_app *, struct net_device *, long unsigned int, void *);
	void (*ctrl_msg_rx)(struct nfp_app *, struct sk_buff *);
	void (*ctrl_msg_rx_raw)(struct nfp_app *, const void *, unsigned int);
	int (*setup_tc)(struct nfp_app *, struct net_device *, enum tc_setup_type, void *);
	int (*bpf)(struct nfp_app *, struct nfp_net *, struct netdev_bpf *);
	int (*xdp_offload)(struct nfp_app *, struct nfp_net *, struct bpf_prog *, struct netlink_ext_ack *);
	int (*sriov_enable)(struct nfp_app *, int);
	void (*sriov_disable)(struct nfp_app *);
	enum devlink_eswitch_mode (*eswitch_mode_get)(struct nfp_app *);
	int (*eswitch_mode_set)(struct nfp_app *, u16);
	struct net_device * (*dev_get)(struct nfp_app *, u32, bool *);
};

struct nfp_net_tx_ring;

struct nfp_net_rx_ring;

struct nfp_net_dp {
	struct device *dev;
	struct net_device *netdev;
	u8 is_vf: 1;
	u8 chained_metadata_format: 1;
	u8 ktls_tx: 1;
	u8 rx_dma_dir;
	u8 rx_offset;
	u32 rx_dma_off;
	u32 ctrl;
	u32 fl_bufsz;
	struct bpf_prog *xdp_prog;
	struct nfp_net_tx_ring *tx_rings;
	struct nfp_net_rx_ring *rx_rings;
	u8 *ctrl_bar;
	unsigned int txd_cnt;
	unsigned int rxd_cnt;
	unsigned int num_r_vecs;
	unsigned int num_tx_rings;
	unsigned int num_stack_tx_rings;
	unsigned int num_rx_rings;
	unsigned int mtu;
};

struct nfp_net_fw_version {
	u8 minor;
	u8 major;
	u8 class;
	u8 resv;
};

struct nfp_net_r_vector {
	struct nfp_net *nfp_net;
	union {
		struct napi_struct napi;
		struct {
			struct tasklet_struct tasklet;
			struct sk_buff_head queue;
			spinlock_t lock;
		};
	};
	struct nfp_net_tx_ring *tx_ring;
	struct nfp_net_rx_ring *rx_ring;
	u16 irq_entry;
	struct u64_stats_sync rx_sync;
	u64 rx_pkts;
	u64 rx_bytes;
	u64 rx_drops;
	u64 hw_csum_rx_ok;
	u64 hw_csum_rx_inner_ok;
	u64 hw_csum_rx_complete;
	u64 hw_tls_rx;
	u64 hw_csum_rx_error;
	u64 rx_replace_buf_alloc_fail;
	struct nfp_net_tx_ring *xdp_ring;
	struct u64_stats_sync tx_sync;
	u64 tx_pkts;
	u64 tx_bytes;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u64 hw_csum_tx;
	u64 hw_csum_tx_inner;
	u64 tx_gather;
	u64 tx_lso;
	u64 hw_tls_tx;
	u64 tls_tx_fallback;
	u64 tls_tx_no_fallback;
	u64 tx_errors;
	u64 tx_busy;
	u32 irq_vector;
	irq_handler_t handler;
	char name[24];
	cpumask_t affinity_mask;
};

struct nfp_net_tlv_caps {
	u32 me_freq_mhz;
	unsigned int mbox_off;
	unsigned int mbox_len;
	u32 repr_cap;
	u32 mbox_cmsg_types;
	u32 crypto_ops;
	unsigned int crypto_enable_off;
	unsigned int vnic_stats_off;
	unsigned int vnic_stats_cnt;
	unsigned int tls_resync_ss: 1;
};

struct nfp_net {
	struct nfp_net_dp dp;
	struct nfp_net_fw_version fw_ver;
	u32 id;
	u32 cap;
	u32 max_mtu;
	u8 rss_hfunc;
	u32 rss_cfg;
	u8 rss_key[40];
	u8 rss_itbl[128];
	struct xdp_attachment_info xdp;
	struct xdp_attachment_info xdp_hw;
	unsigned int max_tx_rings;
	unsigned int max_rx_rings;
	int stride_tx;
	int stride_rx;
	unsigned int max_r_vecs;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct nfp_net_r_vector r_vecs[64];
	struct msix_entry irq_entries[66];
	irq_handler_t lsc_handler;
	char lsc_name[24];
	irq_handler_t exn_handler;
	char exn_name[24];
	irq_handler_t shared_handler;
	char shared_name[24];
	u32 me_freq_mhz;
	bool link_up;
	spinlock_t link_status_lock;
	spinlock_t reconfig_lock;
	u32 reconfig_posted;
	bool reconfig_timer_active;
	bool reconfig_sync_present;
	struct timer_list reconfig_timer;
	u32 reconfig_in_progress_update;
	struct semaphore bar_lock;
	u32 rx_coalesce_usecs;
	u32 rx_coalesce_max_frames;
	u32 tx_coalesce_usecs;
	u32 tx_coalesce_max_frames;
	u8 *qcp_cfg;
	u8 *tx_bar;
	u8 *rx_bar;
	struct nfp_net_tlv_caps tlv_caps;
	unsigned int ktls_tx_conn_cnt;
	unsigned int ktls_rx_conn_cnt;
	atomic64_t ktls_conn_id_gen;
	atomic_t ktls_no_space;
	atomic_t ktls_rx_resync_req;
	atomic_t ktls_rx_resync_ign;
	atomic_t ktls_rx_resync_sent;
	struct {
		struct sk_buff_head queue;
		wait_queue_head_t wq;
		struct workqueue_struct *workq;
		struct work_struct wait_work;
		struct work_struct runq_work;
		u16 tag;
	} mbox_cmsg;
	struct dentry *debugfs_dir;
	struct list_head vnic_list;
	struct pci_dev *pdev;
	struct nfp_app *app;
	bool vnic_no_name;
	struct nfp_port *port;
	void *app_priv;
	long: 64;
	long: 64;
	long: 64;
};

struct nfp_net_tx_desc {
	union {
		struct {
			u8 dma_addr_hi;
			__le16 dma_len;
			u8 offset_eop;
			__le32 dma_addr_lo;
			__le16 mss;
			u8 lso_hdrlen;
			u8 flags;
			union {
				struct {
					u8 l3_offset;
					u8 l4_offset;
				};
				__le16 vlan;
			};
			__le16 data_len;
		} __attribute__((packed));
		__le32 vals[4];
		__le64 vals8[2];
	};
};

struct nfp_net_tx_buf {
	union {
		struct sk_buff *skb;
		void *frag;
	};
	dma_addr_t dma_addr;
	short int fidx;
	u16 pkt_cnt;
	u32 real_len;
};

struct nfp_net_tx_ring {
	struct nfp_net_r_vector *r_vec;
	u32 idx;
	int qcidx;
	u8 *qcp_q;
	u32 cnt;
	u32 wr_p;
	u32 rd_p;
	u32 qcp_rd_p;
	u32 wr_ptr_add;
	struct nfp_net_tx_buf *txbufs;
	struct nfp_net_tx_desc *txds;
	dma_addr_t dma;
	size_t size;
	bool is_xdp;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nfp_net_rx_desc {
	union {
		struct {
			u8 dma_addr_hi;
			__le16 reserved;
			u8 meta_len_dd;
			__le32 dma_addr_lo;
		} __attribute__((packed)) fld;
		struct {
			__le16 data_len;
			u8 reserved;
			u8 meta_len_dd;
			__le16 flags;
			__le16 vlan;
		} rxd;
		__le32 vals[2];
	};
};

struct nfp_net_rx_buf {
	void *frag;
	dma_addr_t dma_addr;
};

struct nfp_net_rx_ring {
	struct nfp_net_r_vector *r_vec;
	u32 cnt;
	u32 wr_p;
	u32 rd_p;
	u32 idx;
	int fl_qcidx;
	u8 *qcp_fl;
	struct nfp_net_rx_buf *rxbufs;
	struct nfp_net_rx_desc *rxds;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	dma_addr_t dma;
	size_t size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum nfp_ccm_mbox_tlv_type {
	NFP_NET_MBOX_TLV_TYPE_UNKNOWN = 0,
	NFP_NET_MBOX_TLV_TYPE_END = 1,
	NFP_NET_MBOX_TLV_TYPE_MSG = 2,
	NFP_NET_MBOX_TLV_TYPE_MSG_NOSUP = 3,
	NFP_NET_MBOX_TLV_TYPE_RESV = 4,
};

enum nfp_net_mbox_cmsg_state {
	NFP_NET_MBOX_CMSG_STATE_QUEUED = 0,
	NFP_NET_MBOX_CMSG_STATE_NEXT = 1,
	NFP_NET_MBOX_CMSG_STATE_BUSY = 2,
	NFP_NET_MBOX_CMSG_STATE_REPLY_FOUND = 3,
	NFP_NET_MBOX_CMSG_STATE_DONE = 4,
};

struct nfp_ccm_mbox_cmsg_cb {
	enum nfp_net_mbox_cmsg_state state;
	int err;
	unsigned int max_len;
	unsigned int exp_reply;
	bool posted;
};

enum devlink_param_fw_load_policy_value {
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DRIVER = 0,
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_FLASH = 1,
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DISK = 2,
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_UNKNOWN = 3,
};

enum devlink_param_reset_dev_on_drv_probe_value {
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_UNKNOWN = 0,
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_ALWAYS = 1,
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_NEVER = 2,
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_DISK = 3,
};

struct nfp_dumpspec {
	u32 size;
	u8 data[0];
};

struct nfp_rtsym_table___2;

struct nfp_hwinfo___2;

struct nfp_shared_buf;

struct nfp_pf {
	struct pci_dev *pdev;
	struct nfp_cpp *cpp;
	struct nfp_app *app;
	struct nfp_cpp_area *data_vnic_bar;
	struct nfp_cpp_area *ctrl_vnic_bar;
	struct nfp_cpp_area *qc_area;
	struct nfp_cpp_area *mac_stats_bar;
	u8 *mac_stats_mem;
	struct nfp_cpp_area *vf_cfg_bar;
	u8 *vf_cfg_mem;
	struct nfp_cpp_area *vfcfg_tbl2_area;
	u8 *vfcfg_tbl2;
	const struct nfp_rtsym *mbox;
	struct msix_entry *irq_entries;
	unsigned int limit_vfs;
	unsigned int num_vfs;
	bool fw_loaded;
	bool unload_fw_on_remove;
	struct nfp_net *ctrl_vnic;
	const struct nfp_mip___2 *mip;
	struct nfp_rtsym_table___2 *rtbl;
	struct nfp_hwinfo___2 *hwinfo;
	struct nfp_dumpspec *dumpspec;
	u32 dump_flag;
	u32 dump_len;
	struct nfp_eth_table *eth_tbl;
	struct nfp_nsp_identify *nspi;
	struct device *hwmon_dev;
	struct dentry *ddir;
	unsigned int max_data_vnics;
	unsigned int num_vnics;
	struct list_head vnics;
	struct list_head ports;
	struct workqueue_struct *wq;
	struct work_struct port_refresh_work;
	struct nfp_shared_buf *shared_bufs;
	unsigned int num_shared_bufs;
	struct mutex lock;
};

struct nfp_devlink_param_u8_arg {
	const char *hwinfo_name;
	const char *default_hi_val;
	int invalid_dl_val;
	u8 hi_to_dl[4];
	u8 dl_to_hi[4];
	u8 max_dl_val;
	u8 max_hi_val;
};

enum immed_width {
	IMMED_WIDTH_ALL = 0,
	IMMED_WIDTH_BYTE = 1,
	IMMED_WIDTH_WORD = 2,
};

enum alu_dst_ab {
	ALU_DST_A = 0,
	ALU_DST_B = 1,
};

struct cmd_tgt_act {
	u8 token;
	u8 tgt_cmd;
};

enum cmd_tgt_map {
	CMD_TGT_READ8 = 0,
	CMD_TGT_WRITE8_SWAP = 1,
	CMD_TGT_WRITE32_SWAP = 2,
	CMD_TGT_READ32 = 3,
	CMD_TGT_READ32_LE = 4,
	CMD_TGT_READ32_SWAP = 5,
	CMD_TGT_READ_LE = 6,
	CMD_TGT_READ_SWAP_LE = 7,
	CMD_TGT_ADD = 8,
	CMD_TGT_ADD_IMM = 9,
	__CMD_TGT_MAP_SIZE = 10,
};

enum nfp_bpf_reg_type {
	NN_REG_GPR_A = 1,
	NN_REG_GPR_B = 2,
	NN_REG_GPR_BOTH = 3,
	NN_REG_NNR = 4,
	NN_REG_XFER = 8,
	NN_REG_IMM = 16,
	NN_REG_NONE = 32,
	NN_REG_LMEM = 64,
};

enum nfp_bpf_lm_mode {
	NN_LM_MOD_NONE = 0,
	NN_LM_MOD_INC = 1,
	NN_LM_MOD_DEC = 2,
};

typedef __u32 swreg;

struct nfp_insn_ur_regs {
	enum alu_dst_ab dst_ab;
	u16 dst;
	u16 areg;
	u16 breg;
	bool swap;
	bool wr_both;
	bool dst_lmextn;
	bool src_lmextn;
};

struct nfp_insn_re_regs {
	enum alu_dst_ab dst_ab;
	u8 dst;
	u8 areg;
	u8 breg;
	bool swap;
	bool wr_both;
	bool i8;
	bool dst_lmextn;
	bool src_lmextn;
};

enum nfp_port_type {
	NFP_PORT_INVALID = 0,
	NFP_PORT_PHYS_PORT = 1,
	NFP_PORT_PF_PORT = 2,
	NFP_PORT_VF_PORT = 3,
};

struct nfp_port {
	struct net_device *netdev;
	enum nfp_port_type type;
	long unsigned int flags;
	long unsigned int tc_offload_cnt;
	struct nfp_app *app;
	struct devlink_port dl_port;
	union {
		struct {
			unsigned int eth_id;
			bool eth_forced;
			struct nfp_eth_table_port *eth_port;
			u8 *eth_stats;
		};
		struct {
			unsigned int pf_id;
			unsigned int vf_id;
			bool pf_split;
			unsigned int pf_split_id;
			u8 *vnic;
		};
	};
	struct list_head port_list;
};

enum nfp_repr_type {
	NFP_REPR_TYPE_PHYS_PORT = 0,
	NFP_REPR_TYPE_PF = 1,
	NFP_REPR_TYPE_VF = 2,
	__NFP_REPR_TYPE_MAX = 3,
};

struct nfp_devlink_versions_simple {
	const char *key;
	const char *hwinfo;
};

struct nfp_devlink_versions {
	enum nfp_nsp_versions id;
	const char *key;
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct nfp_shared_buf {
	__le32 id;
	__le32 size;
	__le16 ingress_pools_count;
	__le16 egress_pools_count;
	__le16 ingress_tc_count;
	__le16 egress_tc_count;
	__le32 pool_size_unit;
};

enum nfp_dump_diag {
	NFP_DUMP_NSP_DIAG = 0,
};

struct nfp_meta_parsed {
	u8 hash_type;
	u8 csum_type;
	u32 hash;
	u32 mark;
	u32 portid;
	__wsum csum;
};

struct nfp_net_rx_hash {
	__be32 hash_type;
	__be32 hash;
};

enum nfp_qcp_ptr {
	NFP_QCP_READ_PTR = 0,
	NFP_QCP_WRITE_PTR = 1,
};

enum nfp_port_flags {
	NFP_PORT_CHANGED = 0,
};

struct nfp_net_tls_resync_req {
	__be32 fw_handle[2];
	__be32 tcp_seq;
	u8 l3_offset;
	u8 l4_offset;
	u8 resv[2];
};

enum nfp_dumpspec_type {
	NFP_DUMPSPEC_TYPE_CPP_CSR = 0,
	NFP_DUMPSPEC_TYPE_XPB_CSR = 1,
	NFP_DUMPSPEC_TYPE_ME_CSR = 2,
	NFP_DUMPSPEC_TYPE_INDIRECT_ME_CSR = 3,
	NFP_DUMPSPEC_TYPE_RTSYM = 4,
	NFP_DUMPSPEC_TYPE_HWINFO = 5,
	NFP_DUMPSPEC_TYPE_FWNAME = 6,
	NFP_DUMPSPEC_TYPE_HWINFO_FIELD = 7,
	NFP_DUMPSPEC_TYPE_PROLOG = 10000,
	NFP_DUMPSPEC_TYPE_ERROR = 10001,
};

struct nfp_dump_tl {
	__be32 type;
	__be32 length;
	char data[0];
};

struct nfp_dumpspec_cpp_isl_id {
	u8 target;
	u8 action;
	u8 token;
	u8 island;
};

struct nfp_dump_common_cpp {
	struct nfp_dumpspec_cpp_isl_id cpp_id;
	__be32 offset;
	__be32 dump_length;
};

struct nfp_dumpspec_csr {
	struct nfp_dump_tl tl;
	struct nfp_dump_common_cpp cpp;
	__be32 register_width;
};

struct nfp_dumpspec_rtsym {
	struct nfp_dump_tl tl;
	char rtsym[0];
};

struct nfp_dump_csr {
	struct nfp_dump_tl tl;
	struct nfp_dump_common_cpp cpp;
	__be32 register_width;
	__be32 error;
	__be32 error_offset;
};

struct nfp_dump_rtsym {
	struct nfp_dump_tl tl;
	struct nfp_dump_common_cpp cpp;
	__be32 error;
	u8 padded_name_length;
	char rtsym[0];
};

struct nfp_dump_prolog {
	struct nfp_dump_tl tl;
	__be32 dump_level;
};

struct nfp_dump_error {
	struct nfp_dump_tl tl;
	__be32 error;
	char padding[4];
	char spec[0];
};

struct nfp_level_size {
	__be32 requested_level;
	u32 total_size;
};

struct nfp_dump_state {
	__be32 requested_level;
	u32 dumped_size;
	u32 buf_size;
	void *p;
};

typedef int (*nfp_tlv_visit)(struct nfp_pf *, struct nfp_dump_tl *, void *);

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

enum {
	SFP_PHYS_ID = 0,
	SFP_PHYS_EXT_ID = 1,
	SFP_CONNECTOR = 2,
	SFP_COMPLIANCE = 3,
	SFP_ENCODING = 11,
	SFP_BR_NOMINAL = 12,
	SFP_RATE_ID = 13,
	SFP_LINK_LEN_SM_KM = 14,
	SFP_LINK_LEN_SM_100M = 15,
	SFP_LINK_LEN_50UM_OM2_10M = 16,
	SFP_LINK_LEN_62_5UM_OM1_10M = 17,
	SFP_LINK_LEN_COPPER_1M = 18,
	SFP_LINK_LEN_50UM_OM4_10M = 18,
	SFP_LINK_LEN_50UM_OM3_10M = 19,
	SFP_VENDOR_NAME = 20,
	SFP_VENDOR_OUI = 37,
	SFP_VENDOR_PN = 40,
	SFP_VENDOR_REV = 56,
	SFP_OPTICAL_WAVELENGTH_MSB = 60,
	SFP_OPTICAL_WAVELENGTH_LSB = 61,
	SFP_CABLE_SPEC = 60,
	SFP_CC_BASE = 63,
	SFP_OPTIONS = 64,
	SFP_BR_MAX = 66,
	SFP_BR_MIN = 67,
	SFP_VENDOR_SN = 68,
	SFP_DATECODE = 84,
	SFP_DIAGMON = 92,
	SFP_ENHOPTS = 93,
	SFP_SFF8472_COMPLIANCE = 94,
	SFP_CC_EXT = 95,
	SFP_PHYS_EXT_ID_SFP = 4,
	SFP_OPTIONS_HIGH_POWER_LEVEL = 8192,
	SFP_OPTIONS_PAGING_A2 = 4096,
	SFP_OPTIONS_RETIMER = 2048,
	SFP_OPTIONS_COOLED_XCVR = 1024,
	SFP_OPTIONS_POWER_DECL = 512,
	SFP_OPTIONS_RX_LINEAR_OUT = 256,
	SFP_OPTIONS_RX_DECISION_THRESH = 128,
	SFP_OPTIONS_TUNABLE_TX = 64,
	SFP_OPTIONS_RATE_SELECT = 32,
	SFP_OPTIONS_TX_DISABLE = 16,
	SFP_OPTIONS_TX_FAULT = 8,
	SFP_OPTIONS_LOS_INVERTED = 4,
	SFP_OPTIONS_LOS_NORMAL = 2,
	SFP_DIAGMON_DDM = 64,
	SFP_DIAGMON_INT_CAL = 32,
	SFP_DIAGMON_EXT_CAL = 16,
	SFP_DIAGMON_RXPWR_AVG = 8,
	SFP_DIAGMON_ADDRMODE = 4,
	SFP_ENHOPTS_ALARMWARN = 128,
	SFP_ENHOPTS_SOFT_TX_DISABLE = 64,
	SFP_ENHOPTS_SOFT_TX_FAULT = 32,
	SFP_ENHOPTS_SOFT_RX_LOS = 16,
	SFP_ENHOPTS_SOFT_RATE_SELECT = 8,
	SFP_ENHOPTS_APP_SELECT_SFF8079 = 4,
	SFP_ENHOPTS_SOFT_RATE_SFF8431 = 2,
	SFP_SFF8472_COMPLIANCE_NONE = 0,
	SFP_SFF8472_COMPLIANCE_REV9_3 = 1,
	SFP_SFF8472_COMPLIANCE_REV9_5 = 2,
	SFP_SFF8472_COMPLIANCE_REV10_2 = 3,
	SFP_SFF8472_COMPLIANCE_REV10_4 = 4,
	SFP_SFF8472_COMPLIANCE_REV11_0 = 5,
	SFP_SFF8472_COMPLIANCE_REV11_3 = 6,
	SFP_SFF8472_COMPLIANCE_REV11_4 = 7,
	SFP_SFF8472_COMPLIANCE_REV12_0 = 8,
};

struct nfp_et_stat {
	char name[32];
	int off;
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	__IFLA_OFFLOAD_XSTATS_MAX = 2,
};

struct nfp_net_vf {
	struct nfp_net *nn;
	struct msix_entry irq_entries[66];
	u8 *q_bar;
	struct dentry *ddir;
};

enum nfp_mbox_cmd {
	NFP_MBOX_NO_CMD = 0,
	NFP_MBOX_POOL_GET = 1,
	NFP_MBOX_POOL_SET = 2,
	NFP_MBOX_PCIE_ABM_ENABLE = 3,
	NFP_MBOX_PCIE_ABM_DISABLE = 4,
};

struct nfp_shared_buf_pool_id {
	__le32 shared_buf;
	__le32 pool;
};

struct nfp_shared_buf_pool_info_get {
	__le32 pool_type;
	__le32 size;
	__le32 threshold_type;
};

struct nfp_shared_buf_pool_info_set {
	struct nfp_shared_buf_pool_id id;
	__le32 size;
	__le32 threshold_type;
};

enum nfp_bpf_cmsg_status {
	CMSG_RC_SUCCESS = 0,
	CMSG_RC_ERR_MAP_FD = 1,
	CMSG_RC_ERR_MAP_NOENT = 2,
	CMSG_RC_ERR_MAP_ERR = 3,
	CMSG_RC_ERR_MAP_PARSE = 4,
	CMSG_RC_ERR_MAP_EXIST = 5,
	CMSG_RC_ERR_MAP_NOMEM = 6,
	CMSG_RC_ERR_MAP_E2BIG = 7,
};

struct cmsg_reply_map_simple {
	struct nfp_ccm_hdr hdr;
	__be32 rc;
};

struct cmsg_req_map_alloc_tbl {
	struct nfp_ccm_hdr hdr;
	__be32 key_size;
	__be32 value_size;
	__be32 max_entries;
	__be32 map_type;
	__be32 map_flags;
};

struct cmsg_reply_map_alloc_tbl {
	struct cmsg_reply_map_simple reply_hdr;
	__be32 tid;
};

struct cmsg_req_map_free_tbl {
	struct nfp_ccm_hdr hdr;
	__be32 tid;
};

struct cmsg_reply_map_free_tbl {
	struct cmsg_reply_map_simple reply_hdr;
	__be32 count;
};

struct cmsg_req_map_op {
	struct nfp_ccm_hdr hdr;
	__be32 tid;
	__be32 count;
	__be32 flags;
	u8 data[0];
};

struct cmsg_reply_map_op {
	struct cmsg_reply_map_simple reply_hdr;
	__be32 count;
	__be32 resv;
	u8 data[0];
};

struct nfp_bpf_cap_adjust_head {
	u32 flags;
	int off_min;
	int off_max;
	int guaranteed_sub;
	int guaranteed_add;
};

struct nfp_app_bpf {
	struct nfp_app *app;
	struct nfp_ccm ccm;
	struct bpf_offload_dev *bpf_dev;
	unsigned int cmsg_key_sz;
	unsigned int cmsg_val_sz;
	unsigned int cmsg_cache_cnt;
	struct list_head map_list;
	unsigned int maps_in_use;
	unsigned int map_elems_in_use;
	struct rhashtable maps_neutral;
	u32 abi_version;
	struct nfp_bpf_cap_adjust_head adjust_head;
	struct {
		u32 types;
		u32 max_maps;
		u32 max_elems;
		u32 max_key_sz;
		u32 max_val_sz;
		u32 max_elem_sz;
	} maps;
	struct {
		u32 map_lookup;
		u32 map_update;
		u32 map_delete;
		u32 perf_event_output;
	} helpers;
	bool pseudo_random;
	bool queue_select;
	bool adjust_tail;
	bool cmsg_multi_ent;
};

struct nfp_bpf_map_word {
	unsigned char type: 4;
	unsigned char non_zero_update: 1;
};

struct nfp_bpf_map {
	struct bpf_offloaded_map *offmap;
	struct nfp_app_bpf *bpf;
	u32 tid;
	spinlock_t cache_lock;
	u32 cache_blockers;
	u32 cache_gen;
	u64 cache_to;
	struct sk_buff *cache;
	struct list_head l;
	struct nfp_bpf_map_word use_map[0];
};

enum tc_clsbpf_command {
	TC_CLSBPF_OFFLOAD = 0,
	TC_CLSBPF_STATS = 1,
};

struct tc_cls_bpf_offload {
	struct flow_cls_common_offload common;
	enum tc_clsbpf_command command;
	struct tcf_exts *exts;
	struct bpf_prog *prog;
	struct bpf_prog *oldprog;
	const char *name;
	bool exts_integrated;
};

enum bpf_cap_tlv_type {
	NFP_BPF_CAP_TYPE_FUNC = 1,
	NFP_BPF_CAP_TYPE_ADJUST_HEAD = 2,
	NFP_BPF_CAP_TYPE_MAPS = 3,
	NFP_BPF_CAP_TYPE_RANDOM = 4,
	NFP_BPF_CAP_TYPE_QUEUE_SELECT = 5,
	NFP_BPF_CAP_TYPE_ADJUST_TAIL = 6,
	NFP_BPF_CAP_TYPE_ABI_VERSION = 7,
	NFP_BPF_CAP_TYPE_CMSG_MULTI_ENT = 8,
};

struct nfp_bpf_cap_tlv_func {
	__le32 func_id;
	__le32 func_addr;
};

struct nfp_bpf_cap_tlv_adjust_head {
	__le32 flags;
	__le32 off_min;
	__le32 off_max;
	__le32 guaranteed_sub;
	__le32 guaranteed_add;
};

struct nfp_bpf_cap_tlv_maps {
	__le32 types;
	__le32 max_maps;
	__le32 max_elems;
	__le32 max_key_sz;
	__le32 max_val_sz;
	__le32 max_elem_sz;
};

struct nfp_bpf_vnic {
	struct bpf_prog *tc_prog;
	unsigned int start_off;
	unsigned int tgt_done;
};

struct cmsg_bpf_event {
	struct nfp_ccm_hdr hdr;
	__be32 cpu_id;
	__be64 map_ptr;
	__be32 data_size;
	__be32 pkt_size;
	u8 data[0];
};

enum nfp_bpf_map_use {
	NFP_MAP_UNUSED = 0,
	NFP_MAP_USE_READ = 1,
	NFP_MAP_USE_WRITE = 2,
	NFP_MAP_USE_ATOMIC_CNT = 3,
};

struct nfp_bpf_neutral_map {
	struct rhash_head l;
	struct bpf_map *ptr;
	u32 map_id;
	u32 count;
};

struct nfp_prog;

struct nfp_insn_meta;

typedef int (*instr_cb_t)(struct nfp_prog *, struct nfp_insn_meta *);

struct nfp_bpf_subprog_info;

struct nfp_prog {
	struct nfp_app_bpf *bpf;
	u64 *prog;
	unsigned int prog_len;
	unsigned int __prog_alloc_len;
	unsigned int stack_size;
	struct nfp_insn_meta *verifier_meta;
	enum bpf_prog_type type;
	unsigned int last_bpf_off;
	unsigned int tgt_out;
	unsigned int tgt_abort;
	unsigned int tgt_call_push_regs;
	unsigned int tgt_call_pop_regs;
	unsigned int n_translated;
	int error;
	unsigned int stack_frame_depth;
	unsigned int adjust_head_location;
	unsigned int map_records_cnt;
	unsigned int subprog_cnt;
	struct nfp_bpf_neutral_map **map_records;
	struct nfp_bpf_subprog_info *subprog;
	unsigned int n_insns;
	struct list_head insns;
};

struct nfp_bpf_reg_state {
	struct bpf_reg_state reg;
	bool var_off;
};

struct nfp_insn_meta {
	struct bpf_insn insn;
	union {
		struct {
			struct bpf_reg_state ptr;
			struct bpf_insn *paired_st;
			s16 ldst_gather_len;
			bool ptr_not_const;
			struct {
				s16 range_start;
				s16 range_end;
				bool do_init;
			} pkt_cache;
			bool xadd_over_16bit;
			bool xadd_maybe_16bit;
		};
		struct {
			struct nfp_insn_meta *jmp_dst;
			bool jump_neg_op;
			u32 num_insns_after_br;
		};
		struct {
			u32 func_id;
			struct bpf_reg_state arg1;
			struct nfp_bpf_reg_state arg2;
		};
		struct {
			u64 umin_src;
			u64 umax_src;
			u64 umin_dst;
			u64 umax_dst;
		};
	};
	unsigned int off;
	short unsigned int n;
	short unsigned int flags;
	short unsigned int subprog_idx;
	instr_cb_t double_cb;
	struct list_head l;
};

struct nfp_bpf_subprog_info {
	u16 stack_depth;
	u8 needs_reg_push: 1;
};

enum br_mask {
	BR_BEQ = 0,
	BR_BNE = 1,
	BR_BMI = 2,
	BR_BHS = 4,
	BR_BCC = 5,
	BR_BLO = 5,
	BR_BGE = 8,
	BR_BLT = 9,
	BR_UNC = 24,
};

enum br_ev_pip {
	BR_EV_PIP_UNCOND = 0,
	BR_EV_PIP_COND = 1,
};

enum br_ctx_signal_state {
	BR_CSS_NONE = 2,
};

enum immed_shift {
	IMMED_SHIFT_0B = 0,
	IMMED_SHIFT_1B = 1,
	IMMED_SHIFT_2B = 2,
};

enum shf_op {
	SHF_OP_NONE = 0,
	SHF_OP_AND = 2,
	SHF_OP_OR = 5,
	SHF_OP_ASHR = 6,
};

enum shf_sc {
	SHF_SC_R_ROT = 0,
	SHF_SC_NONE = 0,
	SHF_SC_R_SHF = 1,
	SHF_SC_L_SHF = 2,
	SHF_SC_R_DSHF = 3,
};

enum alu_op {
	ALU_OP_NONE = 0,
	ALU_OP_ADD = 1,
	ALU_OP_NOT = 4,
	ALU_OP_ADD_2B = 5,
	ALU_OP_AND = 8,
	ALU_OP_AND_NOT_A = 12,
	ALU_OP_SUB_C = 13,
	ALU_OP_AND_NOT_B = 16,
	ALU_OP_ADD_C = 17,
	ALU_OP_OR = 20,
	ALU_OP_SUB = 21,
	ALU_OP_XOR = 24,
};

enum cmd_mode {
	CMD_MODE_40b_AB = 0,
	CMD_MODE_40b_BA = 1,
	CMD_MODE_32b = 4,
};

enum cmd_ctx_swap {
	CMD_CTX_SWAP = 0,
	CMD_CTX_SWAP_DEFER1 = 1,
	CMD_CTX_SWAP_DEFER2 = 2,
	CMD_CTX_NO_SWAP = 3,
};

enum mul_type {
	MUL_TYPE_START = 0,
	MUL_TYPE_STEP_24x8 = 1,
	MUL_TYPE_STEP_16x16 = 2,
	MUL_TYPE_STEP_32x32 = 3,
};

enum mul_step {
	MUL_STEP_1 = 0,
	MUL_STEP_NONE = 0,
	MUL_STEP_2 = 1,
	MUL_STEP_3 = 2,
	MUL_STEP_4 = 3,
	MUL_LAST = 4,
	MUL_LAST_2 = 5,
};

enum nfp_relo_type {
	RELO_NONE = 0,
	RELO_BR_REL = 1,
	RELO_BR_GO_OUT = 2,
	RELO_BR_GO_ABORT = 3,
	RELO_BR_GO_CALL_PUSH_REGS = 4,
	RELO_BR_GO_CALL_POP_REGS = 5,
	RELO_BR_NEXT_PKT = 6,
	RELO_BR_HELPER = 7,
	RELO_IMMED_REL = 8,
};

enum static_regs {
	STATIC_REG_IMMA = 20,
	STATIC_REG_IMM = 21,
	STATIC_REG_STACK = 22,
	STATIC_REG_PKT_LEN = 22,
};

enum pkt_vec {
	PKT_VEC_PKT_LEN = 0,
	PKT_VEC_PKT_PTR = 2,
	PKT_VEC_QSEL_SET = 4,
	PKT_VEC_QSEL_VAL = 6,
};

typedef int (*lmem_step)(struct nfp_prog *, u8, u8, s32, unsigned int, bool, bool, bool, bool, bool);

struct jmp_code_map {
	enum br_mask br_mask;
	bool swap;
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct nsim_sa {
	struct xfrm_state *xs;
	__be32 ipaddr[4];
	u32 key[4];
	u32 salt;
	bool used;
	bool crypt;
	bool rx;
};

struct nsim_ipsec {
	struct nsim_sa sa[33];
	struct dentry *pfile;
	u32 count;
	u32 tx;
	u32 ok;
};

struct nsim_ethtool {
	bool rx;
	bool tx;
	bool report_stats_rx;
	bool report_stats_tx;
};

struct nsim_dev;

struct nsim_dev_port;

struct nsim_bus_dev;

struct netdevsim {
	struct net_device *netdev;
	struct nsim_dev *nsim_dev;
	struct nsim_dev_port *nsim_dev_port;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
	struct nsim_bus_dev *nsim_bus_dev;
	struct bpf_prog *bpf_offloaded;
	u32 bpf_offloaded_id;
	struct xdp_attachment_info xdp;
	struct xdp_attachment_info xdp_hw;
	bool bpf_tc_accept;
	bool bpf_tc_non_bound_accept;
	bool bpf_xdpdrv_accept;
	bool bpf_xdpoffload_accept;
	bool bpf_map_accept;
	struct nsim_ipsec ipsec;
	struct {
		u32 inject_error;
		u32 sleep;
		u32 __ports[8];
		u32 (*ports)[4];
		struct debugfs_u32_array dfs_ports[2];
	} udp_ports;
	struct nsim_ethtool ethtool;
};

struct nsim_fib_data;

struct devlink_health_reporter;

struct nsim_dev_health {
	struct devlink_health_reporter *empty_reporter;
	struct devlink_health_reporter *dummy_reporter;
	struct dentry *ddir;
	char *recovered_break_msg;
	u32 binary_len;
	bool fail_recover;
};

struct nsim_trap_data;

struct nsim_dev {
	struct nsim_bus_dev *nsim_bus_dev;
	struct nsim_fib_data *fib_data;
	struct nsim_trap_data *trap_data;
	struct dentry *ddir;
	struct dentry *ports_ddir;
	struct dentry *take_snapshot;
	struct bpf_offload_dev *bpf_dev;
	bool bpf_bind_accept;
	u32 bpf_bind_verifier_delay;
	struct dentry *ddir_bpf_bound_progs;
	u32 prog_id_gen;
	struct list_head bpf_bound_progs;
	struct list_head bpf_bound_maps;
	struct netdev_phys_item_id switch_id;
	struct list_head port_list;
	struct mutex port_list_lock;
	bool fw_update_status;
	u32 fw_update_overwrite_mask;
	u32 max_macs;
	bool test1;
	bool dont_allow_reload;
	bool fail_reload;
	struct devlink_region *dummy_region;
	struct nsim_dev_health health;
	struct flow_action_cookie *fa_cookie;
	spinlock_t fa_cookie_lock;
	bool fail_trap_group_set;
	bool fail_trap_policer_set;
	bool fail_trap_policer_counter_get;
	struct {
		struct udp_tunnel_nic_shared utn_shared;
		u32 __ports[8];
		bool sync_all;
		bool open_only;
		bool ipv4_only;
		bool shared;
		bool static_iana_vxlan;
		u32 sleep;
	} udp_ports;
};

struct nsim_dev_port {
	struct list_head list;
	struct devlink_port devlink_port;
	unsigned int port_index;
	struct dentry *ddir;
	struct netdevsim *ns;
};

struct nsim_vf_config;

struct nsim_bus_dev {
	struct device dev;
	struct list_head list;
	unsigned int port_count;
	struct net *initial_net;
	unsigned int num_vfs;
	struct nsim_vf_config *vfconfigs;
	struct mutex nsim_bus_reload_lock;
	bool init;
};

struct nsim_vf_config {
	int link_state;
	u16 min_tx_rate;
	u16 max_tx_rate;
	u16 vlan;
	__be16 vlan_proto;
	u16 qos;
	u8 vf_mac[6];
	bool spoofchk_enabled;
	bool trusted;
	bool rss_query_enabled;
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
	DEVLINK_TRAP_GENERIC_ID_STP = 29,
	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 90,
	DEVLINK_TRAP_GENERIC_ID_MAX = 89,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 25,
};

enum nsim_resource_id {
	NSIM_RESOURCE_NONE = 0,
	NSIM_RESOURCE_IPV4 = 1,
	NSIM_RESOURCE_IPV4_FIB = 2,
	NSIM_RESOURCE_IPV4_FIB_RULES = 3,
	NSIM_RESOURCE_IPV6 = 4,
	NSIM_RESOURCE_IPV6_FIB = 5,
	NSIM_RESOURCE_IPV6_FIB_RULES = 6,
	NSIM_RESOURCE_NEXTHOPS = 7,
};

struct nsim_trap_item;

struct nsim_trap_data {
	struct delayed_work trap_report_dw;
	struct nsim_trap_item *trap_items_arr;
	u64 *trap_policers_cnt_arr;
	struct nsim_dev *nsim_dev;
	spinlock_t trap_lock;
};

enum nsim_devlink_param_id {
	NSIM_DEVLINK_PARAM_ID_BASE = 10,
	NSIM_DEVLINK_PARAM_ID_TEST1 = 11,
};

struct nsim_trap_item {
	void *trap_ctx;
	enum devlink_trap_action action;
};

enum {
	NSIM_TRAP_ID_BASE = 89,
	NSIM_TRAP_ID_FID_MISS = 90,
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	u8 tos;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 6;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	u8 tos;
	u8 type;
	u32 tb_id;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct nsim_fib_entry {
	u64 max;
	u64 num;
};

struct nsim_per_fib_data {
	struct nsim_fib_entry fib;
	struct nsim_fib_entry rules;
};

struct nsim_fib_data___2 {
	struct notifier_block fib_nb;
	struct nsim_per_fib_data ipv4;
	struct nsim_per_fib_data ipv6;
	struct nsim_fib_entry nexthops;
	struct rhashtable fib_rt_ht;
	struct list_head fib_rt_list;
	spinlock_t fib_lock;
	struct notifier_block nexthop_nb;
	struct rhashtable nexthop_ht;
	struct devlink *devlink;
};

struct nsim_fib_rt_key {
	unsigned char addr[16];
	unsigned char prefix_len;
	int family;
	u32 tb_id;
};

struct nsim_fib_rt {
	struct nsim_fib_rt_key key;
	struct rhash_head ht_node;
	struct list_head list;
};

struct nsim_fib4_rt {
	struct nsim_fib_rt common;
	struct fib_info *fi;
	u8 tos;
	u8 type;
};

struct nsim_fib6_rt {
	struct nsim_fib_rt common;
	struct list_head nh_list;
	unsigned int nhs;
};

struct nsim_fib6_rt_nh {
	struct list_head list;
	struct fib6_info *rt;
};

struct nsim_nexthop {
	struct rhash_head ht_node;
	u64 occ;
	u32 id;
};

struct devlink_fmsg;

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
};

struct nsim_dev_dummy_reporter_ctx {
	char *break_msg;
};

struct nsim_bpf_bound_prog {
	struct nsim_dev *nsim_dev;
	struct bpf_prog *prog;
	struct dentry *ddir;
	const char *state;
	bool is_loaded;
	struct list_head l;
};

struct nsim_map_entry {
	void *key;
	void *value;
};

struct nsim_bpf_bound_map {
	struct netdevsim *ns;
	struct bpf_offloaded_map *map;
	struct mutex mutex;
	struct nsim_map_entry entry[2];
	struct list_head l;
};

struct netpoll_info {
	refcount_t refcnt;
	struct semaphore dev_lock;
	struct sk_buff_head txq;
	struct delayed_work tx_work;
	struct netpoll *netpoll;
	struct callback_head rcu;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

union inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct netpoll {
	struct net_device *dev;
	char dev_name[16];
	const char *name;
	union inet_addr local_ip;
	union inet_addr remote_ip;
	bool ipv6;
	u16 local_port;
	u16 remote_port;
	u8 remote_mac[6];
};

struct net_failover_info {
	struct net_device *primary_dev;
	struct net_device *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
};

typedef unsigned char U8;

typedef short unsigned int U16___2;

typedef u_int32_t U32___2;

struct _U64 {
	U32___2 Low;
	U32___2 High;
};

typedef struct _U64 U64___2;

struct _SGE_SIMPLE32 {
	U32___2 FlagsLength;
	U32___2 Address;
};

typedef struct _SGE_SIMPLE32 SGESimple32_t;

struct _SGE_SIMPLE64 {
	U32___2 FlagsLength;
	U64___2 Address;
};

typedef struct _SGE_SIMPLE64 SGESimple64_t;

struct _SGE_SIMPLE_UNION {
	U32___2 FlagsLength;
	union {
		U32___2 Address32;
		U64___2 Address64;
	} u;
};

typedef struct _SGE_SIMPLE_UNION SGE_SIMPLE_UNION;

struct _SGE_CHAIN32 {
	U16___2 Length;
	U8 NextChainOffset;
	U8 Flags;
	U32___2 Address;
};

typedef struct _SGE_CHAIN32 SGEChain32_t;

struct _SGE_CHAIN64 {
	U16___2 Length;
	U8 NextChainOffset;
	U8 Flags;
	U64___2 Address;
};

typedef struct _SGE_CHAIN64 SGEChain64_t;

struct _SGE_CHAIN_UNION {
	U16___2 Length;
	U8 NextChainOffset;
	U8 Flags;
	union {
		U32___2 Address32;
		U64___2 Address64;
	} u;
};

typedef struct _SGE_CHAIN_UNION SGE_CHAIN_UNION;

struct _SGE_TRANSACTION_UNION {
	U8 Reserved;
	U8 ContextSize;
	U8 DetailsLength;
	U8 Flags;
	union {
		U32___2 TransactionContext32[1];
		U32___2 TransactionContext64[2];
		U32___2 TransactionContext96[3];
		U32___2 TransactionContext128[4];
	} u;
	U32___2 TransactionDetails[1];
};

typedef struct _SGE_TRANSACTION_UNION SGE_TRANSACTION_UNION;

struct _SGE_IO_UNION {
	union {
		SGE_SIMPLE_UNION Simple;
		SGE_CHAIN_UNION Chain;
	} u;
};

typedef struct _SGE_IO_UNION SGE_IO_UNION;

struct _SGE_MPI_UNION {
	union {
		SGE_SIMPLE_UNION Simple;
		SGE_CHAIN_UNION Chain;
		SGE_TRANSACTION_UNION Transaction;
	} u;
};

typedef struct _SGE_MPI_UNION SGE_MPI_UNION;

struct _MSG_REQUEST_HEADER {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_REQUEST_HEADER MPIHeader_t;

struct _MSG_DEFAULT_REPLY {
	U8 Reserved[2];
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
};

typedef struct _MSG_DEFAULT_REPLY MPIDefaultReply_t;

struct _MSG_IOC_INIT {
	U8 WhoInit;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Flags;
	U8 MaxDevices;
	U8 MaxBuses;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 ReplyFrameSize;
	U8 Reserved1[2];
	U32___2 HostMfaHighAddr;
	U32___2 SenseBufferHighAddr;
	U32___2 ReplyFifoHostSignalingAddr;
	SGE_SIMPLE_UNION HostPageBufferSGE;
	U16___2 MsgVersion;
	U16___2 HeaderVersion;
};

typedef struct _MSG_IOC_INIT IOCInit_t;

typedef struct _MSG_IOC_INIT *pIOCInit_t;

struct _MSG_IOC_FACTS {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_IOC_FACTS IOCFacts_t;

struct _MPI_FW_VERSION_STRUCT {
	U8 Dev;
	U8 Unit;
	U8 Minor;
	U8 Major;
};

typedef struct _MPI_FW_VERSION_STRUCT MPI_FW_VERSION_STRUCT;

union _MPI_FW_VERSION {
	MPI_FW_VERSION_STRUCT Struct;
	U32___2 Word;
};

typedef union _MPI_FW_VERSION MPI_FW_VERSION;

struct _MSG_IOC_FACTS_REPLY {
	U16___2 MsgVersion;
	U8 MsgLength;
	U8 Function;
	U16___2 HeaderVersion;
	U8 IOCNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 IOCExceptions;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U8 MaxChainDepth;
	U8 WhoInit;
	U8 BlockSize;
	U8 Flags;
	U16___2 ReplyQueueDepth;
	U16___2 RequestFrameSize;
	U16___2 Reserved_0101_FWVersion;
	U16___2 ProductID;
	U32___2 CurrentHostMfaHighAddr;
	U16___2 GlobalCredits;
	U8 NumberOfPorts;
	U8 EventState;
	U32___2 CurrentSenseBufferHighAddr;
	U16___2 CurReplyFrameSize;
	U8 MaxDevices;
	U8 MaxBuses;
	U32___2 FWImageSize;
	U32___2 IOCCapabilities;
	MPI_FW_VERSION FWVersion;
	U16___2 HighPriorityQueueDepth;
	U16___2 Reserved2;
	SGE_SIMPLE_UNION HostPageBufferSGE;
	U32___2 ReplyFifoHostSignalingAddr;
};

typedef struct _MSG_IOC_FACTS_REPLY IOCFactsReply_t;

struct _MSG_PORT_FACTS {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[2];
	U8 PortNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_PORT_FACTS PortFacts_t;

struct _MSG_PORT_FACTS_REPLY {
	U16___2 Reserved;
	U8 MsgLength;
	U8 Function;
	U16___2 Reserved1;
	U8 PortNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved2;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U8 Reserved3;
	U8 PortType;
	U16___2 MaxDevices;
	U16___2 PortSCSIID;
	U16___2 ProtocolFlags;
	U16___2 MaxPostedCmdBuffers;
	U16___2 MaxPersistentIDs;
	U16___2 MaxLanBuckets;
	U8 MaxInitiators;
	U8 Reserved4;
	U32___2 Reserved5;
};

typedef struct _MSG_PORT_FACTS_REPLY PortFactsReply_t;

struct _MSG_PORT_ENABLE {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[2];
	U8 PortNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_PORT_ENABLE PortEnable_t;

struct _MSG_EVENT_NOTIFY {
	U8 Switch;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_EVENT_NOTIFY EventNotification_t;

struct _MSG_EVENT_NOTIFY_REPLY {
	U16___2 EventDataLength;
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[2];
	U8 AckRequired;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 Event;
	U32___2 EventContext;
	U32___2 Data[1];
};

typedef struct _MSG_EVENT_NOTIFY_REPLY EventNotificationReply_t;

struct _MSG_EVENT_ACK {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 Event;
	U32___2 EventContext;
};

typedef struct _MSG_EVENT_ACK EventAck_t;

struct _EVENT_DATA_RAID {
	U8 VolumeID;
	U8 VolumeBus;
	U8 ReasonCode;
	U8 PhysDiskNum;
	U8 ASC;
	U8 ASCQ;
	U16___2 Reserved;
	U32___2 SettingsStatus;
};

typedef struct _EVENT_DATA_RAID MpiEventDataRaid_t;

struct _MSG_FW_UPLOAD {
	U8 ImageType;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	SGE_MPI_UNION SGL;
};

typedef struct _MSG_FW_UPLOAD FWUpload_t;

struct _FWUploadTCSGE {
	U8 Reserved;
	U8 ContextSize;
	U8 DetailsLength;
	U8 Flags;
	U32___2 Reserved1;
	U32___2 ImageOffset;
	U32___2 ImageSize;
};

typedef struct _FWUploadTCSGE FWUploadTCSGE_t;

struct _MSG_FW_UPLOAD_REPLY {
	U8 ImageType;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved2;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 ActualImageSize;
};

typedef struct _MSG_FW_UPLOAD_REPLY FWUploadReply_t;

struct _MPI_FW_HEADER {
	U32___2 ArmBranchInstruction0;
	U32___2 Signature0;
	U32___2 Signature1;
	U32___2 Signature2;
	U32___2 ArmBranchInstruction1;
	U32___2 ArmBranchInstruction2;
	U32___2 Reserved;
	U32___2 Checksum;
	U16___2 VendorId;
	U16___2 ProductId;
	MPI_FW_VERSION FWVersion;
	U32___2 SeqCodeVersion;
	U32___2 ImageSize;
	U32___2 NextImageHeaderOffset;
	U32___2 LoadStartAddress;
	U32___2 IopResetVectorValue;
	U32___2 IopResetRegAddr;
	U32___2 VersionNameWhat;
	U8 VersionName[32];
	U32___2 VendorNameWhat;
	U8 VendorName[32];
};

typedef struct _MPI_FW_HEADER MpiFwHeader_t;

struct _MPI_EXT_IMAGE_HEADER {
	U8 ImageType;
	U8 Reserved;
	U16___2 Reserved1;
	U32___2 Checksum;
	U32___2 ImageSize;
	U32___2 NextImageHeaderOffset;
	U32___2 LoadStartAddress;
	U32___2 Reserved2;
};

typedef struct _MPI_EXT_IMAGE_HEADER MpiExtImageHeader_t;

struct _CONFIG_PAGE_HEADER {
	U8 PageVersion;
	U8 PageLength;
	U8 PageNumber;
	U8 PageType;
};

typedef struct _CONFIG_PAGE_HEADER CONFIG_PAGE_HEADER;

typedef struct _CONFIG_PAGE_HEADER ConfigPageHeader_t;

struct _CONFIG_EXTENDED_PAGE_HEADER {
	U8 PageVersion;
	U8 Reserved1;
	U8 PageNumber;
	U8 PageType;
	U16___2 ExtPageLength;
	U8 ExtPageType;
	U8 Reserved2;
};

typedef struct _CONFIG_EXTENDED_PAGE_HEADER CONFIG_EXTENDED_PAGE_HEADER;

typedef struct _CONFIG_EXTENDED_PAGE_HEADER ConfigExtendedPageHeader_t;

struct _MSG_CONFIG {
	U8 Action;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U16___2 ExtPageLength;
	U8 ExtPageType;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[8];
	CONFIG_PAGE_HEADER Header;
	U32___2 PageAddress;
	SGE_IO_UNION PageBufferSGE;
};

typedef struct _MSG_CONFIG Config_t;

struct _MSG_CONFIG_REPLY {
	U8 Action;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U16___2 ExtPageLength;
	U8 ExtPageType;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	CONFIG_PAGE_HEADER Header;
};

typedef struct _MSG_CONFIG_REPLY ConfigReply_t;

struct _CONFIG_PAGE_MANUFACTURING_0 {
	CONFIG_PAGE_HEADER Header;
	U8 ChipName[16];
	U8 ChipRevision[8];
	U8 BoardName[16];
	U8 BoardAssembly[16];
	U8 BoardTracerNumber[16];
};

typedef struct _CONFIG_PAGE_MANUFACTURING_0 ManufacturingPage0_t;

struct _MPI_ADAPTER_INFO {
	U8 PciBusNumber;
	U8 PciDeviceAndFunctionNumber;
	U16___2 AdapterFlags;
};

typedef struct _MPI_ADAPTER_INFO MPI_ADAPTER_INFO;

struct _CONFIG_PAGE_IO_UNIT_2 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U32___2 BiosVersion;
	MPI_ADAPTER_INFO AdapterOrder[4];
	U32___2 Reserved1;
};

typedef struct _CONFIG_PAGE_IO_UNIT_2 IOUnitPage2_t;

struct _CONFIG_PAGE_IOC_1 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U32___2 CoalescingTimeout;
	U8 CoalescingDepth;
	U8 PCISlotNum;
	U8 Reserved[2];
};

typedef struct _CONFIG_PAGE_IOC_1 IOCPage1_t;

struct _CONFIG_PAGE_IOC_2_RAID_VOL {
	U8 VolumeID;
	U8 VolumeBus;
	U8 VolumeIOC;
	U8 VolumePageNumber;
	U8 VolumeType;
	U8 Flags;
	U16___2 Reserved3;
};

typedef struct _CONFIG_PAGE_IOC_2_RAID_VOL CONFIG_PAGE_IOC_2_RAID_VOL;

struct _CONFIG_PAGE_IOC_2 {
	CONFIG_PAGE_HEADER Header;
	U32___2 CapabilitiesFlags;
	U8 NumActiveVolumes;
	U8 MaxVolumes;
	U8 NumActivePhysDisks;
	U8 MaxPhysDisks;
	CONFIG_PAGE_IOC_2_RAID_VOL RaidVolume[1];
};

typedef struct _CONFIG_PAGE_IOC_2 IOCPage2_t;

struct _IOC_3_PHYS_DISK {
	U8 PhysDiskID;
	U8 PhysDiskBus;
	U8 PhysDiskIOC;
	U8 PhysDiskNum;
};

typedef struct _IOC_3_PHYS_DISK IOC_3_PHYS_DISK;

struct _CONFIG_PAGE_IOC_3 {
	CONFIG_PAGE_HEADER Header;
	U8 NumPhysDisks;
	U8 Reserved1;
	U16___2 Reserved2;
	IOC_3_PHYS_DISK PhysDisk[1];
};

typedef struct _CONFIG_PAGE_IOC_3 IOCPage3_t;

struct _IOC_4_SEP {
	U8 SEPTargetID;
	U8 SEPBus;
	U16___2 Reserved;
};

typedef struct _IOC_4_SEP IOC_4_SEP;

struct _CONFIG_PAGE_IOC_4 {
	CONFIG_PAGE_HEADER Header;
	U8 ActiveSEP;
	U8 MaxSEP;
	U16___2 Reserved1;
	IOC_4_SEP SEP[1];
};

typedef struct _CONFIG_PAGE_IOC_4 IOCPage4_t;

struct _CONFIG_PAGE_SCSI_PORT_0 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Capabilities;
	U32___2 PhysicalInterface;
};

typedef struct _CONFIG_PAGE_SCSI_PORT_0 SCSIPortPage0_t;

struct _MPI_DEVICE_INFO {
	U8 Timeout;
	U8 SyncFactor;
	U16___2 DeviceFlags;
};

typedef struct _MPI_DEVICE_INFO MPI_DEVICE_INFO;

typedef struct _MPI_DEVICE_INFO MpiDeviceInfo_t;

struct _CONFIG_PAGE_SCSI_PORT_2 {
	CONFIG_PAGE_HEADER Header;
	U32___2 PortFlags;
	U32___2 PortSettings;
	MPI_DEVICE_INFO DeviceSettings[16];
};

typedef struct _CONFIG_PAGE_SCSI_PORT_2 SCSIPortPage2_t;

struct _CONFIG_PAGE_FC_PORT_0 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U8 MPIPortNumber;
	U8 LinkType;
	U8 PortState;
	U8 Reserved;
	U32___2 PortIdentifier;
	U64___2 WWNN;
	U64___2 WWPN;
	U32___2 SupportedServiceClass;
	U32___2 SupportedSpeeds;
	U32___2 CurrentSpeed;
	U32___2 MaxFrameSize;
	U64___2 FabricWWNN;
	U64___2 FabricWWPN;
	U32___2 DiscoveredPortsCount;
	U32___2 MaxInitiators;
	U8 MaxAliasesSupported;
	U8 MaxHardAliasesSupported;
	U8 NumCurrentAliases;
	U8 Reserved1;
};

typedef struct _CONFIG_PAGE_FC_PORT_0 FCPortPage0_t;

struct _CONFIG_PAGE_FC_PORT_1 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U64___2 NoSEEPROMWWNN;
	U64___2 NoSEEPROMWWPN;
	U8 HardALPA;
	U8 LinkConfig;
	U8 TopologyConfig;
	U8 AltConnector;
	U8 NumRequestedAliases;
	U8 RR_TOV;
	U8 InitiatorDeviceTimeout;
	U8 InitiatorIoPendTimeout;
};

typedef struct _CONFIG_PAGE_FC_PORT_1 FCPortPage1_t;

struct _RAID_VOL0_PHYS_DISK {
	U16___2 Reserved;
	U8 PhysDiskMap;
	U8 PhysDiskNum;
};

typedef struct _RAID_VOL0_PHYS_DISK RAID_VOL0_PHYS_DISK;

struct _RAID_VOL0_STATUS {
	U8 Flags;
	U8 State;
	U16___2 Reserved;
};

typedef struct _RAID_VOL0_STATUS RAID_VOL0_STATUS;

struct _RAID_VOL0_SETTINGS {
	U16___2 Settings;
	U8 HotSparePool;
	U8 Reserved;
};

typedef struct _RAID_VOL0_SETTINGS RAID_VOL0_SETTINGS;

struct _CONFIG_PAGE_RAID_VOL_0 {
	CONFIG_PAGE_HEADER Header;
	U8 VolumeID;
	U8 VolumeBus;
	U8 VolumeIOC;
	U8 VolumeType;
	RAID_VOL0_STATUS VolumeStatus;
	RAID_VOL0_SETTINGS VolumeSettings;
	U32___2 MaxLBA;
	U32___2 MaxLBAHigh;
	U32___2 StripeSize;
	U32___2 Reserved2;
	U32___2 Reserved3;
	U8 NumPhysDisks;
	U8 DataScrubRate;
	U8 ResyncRate;
	U8 InactiveStatus;
	RAID_VOL0_PHYS_DISK PhysDisk[1];
};

typedef struct _CONFIG_PAGE_RAID_VOL_0 *pRaidVolumePage0_t;

struct _RAID_PHYS_DISK0_ERROR_DATA {
	U8 ErrorCdbByte;
	U8 ErrorSenseKey;
	U16___2 Reserved;
	U16___2 ErrorCount;
	U8 ErrorASC;
	U8 ErrorASCQ;
	U16___2 SmartCount;
	U8 SmartASC;
	U8 SmartASCQ;
};

typedef struct _RAID_PHYS_DISK0_ERROR_DATA RAID_PHYS_DISK0_ERROR_DATA;

struct _RAID_PHYS_DISK_INQUIRY_DATA {
	U8 VendorID[8];
	U8 ProductID[16];
	U8 ProductRevLevel[4];
	U8 Info[32];
};

typedef struct _RAID_PHYS_DISK_INQUIRY_DATA RAID_PHYS_DISK0_INQUIRY_DATA;

struct _RAID_PHYS_DISK0_SETTINGS {
	U8 SepID;
	U8 SepBus;
	U8 HotSparePool;
	U8 PhysDiskSettings;
};

typedef struct _RAID_PHYS_DISK0_SETTINGS RAID_PHYS_DISK0_SETTINGS;

struct _RAID_PHYS_DISK0_STATUS {
	U8 Flags;
	U8 State;
	U16___2 Reserved;
};

typedef struct _RAID_PHYS_DISK0_STATUS RAID_PHYS_DISK0_STATUS;

struct _CONFIG_PAGE_RAID_PHYS_DISK_0 {
	CONFIG_PAGE_HEADER Header;
	U8 PhysDiskID;
	U8 PhysDiskBus;
	U8 PhysDiskIOC;
	U8 PhysDiskNum;
	RAID_PHYS_DISK0_SETTINGS PhysDiskSettings;
	U32___2 Reserved1;
	U8 ExtDiskIdentifier[8];
	U8 DiskIdentifier[16];
	RAID_PHYS_DISK0_INQUIRY_DATA InquiryData;
	RAID_PHYS_DISK0_STATUS PhysDiskStatus;
	U32___2 MaxLBA;
	RAID_PHYS_DISK0_ERROR_DATA ErrorData;
};

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0 RaidPhysDiskPage0_t;

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0 *pRaidPhysDiskPage0_t;

struct _RAID_PHYS_DISK1_PATH {
	U8 PhysDiskID;
	U8 PhysDiskBus;
	U16___2 Reserved1;
	U64___2 WWID;
	U64___2 OwnerWWID;
	U8 OwnerIdentifier;
	U8 Reserved2;
	U16___2 Flags;
};

typedef struct _RAID_PHYS_DISK1_PATH RAID_PHYS_DISK1_PATH;

struct _CONFIG_PAGE_RAID_PHYS_DISK_1 {
	CONFIG_PAGE_HEADER Header;
	U8 NumPhysDiskPaths;
	U8 PhysDiskNum;
	U16___2 Reserved2;
	U32___2 Reserved1;
	RAID_PHYS_DISK1_PATH Path[1];
};

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_1 RaidPhysDiskPage1_t;

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_1 *pRaidPhysDiskPage1_t;

struct _CONFIG_PAGE_LAN_0 {
	ConfigPageHeader_t Header;
	U16___2 TxRxModes;
	U16___2 Reserved;
	U32___2 PacketPrePad;
};

typedef struct _CONFIG_PAGE_LAN_0 LANPage0_t;

struct _CONFIG_PAGE_LAN_1 {
	ConfigPageHeader_t Header;
	U16___2 Reserved;
	U8 CurrentDeviceState;
	U8 Reserved1;
	U32___2 MinPacketSize;
	U32___2 MaxPacketSize;
	U32___2 HardwareAddressLow;
	U32___2 HardwareAddressHigh;
	U32___2 MaxWireSpeedLow;
	U32___2 MaxWireSpeedHigh;
	U32___2 BucketsRemaining;
	U32___2 MaxReplySize;
	U32___2 NegWireSpeedLow;
	U32___2 NegWireSpeedHigh;
};

typedef struct _CONFIG_PAGE_LAN_1 LANPage1_t;

struct _MPI_SAS_IO_UNIT0_PHY_DATA {
	U8 Port;
	U8 PortFlags;
	U8 PhyFlags;
	U8 NegotiatedLinkRate;
	U32___2 ControllerPhyDeviceInfo;
	U16___2 AttachedDeviceHandle;
	U16___2 ControllerDevHandle;
	U32___2 DiscoveryStatus;
};

typedef struct _MPI_SAS_IO_UNIT0_PHY_DATA MPI_SAS_IO_UNIT0_PHY_DATA;

struct _CONFIG_PAGE_SAS_IO_UNIT_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 NvdataVersionDefault;
	U16___2 NvdataVersionPersistent;
	U8 NumPhys;
	U8 Reserved2;
	U16___2 Reserved3;
	MPI_SAS_IO_UNIT0_PHY_DATA PhyData[1];
};

typedef struct _CONFIG_PAGE_SAS_IO_UNIT_0 SasIOUnitPage0_t;

struct _MSG_SCSI_IO_REQUEST {
	U8 TargetID;
	U8 Bus;
	U8 ChainOffset;
	U8 Function;
	U8 CDBLength;
	U8 SenseBufferLength;
	U8 Reserved;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 LUN[8];
	U32___2 Control;
	U8 CDB[16];
	U32___2 DataLength;
	U32___2 SenseBufferLowAddr;
	SGE_IO_UNION SGL;
};

typedef struct _MSG_SCSI_IO_REQUEST SCSIIORequest_t;

struct _MSG_SCSI_IO_REPLY {
	U8 TargetID;
	U8 Bus;
	U8 MsgLength;
	U8 Function;
	U8 CDBLength;
	U8 SenseBufferLength;
	U8 Reserved;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 SCSIStatus;
	U8 SCSIState;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 TransferCount;
	U32___2 SenseCount;
	U32___2 ResponseInfo;
	U16___2 TaskTag;
	U16___2 Reserved1;
};

typedef struct _MSG_SCSI_IO_REPLY SCSIIOReply_t;

struct _MSG_SAS_IOUNIT_CONTROL_REQUEST {
	U8 Operation;
	U8 Reserved1;
	U8 ChainOffset;
	U8 Function;
	U16___2 DevHandle;
	U8 IOCParameter;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 TargetID;
	U8 Bus;
	U8 PhyNum;
	U8 PrimFlags;
	U32___2 Primitive;
	U64___2 SASAddress;
	U32___2 IOCParameterValue;
};

typedef struct _MSG_SAS_IOUNIT_CONTROL_REQUEST SasIoUnitControlRequest_t;

struct _MSG_SAS_IOUNIT_CONTROL_REPLY {
	U8 Operation;
	U8 Reserved1;
	U8 MsgLength;
	U8 Function;
	U16___2 DevHandle;
	U8 IOCParameter;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved4;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
};

typedef struct _MSG_SAS_IOUNIT_CONTROL_REPLY SasIoUnitControlReply_t;

struct _ATTO_DEVICE_INFO {
	u8 Offset;
	u8 Period;
	u16 ATTOFlags;
};

typedef struct _ATTO_DEVICE_INFO ATTO_DEVICE_INFO;

typedef struct _ATTO_DEVICE_INFO ATTODeviceInfo_t;

struct _ATTO_CONFIG_PAGE_SCSI_PORT_2 {
	CONFIG_PAGE_HEADER Header;
	u16 PortFlags;
	u16 Unused1;
	u32 Unused2;
	ATTO_DEVICE_INFO DeviceSettings[16];
};

typedef struct _ATTO_CONFIG_PAGE_SCSI_PORT_2 ATTO_SCSIPortPage2_t;

typedef enum {
	MPTBASE_DRIVER = 0,
	MPTCTL_DRIVER = 1,
	MPTSPI_DRIVER = 2,
	MPTFC_DRIVER = 3,
	MPTSAS_DRIVER = 4,
	MPTLAN_DRIVER = 5,
	MPTSTM_DRIVER = 6,
	MPTUNKNOWN_DRIVER = 7,
} MPT_DRIVER_CLASS;

struct mpt_pci_driver {
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
};

union _MPT_FRAME_TRACKER {
	struct {
		struct list_head list;
		u32 arg1;
		u32 pad;
		void *argp1;
	} linkage;
	struct {
		u32 __hdr[2];
		union {
			u32 MsgContext;
			struct {
				u16 req_idx;
				u8 cb_idx;
				u8 rsvd;
			} fld;
		} msgctxu;
	} hwhdr;
};

typedef union _MPT_FRAME_TRACKER MPT_FRAME_TRACKER;

struct _MPT_FRAME_HDR {
	union {
		MPIHeader_t hdr;
		SCSIIORequest_t scsireq;
		SCSIIOReply_t sreply;
		ConfigReply_t configreply;
		MPIDefaultReply_t reply;
		MPT_FRAME_TRACKER frame;
	} u;
};

typedef struct _MPT_FRAME_HDR MPT_FRAME_HDR;

struct _SYSIF_REGS {
	u32 Doorbell;
	u32 WriteSequence;
	u32 Diagnostic;
	u32 TestBase;
	u32 DiagRwData;
	u32 DiagRwAddress;
	u32 Reserved1[6];
	u32 IntStatus;
	u32 IntMask;
	u32 Reserved2[2];
	u32 RequestFifo;
	u32 ReplyFifo;
	u32 RequestHiPriFifo;
	u32 Reserved3;
	u32 HostIndex;
	u32 Reserved4[15];
	u32 Fubar;
	u32 Reserved5[1050];
	u32 Reset_1078;
};

typedef struct _SYSIF_REGS SYSIF_REGS;

struct _MPT_MGMT {
	struct mutex mutex;
	struct completion done;
	u8 reply[128];
	u8 sense[64];
	u8 status;
	int completion_code;
	u32 msg_context;
};

typedef struct _MPT_MGMT MPT_MGMT;

struct _mpt_ioctl_events {
	u32 event;
	u32 eventContext;
	u32 data[2];
};

struct _SpiCfgData {
	u32 PortFlags;
	int *nvram;
	IOCPage4_t *pIocPg4;
	dma_addr_t IocPg4_dma;
	int IocPg4Sz;
	u8 minSyncFactor;
	u8 maxSyncOffset;
	u8 maxBusWidth;
	u8 busType;
	u8 sdp1version;
	u8 sdp1length;
	u8 sdp0version;
	u8 sdp0length;
	u8 dvScheduled;
	u8 noQas;
	u8 Saf_Te;
	u8 bus_reset;
	u8 rsvd[1];
};

typedef struct _SpiCfgData SpiCfgData;

struct _SasCfgData {
	u8 ptClear;
};

typedef struct _SasCfgData SasCfgData;

struct inactive_raid_component_info {
	struct list_head list;
	u8 volumeID;
	u8 volumeBus;
	IOC_3_PHYS_DISK d;
};

struct _RaidCfgData {
	IOCPage2_t *pIocPg2;
	IOCPage3_t *pIocPg3;
	struct mutex inactive_list_mutex;
	struct list_head inactive_list;
};

typedef struct _RaidCfgData RaidCfgData;

struct _FcCfgData {
	struct {
		FCPortPage1_t *data;
		dma_addr_t dma;
		int pg_sz;
	} fc_port_page1[2];
};

typedef struct _FcCfgData FcCfgData;

enum {
	FC = 0,
	SPI = 1,
	SAS___2 = 2,
};

struct _MPT_ADAPTER;

struct _MPT_SCSI_HOST {
	struct _MPT_ADAPTER *ioc;
	ushort sel_timeout[255];
	char *info_kbuf;
	long int last_queue_full;
	u16 spi_pending;
	struct list_head target_reset_list;
};

typedef void (*MPT_ADD_SGE)(void *, u32, dma_addr_t);

typedef void (*MPT_ADD_CHAIN)(void *, u8, u16, dma_addr_t);

typedef void (*MPT_SCHEDULE_TARGET_RESET)(void *);

typedef struct _MPT_SCSI_HOST MPT_SCSI_HOST;

typedef void (*MPT_FLUSH_RUNNING_CMDS)(MPT_SCSI_HOST *);

struct mptsas_portinfo;

struct _MPT_ADAPTER {
	int id;
	int pci_irq;
	char name[32];
	const char *prod_name;
	char board_name[16];
	char board_assembly[16];
	char board_tracer[16];
	u16 nvdata_version_persistent;
	u16 nvdata_version_default;
	int debug_level;
	u8 io_missing_delay;
	u16 device_missing_delay;
	SYSIF_REGS *chip;
	SYSIF_REGS *pio_chip;
	u8 bus_type;
	u32 mem_phys;
	u32 pio_mem_phys;
	int mem_size;
	int number_of_buses;
	int devices_per_bus;
	int alloc_total;
	u32 last_state;
	int active;
	u8 *alloc;
	dma_addr_t alloc_dma;
	u32 alloc_sz;
	MPT_FRAME_HDR *reply_frames;
	u32 reply_frames_low_dma;
	int reply_depth;
	int reply_sz;
	int num_chain;
	MPT_ADD_SGE add_sge;
	MPT_ADD_CHAIN add_chain;
	int *ReqToChain;
	int *RequestNB;
	int *ChainToChain;
	u8 *ChainBuffer;
	dma_addr_t ChainBufferDMA;
	struct list_head FreeChainQ;
	spinlock_t FreeChainQlock;
	dma_addr_t req_frames_dma;
	MPT_FRAME_HDR *req_frames;
	u32 req_frames_low_dma;
	int req_depth;
	int req_sz;
	spinlock_t FreeQlock;
	struct list_head FreeQ;
	u8 *sense_buf_pool;
	dma_addr_t sense_buf_pool_dma;
	u32 sense_buf_low_dma;
	u8 *HostPageBuffer;
	u32 HostPageBuffer_sz;
	dma_addr_t HostPageBuffer_dma;
	struct pci_dev *pcidev;
	int bars;
	int msi_enable;
	u8 *memmap;
	struct Scsi_Host *sh;
	SpiCfgData spi_data;
	RaidCfgData raid_data;
	SasCfgData sas_data;
	FcCfgData fc_data;
	struct proc_dir_entry *ioc_dentry;
	struct _MPT_ADAPTER *alt_ioc;
	u32 biosVersion;
	int eventTypes;
	int eventContext;
	int eventLogSize;
	struct _mpt_ioctl_events *events;
	u8 *cached_fw;
	dma_addr_t cached_fw_dma;
	int hs_reply_idx;
	u32 pad0;
	u32 NB_for_64_byte_frame;
	u32 hs_req[32];
	u16 hs_reply[64];
	IOCFactsReply_t facts;
	PortFactsReply_t pfacts[2];
	FCPortPage0_t fc_port_page0[2];
	LANPage0_t lan_cnfg_page0;
	LANPage1_t lan_cnfg_page1;
	u8 ir_firmware;
	int errata_flag_1064;
	int aen_event_read_flag;
	u8 FirstWhoInit;
	u8 upload_fw;
	u8 NBShiftFactor;
	u8 pad1[4];
	u8 DoneCtx;
	u8 TaskCtx;
	u8 InternalCtx;
	struct list_head list;
	struct net_device *netdev;
	struct list_head sas_topology;
	struct mutex sas_topology_mutex;
	struct workqueue_struct *fw_event_q;
	struct list_head fw_event_list;
	spinlock_t fw_event_lock;
	u8 fw_events_off;
	char fw_event_q_name[20];
	struct mutex sas_discovery_mutex;
	u8 sas_discovery_runtime;
	u8 sas_discovery_ignore_events;
	struct mptsas_portinfo *hba_port_info;
	u64 hba_port_sas_addr;
	u16 hba_port_num_phy;
	struct list_head sas_device_info_list;
	struct mutex sas_device_info_mutex;
	u8 old_sas_discovery_protocal;
	u8 sas_discovery_quiesce_io;
	int sas_index;
	MPT_MGMT sas_mgmt;
	MPT_MGMT mptbase_cmds;
	MPT_MGMT internal_cmds;
	MPT_MGMT taskmgmt_cmds;
	MPT_MGMT ioctl_cmds;
	spinlock_t taskmgmt_lock;
	int taskmgmt_in_progress;
	u8 taskmgmt_quiesce_io;
	u8 ioc_reset_in_progress;
	u8 reset_status;
	u8 wait_on_reset_completion;
	MPT_SCHEDULE_TARGET_RESET schedule_target_reset;
	MPT_FLUSH_RUNNING_CMDS schedule_dead_ioc_flush_running_cmds;
	struct work_struct sas_persist_task;
	struct work_struct fc_setup_reset_work;
	struct list_head fc_rports;
	struct work_struct fc_lsc_work;
	u8 fc_link_speed[2];
	spinlock_t fc_rescan_work_lock;
	struct work_struct fc_rescan_work;
	char fc_rescan_work_q_name[20];
	struct workqueue_struct *fc_rescan_work_q;
	long unsigned int hard_resets;
	long unsigned int soft_resets;
	long unsigned int timeouts;
	struct scsi_cmnd **ScsiLookup;
	spinlock_t scsi_lookup_lock;
	u64 dma_mask;
	u32 broadcast_aen_busy;
	char reset_work_q_name[20];
	struct workqueue_struct *reset_work_q;
	struct delayed_work fault_reset_work;
	u8 sg_addr_size;
	u8 in_rescan;
	u8 SGE_size;
};

typedef struct _MPT_ADAPTER MPT_ADAPTER;

typedef int (*MPT_CALLBACK)(MPT_ADAPTER *, MPT_FRAME_HDR *, MPT_FRAME_HDR *);

typedef int (*MPT_EVHANDLER)(MPT_ADAPTER *, EventNotificationReply_t *);

typedef int (*MPT_RESETHANDLER)(MPT_ADAPTER *, int);

struct _x_config_parms {
	union {
		ConfigExtendedPageHeader_t *ehdr;
		ConfigPageHeader_t *hdr;
	} cfghdr;
	dma_addr_t physAddr;
	u32 pageAddr;
	u16 status;
	u8 action;
	u8 dir;
	u8 timeout;
};

typedef struct _x_config_parms CONFIGPARMS;

enum _MpiIocLogInfoFc {
	MPI_IOCLOGINFO_FC_INIT_BASE = 536870912,
	MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME = 536870913,
	MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME = 536870914,
	MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_END_OF_FRAME = 536870915,
	MPI_IOCLOGINFO_FC_INIT_ERROR_OVER_RUN = 536870916,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_OTHER = 536870917,
	MPI_IOCLOGINFO_FC_INIT_ERROR_SUBPROC_DEAD = 536870918,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_OVERRUN = 536870919,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_BAD_STATUS = 536870920,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_UNEXPECTED_FRAME = 536870921,
	MPI_IOCLOGINFO_FC_INIT_ERROR_LINK_FAILURE = 536870922,
	MPI_IOCLOGINFO_FC_INIT_ERROR_TX_TIMEOUT = 536870923,
	MPI_IOCLOGINFO_FC_TARGET_BASE = 553648128,
	MPI_IOCLOGINFO_FC_TARGET_NO_PDISC = 553648129,
	MPI_IOCLOGINFO_FC_TARGET_NO_LOGIN = 553648130,
	MPI_IOCLOGINFO_FC_TARGET_DOAR_KILLED_BY_LIP = 553648131,
	MPI_IOCLOGINFO_FC_TARGET_DIAR_KILLED_BY_LIP = 553648132,
	MPI_IOCLOGINFO_FC_TARGET_DIAR_MISSING_DATA = 553648133,
	MPI_IOCLOGINFO_FC_TARGET_DONR_KILLED_BY_LIP = 553648134,
	MPI_IOCLOGINFO_FC_TARGET_WRSP_KILLED_BY_LIP = 553648135,
	MPI_IOCLOGINFO_FC_TARGET_DINR_KILLED_BY_LIP = 553648136,
	MPI_IOCLOGINFO_FC_TARGET_DINR_MISSING_DATA = 553648137,
	MPI_IOCLOGINFO_FC_TARGET_MRSP_KILLED_BY_LIP = 553648138,
	MPI_IOCLOGINFO_FC_TARGET_NO_CLASS_3 = 553648139,
	MPI_IOCLOGINFO_FC_TARGET_LOGIN_NOT_VALID = 553648140,
	MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND = 553648142,
	MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN = 553648143,
	MPI_IOCLOGINFO_FC_LAN_BASE = 570425344,
	MPI_IOCLOGINFO_FC_LAN_TRANS_SGL_MISSING = 570425345,
	MPI_IOCLOGINFO_FC_LAN_TRANS_WRONG_PLACE = 570425346,
	MPI_IOCLOGINFO_FC_LAN_TRANS_RES_BITS_SET = 570425347,
	MPI_IOCLOGINFO_FC_LAN_WRONG_SGL_FLAG = 570425348,
	MPI_IOCLOGINFO_FC_MSG_BASE = 587202560,
	MPI_IOCLOGINFO_FC_LINK_BASE = 603979776,
	MPI_IOCLOGINFO_FC_LINK_LOOP_INIT_TIMEOUT = 603979777,
	MPI_IOCLOGINFO_FC_LINK_ALREADY_INITIALIZED = 603979778,
	MPI_IOCLOGINFO_FC_LINK_LINK_NOT_ESTABLISHED = 603979779,
	MPI_IOCLOGINFO_FC_LINK_CRC_ERROR = 603979780,
	MPI_IOCLOGINFO_FC_CTX_BASE = 620756992,
	MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET = 637534208,
	MPI_IOCLOGINFO_FC_INVALID_FIELD_MAX_OFFSET = 654311423,
	MPI_IOCLOGINFO_FC_STATE_CHANGE = 654311424,
};

union loginfo_type {
	u32 loginfo;
	struct {
		u32 subcode: 16;
		u32 code: 8;
		u32 originator: 4;
		u32 bus_type: 4;
	} dw;
};

struct _MSG_SCSI_TASK_MGMT {
	U8 TargetID;
	U8 Bus;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved;
	U8 TaskType;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 LUN[8];
	U32___2 Reserved2[7];
	U32___2 TaskMsgContext;
};

typedef struct _MSG_SCSI_TASK_MGMT SCSITaskMgmt_t;

struct _MSG_SCSI_TASK_MGMT_REPLY {
	U8 TargetID;
	U8 Bus;
	U8 MsgLength;
	U8 Function;
	U8 ResponseCode;
	U8 TaskType;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 TerminationCount;
};

typedef struct _MSG_SCSI_TASK_MGMT_REPLY SCSITaskMgmtReply_t;

struct _MSG_SEP_REQUEST {
	U8 TargetID;
	U8 Bus;
	U8 ChainOffset;
	U8 Function;
	U8 Action;
	U8 Flags;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 SlotStatus;
	U32___2 Reserved2;
	U32___2 Reserved3;
	U32___2 Reserved4;
	U16___2 Slot;
	U16___2 EnclosureHandle;
};

typedef struct _MSG_SEP_REQUEST SEPRequest_t;

struct _MSG_RAID_ACTION_REPLY {
	U8 Action;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U8 VolumeID;
	U8 VolumeBus;
	U8 PhysDiskNum;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 ActionStatus;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 VolumeStatus;
	U32___2 ActionData;
};

typedef struct _MSG_RAID_ACTION_REPLY MpiRaidActionReply_t;

struct _VirtTarget {
	struct scsi_target *starget;
	u8 tflags;
	u8 ioc_id;
	u8 id;
	u8 channel;
	u8 minSyncFactor;
	u8 maxOffset;
	u8 maxWidth;
	u8 negoFlags;
	u8 raidVolume;
	u8 type;
	u8 deleted;
	u8 inDMD;
	u32 num_luns;
};

typedef struct _VirtTarget VirtTarget;

struct _VirtDevice {
	VirtTarget *vtarget;
	u8 configured_lun;
	u64 lun;
};

typedef struct _VirtDevice VirtDevice;

struct _internal_cmd {
	char *data;
	dma_addr_t data_dma;
	int size;
	u8 cmd;
	u8 channel;
	u8 id;
	u64 lun;
	u8 flags;
	u8 physDiskNum;
	u8 rsvd2;
	u8 rsvd;
};

typedef struct _internal_cmd INTERNAL_CMD;

struct _CONFIG_PAGE_SCSI_DEVICE_0 {
	CONFIG_PAGE_HEADER Header;
	U32___2 NegotiatedParameters;
	U32___2 Information;
};

struct _CONFIG_PAGE_SCSI_DEVICE_1 {
	CONFIG_PAGE_HEADER Header;
	U32___2 RequestedParameters;
	U32___2 Reserved;
	U32___2 Configuration;
};

struct _MSG_RAID_ACTION {
	U8 Action;
	U8 Reserved1;
	U8 ChainOffset;
	U8 Function;
	U8 VolumeID;
	U8 VolumeBus;
	U8 PhysDiskNum;
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 Reserved2;
	U32___2 ActionDataWord;
	SGE_SIMPLE_UNION ActionDataSGE;
};

typedef struct _MSG_RAID_ACTION MpiRaidActionRequest_t;

struct work_queue_wrapper___2 {
	struct work_struct work;
	struct _MPT_SCSI_HOST *hd;
	int disk;
};

struct _CONFIG_PAGE_FC_DEVICE_0 {
	CONFIG_PAGE_HEADER Header;
	U64___2 WWNN;
	U64___2 WWPN;
	U32___2 PortIdentifier;
	U8 Protocol;
	U8 Flags;
	U16___2 BBCredit;
	U16___2 MaxRxFrameSize;
	U8 ADISCHardALPA;
	U8 PortNumber;
	U8 FcPhLowestVersion;
	U8 FcPhHighestVersion;
	U8 CurrentTargetID;
	U8 CurrentBus;
};

typedef struct _CONFIG_PAGE_FC_DEVICE_0 FCDevicePage0_t;

struct mptfc_rport_info {
	struct list_head list;
	struct fc_rport *rport;
	struct scsi_target *starget;
	FCDevicePage0_t pg0;
	u8 flags;
};

struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE {
	U8 TargetID;
	U8 Bus;
	U8 ReasonCode;
	U8 Reserved;
	U8 ASC;
	U8 ASCQ;
	U16___2 DevHandle;
	U32___2 DeviceInfo;
	U16___2 ParentDevHandle;
	U8 PhyNum;
	U8 Reserved1;
	U64___2 SASAddress;
	U8 LUN[8];
	U16___2 TaskTag;
	U16___2 Reserved2;
};

typedef struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE EVENT_DATA_SAS_DEVICE_STATUS_CHANGE;

typedef struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE MpiEventDataSasDeviceStatusChange_t;

struct _EVENT_DATA_QUEUE_FULL {
	U8 TargetID;
	U8 Bus;
	U16___2 CurrentDepth;
};

typedef struct _EVENT_DATA_QUEUE_FULL EventDataQueueFull_t;

typedef struct _EVENT_DATA_RAID EVENT_DATA_RAID;

struct _IR2_STATE_CHANGED {
	U16___2 PreviousState;
	U16___2 NewState;
};

typedef struct _IR2_STATE_CHANGED IR2_STATE_CHANGED;

struct _IR2_PD_INFO {
	U16___2 DeviceHandle;
	U8 TruncEnclosureHandle;
	U8 TruncatedSlot;
};

typedef struct _IR2_PD_INFO IR2_PD_INFO;

union _MPI_IR2_RC_EVENT_DATA {
	IR2_STATE_CHANGED StateChanged;
	U32___2 Lba;
	IR2_PD_INFO PdInfo;
};

typedef union _MPI_IR2_RC_EVENT_DATA MPI_IR2_RC_EVENT_DATA;

struct _MPI_EVENT_DATA_IR2 {
	U8 TargetID;
	U8 Bus;
	U8 ReasonCode;
	U8 PhysDiskNum;
	MPI_IR2_RC_EVENT_DATA IR2EventData;
};

typedef struct _MPI_EVENT_DATA_IR2 MPI_EVENT_DATA_IR2;

struct _EVENT_DATA_SAS_BROADCAST_PRIMITIVE {
	U8 PhyNum;
	U8 Port;
	U8 PortWidth;
	U8 Primitive;
};

typedef struct _EVENT_DATA_SAS_BROADCAST_PRIMITIVE EVENT_DATA_SAS_BROADCAST_PRIMITIVE;

struct _EVENT_DATA_SAS_PHY_LINK_STATUS {
	U8 PhyNum;
	U8 LinkRates;
	U16___2 DevHandle;
	U64___2 SASAddress;
};

typedef struct _EVENT_DATA_SAS_PHY_LINK_STATUS MpiEventDataSasPhyLinkStatus_t;

struct _EVENT_DATA_SAS_DISCOVERY {
	U32___2 DiscoveryStatus;
	U32___2 Reserved1;
};

typedef struct _EVENT_DATA_SAS_DISCOVERY EventDataSasDiscovery_t;

struct _EVENT_DATA_SAS_EXPANDER_STATUS_CHANGE {
	U8 ReasonCode;
	U8 Reserved1;
	U16___2 Reserved2;
	U8 PhysicalPort;
	U8 Reserved3;
	U16___2 EnclosureHandle;
	U64___2 SASAddress;
	U32___2 DiscoveryStatus;
	U16___2 DevHandle;
	U16___2 ParentDevHandle;
	U16___2 ExpanderChangeCount;
	U16___2 ExpanderRouteIndexes;
	U8 NumPhys;
	U8 SASLevel;
	U8 Flags;
	U8 Reserved4;
};

typedef struct _EVENT_DATA_SAS_EXPANDER_STATUS_CHANGE MpiEventDataSasExpanderStatusChange_t;

struct _MPI_SAS_IO_UNIT1_PHY_DATA {
	U8 Port;
	U8 PortFlags;
	U8 PhyFlags;
	U8 MaxMinLinkRate;
	U32___2 ControllerPhyDeviceInfo;
	U16___2 MaxTargetPortConnectTime;
	U16___2 Reserved1;
};

typedef struct _MPI_SAS_IO_UNIT1_PHY_DATA MPI_SAS_IO_UNIT1_PHY_DATA;

struct _CONFIG_PAGE_SAS_IO_UNIT_1 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 ControlFlags;
	U16___2 MaxNumSATATargets;
	U16___2 AdditionalControlFlags;
	U16___2 Reserved1;
	U8 NumPhys;
	U8 SATAMaxQDepth;
	U8 ReportDeviceMissingDelay;
	U8 IODeviceMissingDelay;
	MPI_SAS_IO_UNIT1_PHY_DATA PhyData[1];
};

typedef struct _CONFIG_PAGE_SAS_IO_UNIT_1 SasIOUnitPage1_t;

struct _CONFIG_PAGE_SAS_EXPANDER_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U8 PhysicalPort;
	U8 Reserved1;
	U16___2 EnclosureHandle;
	U64___2 SASAddress;
	U32___2 DiscoveryStatus;
	U16___2 DevHandle;
	U16___2 ParentDevHandle;
	U16___2 ExpanderChangeCount;
	U16___2 ExpanderRouteIndexes;
	U8 NumPhys;
	U8 SASLevel;
	U8 Flags;
	U8 Reserved3;
};

typedef struct _CONFIG_PAGE_SAS_EXPANDER_0 SasExpanderPage0_t;

struct _CONFIG_PAGE_SAS_EXPANDER_1 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U8 PhysicalPort;
	U8 Reserved1;
	U16___2 Reserved2;
	U8 NumPhys;
	U8 Phy;
	U16___2 NumTableEntriesProgrammed;
	U8 ProgrammedLinkRate;
	U8 HwLinkRate;
	U16___2 AttachedDevHandle;
	U32___2 PhyInfo;
	U32___2 AttachedDeviceInfo;
	U16___2 OwnerDevHandle;
	U8 ChangeCount;
	U8 NegotiatedLinkRate;
	U8 PhyIdentifier;
	U8 AttachedPhyIdentifier;
	U8 Reserved3;
	U8 DiscoveryInfo;
	U32___2 Reserved4;
};

typedef struct _CONFIG_PAGE_SAS_EXPANDER_1 SasExpanderPage1_t;

struct _CONFIG_PAGE_SAS_DEVICE_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 Slot;
	U16___2 EnclosureHandle;
	U64___2 SASAddress;
	U16___2 ParentDevHandle;
	U8 PhyNum;
	U8 AccessStatus;
	U16___2 DevHandle;
	U8 TargetID;
	U8 Bus;
	U32___2 DeviceInfo;
	U16___2 Flags;
	U8 PhysicalPort;
	U8 Reserved2;
};

typedef struct _CONFIG_PAGE_SAS_DEVICE_0 SasDevicePage0_t;

struct _CONFIG_PAGE_SAS_PHY_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 OwnerDevHandle;
	U16___2 Reserved1;
	U64___2 SASAddress;
	U16___2 AttachedDevHandle;
	U8 AttachedPhyIdentifier;
	U8 Reserved2;
	U32___2 AttachedDeviceInfo;
	U8 ProgrammedLinkRate;
	U8 HwLinkRate;
	U8 ChangeCount;
	U8 Flags;
	U32___2 PhyInfo;
};

typedef struct _CONFIG_PAGE_SAS_PHY_0 SasPhyPage0_t;

struct _CONFIG_PAGE_SAS_PHY_1 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U32___2 Reserved1;
	U32___2 InvalidDwordCount;
	U32___2 RunningDisparityErrorCount;
	U32___2 LossDwordSynchCount;
	U32___2 PhyResetProblemCount;
};

typedef struct _CONFIG_PAGE_SAS_PHY_1 SasPhyPage1_t;

struct _CONFIG_PAGE_SAS_ENCLOSURE_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U32___2 Reserved1;
	U64___2 EnclosureLogicalID;
	U16___2 Flags;
	U16___2 EnclosureHandle;
	U16___2 NumSlots;
	U16___2 StartSlot;
	U8 StartTargetID;
	U8 StartBus;
	U8 SEPTargetID;
	U8 SEPBus;
	U32___2 Reserved2;
	U32___2 Reserved3;
};

typedef struct _CONFIG_PAGE_SAS_ENCLOSURE_0 SasEnclosurePage0_t;

struct _MSG_SMP_PASSTHROUGH_REQUEST {
	U8 PassthroughFlags;
	U8 PhysicalPort;
	U8 ChainOffset;
	U8 Function;
	U16___2 RequestDataLength;
	U8 ConnectionRate;
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 Reserved1;
	U64___2 SASAddress;
	U32___2 Reserved2;
	U32___2 Reserved3;
	SGE_SIMPLE_UNION SGL;
};

typedef struct _MSG_SMP_PASSTHROUGH_REQUEST SmpPassthroughRequest_t;

struct _MSG_SMP_PASSTHROUGH_REPLY {
	U8 PassthroughFlags;
	U8 PhysicalPort;
	U8 MsgLength;
	U8 Function;
	U16___2 ResponseDataLength;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2;
	U8 SASStatus;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 Reserved3;
	U8 ResponseData[4];
};

typedef struct _MSG_SMP_PASSTHROUGH_REPLY SmpPassthroughReply_t;

struct mptsas_phyinfo;

struct mptsas_portinfo {
	struct list_head list;
	u16 num_phys;
	struct mptsas_phyinfo *phy_info;
};

struct mptsas_target_reset_event {
	struct list_head list;
	EVENT_DATA_SAS_DEVICE_STATUS_CHANGE sas_event_data;
	u8 target_reset_issued;
	long unsigned int time_count;
};

enum mptsas_hotplug_action {
	MPTSAS_ADD_DEVICE = 0,
	MPTSAS_DEL_DEVICE = 1,
	MPTSAS_ADD_RAID = 2,
	MPTSAS_DEL_RAID = 3,
	MPTSAS_ADD_PHYSDISK = 4,
	MPTSAS_ADD_PHYSDISK_REPROBE = 5,
	MPTSAS_DEL_PHYSDISK = 6,
	MPTSAS_DEL_PHYSDISK_REPROBE = 7,
	MPTSAS_ADD_INACTIVE_VOLUME = 8,
	MPTSAS_IGNORE_EVENT = 9,
};

struct mptsas_mapping {
	u8 id;
	u8 channel;
};

struct mptsas_device_info {
	struct list_head list;
	struct mptsas_mapping os;
	struct mptsas_mapping fw;
	u64 sas_address;
	u32 device_info;
	u16 slot;
	u64 enclosure_logical_id;
	u8 is_logical_volume;
	u8 is_hidden_raid_component;
	u8 volume_id;
	u8 is_cached;
};

struct mptsas_hotplug_event {
	MPT_ADAPTER *ioc;
	enum mptsas_hotplug_action event_type;
	u64 sas_address;
	u8 channel;
	u8 id;
	u32 device_info;
	u16 handle;
	u8 phy_id;
	u8 phys_disk_num;
	struct scsi_device *sdev;
};

struct fw_event_work {
	struct list_head list;
	struct delayed_work work;
	MPT_ADAPTER *ioc;
	u32 event;
	u8 retries;
	int: 24;
	char event_data[0];
};

struct mptsas_devinfo {
	u16 handle;
	u16 handle_parent;
	u16 handle_enclosure;
	u16 slot;
	u8 phy_id;
	u8 port_id;
	u8 id;
	u32 phys_disk_num;
	u8 channel;
	u64 sas_address;
	u32 device_info;
	u16 flags;
};

struct mptsas_portinfo_details {
	u16 num_phys;
	u64 phy_bitmask;
	struct sas_rphy *rphy;
	struct sas_port *port;
	struct scsi_target *starget;
	struct mptsas_portinfo *port_info;
};

struct mptsas_phyinfo {
	u16 handle;
	u8 phy_id;
	u8 port_id;
	u8 negotiated_link_rate;
	u8 hw_link_rate;
	u8 programmed_link_rate;
	u8 sas_port_add_phy;
	struct mptsas_devinfo identify;
	struct mptsas_devinfo attached;
	struct sas_phy *phy;
	struct mptsas_portinfo *portinfo;
	struct mptsas_portinfo_details *port_details;
};

struct mptsas_enclosure {
	u64 enclosure_logical_id;
	u16 enclosure_handle;
	u16 flags;
	u16 num_slot;
	u16 start_slot;
	u8 start_id;
	u8 start_channel;
	u8 sep_id;
	u8 sep_channel;
};

struct rep_manu_request {
	u8 smp_frame_type;
	u8 function;
	u8 reserved;
	u8 request_length;
};

struct rep_manu_reply {
	u8 smp_frame_type;
	u8 function;
	u8 function_result;
	u8 response_length;
	u16 expander_change_count;
	u8 reserved0[2];
	u8 sas_format: 1;
	u8 reserved1: 7;
	u8 reserved2[3];
	u8 vendor_id[8];
	u8 product_id[16];
	u8 product_rev[4];
	u8 component_vendor_id[8];
	u16 component_id;
	u8 component_revision_id;
	u8 reserved3;
	u8 vendor_specific[8];
};

struct socket_state_t {
	u_int flags;
	u_int csc_mask;
	u_char Vcc;
	u_char Vpp;
	u_char io_irq;
};

typedef struct socket_state_t socket_state_t;

struct pccard_io_map {
	u_char map;
	u_char flags;
	u_short speed;
	phys_addr_t start;
	phys_addr_t stop;
};

struct pccard_mem_map {
	u_char map;
	u_char flags;
	u_short speed;
	phys_addr_t static_start;
	u_int card_start;
	struct resource *res;
};

typedef struct pccard_mem_map pccard_mem_map;

struct io_window_t {
	u_int InUse;
	u_int Config;
	struct resource *res;
};

typedef struct io_window_t io_window_t;

struct pcmcia_socket;

struct pccard_operations {
	int (*init)(struct pcmcia_socket *);
	int (*suspend)(struct pcmcia_socket *);
	int (*get_status)(struct pcmcia_socket *, u_int *);
	int (*set_socket)(struct pcmcia_socket *, socket_state_t *);
	int (*set_io_map)(struct pcmcia_socket *, struct pccard_io_map *);
	int (*set_mem_map)(struct pcmcia_socket *, struct pccard_mem_map *);
};

struct pccard_resource_ops;

struct pcmcia_callback;

struct pcmcia_socket {
	struct module *owner;
	socket_state_t socket;
	u_int state;
	u_int suspended_state;
	u_short functions;
	u_short lock_count;
	pccard_mem_map cis_mem;
	void *cis_virt;
	io_window_t io[2];
	pccard_mem_map win[4];
	struct list_head cis_cache;
	size_t fake_cis_len;
	u8 *fake_cis;
	struct list_head socket_list;
	struct completion socket_released;
	unsigned int sock;
	u_int features;
	u_int irq_mask;
	u_int map_size;
	u_int io_offset;
	u_int pci_irq;
	struct pci_dev *cb_dev;
	u8 resource_setup_done;
	struct pccard_operations *ops;
	struct pccard_resource_ops *resource_ops;
	void *resource_data;
	void (*zoom_video)(struct pcmcia_socket *, int);
	int (*power_hook)(struct pcmcia_socket *, int);
	void (*tune_bridge)(struct pcmcia_socket *, struct pci_bus *);
	struct task_struct *thread;
	struct completion thread_done;
	unsigned int thread_events;
	unsigned int sysfs_events;
	struct mutex skt_mutex;
	struct mutex ops_mutex;
	spinlock_t thread_lock;
	struct pcmcia_callback *callback;
	struct list_head devices_list;
	u8 device_count;
	u8 pcmcia_pfc;
	atomic_t present;
	unsigned int pcmcia_irq;
	struct device dev;
	void *driver_data;
	int resume_status;
};

struct pccard_resource_ops {
	int (*validate_mem)(struct pcmcia_socket *);
	int (*find_io)(struct pcmcia_socket *, unsigned int, unsigned int *, unsigned int, unsigned int, struct resource **);
	struct resource * (*find_mem)(long unsigned int, long unsigned int, long unsigned int, int, struct pcmcia_socket *);
	int (*init)(struct pcmcia_socket *);
	void (*exit)(struct pcmcia_socket *);
};

struct pcmcia_callback {
	struct module *owner;
	int (*add)(struct pcmcia_socket *);
	int (*remove)(struct pcmcia_socket *);
	void (*requery)(struct pcmcia_socket *);
	int (*validate)(struct pcmcia_socket *, unsigned int *);
	int (*suspend)(struct pcmcia_socket *);
	int (*early_resume)(struct pcmcia_socket *);
	int (*resume)(struct pcmcia_socket *);
};

enum {
	PCMCIA_IOPORT_0 = 0,
	PCMCIA_IOPORT_1 = 1,
	PCMCIA_IOMEM_0 = 2,
	PCMCIA_IOMEM_1 = 3,
	PCMCIA_IOMEM_2 = 4,
	PCMCIA_IOMEM_3 = 5,
	PCMCIA_NUM_RESOURCES = 6,
};

struct cistpl_longlink_mfc_t {
	u_char nfn;
	struct {
		u_char space;
		u_int addr;
	} fn[8];
};

typedef struct cistpl_longlink_mfc_t cistpl_longlink_mfc_t;

struct cistpl_vers_1_t {
	u_char major;
	u_char minor;
	u_char ns;
	u_char ofs[4];
	char str[254];
};

typedef struct cistpl_vers_1_t cistpl_vers_1_t;

struct cistpl_manfid_t {
	u_short manf;
	u_short card;
};

typedef struct cistpl_manfid_t cistpl_manfid_t;

struct cistpl_funcid_t {
	u_char func;
	u_char sysinit;
};

typedef struct cistpl_funcid_t cistpl_funcid_t;

struct cistpl_config_t {
	u_char last_idx;
	u_int base;
	u_int rmask[4];
	u_char subtuples;
};

typedef struct cistpl_config_t cistpl_config_t;

struct cistpl_device_geo_t {
	u_char ngeo;
	struct {
		u_char buswidth;
		u_int erase_block;
		u_int read_block;
		u_int write_block;
		u_int partition;
		u_int interleave;
	} geo[4];
};

typedef struct cistpl_device_geo_t cistpl_device_geo_t;

struct pcmcia_device_id {
	__u16 match_flags;
	__u16 manf_id;
	__u16 card_id;
	__u8 func_id;
	__u8 function;
	__u8 device_no;
	__u32 prod_id_hash[4];
	const char *prod_id[4];
	kernel_ulong_t driver_info;
	char *cisfile;
};

struct pcmcia_dynids {
	struct mutex lock;
	struct list_head list;
};

struct pcmcia_device;

struct pcmcia_driver {
	const char *name;
	int (*probe)(struct pcmcia_device *);
	void (*remove)(struct pcmcia_device *);
	int (*suspend)(struct pcmcia_device *);
	int (*resume)(struct pcmcia_device *);
	struct module *owner;
	const struct pcmcia_device_id *id_table;
	struct device_driver drv;
	struct pcmcia_dynids dynids;
};

struct config_t;

struct pcmcia_device {
	struct pcmcia_socket *socket;
	char *devname;
	u8 device_no;
	u8 func;
	struct config_t *function_config;
	struct list_head socket_device_list;
	unsigned int irq;
	struct resource *resource[6];
	resource_size_t card_addr;
	unsigned int vpp;
	unsigned int config_flags;
	unsigned int config_base;
	unsigned int config_index;
	unsigned int config_regs;
	unsigned int io_lines;
	u16 suspended: 1;
	u16 _irq: 1;
	u16 _io: 1;
	u16 _win: 4;
	u16 _locked: 1;
	u16 allow_func_id_match: 1;
	u16 has_manf_id: 1;
	u16 has_card_id: 1;
	u16 has_func_id: 1;
	u16 reserved: 4;
	u8 func_id;
	u16 manf_id;
	u16 card_id;
	char *prod_id[4];
	u64 dma_mask;
	struct device dev;
	void *priv;
	unsigned int open;
};

struct config_t {
	struct kref ref;
	unsigned int state;
	struct resource io[2];
	struct resource mem[4];
};

typedef struct config_t config_t;

struct pcmcia_dynid {
	struct list_head node;
	struct pcmcia_device_id id;
};

typedef struct pccard_io_map pccard_io_map;

typedef unsigned char cisdata_t;

struct cistpl_longlink_t {
	u_int addr;
};

typedef struct cistpl_longlink_t cistpl_longlink_t;

struct cistpl_checksum_t {
	u_short addr;
	u_short len;
	u_char sum;
};

typedef struct cistpl_checksum_t cistpl_checksum_t;

struct cistpl_altstr_t {
	u_char ns;
	u_char ofs[4];
	char str[254];
};

typedef struct cistpl_altstr_t cistpl_altstr_t;

struct cistpl_device_t {
	u_char ndev;
	struct {
		u_char type;
		u_char wp;
		u_int speed;
		u_int size;
	} dev[4];
};

typedef struct cistpl_device_t cistpl_device_t;

struct cistpl_jedec_t {
	u_char nid;
	struct {
		u_char mfr;
		u_char info;
	} id[4];
};

typedef struct cistpl_jedec_t cistpl_jedec_t;

struct cistpl_funce_t {
	u_char type;
	u_char data[0];
};

typedef struct cistpl_funce_t cistpl_funce_t;

struct cistpl_bar_t {
	u_char attr;
	u_int size;
};

typedef struct cistpl_bar_t cistpl_bar_t;

struct cistpl_power_t {
	u_char present;
	u_char flags;
	u_int param[7];
};

typedef struct cistpl_power_t cistpl_power_t;

struct cistpl_timing_t {
	u_int wait;
	u_int waitscale;
	u_int ready;
	u_int rdyscale;
	u_int reserved;
	u_int rsvscale;
};

typedef struct cistpl_timing_t cistpl_timing_t;

struct cistpl_io_t {
	u_char flags;
	u_char nwin;
	struct {
		u_int base;
		u_int len;
	} win[16];
};

typedef struct cistpl_io_t cistpl_io_t;

struct cistpl_irq_t {
	u_int IRQInfo1;
	u_int IRQInfo2;
};

typedef struct cistpl_irq_t cistpl_irq_t;

struct cistpl_mem_t {
	u_char flags;
	u_char nwin;
	struct {
		u_int len;
		u_int card_addr;
		u_int host_addr;
	} win[8];
};

typedef struct cistpl_mem_t cistpl_mem_t;

struct cistpl_cftable_entry_t {
	u_char index;
	u_short flags;
	u_char interface;
	cistpl_power_t vcc;
	cistpl_power_t vpp1;
	cistpl_power_t vpp2;
	cistpl_timing_t timing;
	cistpl_io_t io;
	cistpl_irq_t irq;
	cistpl_mem_t mem;
	u_char subtuples;
};

typedef struct cistpl_cftable_entry_t cistpl_cftable_entry_t;

struct cistpl_cftable_entry_cb_t {
	u_char index;
	u_int flags;
	cistpl_power_t vcc;
	cistpl_power_t vpp1;
	cistpl_power_t vpp2;
	u_char io;
	cistpl_irq_t irq;
	u_char mem;
	u_char subtuples;
};

typedef struct cistpl_cftable_entry_cb_t cistpl_cftable_entry_cb_t;

struct cistpl_vers_2_t {
	u_char vers;
	u_char comply;
	u_short dindex;
	u_char vspec8;
	u_char vspec9;
	u_char nhdr;
	u_char vendor;
	u_char info;
	char str[244];
};

typedef struct cistpl_vers_2_t cistpl_vers_2_t;

struct cistpl_org_t {
	u_char data_org;
	char desc[30];
};

typedef struct cistpl_org_t cistpl_org_t;

struct cistpl_format_t {
	u_char type;
	u_char edc;
	u_int offset;
	u_int length;
};

typedef struct cistpl_format_t cistpl_format_t;

union cisparse_t {
	cistpl_device_t device;
	cistpl_checksum_t checksum;
	cistpl_longlink_t longlink;
	cistpl_longlink_mfc_t longlink_mfc;
	cistpl_vers_1_t version_1;
	cistpl_altstr_t altstr;
	cistpl_jedec_t jedec;
	cistpl_manfid_t manfid;
	cistpl_funcid_t funcid;
	cistpl_funce_t funce;
	cistpl_bar_t bar;
	cistpl_config_t config;
	cistpl_cftable_entry_t cftable_entry;
	cistpl_cftable_entry_cb_t cftable_entry_cb;
	cistpl_device_geo_t device_geo;
	cistpl_vers_2_t vers_2;
	cistpl_org_t org;
	cistpl_format_t format;
};

typedef union cisparse_t cisparse_t;

struct tuple_t {
	u_int Attributes;
	cisdata_t DesiredTuple;
	u_int Flags;
	u_int LinkOffset;
	u_int CISOffset;
	cisdata_t TupleCode;
	cisdata_t TupleLink;
	cisdata_t TupleOffset;
	cisdata_t TupleDataMax;
	cisdata_t TupleDataLen;
	cisdata_t *TupleData;
};

typedef struct tuple_t tuple_t;

struct cis_cache_entry {
	struct list_head node;
	unsigned int addr;
	unsigned int len;
	unsigned int attr;
	unsigned char cache[0];
};

struct tuple_flags {
	u_int link_space: 4;
	u_int has_link: 1;
	u_int mfc_fn: 3;
	u_int space: 4;
};

struct pcmcia_cfg_mem {
	struct pcmcia_device *p_dev;
	int (*conf_check)(struct pcmcia_device *, void *);
	void *priv_data;
	cisparse_t parse;
	cistpl_cftable_entry_t dflt;
};

struct pcmcia_loop_mem {
	struct pcmcia_device *p_dev;
	void *priv_data;
	int (*loop_tuple)(struct pcmcia_device *, tuple_t *, void *);
};

struct pcmcia_loop_get {
	size_t len;
	cisdata_t **buf;
};

struct resource_map {
	u_long base;
	u_long num;
	struct resource_map *next;
};

struct socket_data {
	struct resource_map mem_db;
	struct resource_map mem_db_valid;
	struct resource_map io_db;
};

struct pcmcia_align_data {
	long unsigned int mask;
	long unsigned int offset;
	struct resource_map *map;
};

struct yenta_socket;

struct cardbus_type {
	int (*override)(struct yenta_socket *);
	void (*save_state)(struct yenta_socket *);
	void (*restore_state)(struct yenta_socket *);
	int (*sock_init)(struct yenta_socket *);
};

struct yenta_socket {
	struct pci_dev *dev;
	int cb_irq;
	int io_irq;
	void *base;
	struct timer_list poll_timer;
	struct pcmcia_socket socket;
	struct cardbus_type *type;
	u32 flags;
	unsigned int probe_status;
	unsigned int private[8];
	u32 saved_state[2];
};

enum {
	CARDBUS_TYPE_DEFAULT = 4294967295,
	CARDBUS_TYPE_TI = 0,
	CARDBUS_TYPE_TI113X = 1,
	CARDBUS_TYPE_TI12XX = 2,
	CARDBUS_TYPE_TI1250 = 3,
	CARDBUS_TYPE_RICOH = 4,
	CARDBUS_TYPE_TOPIC95 = 5,
	CARDBUS_TYPE_TOPIC97 = 6,
	CARDBUS_TYPE_O2MICRO = 7,
	CARDBUS_TYPE_ENE = 8,
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	char: 8;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	int: 32;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[2];
};

struct usb_device;

struct mon_bus;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
	struct mon_bus *mon_bus;
	int monitored;
};

struct wusb_dev;

enum usb_device_removable {
	USB_DEVICE_REMOVABLE_UNKNOWN = 0,
	USB_DEVICE_REMOVABLE = 1,
	USB_DEVICE_FIXED = 2,
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	enum usb_device_removable removable;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct giveback_urb_bh {
	bool running;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy_roothub;

struct hc_driver;

struct usb_phy;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool___2 *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

struct extcon_dev;

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_otg;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

typedef u32 usb_port_location_t;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
};

struct usb_dev_state;

struct usb_port {
	struct usb_device *child;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_mon_operations {
	void (*urb_submit)(struct usb_bus *, struct urb *);
	void (*urb_submit_error)(struct usb_bus *, struct urb *, int);
	void (*urb_complete)(struct usb_bus *, struct urb *, int);
};

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct api_context {
	struct completion done;
	int status;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_class {
	struct kref kref;
	struct class *class;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usbdevfs_ctrltransfer32 {
	u8 bRequestType;
	u8 bRequest;
	u16 wValue;
	u16 wIndex;
	u16 wLength;
	u32 timeout;
	compat_caddr_t data;
};

struct usbdevfs_bulktransfer32 {
	compat_uint_t ep;
	compat_uint_t len;
	compat_uint_t timeout;
	compat_caddr_t data;
};

struct usbdevfs_disconnectsignal32 {
	compat_int_t signr;
	compat_caddr_t context;
};

struct usbdevfs_urb32 {
	unsigned char type;
	unsigned char endpoint;
	compat_int_t status;
	compat_uint_t flags;
	compat_caddr_t buffer;
	compat_int_t buffer_length;
	compat_int_t actual_length;
	compat_int_t start_frame;
	compat_int_t number_of_packets;
	compat_int_t error_count;
	compat_uint_t signr;
	compat_caddr_t usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl32 {
	s32 ifno;
	s32 ioctl_code;
	compat_caddr_t data;
};

struct usb_dev_state___2 {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state___2 *ps;
};

struct async {
	struct list_head asynclist;
	struct usb_dev_state___2 *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE = 1,
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct class_info {
	int class;
	char *class_name;
};

struct usb_phy_roothub___2 {
	struct phy *phy;
	struct list_head list;
};

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

struct mon_bus {
	struct list_head bus_link;
	spinlock_t lock;
	struct usb_bus *u_bus;
	int text_inited;
	int bin_inited;
	struct dentry *dent_s;
	struct dentry *dent_t;
	struct dentry *dent_u;
	struct device *classdev;
	int nreaders;
	struct list_head r_list;
	struct kref ref;
	unsigned int cnt_events;
	unsigned int cnt_text_lost;
};

struct mon_reader {
	struct list_head r_link;
	struct mon_bus *m_bus;
	void *r_data;
	void (*rnf_submit)(void *, struct urb *);
	void (*rnf_error)(void *, struct urb *, int);
	void (*rnf_complete)(void *, struct urb *, int);
};

struct snap {
	int slen;
	char str[80];
};

struct mon_iso_desc {
	int status;
	unsigned int offset;
	unsigned int length;
};

struct mon_event_text {
	struct list_head e_link;
	int type;
	long unsigned int id;
	unsigned int tstamp;
	int busnum;
	char devnum;
	char epnum;
	char is_in;
	char xfertype;
	int length;
	int status;
	int interval;
	int start_frame;
	int error_count;
	char setup_flag;
	char data_flag;
	int numdesc;
	struct mon_iso_desc isodesc[5];
	unsigned char setup[8];
	unsigned char data[32];
};

struct mon_reader_text {
	struct kmem_cache *e_slab;
	int nevents;
	struct list_head e_list;
	struct mon_reader r;
	wait_queue_head_t wait;
	int printf_size;
	size_t printf_offset;
	size_t printf_togo;
	char *printf_buf;
	struct mutex printf_lock;
	char slab_name[30];
};

struct mon_text_ptr {
	int cnt;
	int limit;
	char *pbuf;
};

enum {
	NAMESZ = 10,
};

struct iso_rec {
	int error_count;
	int numdesc;
};

struct mon_bin_hdr {
	u64 id;
	unsigned char type;
	unsigned char xfer_type;
	unsigned char epnum;
	unsigned char devnum;
	short unsigned int busnum;
	char flag_setup;
	char flag_data;
	s64 ts_sec;
	s32 ts_usec;
	int status;
	unsigned int len_urb;
	unsigned int len_cap;
	union {
		unsigned char setup[8];
		struct iso_rec iso;
	} s;
	int interval;
	int start_frame;
	unsigned int xfer_flags;
	unsigned int ndesc;
};

struct mon_bin_isodesc {
	int iso_status;
	unsigned int iso_off;
	unsigned int iso_len;
	u32 _pad;
};

struct mon_bin_stats {
	u32 queued;
	u32 dropped;
};

struct mon_bin_get {
	struct mon_bin_hdr *hdr;
	void *data;
	size_t alloc;
};

struct mon_bin_mfetch {
	u32 *offvec;
	u32 nfetch;
	u32 nflush;
};

struct mon_bin_get32 {
	u32 hdr32;
	u32 data32;
	u32 alloc32;
};

struct mon_bin_mfetch32 {
	u32 offvec32;
	u32 nfetch32;
	u32 nflush32;
};

struct mon_pgmap {
	struct page *pg;
	unsigned char *ptr;
};

struct mon_reader_bin {
	spinlock_t b_lock;
	unsigned int b_size;
	unsigned int b_cnt;
	unsigned int b_in;
	unsigned int b_out;
	unsigned int b_read;
	struct mon_pgmap *b_vec;
	wait_queue_head_t b_wait;
	struct mutex fetch_lock;
	int mmap_active;
	struct mon_reader r;
	unsigned int cnt_lost;
};

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

enum i8042_controller_reset_mode {
	I8042_RESET_NEVER = 0,
	I8042_RESET_ALWAYS = 1,
	I8042_RESET_ON_S2RAM = 2,
};

struct i8042_port {
	struct serio *serio;
	int irq;
	bool exists;
	bool driver_bound;
	signed char mux;
};

struct serport {
	struct tty_struct *tty;
	wait_queue_head_t wait;
	struct serio *serio;
	struct serio_device_id id;
	spinlock_t lock;
	long unsigned int flags;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_event_compat {
	compat_ulong_t sec;
	compat_ulong_t usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct ff_periodic_effect_compat {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	compat_uptr_t custom_data;
};

struct ff_effect_compat {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect_compat periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct ml_effect_state {
	struct ff_effect *effect;
	long unsigned int flags;
	int count;
	long unsigned int play_at;
	long unsigned int stop_at;
	long unsigned int adj_at;
};

struct ml_device {
	void *private;
	struct ml_effect_state states[16];
	int gain;
	struct timer_list timer;
	struct input_dev *dev;
	int (*play_effect)(struct input_dev *, void *, struct ff_effect *);
};

struct mousedev_hw_data {
	int dx;
	int dy;
	int dz;
	int x;
	int y;
	int abs_event;
	long unsigned int buttons;
};

struct mousedev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
	struct list_head mixdev_node;
	bool opened_by_mixdev;
	struct mousedev_hw_data packet;
	unsigned int pkt_count;
	int old_x[4];
	int old_y[4];
	int frac_dx;
	int frac_dy;
	long unsigned int touch;
	int (*open_device)(struct mousedev *);
	void (*close_device)(struct mousedev *);
};

enum mousedev_emul {
	MOUSEDEV_EMUL_PS2 = 0,
	MOUSEDEV_EMUL_IMPS = 1,
	MOUSEDEV_EMUL_EXPS = 2,
};

struct mousedev_motion {
	int dx;
	int dy;
	int dz;
	long unsigned int buttons;
};

struct mousedev_client {
	struct fasync_struct *fasync;
	struct mousedev *mousedev;
	struct list_head node;
	struct mousedev_motion packets[16];
	unsigned int head;
	unsigned int tail;
	spinlock_t packet_lock;
	int pos_x;
	int pos_y;
	u8 ps2[6];
	unsigned char ready;
	unsigned char buffer;
	unsigned char bufsiz;
	unsigned char imexseq;
	unsigned char impsseq;
	enum mousedev_emul mode;
	long unsigned int last_buttons;
};

enum {
	FRACTION_DENOM = 128,
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	u32 function_row_physmap[24];
	int num_function_row_keys;
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

struct psmouse;

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	long unsigned int last;
	long unsigned int out_of_sync_cnt;
	long unsigned int num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct psmouse_attribute {
	struct device_attribute dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

enum synaptics_pkt_type {
	SYN_NEWABS = 0,
	SYN_NEWABS_STRICT = 1,
	SYN_NEWABS_RELAXED = 2,
	SYN_OLDABS = 3,
};

struct synaptics_hw_state {
	int x;
	int y;
	int z;
	int w;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int up: 1;
	unsigned int down: 1;
	u8 ext_buttons;
	s8 scroll;
};

struct synaptics_device_info {
	u32 model_id;
	u32 firmware_id;
	u32 board_id;
	u32 capabilities;
	u32 ext_cap;
	u32 ext_cap_0c;
	u32 ext_cap_10;
	u32 identity;
	u32 x_res;
	u32 y_res;
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
};

struct synaptics_data {
	struct synaptics_device_info info;
	enum synaptics_pkt_type pkt_type;
	u8 mode;
	int scroll;
	bool absolute_mode;
	bool disable_gesture;
	struct serio *pt_port;
	struct synaptics_hw_state agm;
	unsigned int agm_count;
	long unsigned int press_start;
	bool press;
	bool report_press;
	bool is_forcepad;
};

struct min_max_quirk {
	const char * const *pnp_ids;
	struct {
		u32 min;
		u32 max;
	} board_id;
	u32 x_min;
	u32 x_max;
	u32 y_min;
	u32 y_max;
};

enum SS4_PACKET_ID {
	SS4_PACKET_ID_IDLE = 0,
	SS4_PACKET_ID_ONE = 1,
	SS4_PACKET_ID_TWO = 2,
	SS4_PACKET_ID_MULTI = 3,
	SS4_PACKET_ID_STICK = 4,
};

enum V7_PACKET_ID {
	V7_PACKET_ID_IDLE = 0,
	V7_PACKET_ID_TWO = 1,
	V7_PACKET_ID_MULTI = 2,
	V7_PACKET_ID_NEW = 3,
	V7_PACKET_ID_UNKNOWN = 4,
};

struct alps_protocol_info {
	u16 version;
	u8 byte0;
	u8 mask0;
	unsigned int flags;
};

struct alps_model_info {
	u8 signature[3];
	struct alps_protocol_info protocol_info;
};

struct alps_nibble_commands {
	int command;
	unsigned char data;
};

struct alps_bitmap_point {
	int start_bit;
	int num_bits;
};

struct alps_fields {
	unsigned int x_map;
	unsigned int y_map;
	unsigned int fingers;
	int pressure;
	struct input_mt_pos st;
	struct input_mt_pos mt[4];
	unsigned int first_mp: 1;
	unsigned int is_mp: 1;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int ts_left: 1;
	unsigned int ts_right: 1;
	unsigned int ts_middle: 1;
};

struct alps_data {
	struct psmouse *psmouse;
	struct input_dev *dev2;
	struct input_dev *dev3;
	char phys2[32];
	char phys3[32];
	struct delayed_work dev3_register_work;
	const struct alps_nibble_commands *nibble_commands;
	int addr_command;
	u16 proto_version;
	u8 byte0;
	u8 mask0;
	u8 dev_id[3];
	u8 fw_ver[3];
	int flags;
	int x_max;
	int y_max;
	int x_bits;
	int y_bits;
	unsigned int x_res;
	unsigned int y_res;
	int (*hw_init)(struct psmouse *);
	void (*process_packet)(struct psmouse *);
	int (*decode_fields)(struct alps_fields *, unsigned char *, struct psmouse *);
	void (*set_abs_params)(struct alps_data *, struct input_dev *);
	int prev_fin;
	int multi_packet;
	int second_touch;
	unsigned char multi_data[6];
	struct alps_fields f;
	u8 quirks;
	struct timer_list timer;
};

struct byd_data {
	struct timer_list timer;
	struct psmouse *psmouse;
	s32 abs_x;
	s32 abs_y;
	volatile long unsigned int last_touch_time;
	bool btn_left;
	bool btn_right;
	bool touch;
};

struct ps2pp_info {
	u8 model;
	u8 kind;
	u16 features;
};

struct lifebook_data {
	struct input_dev *dev2;
	char phys[32];
};

struct trackpoint_data {
	u8 variant_id;
	u8 firmware_id;
	u8 sensitivity;
	u8 speed;
	u8 inertia;
	u8 reach;
	u8 draghys;
	u8 mindrag;
	u8 thresh;
	u8 upthresh;
	u8 ztime;
	u8 jenks;
	u8 drift_time;
	bool press_to_select;
	bool skipback;
	bool ext_dev;
};

struct trackpoint_attr_data {
	size_t field_offset;
	u8 command;
	u8 mask;
	bool inverted;
	u8 power_on_default;
};

struct cytp_contact {
	int x;
	int y;
	int z;
};

struct cytp_report_data {
	int contact_cnt;
	struct cytp_contact contacts[2];
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int tap: 1;
};

struct cytp_data {
	int fw_version;
	int pkt_size;
	int mode;
	int tp_min_pressure;
	int tp_max_pressure;
	int tp_width;
	int tp_high;
	int tp_max_abs_x;
	int tp_max_abs_y;
	int tp_res_x;
	int tp_res_y;
	int tp_metrics_supported;
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
};

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	struct gpio_desc___2 *wp_gpio;
	const struct nvmem_cell_info *cells;
	int ncells;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_device;

struct cmos_rtc_board_info {
	void (*wake_on)(struct device *);
	void (*wake_off)(struct device *);
	u32 flags;
	int address_space;
	u8 rtc_day_alarm;
	u8 rtc_mon_alarm;
	u8 rtc_century;
};

struct cmos_rtc {
	struct rtc_device *rtc;
	struct device *dev;
	int irq;
	struct resource *iomem;
	time64_t alarm_expires;
	void (*wake_on)(struct device *);
	void (*wake_off)(struct device *);
	u8 enabled_wake;
	u8 suspend_ctrl;
	u8 day_alrm;
	u8 mon_alrm;
	u8 century;
	struct rtc_wkalrm saved_wkalrm;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct property_entry *properties;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_ktime_compat {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
};

struct pps_kinfo_compat {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime_compat assert_tu;
	struct pps_ktime_compat clear_tu;
	int current_mode;
} __attribute__((packed));

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_fdata_compat {
	struct pps_kinfo_compat info;
	struct pps_ktime_compat timeout;
} __attribute__((packed));

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct cdev cdev;
	struct device *dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
};

struct ptp_clock___2 {
	struct posix_clock clock;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	struct timestamp_event_queue tsevq;
	struct mutex tsevq_mux;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int rsv[12];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_pattern;

struct led_trigger;

struct led_classdev {
	const char *name;
	enum led_brightness brightness;
	enum led_brightness max_brightness;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	struct led_hw_trigger_type *trigger_type;
	rwlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 37,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 39,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 40,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 43,
	POWER_SUPPLY_PROP_ENERGY_NOW = 44,
	POWER_SUPPLY_PROP_ENERGY_AVG = 45,
	POWER_SUPPLY_PROP_CAPACITY = 46,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 48,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 50,
	POWER_SUPPLY_PROP_TEMP = 51,
	POWER_SUPPLY_PROP_TEMP_MAX = 52,
	POWER_SUPPLY_PROP_TEMP_MIN = 53,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 55,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 58,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 60,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 62,
	POWER_SUPPLY_PROP_TYPE = 63,
	POWER_SUPPLY_PROP_USB_TYPE = 64,
	POWER_SUPPLY_PROP_SCOPE = 65,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 66,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 67,
	POWER_SUPPLY_PROP_CALIBRATE = 68,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 71,
	POWER_SUPPLY_PROP_MODEL_NAME = 72,
	POWER_SUPPLY_PROP_MANUFACTURER = 73,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 74,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *charging_full_trig;
	char *charging_full_trig_name;
	struct led_trigger *charging_trig;
	char *charging_trig_name;
	struct led_trigger *full_trig;
	char *full_trig_name;
	struct led_trigger *online_trig;
	char *online_trig_name;
	struct led_trigger *charging_blink_full_solid_trig;
	char *charging_blink_full_solid_trig_name;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_battery_info {
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	int factory_internal_resistance_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

struct hwmon_device {
	const char *name;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct powerclamp_worker_data {
	struct kthread_worker *worker;
	struct kthread_work balancing_work;
	struct kthread_delayed_work idle_injection_work;
	unsigned int cpu;
	unsigned int count;
	unsigned int guard;
	unsigned int window_size_now;
	unsigned int target_ratio;
	unsigned int duration_jiffies;
	bool clamping;
};

struct powerclamp_calibration_data {
	long unsigned int confidence;
	long unsigned int steady_comp;
	long unsigned int dynamic_comp;
};

struct pkg_cstate_info {
	bool skip;
	int msr_index;
	int cstate_id;
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct mdp_device_descriptor_s {
	__u32 number;
	__u32 major;
	__u32 minor;
	__u32 raid_disk;
	__u32 state;
	__u32 reserved[27];
};

typedef struct mdp_device_descriptor_s mdp_disk_t;

struct mdp_superblock_s {
	__u32 md_magic;
	__u32 major_version;
	__u32 minor_version;
	__u32 patch_version;
	__u32 gvalid_words;
	__u32 set_uuid0;
	__u32 ctime;
	__u32 level;
	__u32 size;
	__u32 nr_disks;
	__u32 raid_disks;
	__u32 md_minor;
	__u32 not_persistent;
	__u32 set_uuid1;
	__u32 set_uuid2;
	__u32 set_uuid3;
	__u32 gstate_creserved[16];
	__u32 utime;
	__u32 state;
	__u32 active_disks;
	__u32 working_disks;
	__u32 failed_disks;
	__u32 spare_disks;
	__u32 sb_csum;
	__u32 events_lo;
	__u32 events_hi;
	__u32 cp_events_lo;
	__u32 cp_events_hi;
	__u32 recovery_cp;
	__u64 reshape_position;
	__u32 new_level;
	__u32 delta_disks;
	__u32 new_layout;
	__u32 new_chunk;
	__u32 gstate_sreserved[14];
	__u32 layout;
	__u32 chunk_size;
	__u32 root_pv;
	__u32 root_block;
	__u32 pstate_reserved[60];
	mdp_disk_t disks[27];
	__u32 reserved[0];
	mdp_disk_t this_disk;
};

typedef struct mdp_superblock_s mdp_super_t;

struct mdp_superblock_1 {
	__le32 magic;
	__le32 major_version;
	__le32 feature_map;
	__le32 pad0;
	__u8 set_uuid[16];
	char set_name[32];
	__le64 ctime;
	__le32 level;
	__le32 layout;
	__le64 size;
	__le32 chunksize;
	__le32 raid_disks;
	union {
		__le32 bitmap_offset;
		struct {
			__le16 offset;
			__le16 size;
		} ppl;
	};
	__le32 new_level;
	__le64 reshape_position;
	__le32 delta_disks;
	__le32 new_layout;
	__le32 new_chunk;
	__le32 new_offset;
	__le64 data_offset;
	__le64 data_size;
	__le64 super_offset;
	union {
		__le64 recovery_offset;
		__le64 journal_tail;
	};
	__le32 dev_number;
	__le32 cnt_corrected_read;
	__u8 device_uuid[16];
	__u8 devflags;
	__u8 bblog_shift;
	__le16 bblog_size;
	__le32 bblog_offset;
	__le64 utime;
	__le64 events;
	__le64 resync_offset;
	__le32 sb_csum;
	__le32 max_dev;
	__u8 pad3[32];
	__le16 dev_roles[0];
};

struct mdu_version_s {
	int major;
	int minor;
	int patchlevel;
};

typedef struct mdu_version_s mdu_version_t;

struct mdu_array_info_s {
	int major_version;
	int minor_version;
	int patch_version;
	unsigned int ctime;
	int level;
	int size;
	int nr_disks;
	int raid_disks;
	int md_minor;
	int not_persistent;
	unsigned int utime;
	int state;
	int active_disks;
	int working_disks;
	int failed_disks;
	int spare_disks;
	int layout;
	int chunk_size;
};

typedef struct mdu_array_info_s mdu_array_info_t;

struct mdu_disk_info_s {
	int number;
	int major;
	int minor;
	int raid_disk;
	int state;
};

typedef struct mdu_disk_info_s mdu_disk_info_t;

struct mdu_bitmap_file_s {
	char pathname[4096];
};

typedef struct mdu_bitmap_file_s mdu_bitmap_file_t;

struct mddev;

struct md_rdev;

struct md_cluster_operations {
	int (*join)(struct mddev *, int);
	int (*leave)(struct mddev *);
	int (*slot_number)(struct mddev *);
	int (*resync_info_update)(struct mddev *, sector_t, sector_t);
	void (*resync_info_get)(struct mddev *, sector_t *, sector_t *);
	int (*metadata_update_start)(struct mddev *);
	int (*metadata_update_finish)(struct mddev *);
	void (*metadata_update_cancel)(struct mddev *);
	int (*resync_start)(struct mddev *);
	int (*resync_finish)(struct mddev *);
	int (*area_resyncing)(struct mddev *, int, sector_t, sector_t);
	int (*add_new_disk)(struct mddev *, struct md_rdev *);
	void (*add_new_disk_cancel)(struct mddev *);
	int (*new_disk_ack)(struct mddev *, bool);
	int (*remove_disk)(struct mddev *, struct md_rdev *);
	void (*load_bitmaps)(struct mddev *, int);
	int (*gather_bitmaps)(struct md_rdev *);
	int (*resize_bitmaps)(struct mddev *, sector_t, sector_t);
	int (*lock_all_bitmaps)(struct mddev *);
	void (*unlock_all_bitmaps)(struct mddev *);
	void (*update_size)(struct mddev *, sector_t);
};

struct md_cluster_info;

struct md_personality;

struct md_thread;

struct bitmap;

struct mddev {
	void *private;
	struct md_personality *pers;
	dev_t unit;
	int md_minor;
	struct list_head disks;
	long unsigned int flags;
	long unsigned int sb_flags;
	int suspended;
	atomic_t active_io;
	int ro;
	int sysfs_active;
	struct gendisk *gendisk;
	struct kobject kobj;
	int hold_active;
	int major_version;
	int minor_version;
	int patch_version;
	int persistent;
	int external;
	char metadata_type[17];
	int chunk_sectors;
	time64_t ctime;
	time64_t utime;
	int level;
	int layout;
	char clevel[16];
	int raid_disks;
	int max_disks;
	sector_t dev_sectors;
	sector_t array_sectors;
	int external_size;
	__u64 events;
	int can_decrease_events;
	char uuid[16];
	sector_t reshape_position;
	int delta_disks;
	int new_level;
	int new_layout;
	int new_chunk_sectors;
	int reshape_backwards;
	struct md_thread *thread;
	struct md_thread *sync_thread;
	char *last_sync_action;
	sector_t curr_resync;
	sector_t curr_resync_completed;
	long unsigned int resync_mark;
	sector_t resync_mark_cnt;
	sector_t curr_mark_cnt;
	sector_t resync_max_sectors;
	atomic64_t resync_mismatches;
	sector_t suspend_lo;
	sector_t suspend_hi;
	int sync_speed_min;
	int sync_speed_max;
	int parallel_resync;
	int ok_start_degraded;
	long unsigned int recovery;
	int recovery_disabled;
	int in_sync;
	struct mutex open_mutex;
	struct mutex reconfig_mutex;
	atomic_t active;
	atomic_t openers;
	int changed;
	int degraded;
	atomic_t recovery_active;
	wait_queue_head_t recovery_wait;
	sector_t recovery_cp;
	sector_t resync_min;
	sector_t resync_max;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_action;
	struct kernfs_node *sysfs_completed;
	struct kernfs_node *sysfs_degraded;
	struct kernfs_node *sysfs_level;
	struct work_struct del_work;
	spinlock_t lock;
	wait_queue_head_t sb_wait;
	atomic_t pending_writes;
	unsigned int safemode;
	unsigned int safemode_delay;
	struct timer_list safemode_timer;
	struct percpu_ref writes_pending;
	int sync_checkers;
	struct request_queue *queue;
	struct bitmap *bitmap;
	struct {
		struct file *file;
		loff_t offset;
		long unsigned int space;
		loff_t default_offset;
		long unsigned int default_space;
		struct mutex mutex;
		long unsigned int chunksize;
		long unsigned int daemon_sleep;
		long unsigned int max_write_behind;
		int external;
		int nodes;
		char cluster_name[64];
	} bitmap_info;
	atomic_t max_corr_read_errors;
	struct list_head all_mddevs;
	struct attribute_group *to_remove;
	struct bio_set bio_set;
	struct bio_set sync_set;
	mempool_t md_io_pool;
	struct bio *flush_bio;
	atomic_t flush_pending;
	ktime_t start_flush;
	ktime_t last_flush;
	struct work_struct flush_work;
	struct work_struct event_work;
	mempool_t *serial_info_pool;
	void (*sync_super)(struct mddev *, struct md_rdev *);
	struct md_cluster_info *cluster_info;
	unsigned int good_device_nr;
	unsigned int noio_flag;
	bool has_superblocks: 1;
	bool fail_last_dev: 1;
	bool serialize_policy: 1;
};

struct serial_in_rdev;

struct md_rdev {
	struct list_head same_set;
	sector_t sectors;
	struct mddev *mddev;
	int last_events;
	struct block_device *meta_bdev;
	struct block_device *bdev;
	struct page *sb_page;
	struct page *bb_page;
	int sb_loaded;
	__u64 sb_events;
	sector_t data_offset;
	sector_t new_data_offset;
	sector_t sb_start;
	int sb_size;
	int preferred_minor;
	struct kobject kobj;
	long unsigned int flags;
	wait_queue_head_t blocked_wait;
	int desc_nr;
	int raid_disk;
	int new_raid_disk;
	int saved_raid_disk;
	union {
		sector_t recovery_offset;
		sector_t journal_tail;
	};
	atomic_t nr_pending;
	atomic_t read_errors;
	time64_t last_read_error;
	atomic_t corrected_errors;
	struct serial_in_rdev *serial;
	struct work_struct del_work;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_unack_badblocks;
	struct kernfs_node *sysfs_badblocks;
	struct badblocks badblocks;
	struct {
		short int offset;
		unsigned int size;
		sector_t sector;
	} ppl;
};

struct serial_in_rdev {
	struct rb_root_cached serial_rb;
	spinlock_t serial_lock;
	wait_queue_head_t serial_io_wait;
};

enum flag_bits {
	Faulty = 0,
	In_sync = 1,
	Bitmap_sync = 2,
	WriteMostly = 3,
	AutoDetected = 4,
	Blocked = 5,
	WriteErrorSeen = 6,
	FaultRecorded = 7,
	BlockedBadBlocks = 8,
	WantReplacement = 9,
	Replacement = 10,
	Candidate = 11,
	Journal = 12,
	ClusterRemove = 13,
	RemoveSynchronized = 14,
	ExternalBbl = 15,
	FailFast = 16,
	LastDev = 17,
	CollisionCheck = 18,
};

enum mddev_flags {
	MD_ARRAY_FIRST_USE = 0,
	MD_CLOSING = 1,
	MD_JOURNAL_CLEAN = 2,
	MD_HAS_JOURNAL = 3,
	MD_CLUSTER_RESYNC_LOCKED = 4,
	MD_FAILFAST_SUPPORTED = 5,
	MD_HAS_PPL = 6,
	MD_HAS_MULTIPLE_PPLS = 7,
	MD_ALLOW_SB_UPDATE = 8,
	MD_UPDATING_SB = 9,
	MD_NOT_READY = 10,
	MD_BROKEN = 11,
};

enum mddev_sb_flags {
	MD_SB_CHANGE_DEVS = 0,
	MD_SB_CHANGE_CLEAN = 1,
	MD_SB_CHANGE_PENDING = 2,
	MD_SB_NEED_REWRITE = 3,
};

struct md_personality {
	char *name;
	int level;
	struct list_head list;
	struct module *owner;
	bool (*make_request)(struct mddev *, struct bio *);
	int (*run)(struct mddev *);
	int (*start)(struct mddev *);
	void (*free)(struct mddev *, void *);
	void (*status)(struct seq_file *, struct mddev *);
	void (*error_handler)(struct mddev *, struct md_rdev *);
	int (*hot_add_disk)(struct mddev *, struct md_rdev *);
	int (*hot_remove_disk)(struct mddev *, struct md_rdev *);
	int (*spare_active)(struct mddev *);
	sector_t (*sync_request)(struct mddev *, sector_t, int *);
	int (*resize)(struct mddev *, sector_t);
	sector_t (*size)(struct mddev *, sector_t, int);
	int (*check_reshape)(struct mddev *);
	int (*start_reshape)(struct mddev *);
	void (*finish_reshape)(struct mddev *);
	void (*update_reshape_pos)(struct mddev *);
	void (*quiesce)(struct mddev *, int);
	void * (*takeover)(struct mddev *);
	int (*change_consistency_policy)(struct mddev *, const char *);
};

struct md_thread {
	void (*run)(struct md_thread *);
	struct mddev *mddev;
	wait_queue_head_t wqueue;
	long unsigned int flags;
	struct task_struct *tsk;
	long unsigned int timeout;
	void *private;
};

struct bitmap_page;

struct bitmap_counts {
	spinlock_t lock;
	struct bitmap_page *bp;
	long unsigned int pages;
	long unsigned int missing_pages;
	long unsigned int chunkshift;
	long unsigned int chunks;
};

struct bitmap_storage {
	struct file *file;
	struct page *sb_page;
	struct page **filemap;
	long unsigned int *filemap_attr;
	long unsigned int file_pages;
	long unsigned int bytes;
};

struct bitmap {
	struct bitmap_counts counts;
	struct mddev *mddev;
	__u64 events_cleared;
	int need_sync;
	struct bitmap_storage storage;
	long unsigned int flags;
	int allclean;
	atomic_t behind_writes;
	long unsigned int behind_writes_used;
	long unsigned int daemon_lastrun;
	long unsigned int last_end_sync;
	atomic_t pending_writes;
	wait_queue_head_t write_wait;
	wait_queue_head_t overflow_wait;
	wait_queue_head_t behind_wait;
	struct kernfs_node *sysfs_can_clear;
	int cluster_slot;
};

enum recovery_flags {
	MD_RECOVERY_RUNNING = 0,
	MD_RECOVERY_SYNC = 1,
	MD_RECOVERY_RECOVER = 2,
	MD_RECOVERY_INTR = 3,
	MD_RECOVERY_DONE = 4,
	MD_RECOVERY_NEEDED = 5,
	MD_RECOVERY_REQUESTED = 6,
	MD_RECOVERY_CHECK = 7,
	MD_RECOVERY_RESHAPE = 8,
	MD_RECOVERY_FROZEN = 9,
	MD_RECOVERY_ERROR = 10,
	MD_RECOVERY_WAIT = 11,
	MD_RESYNCING_REMOTE = 12,
};

struct md_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct mddev *, char *);
	ssize_t (*store)(struct mddev *, const char *, size_t);
};

struct bitmap_page {
	char *map;
	unsigned int hijacked: 1;
	unsigned int pending: 1;
	unsigned int count: 30;
};

struct md_io {
	struct mddev *mddev;
	bio_end_io_t *orig_bi_end_io;
	void *orig_bi_private;
	long unsigned int start_time;
	struct hd_struct *part;
};

struct super_type {
	char *name;
	struct module *owner;
	int (*load_super)(struct md_rdev *, struct md_rdev *, int);
	int (*validate_super)(struct mddev *, struct md_rdev *);
	void (*sync_super)(struct mddev *, struct md_rdev *);
	long long unsigned int (*rdev_size_change)(struct md_rdev *, sector_t);
	int (*allow_new_offset)(struct md_rdev *, long long unsigned int);
};

struct rdev_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct md_rdev *, char *);
	ssize_t (*store)(struct md_rdev *, const char *, size_t);
};

enum array_state {
	clear = 0,
	inactive = 1,
	suspended = 2,
	readonly = 3,
	read_auto = 4,
	clean = 5,
	active = 6,
	write_pending = 7,
	active_idle = 8,
	broken = 9,
	bad_word = 10,
};

struct detected_devices_node {
	struct list_head list;
	dev_t dev;
};

typedef __u16 bitmap_counter_t;

enum bitmap_state {
	BITMAP_STALE = 1,
	BITMAP_WRITE_ERROR = 2,
	BITMAP_HOSTENDIAN = 15,
};

struct bitmap_super_s {
	__le32 magic;
	__le32 version;
	__u8 uuid[16];
	__le64 events;
	__le64 events_cleared;
	__le64 sync_size;
	__le32 state;
	__le32 chunksize;
	__le32 daemon_sleep;
	__le32 write_behind;
	__le32 sectors_reserved;
	__le32 nodes;
	__u8 cluster_name[64];
	__u8 pad[120];
};

typedef struct bitmap_super_s bitmap_super_t;

enum bitmap_page_attr {
	BITMAP_PAGE_DIRTY = 0,
	BITMAP_PAGE_PENDING = 1,
	BITMAP_PAGE_NEEDWRITE = 2,
};

struct md_setup_args {
	int minor;
	int partitioned;
	int level;
	int chunk;
	char *device_names;
};

struct dm_kobject_holder {
	struct kobject kobj;
	struct completion completion;
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	unsigned int (*resolve_freq)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	void (*stop_cpu)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
};

struct cpufreq_stats {
	unsigned int total_trans;
	long long unsigned int last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	long long unsigned int reset_time;
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_data {
	struct gov_attr_set attr_set;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cs_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int down_skip;
	unsigned int requested_freq;
};

struct cs_dbs_tuners {
	unsigned int down_threshold;
	unsigned int freq_step;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

enum {
	UNDEFINED_CAPABLE = 0,
	SYSTEM_INTEL_MSR_CAPABLE = 1,
	SYSTEM_AMD_MSR_CAPABLE = 2,
	SYSTEM_IO_CAPABLE = 3,
};

struct acpi_cpufreq_data {
	unsigned int resume;
	unsigned int cpu_feature;
	unsigned int acpi_perf_cpu;
	cpumask_var_t freqdomain_cpus;
	void (*cpu_freq_write)(struct acpi_pct_register *, u32);
	u32 (*cpu_freq_read)(struct acpi_pct_register *);
};

struct drv_cmd {
	struct acpi_pct_register *reg;
	u32 val;
	union {
		void (*write)(struct acpi_pct_register *, u32);
		u32 (*read)(struct acpi_pct_register *);
	} func;
};

struct powernow_k8_data {
	unsigned int cpu;
	u32 numps;
	u32 batps;
	u32 rvo;
	u32 irt;
	u32 vidmvs;
	u32 vstable;
	u32 plllock;
	u32 exttype;
	u32 currvid;
	u32 currfid;
	struct cpufreq_frequency_table *powernow_table;
	struct acpi_processor_performance acpi_data;
	struct cpumask *available_cores;
};

struct psb_s {
	u8 signature[10];
	u8 tableversion;
	u8 flags1;
	u16 vstable;
	u8 flags2;
	u8 num_tables;
	u32 cpuid;
	u8 plllocktime;
	u8 maxfid;
	u8 maxvid;
	u8 numps;
};

struct pst_s {
	u8 fid;
	u8 vid;
};

struct powernowk8_target_arg {
	struct cpufreq_policy *pol;
	unsigned int newstate;
};

struct init_on_cpu {
	struct powernow_k8_data *data;
	int rc;
};

enum acpi_preferred_pm_profiles {
	PM_UNSPECIFIED = 0,
	PM_DESKTOP = 1,
	PM_MOBILE = 2,
	PM_WORKSTATION = 3,
	PM_ENTERPRISE_SERVER = 4,
	PM_SOHO_SERVER = 5,
	PM_APPLIANCE_PC = 6,
	PM_PERFORMANCE_SERVER = 7,
	PM_TABLET = 8,
};

struct sample {
	int32_t core_avg_perf;
	int32_t busy_scaled;
	u64 aperf;
	u64 mperf;
	u64 tsc;
	u64 time;
};

struct pstate_data {
	int current_pstate;
	int min_pstate;
	int max_pstate;
	int max_pstate_physical;
	int scaling;
	int turbo_pstate;
	unsigned int max_freq;
	unsigned int turbo_freq;
};

struct vid_data {
	int min;
	int max;
	int turbo;
	int32_t ratio;
};

struct global_params {
	bool no_turbo;
	bool turbo_disabled;
	bool turbo_disabled_mf;
	int max_perf_pct;
	int min_perf_pct;
};

struct cpudata {
	int cpu;
	unsigned int policy;
	struct update_util_data update_util;
	bool update_util_set;
	struct pstate_data pstate;
	struct vid_data vid;
	u64 last_update;
	u64 last_sample_time;
	u64 aperf_mperf_shift;
	u64 prev_aperf;
	u64 prev_mperf;
	u64 prev_tsc;
	u64 prev_cummulative_iowait;
	struct sample sample;
	int32_t min_perf_ratio;
	int32_t max_perf_ratio;
	struct acpi_processor_performance acpi_perf_data;
	bool valid_pss_table;
	unsigned int iowait_boost;
	s16 epp_powersave;
	s16 epp_policy;
	s16 epp_default;
	s16 epp_cached;
	u64 hwp_req_cached;
	u64 hwp_cap_cached;
	u64 last_io_update;
	unsigned int sched_flags;
	u32 hwp_boost_min;
	bool suspended;
};

struct pstate_funcs {
	int (*get_max)();
	int (*get_max_physical)();
	int (*get_min)();
	int (*get_turbo)();
	int (*get_scaling)();
	int (*get_aperf_mperf_shift)();
	u64 (*get_val)(struct cpudata *, int);
	void (*get_vid)(struct cpudata *);
};

enum {
	PSS = 0,
	PPC = 1,
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct ladder_device_state {
	struct {
		u32 promotion_count;
		u32 demotion_count;
		u64 promotion_time_ns;
		u64 demotion_time_ns;
	} threshold;
	struct {
		int promotion_count;
		int demotion_count;
	} stats;
};

struct ladder_device {
	struct ladder_device_state states[10];
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
	u8 type;
};

struct dmi_device_attribute {
	struct device_attribute dev_attr;
	int field;
};

struct mafield {
	const char *prefix;
	int field;
};

struct firmware_map_entry {
	u64 start;
	u64 end;
	const char *type;
	struct list_head list;
	struct kobject kobj;
};

struct memmap_attribute {
	struct attribute attr;
	ssize_t (*show)(struct firmware_map_entry *, char *);
};

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
};

struct efivars {
	struct kset *kset;
	struct kobject *kobject;
	const struct efivar_operations *ops;
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	long unsigned int DataSize;
	__u8 Data[1024];
	efi_status_t Status;
	__u32 Attributes;
} __attribute__((packed));

struct efivar_entry {
	struct efi_variable var;
	struct list_head list;
	struct kobject kobj;
	bool scanning;
	bool deleting;
};

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, long unsigned int);
};

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 reserved;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);

typedef u64 efi_physical_addr_t;

typedef struct {
	u64 length;
	u64 data;
} efi_capsule_block_desc_t;

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
	ssize_t (*store)(struct esre_entry *, const char *, size_t);
};

struct efi_runtime_map_entry {
	efi_memory_desc_t md;
	struct kobject kobj;
};

struct map_attribute {
	struct attribute attr;
	ssize_t (*show)(struct efi_runtime_map_entry *, char *);
};

struct dca_domain {
	struct list_head node;
	struct list_head dca_providers;
	struct pci_bus *pci_rc;
};

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_report;

struct hid_input;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
};

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	unsigned int id;
	unsigned int type;
	unsigned int application;
	struct hid_field *field[256];
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	bool registered;
	struct list_head reports;
	unsigned int application;
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	struct device dev;
	struct hid_driver *driver;
	struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

struct a4tech_sc {
	long unsigned int quirks;
	unsigned int hw_wheel;
	__s32 delayed_value;
};

struct apple_sc {
	long unsigned int quirks;
	unsigned int fn_on;
	unsigned int fn_found;
	long unsigned int pressed_numlock[12];
};

struct apple_key_translation {
	u16 from;
	u16 to;
	u8 flags;
};

struct lg_drv_data {
	long unsigned int quirks;
	void *device_props;
};

struct dev_type {
	u16 idVendor;
	u16 idProduct;
	const short int *ff;
};

struct lg4ff_wheel_data {
	const u32 product_id;
	u16 combine;
	u16 range;
	const u16 min_range;
	const u16 max_range;
	u8 led_state;
	struct led_classdev *led[5];
	const u32 alternate_modes;
	const char * const real_tag;
	const char * const real_name;
	const u16 real_product_id;
	void (*set_range)(struct hid_device *, u16);
};

struct lg4ff_device_entry {
	spinlock_t report_lock;
	struct hid_report *report;
	struct lg4ff_wheel_data wdata;
};

struct lg4ff_wheel {
	const u32 product_id;
	const short int *ff_effects;
	const u16 min_range;
	const u16 max_range;
	void (*set_range)(struct hid_device *, u16);
};

struct lg4ff_compat_mode_switch {
	const u8 cmd_count;
	const u8 cmd[0];
};

struct lg4ff_wheel_ident_info {
	const u32 modes;
	const u16 mask;
	const u16 result;
	const u16 real_product_id;
};

struct lg4ff_multimode_wheel {
	const u16 product_id;
	const u32 alternate_modes;
	const char *real_tag;
	const char *real_name;
};

struct lg4ff_alternate_mode {
	const u16 product_id;
	const char *tag;
	const char *name;
};

enum lg_g15_model {
	LG_G15 = 0,
	LG_G15_V2 = 1,
	LG_G510 = 2,
	LG_G510_USB_AUDIO = 3,
};

enum lg_g15_led_type {
	LG_G15_KBD_BRIGHTNESS = 0,
	LG_G15_LCD_BRIGHTNESS = 1,
	LG_G15_BRIGHTNESS_MAX = 2,
	LG_G15_MACRO_PRESET1 = 2,
	LG_G15_MACRO_PRESET2 = 3,
	LG_G15_MACRO_PRESET3 = 4,
	LG_G15_MACRO_RECORD = 5,
	LG_G15_LED_MAX = 6,
};

struct lg_g15_led {
	struct led_classdev cdev;
	enum led_brightness brightness;
	enum lg_g15_led_type led;
	u8 red;
	u8 green;
	u8 blue;
};

struct lg_g15_data {
	u8 transfer_buf[20];
	struct mutex mutex;
	struct work_struct work;
	struct input_dev *input;
	struct hid_device *hdev;
	enum lg_g15_model model;
	struct lg_g15_led leds[6];
	bool game_mode_enabled;
};

struct ms_data {
	long unsigned int quirks;
	struct hid_device *hdev;
	struct work_struct ff_worker;
	__u8 strong;
	__u8 weak;
	void *output_report_dmabuf;
};

enum {
	MAGNITUDE_STRONG = 2,
	MAGNITUDE_WEAK = 3,
	MAGNITUDE_NUM = 4,
};

struct xb1s_ff_report {
	__u8 report_id;
	__u8 enable;
	__u8 magnitude[4];
	__u8 duration_10ms;
	__u8 start_delay_10ms;
	__u8 loop_count;
};

struct ntrig_data {
	__u16 x;
	__u16 y;
	__u16 w;
	__u16 h;
	__u16 id;
	bool tipswitch;
	bool confidence;
	bool first_contact_touch;
	bool reading_mt;
	__u8 mt_footer[4];
	__u8 mt_foot_count;
	__s8 act_state;
	__s8 deactivate_slack;
	__s8 activate_slack;
	__u16 min_width;
	__u16 min_height;
	__u16 activation_width;
	__u16 activation_height;
	__u16 sensor_logical_width;
	__u16 sensor_logical_height;
	__u16 sensor_physical_width;
	__u16 sensor_physical_height;
};

struct sixaxis_led {
	u8 time_enabled;
	u8 duty_length;
	u8 enabled;
	u8 duty_off;
	u8 duty_on;
};

struct sixaxis_rumble {
	u8 padding;
	u8 right_duration;
	u8 right_motor_on;
	u8 left_duration;
	u8 left_motor_force;
};

struct sixaxis_output_report {
	u8 report_id;
	struct sixaxis_rumble rumble;
	u8 padding[4];
	u8 leds_bitmap;
	struct sixaxis_led led[4];
	struct sixaxis_led _reserved;
};

union sixaxis_output_report_01 {
	struct sixaxis_output_report data;
	u8 buf[36];
};

struct motion_output_report_02 {
	u8 type;
	u8 zero;
	u8 r;
	u8 g;
	u8 b;
	u8 zero2;
	u8 rumble;
};

struct ds4_calibration_data {
	int abs_code;
	short int bias;
	int sens_numer;
	int sens_denom;
};

enum ds4_dongle_state {
	DONGLE_DISCONNECTED = 0,
	DONGLE_CALIBRATING = 1,
	DONGLE_CONNECTED = 2,
	DONGLE_DISABLED = 3,
};

enum sony_worker {
	SONY_WORKER_STATE = 0,
	SONY_WORKER_HOTPLUG = 1,
};

struct sony_sc {
	spinlock_t lock;
	struct list_head list_node;
	struct hid_device *hdev;
	struct input_dev *touchpad;
	struct input_dev *sensor_dev;
	struct led_classdev *leds[4];
	long unsigned int quirks;
	struct work_struct hotplug_worker;
	struct work_struct state_worker;
	void (*send_output_report)(struct sony_sc *);
	struct power_supply *battery;
	struct power_supply_desc battery_desc;
	int device_id;
	unsigned int fw_version;
	unsigned int hw_version;
	u8 *output_report_dmabuf;
	u8 mac_address[6];
	u8 hotplug_worker_initialized;
	u8 state_worker_initialized;
	u8 defer_initialization;
	u8 cable_state;
	u8 battery_charging;
	u8 battery_capacity;
	u8 led_state[4];
	u8 led_delay_on[4];
	u8 led_delay_off[4];
	u8 led_count;
	bool timestamp_initialized;
	u16 prev_timestamp;
	unsigned int timestamp_us;
	u8 ds4_bt_poll_interval;
	enum ds4_dongle_state ds4_dongle_state;
	struct ds4_calibration_data ds4_calib_data[6];
};

struct tmff_device {
	struct hid_report *report;
	struct hid_field *ff_field;
};

struct zpff_device {
	struct hid_report *report;
};

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	long unsigned int last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	long unsigned int last_out;
	struct mutex mutex;
	spinlock_t lock;
	long unsigned int iofl;
	struct timer_list io_retry;
	long unsigned int stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct hiddev_event {
	unsigned int hid;
	int value;
};

struct hiddev_devinfo {
	__u32 bustype;
	__u32 busnum;
	__u32 devnum;
	__u32 ifnum;
	__s16 vendor;
	__s16 product;
	__s16 version;
	__u32 num_applications;
};

struct hiddev_collection_info {
	__u32 index;
	__u32 type;
	__u32 usage;
	__u32 level;
};

struct hiddev_report_info {
	__u32 report_type;
	__u32 report_id;
	__u32 num_fields;
};

struct hiddev_field_info {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 maxusage;
	__u32 flags;
	__u32 physical;
	__u32 logical;
	__u32 application;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__u32 unit_exponent;
	__u32 unit;
};

struct hiddev_usage_ref {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 usage_index;
	__u32 usage_code;
	__s32 value;
};

struct hiddev_usage_ref_multi {
	struct hiddev_usage_ref uref;
	__u32 num_values;
	__s32 values[1024];
};

struct hiddev_list {
	struct hiddev_usage_ref buffer[2048];
	int head;
	int tail;
	unsigned int flags;
	struct fasync_struct *fasync;
	struct hiddev *hiddev;
	struct list_head node;
	struct mutex thread_lock;
};

struct pidff_usage {
	struct hid_field *field;
	s32 *value;
};

struct pidff_device {
	struct hid_device *hid;
	struct hid_report *reports[13];
	struct pidff_usage set_effect[7];
	struct pidff_usage set_envelope[5];
	struct pidff_usage set_condition[8];
	struct pidff_usage set_periodic[5];
	struct pidff_usage set_constant[2];
	struct pidff_usage set_ramp[3];
	struct pidff_usage device_gain[1];
	struct pidff_usage block_load[2];
	struct pidff_usage pool[3];
	struct pidff_usage effect_operation[2];
	struct pidff_usage block_free[1];
	struct hid_field *create_new_effect_type;
	struct hid_field *set_effect_type;
	struct hid_field *effect_direction;
	struct hid_field *device_control;
	struct hid_field *block_load_status;
	struct hid_field *effect_operation_status;
	int control_id[2];
	int type_id[11];
	int status_id[2];
	int operation_id[2];
	int pid_id[64];
};

struct pmc_bit_map {
	const char *name;
	u32 bit_mask;
};

struct pmc_reg_map {
	const struct pmc_bit_map *d3_sts_0;
	const struct pmc_bit_map *d3_sts_1;
	const struct pmc_bit_map *func_dis;
	const struct pmc_bit_map *func_dis_2;
	const struct pmc_bit_map *pss;
};

struct pmc_data {
	const struct pmc_reg_map *map;
	const struct pmc_clk *clks;
};

struct pmc_dev {
	u32 base_addr;
	void *regmap;
	const struct pmc_reg_map *map;
	struct dentry *dbgfs_dir;
	bool init;
};

struct acpi_table_pcct {
	struct acpi_table_header header;
	u32 flags;
	u64 reserved;
};

enum acpi_pcct_type {
	ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 1,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 2,
	ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 3,
	ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 4,
	ACPI_PCCT_TYPE_RESERVED = 5,
};

struct acpi_pcct_subspace {
	struct acpi_subtable_header header;
	u8 reserved[6];
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_hw_reduced_type2 {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_write_mask;
} __attribute__((packed));

struct cper_sec_proc_arm {
	u32 validation_bits;
	u16 err_info_num;
	u16 context_info_num;
	u32 section_length;
	u8 affinity_level;
	u8 reserved[3];
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
};

enum hw_event_mc_err_type {
	HW_EVENT_ERR_CORRECTED = 0,
	HW_EVENT_ERR_UNCORRECTED = 1,
	HW_EVENT_ERR_DEFERRED = 2,
	HW_EVENT_ERR_FATAL = 3,
	HW_EVENT_ERR_INFO = 4,
};

struct aer_header_log_regs {
	unsigned int dw0;
	unsigned int dw1;
	unsigned int dw2;
	unsigned int dw3;
};

struct trace_event_raw_mc_event {
	struct trace_entry ent;
	unsigned int error_type;
	u32 __data_loc_msg;
	u32 __data_loc_label;
	u16 error_count;
	u8 mc_index;
	s8 top_layer;
	s8 middle_layer;
	s8 lower_layer;
	long int address;
	u8 grain_bits;
	long int syndrome;
	u32 __data_loc_driver_detail;
	char __data[0];
};

struct trace_event_raw_arm_event {
	struct trace_entry ent;
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
	u8 affinity;
	char __data[0];
};

struct trace_event_raw_non_standard_event {
	struct trace_entry ent;
	char sec_type[16];
	char fru_id[16];
	u32 __data_loc_fru_text;
	u8 sev;
	u32 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_aer_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 status;
	u8 severity;
	u8 tlp_header_valid;
	u32 tlp_header[4];
	char __data[0];
};

struct trace_event_raw_memory_failure_event {
	struct trace_entry ent;
	long unsigned int pfn;
	int type;
	int result;
	char __data[0];
};

struct trace_event_data_offsets_mc_event {
	u32 msg;
	u32 label;
	u32 driver_detail;
};

struct trace_event_data_offsets_arm_event {};

struct trace_event_data_offsets_non_standard_event {
	u32 fru_text;
	u32 buf;
};

struct trace_event_data_offsets_aer_event {
	u32 dev_name;
};

struct trace_event_data_offsets_memory_failure_event {};

typedef void (*btf_trace_mc_event)(void *, const unsigned int, const char *, const char *, const int, const u8, const s8, const s8, const s8, long unsigned int, const u8, long unsigned int, const char *);

typedef void (*btf_trace_arm_event)(void *, const struct cper_sec_proc_arm *);

typedef void (*btf_trace_non_standard_event)(void *, const guid_t *, const guid_t *, const char *, const u8, const u8 *, const u32);

typedef void (*btf_trace_aer_event)(void *, const char *, const u32, const u8, const u8, struct aer_header_log_regs *);

typedef void (*btf_trace_memory_failure_event)(void *, long unsigned int, int, int);

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device___2 {
	struct module *owner;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc___2 *wp_gpio;
	void *priv;
};

struct nvmem_cell {
	const char *name;
	int offset;
	int bytes;
	int bit_offset;
	int nbits;
	struct device_node *np;
	struct nvmem_device___2 *nvmem;
	struct list_head node;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

struct compat_ethtool_rx_flow_spec {
	u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	compat_u64 ring_cookie;
	u32 location;
} __attribute__((packed));

struct compat_ethtool_rxnfc {
	u32 cmd;
	u32 flow_type;
	compat_u64 data;
	struct compat_ethtool_rx_flow_spec fs;
	u32 rule_cnt;
	u32 rule_locs[0];
} __attribute__((packed));

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct sock_skb_cb {
	u32 dropcount;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct prot_inuse {
	int val[64];
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_bind_bucket;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	struct hlist_node icsk_listen_portaddr_node;
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int enabled;
		int search_high;
		int search_low;
		int probe_size;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_sock_af_ops;

struct tcp_md5sig_info;

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 max_packets_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	const struct tcp_sock_af_ops *af_specific;
	struct tcp_md5sig_info *md5sig_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct tcp_md5sig_key;

struct tcp_sock_af_ops {
	struct tcp_md5sig_key * (*md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	int (*md5_parse)(struct sock *, int, sockptr_t, int);
};

struct tcp_md5sig_info {
	struct hlist_head head;
	struct callback_head rcu;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	union tcp_md5_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct net_protocol {
	int (*early_demux)(struct sk_buff *);
	int (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int netns_ok: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct tcp_md5sig_key * (*req_md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	void (*init_req)(struct request_sock *, const struct sock *, struct sk_buff *);
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct flowi *, const struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
};

struct sec_path {
	int len;
	int olen;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

struct ahash_request___2;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
	u32 secid;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator___2 {
	struct gnet_stats_basic_packed *bstats;
	spinlock_t *stats_lock;
	seqcount_t *running;
	struct gnet_stats_basic_cpu *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	int: 32;
};

struct flow_keys_digest {
	u8 data[16];
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct mpls_label {
	__be32 entry;
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_NUMHOOKS = 1,
};

struct netdev_boot_setup {
	char name[16];
	struct ifmap map;
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_DROP = 4,
	GRO_CONSUMED = 5,
};

typedef enum gro_result gro_result_t;

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	void *af_packet_priv;
	struct list_head list;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	__IPV4_DEVCONF_MAX = 33,
};

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

struct xfrm_dst {
	union {
		struct dst_entry dst;
		struct rtable rt;
		struct rt6_info rt6;
	} u;
	struct dst_entry *route;
	struct dst_entry *child;
	struct dst_entry *path;
	struct xfrm_policy *pols[2];
	int num_pols;
	int num_xfrms;
	u32 xfrm_genid;
	u32 policy_genid;
	u32 route_mtu_cached;
	u32 child_mtu_cached;
	u32 route_cookie;
	u32 path_cookie;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	__NDTPA_MAX = 19,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	__IFLA_BRPORT_MAX = 37,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *);
	int (*set_link_af)(struct net_device *, const struct nlattr *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum bpf_lwt_encap_mode {
	BPF_LWT_ENCAP_SEG6 = 0,
	BPF_LWT_ENCAP_SEG6_INLINE = 1,
	BPF_LWT_ENCAP_IP = 2,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	__u16 tunnel_ext;
	__u32 tunnel_label;
};

struct bpf_xfrm_state {
	__u32 reqid;
	__u32 spi;
	__u16 family;
	__u16 ext;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	__u16 tot_len;
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_kill: 1;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
	struct tcp_md5sig_key *tw_md5_key;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	struct sk_buff_head reader_queue;
	int forward_deficit;
	long: 32;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
};

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 in_flight: 30;
			__u32 is_app_limited: 1;
			__u32 unused: 1;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
		struct {
			__u32 flags;
			struct sock *sk_redir;
			void *data_end;
		} bpf;
	};
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct strp_msg {
	int full_len;
	int offset;
};

struct xdp_sock;

struct xsk_map {
	struct bpf_map map;
	spinlock_t lock;
	struct xdp_sock *xsk_map[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_sock {
	struct sock sk;
	long: 64;
	long: 64;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	spinlock_t tx_completion_lock;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

enum {
	SEG6_LOCAL_ACTION_UNSPEC = 0,
	SEG6_LOCAL_ACTION_END = 1,
	SEG6_LOCAL_ACTION_END_X = 2,
	SEG6_LOCAL_ACTION_END_T = 3,
	SEG6_LOCAL_ACTION_END_DX2 = 4,
	SEG6_LOCAL_ACTION_END_DX6 = 5,
	SEG6_LOCAL_ACTION_END_DX4 = 6,
	SEG6_LOCAL_ACTION_END_DT6 = 7,
	SEG6_LOCAL_ACTION_END_DT4 = 8,
	SEG6_LOCAL_ACTION_END_B6 = 9,
	SEG6_LOCAL_ACTION_END_B6_ENCAP = 10,
	SEG6_LOCAL_ACTION_END_BM = 11,
	SEG6_LOCAL_ACTION_END_S = 12,
	SEG6_LOCAL_ACTION_END_AS = 13,
	SEG6_LOCAL_ACTION_END_AM = 14,
	SEG6_LOCAL_ACTION_END_BPF = 15,
	__SEG6_LOCAL_ACTION_MAX = 16,
};

struct seg6_bpf_srh_state {
	struct ipv6_sr_hdr *srh;
	u16 hdrlen;
	bool valid;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct strparser strp;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	struct sk_buff *recv_pkt;
	u8 control;
	u8 async_capable: 1;
	u8 decrypted: 1;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	bool async_notify;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
	};
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid_curr)();

typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_skb_get_xfrm_state)(struct sk_buff *, u32, struct bpf_xfrm_state *, u32, u64);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_store_bytes)(struct sk_buff *, u32, const void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_action)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_adjust_srh)(struct sk_buff *, u32, s32);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

struct bpf_dtab_netdev___2;

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

typedef int gifconf_func_t(struct net_device *, char *, int, int);

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct xdp_frame_bulk {
	int count;
	void *xa;
	void *q[16];
};

struct pp_alloc_cache {
	u32 count;
	void *cache[128];
};

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_WAKE = 19,
	FLOW_ACTION_QUEUE = 20,
	FLOW_ACTION_SAMPLE = 21,
	FLOW_ACTION_POLICE = 22,
	FLOW_ACTION_CT = 23,
	FLOW_ACTION_CT_METADATA = 24,
	FLOW_ACTION_MPLS_PUSH = 25,
	FLOW_ACTION_MPLS_POP = 26,
	FLOW_ACTION_MPLS_MANGLE = 27,
	FLOW_ACTION_GATE = 28,
	NUM_FLOW_ACTIONS = 29,
};

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

typedef void (*action_destr)(void *);

struct nf_flowtable;

struct action_gate_entry;

struct flow_action_entry {
	enum flow_action_id id;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 index;
			u32 burst;
			u64 rate_bytes_ps;
			u32 mtu;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			u32 index;
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
	};
	struct flow_action_cookie *cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
	struct callback_head rcu;
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *skb_parser;
	struct bpf_prog *skb_verdict;
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct sk_psock_parser {
	struct strparser strp;
	bool enabled;
	void (*saved_data_ready)(struct sock *);
};

struct sk_psock_work_state {
	struct sk_buff *skb;
	u32 len;
	u32 off;
};

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct sk_psock_parser parser;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	struct proto *sk_proto;
	struct sk_psock_work_state work_state;
	struct work_struct work;
	union {
		struct callback_head rcu;
		struct work_struct gc;
	};
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	__FRA_MAX = 25,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_ni_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_rx_ni_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int *sysctl_mem;
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
		unsigned char mac_addr[6];
	} dst;
	__be16 proto;
	__u16 vid;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct mac_addr {
	unsigned char addr[6];
};

typedef struct mac_addr mac_addr;

typedef __u16 port_id;

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	long unsigned int delay_time;
};

struct net_bridge_port;

struct bridge_mcast_querier {
	struct br_ip addr;
	struct net_bridge_port *port;
};

struct net_bridge;

struct net_bridge_vlan_group;

struct bridge_mcast_stats;

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_vlan_group *vlgrp;
	struct net_bridge_port *backup_port;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_own_query ip6_own_query;
	unsigned char multicast_router;
	struct bridge_mcast_stats *mcast_stats;
	struct timer_list multicast_router_timer;
	struct hlist_head mglist;
	struct hlist_node rlist;
	char sysfs_name[16];
	struct netpoll *np;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct hlist_head frame_type_list;
	struct net_device *dev;
	struct pcpu_sw_netstats *stats;
	long unsigned int options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group *vlgrp;
	struct rhashtable fdb_hash_tbl;
	struct list_head port_list;
	union {
		struct rtable fake_rtable;
		struct rt6_info fake_rt6_info;
	};
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	u32 hash_max;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	spinlock_t multicast_lock;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct hlist_head router_list;
	struct timer_list multicast_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct bridge_mcast_stats *mcast_stats;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	struct hlist_head fdb_list;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	long unsigned int flags;
	long: 64;
	long: 64;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

struct clock_identity {
	u8 id[8];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	__LWTUNNEL_ENCAP_MAX = 9,
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

enum {
	LWT_BPF_PROG_UNSPEC = 0,
	LWT_BPF_PROG_FD = 1,
	LWT_BPF_PROG_NAME = 2,
	__LWT_BPF_PROG_MAX = 3,
};

enum {
	LWT_BPF_UNSPEC = 0,
	LWT_BPF_IN = 1,
	LWT_BPF_OUT = 2,
	LWT_BPF_XMIT = 3,
	LWT_BPF_XMIT_HEADROOM = 4,
	__LWT_BPF_MAX = 5,
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct bpf_lwt_prog {
	struct bpf_prog *prog;
	char *name;
};

struct bpf_lwt {
	struct bpf_lwt_prog in;
	struct bpf_lwt_prog out;
	struct bpf_lwt_prog xmit;
	int family;
};

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	raw_spinlock_t lock;
	long: 64;
};

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	raw_spinlock_t lock;
};

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
	long: 32;
	long: 64;
	long: 64;
};

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct genl_dumpit_info {
	const struct genl_family *family;
	struct genl_ops op;
	struct nlattr **attrs;
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	DEVLINK_CMD_TRAP_POLICER_GET = 69,
	DEVLINK_CMD_TRAP_POLICER_SET = 70,
	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
	__DEVLINK_CMD_MAX = 74,
	DEVLINK_CMD_MAX = 73,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
	__DEVLINK_ATTR_STATS_MAX = 3,
	DEVLINK_ATTR_STATS_MAX = 2,
};

enum {
	DEVLINK_FLASH_OVERWRITE_SETTINGS_BIT = 0,
	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS_BIT = 1,
	__DEVLINK_FLASH_OVERWRITE_MAX_BIT = 2,
	DEVLINK_FLASH_OVERWRITE_MAX_BIT = 1,
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	DEVLINK_ATTR_NETNS_FD = 138,
	DEVLINK_ATTR_NETNS_PID = 139,
	DEVLINK_ATTR_NETNS_ID = 140,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
	DEVLINK_ATTR_PORT_FUNCTION = 145,
	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
	DEVLINK_ATTR_PORT_LANES = 147,
	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
	DEVLINK_ATTR_PORT_EXTERNAL = 149,
	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
	DEVLINK_ATTR_RELOAD_ACTION = 153,
	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
	DEVLINK_ATTR_RELOAD_LIMITS = 155,
	DEVLINK_ATTR_DEV_STATS = 156,
	DEVLINK_ATTR_RELOAD_STATS = 157,
	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
	__DEVLINK_ATTR_MAX = 162,
	DEVLINK_ATTR_MAX = 161,
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

enum devlink_dpipe_field_ethernet_id {
	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
};

enum devlink_dpipe_field_ipv4_id {
	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
};

enum devlink_dpipe_field_ipv6_id {
	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
};

enum devlink_dpipe_header_id {
	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
	DEVLINK_DPIPE_HEADER_IPV4 = 1,
	DEVLINK_DPIPE_HEADER_IPV6 = 2,
};

enum devlink_port_function_attr {
	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 2,
	DEVLINK_PORT_FUNCTION_ATTR_MAX = 1,
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
};

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

typedef u64 devlink_resource_occ_get_t(void *);

struct devlink_resource {
	const char *name;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

struct devlink_flash_notify {
	const char *status_msg;
	const char *component;
	long unsigned int done;
	long unsigned int total;
	long unsigned int timeout;
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
	bool published;
};

struct devlink_port_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_port *devlink_port;
	struct devlink_fmsg *dump_fmsg;
	struct mutex dump_lock;
	u64 graceful_period;
	bool auto_recover;
	bool auto_dump;
	u8 health_state;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
	refcount_t refcount;
};

struct devlink_fmsg {
	struct list_head item_list;
	bool putting_binary;
};

struct devlink_trap_metadata {
	const char *trap_name;
	const char *trap_group_name;
	struct net_device *input_dev;
	const struct flow_action_cookie *fa_cookie;
	enum devlink_trap_type trap_type;
};

struct devlink_info_req {
	struct sk_buff *msg;
};

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	long unsigned int type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_raw_devlink_trap_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_trap_name;
	u32 __data_loc_trap_group_name;
	u32 __data_loc_input_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_trap_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 trap_name;
	u32 trap_group_name;
	u32 input_dev_name;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct devlink_region___2 {
	struct devlink *devlink;
	struct devlink_port *port;
	struct list_head list;
	union {
		const struct devlink_region_ops *ops;
		const struct devlink_port_region_ops *port_ops;
	};
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	u64 size;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region___2 *region;
	u8 *data;
	u32 id;
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_reload_combination {
	enum devlink_reload_action action;
	enum devlink_reload_limit limit;
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct devlink_stats {
	u64 rx_bytes;
	u64 rx_packets;
	struct u64_stats_sync syncp;
};

struct devlink_trap_policer_item {
	const struct devlink_trap_policer *policer;
	u64 rate;
	u64 burst;
	struct list_head list;
};

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	struct devlink_trap_policer_item *policer_item;
	struct list_head list;
	struct devlink_stats *stats;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats *stats;
	void *priv;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_UNKNOWN = 6,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct compat_cmsghdr {
	compat_size_t cmsg_len;
	compat_int_t cmsg_level;
	compat_int_t cmsg_type;
};

struct llc_addr {
	unsigned char lsap;
	unsigned char mac[6];
};

struct llc_sap {
	unsigned char state;
	unsigned char p_bit;
	unsigned char f_bit;
	refcount_t refcnt;
	int (*rcv_func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	struct llc_addr laddr;
	struct list_head node;
	spinlock_t sk_lock;
	int sk_count;
	struct hlist_nulls_head sk_laddr_hash[64];
	struct hlist_head sk_dev_hash[64];
	struct callback_head rcu;
};

struct llc_pdu_sn {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
	u8 ctrl_2;
};

struct llc_pdu_un {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
};

struct nvmem_cell___2;

struct datalink_proto {
	unsigned char type[8];
	struct llc_sap *sap;
	short unsigned int header_length;
	int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	int (*request)(struct datalink_proto *, struct sk_buff *, unsigned char *);
	struct list_head node;
};

struct fch_hdr {
	__u8 daddr[6];
	__u8 saddr[6];
};

struct fcllc {
	__u8 dsap;
	__u8 ssap;
	__u8 llc;
	__u8 protid[3];
	__be16 ethertype;
};

struct stp_proto {
	unsigned char group_address[6];
	void (*rcv)(const struct stp_proto *, struct sk_buff *, struct net_device *);
	void *data;
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	__TCA_MAX = 16,
};

struct skb_array {
	struct ptr_ring ring;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u8 linklayer;
	u8 shift;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_packed *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct Qdisc_class_common {
	u32 classid;
	struct hlist_node hnode;
};

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct qdisc_watchdog {
	u64 last_expires;
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	__TCA_ACT_MAX = 10,
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto *filter_chain;
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit {
	struct tc_action common;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
};

struct tcf_vlan_params {
	int tcfv_action;
	unsigned char tcfv_push_dst[6];
	unsigned char tcfv_push_src[6];
	u16 tcfv_push_vid;
	__be16 tcfv_push_proto;
	u8 tcfv_push_prio;
	struct callback_head rcu;
};

struct tcf_vlan {
	struct tc_action common;
	struct tcf_vlan_params *vlan_p;
};

struct tcf_tunnel_key_params {
	struct callback_head rcu;
	int tcft_action;
	struct metadata_dst *tcft_enc_metadata;
};

struct tcf_tunnel_key {
	struct tc_action common;
	struct tcf_tunnel_key_params *params;
};

struct tcf_csum_params {
	u32 update_flags;
	struct callback_head rcu;
};

struct tcf_csum {
	struct tc_action common;
	struct tcf_csum_params *params;
};

struct tcf_police_params {
	int tcfp_result;
	u32 tcfp_ewma_rate;
	s64 tcfp_burst;
	u32 tcfp_mtu;
	s64 tcfp_mtu_ptoks;
	struct psched_ratecfg rate;
	bool rate_present;
	struct psched_ratecfg peak;
	bool peak_present;
	struct callback_head rcu;
};

struct tcf_police {
	struct tc_action common;
	struct tcf_police_params *params;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t tcfp_lock;
	s64 tcfp_toks;
	s64 tcfp_ptoks;
	s64 tcfp_t_c;
	long: 64;
	long: 64;
};

struct tcf_sample {
	struct tc_action common;
	u32 rate;
	bool truncate;
	u32 trunc_size;
	struct psample_group *psample_group;
	u32 psample_group_num;
	struct list_head tcfm_list;
};

struct tcf_skbedit_params {
	u32 flags;
	u32 priority;
	u32 mark;
	u32 mask;
	u16 queue_mapping;
	u16 ptype;
	struct callback_head rcu;
};

struct tcf_skbedit {
	struct tc_action common;
	struct tcf_skbedit_params *params;
};

struct tcf_mpls_params {
	int tcfm_action;
	u32 tcfm_label;
	u8 tcfm_tc;
	u8 tcfm_ttl;
	u8 tcfm_bos;
	__be16 tcfm_proto;
	struct callback_head rcu;
};

struct tcf_mpls {
	struct tc_action common;
	struct tcf_mpls_params *mpls_p;
};

struct tcfg_gate_entry {
	int index;
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
	struct list_head list;
};

struct tcf_gate_params {
	s32 tcfg_priority;
	u64 tcfg_basetime;
	u64 tcfg_cycletime;
	u64 tcfg_cycletime_ext;
	u32 tcfg_flags;
	s32 tcfg_clockid;
	size_t num_entries;
	struct list_head entries;
};

struct tcf_gate {
	struct tc_action common;
	struct tcf_gate_params param;
	u8 current_gate_status;
	ktime_t current_close_time;
	u32 current_entry_octets;
	s32 current_max_octets;
	struct tcfg_gate_entry *next_entry;
	struct hrtimer hitimer;
	enum tk_offsets tk_offset;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	__TCA_ROOT_MAX = 5,
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

struct tc_act_bpf {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

enum {
	TCA_ACT_BPF_UNSPEC = 0,
	TCA_ACT_BPF_TM = 1,
	TCA_ACT_BPF_PARMS = 2,
	TCA_ACT_BPF_OPS_LEN = 3,
	TCA_ACT_BPF_OPS = 4,
	TCA_ACT_BPF_FD = 5,
	TCA_ACT_BPF_NAME = 6,
	TCA_ACT_BPF_PAD = 7,
	TCA_ACT_BPF_TAG = 8,
	TCA_ACT_BPF_ID = 9,
	__TCA_ACT_BPF_MAX = 10,
};

struct tcf_bpf {
	struct tc_action common;
	struct bpf_prog *filter;
	union {
		u32 bpf_fd;
		u16 bpf_num_ops;
	};
	struct sock_filter *bpf_ops;
	const char *bpf_name;
};

struct tcf_bpf_cfg {
	struct bpf_prog *filter;
	struct sock_filter *bpf_ops;
	const char *bpf_name;
	u16 bpf_num_ops;
	bool is_ebpf;
};

struct tc_fifo_qopt {
	__u32 limit;
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

struct ingress_sched_data {
	struct tcf_block *block;
	struct tcf_block_ext_info block_info;
	struct mini_Qdisc_pair miniqp;
};

struct clsact_sched_data {
	struct tcf_block *ingress_block;
	struct tcf_block *egress_block;
	struct tcf_block_ext_info ingress_block_info;
	struct tcf_block_ext_info egress_block_info;
	struct mini_Qdisc_pair miniqp_ingress;
	struct mini_Qdisc_pair miniqp_egress;
};

enum {
	TCA_FQ_CODEL_UNSPEC = 0,
	TCA_FQ_CODEL_TARGET = 1,
	TCA_FQ_CODEL_LIMIT = 2,
	TCA_FQ_CODEL_INTERVAL = 3,
	TCA_FQ_CODEL_ECN = 4,
	TCA_FQ_CODEL_FLOWS = 5,
	TCA_FQ_CODEL_QUANTUM = 6,
	TCA_FQ_CODEL_CE_THRESHOLD = 7,
	TCA_FQ_CODEL_DROP_BATCH_SIZE = 8,
	TCA_FQ_CODEL_MEMORY_LIMIT = 9,
	__TCA_FQ_CODEL_MAX = 10,
};

enum {
	TCA_FQ_CODEL_XSTATS_QDISC = 0,
	TCA_FQ_CODEL_XSTATS_CLASS = 1,
};

struct tc_fq_codel_qd_stats {
	__u32 maxpacket;
	__u32 drop_overlimit;
	__u32 ecn_mark;
	__u32 new_flow_count;
	__u32 new_flows_len;
	__u32 old_flows_len;
	__u32 ce_mark;
	__u32 memory_usage;
	__u32 drop_overmemory;
};

struct tc_fq_codel_cl_stats {
	__s32 deficit;
	__u32 ldelay;
	__u32 count;
	__u32 lastcount;
	__u32 dropping;
	__s32 drop_next;
};

struct tc_fq_codel_xstats {
	__u32 type;
	union {
		struct tc_fq_codel_qd_stats qdisc_stats;
		struct tc_fq_codel_cl_stats class_stats;
	};
};

typedef u32 codel_time_t;

typedef s32 codel_tdiff_t;

struct codel_params {
	codel_time_t target;
	codel_time_t ce_threshold;
	codel_time_t interval;
	u32 mtu;
	bool ecn;
};

struct codel_vars {
	u32 count;
	u32 lastcount;
	bool dropping;
	u16 rec_inv_sqrt;
	codel_time_t first_above_time;
	codel_time_t drop_next;
	codel_time_t ldelay;
};

struct codel_stats {
	u32 maxpacket;
	u32 drop_count;
	u32 drop_len;
	u32 ecn_mark;
	u32 ce_mark;
};

typedef u32 (*codel_skb_len_t)(const struct sk_buff *);

typedef codel_time_t (*codel_skb_time_t)(const struct sk_buff *);

typedef void (*codel_skb_drop_t)(struct sk_buff *, void *);

typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *, void *);

struct codel_skb_cb {
	codel_time_t enqueue_time;
	unsigned int mem_usage;
};

struct fq_codel_flow {
	struct sk_buff *head;
	struct sk_buff *tail;
	struct list_head flowchain;
	int deficit;
	struct codel_vars cvars;
};

struct fq_codel_sched_data {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct fq_codel_flow *flows;
	u32 *backlogs;
	u32 flows_cnt;
	u32 quantum;
	u32 drop_batch_size;
	u32 memory_limit;
	struct codel_params cparams;
	struct codel_stats cstats;
	u32 memory_usage;
	u32 drop_overmemory;
	u32 drop_overlimit;
	u32 new_flow_count;
	struct list_head new_flows;
	struct list_head old_flows;
};

enum {
	TCA_FQ_UNSPEC = 0,
	TCA_FQ_PLIMIT = 1,
	TCA_FQ_FLOW_PLIMIT = 2,
	TCA_FQ_QUANTUM = 3,
	TCA_FQ_INITIAL_QUANTUM = 4,
	TCA_FQ_RATE_ENABLE = 5,
	TCA_FQ_FLOW_DEFAULT_RATE = 6,
	TCA_FQ_FLOW_MAX_RATE = 7,
	TCA_FQ_BUCKETS_LOG = 8,
	TCA_FQ_FLOW_REFILL_DELAY = 9,
	TCA_FQ_ORPHAN_MASK = 10,
	TCA_FQ_LOW_RATE_THRESHOLD = 11,
	TCA_FQ_CE_THRESHOLD = 12,
	TCA_FQ_TIMER_SLACK = 13,
	TCA_FQ_HORIZON = 14,
	TCA_FQ_HORIZON_DROP = 15,
	__TCA_FQ_MAX = 16,
};

struct tc_fq_qd_stats {
	__u64 gc_flows;
	__u64 highprio_packets;
	__u64 tcp_retrans;
	__u64 throttled;
	__u64 flows_plimit;
	__u64 pkts_too_long;
	__u64 allocation_errors;
	__s64 time_next_delayed_flow;
	__u32 flows;
	__u32 inactive_flows;
	__u32 throttled_flows;
	__u32 unthrottle_latency_ns;
	__u64 ce_mark;
	__u64 horizon_drops;
	__u64 horizon_caps;
};

struct fq_skb_cb {
	u64 time_to_send;
};

struct fq_flow {
	struct rb_root t_root;
	struct sk_buff *head;
	union {
		struct sk_buff *tail;
		long unsigned int age;
	};
	struct rb_node fq_node;
	struct sock *sk;
	u32 socket_hash;
	int qlen;
	int credit;
	struct fq_flow *next;
	struct rb_node rate_node;
	u64 time_next_packet;
	long: 64;
	long: 64;
};

struct fq_flow_head {
	struct fq_flow *first;
	struct fq_flow *last;
};

struct fq_sched_data {
	struct fq_flow_head new_flows;
	struct fq_flow_head old_flows;
	struct rb_root delayed;
	u64 time_next_delayed_flow;
	u64 ktime_cache;
	long unsigned int unthrottle_latency_ns;
	struct fq_flow internal;
	u32 quantum;
	u32 initial_quantum;
	u32 flow_refill_delay;
	u32 flow_plimit;
	long unsigned int flow_max_rate;
	u64 ce_threshold;
	u64 horizon;
	u32 orphan_mask;
	u32 low_rate_threshold;
	struct rb_root *fq_root;
	u8 rate_enable;
	u8 fq_trees_log;
	u8 horizon_drop;
	u32 flows;
	u32 inactive_flows;
	u32 throttled_flows;
	u64 stat_gc_flows;
	u64 stat_internal_packets;
	u64 stat_throttled;
	u64 stat_ce_mark;
	u64 stat_horizon_drops;
	u64 stat_horizon_caps;
	u64 stat_flows_plimit;
	u64 stat_pkts_too_long;
	u64 stat_allocation_errors;
	u32 timer_slack;
	struct qdisc_watchdog watchdog;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	TCA_CGROUP_UNSPEC = 0,
	TCA_CGROUP_ACT = 1,
	TCA_CGROUP_POLICE = 2,
	TCA_CGROUP_EMATCHES = 3,
	__TCA_CGROUP_MAX = 4,
};

struct tcf_ematch_tree_hdr {
	__u16 nmatches;
	__u16 progid;
};

struct tcf_pkt_info {
	unsigned char *ptr;
	int nexthdr;
};

struct tcf_ematch_ops;

struct tcf_ematch {
	struct tcf_ematch_ops *ops;
	long unsigned int data;
	unsigned int datalen;
	u16 matchid;
	u16 flags;
	struct net *net;
};

struct tcf_ematch_ops {
	int kind;
	int datalen;
	int (*change)(struct net *, void *, int, struct tcf_ematch *);
	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
	void (*destroy)(struct tcf_ematch *);
	int (*dump)(struct sk_buff *, struct tcf_ematch *);
	struct module *owner;
	struct list_head link;
};

struct tcf_ematch_tree {
	struct tcf_ematch_tree_hdr hdr;
	struct tcf_ematch *matches;
};

struct cls_cgroup_head {
	u32 handle;
	struct tcf_exts exts;
	struct tcf_ematch_tree ematches;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

enum {
	TCA_BPF_UNSPEC = 0,
	TCA_BPF_ACT = 1,
	TCA_BPF_POLICE = 2,
	TCA_BPF_CLASSID = 3,
	TCA_BPF_OPS_LEN = 4,
	TCA_BPF_OPS = 5,
	TCA_BPF_FD = 6,
	TCA_BPF_NAME = 7,
	TCA_BPF_FLAGS = 8,
	TCA_BPF_FLAGS_GEN = 9,
	TCA_BPF_TAG = 10,
	TCA_BPF_ID = 11,
	__TCA_BPF_MAX = 12,
};

struct cls_bpf_head {
	struct list_head plist;
	struct idr handle_idr;
	struct callback_head rcu;
};

struct cls_bpf_prog {
	struct bpf_prog *filter;
	struct list_head link;
	struct tcf_result res;
	bool exts_integrated;
	u32 gen_flags;
	unsigned int in_hw_count;
	struct tcf_exts exts;
	u32 handle;
	u16 bpf_num_ops;
	struct sock_filter *bpf_ops;
	const char *bpf_name;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

enum {
	TCA_FLOWER_UNSPEC = 0,
	TCA_FLOWER_CLASSID = 1,
	TCA_FLOWER_INDEV = 2,
	TCA_FLOWER_ACT = 3,
	TCA_FLOWER_KEY_ETH_DST = 4,
	TCA_FLOWER_KEY_ETH_DST_MASK = 5,
	TCA_FLOWER_KEY_ETH_SRC = 6,
	TCA_FLOWER_KEY_ETH_SRC_MASK = 7,
	TCA_FLOWER_KEY_ETH_TYPE = 8,
	TCA_FLOWER_KEY_IP_PROTO = 9,
	TCA_FLOWER_KEY_IPV4_SRC = 10,
	TCA_FLOWER_KEY_IPV4_SRC_MASK = 11,
	TCA_FLOWER_KEY_IPV4_DST = 12,
	TCA_FLOWER_KEY_IPV4_DST_MASK = 13,
	TCA_FLOWER_KEY_IPV6_SRC = 14,
	TCA_FLOWER_KEY_IPV6_SRC_MASK = 15,
	TCA_FLOWER_KEY_IPV6_DST = 16,
	TCA_FLOWER_KEY_IPV6_DST_MASK = 17,
	TCA_FLOWER_KEY_TCP_SRC = 18,
	TCA_FLOWER_KEY_TCP_DST = 19,
	TCA_FLOWER_KEY_UDP_SRC = 20,
	TCA_FLOWER_KEY_UDP_DST = 21,
	TCA_FLOWER_FLAGS = 22,
	TCA_FLOWER_KEY_VLAN_ID = 23,
	TCA_FLOWER_KEY_VLAN_PRIO = 24,
	TCA_FLOWER_KEY_VLAN_ETH_TYPE = 25,
	TCA_FLOWER_KEY_ENC_KEY_ID = 26,
	TCA_FLOWER_KEY_ENC_IPV4_SRC = 27,
	TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK = 28,
	TCA_FLOWER_KEY_ENC_IPV4_DST = 29,
	TCA_FLOWER_KEY_ENC_IPV4_DST_MASK = 30,
	TCA_FLOWER_KEY_ENC_IPV6_SRC = 31,
	TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK = 32,
	TCA_FLOWER_KEY_ENC_IPV6_DST = 33,
	TCA_FLOWER_KEY_ENC_IPV6_DST_MASK = 34,
	TCA_FLOWER_KEY_TCP_SRC_MASK = 35,
	TCA_FLOWER_KEY_TCP_DST_MASK = 36,
	TCA_FLOWER_KEY_UDP_SRC_MASK = 37,
	TCA_FLOWER_KEY_UDP_DST_MASK = 38,
	TCA_FLOWER_KEY_SCTP_SRC_MASK = 39,
	TCA_FLOWER_KEY_SCTP_DST_MASK = 40,
	TCA_FLOWER_KEY_SCTP_SRC = 41,
	TCA_FLOWER_KEY_SCTP_DST = 42,
	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT = 43,
	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK = 44,
	TCA_FLOWER_KEY_ENC_UDP_DST_PORT = 45,
	TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK = 46,
	TCA_FLOWER_KEY_FLAGS = 47,
	TCA_FLOWER_KEY_FLAGS_MASK = 48,
	TCA_FLOWER_KEY_ICMPV4_CODE = 49,
	TCA_FLOWER_KEY_ICMPV4_CODE_MASK = 50,
	TCA_FLOWER_KEY_ICMPV4_TYPE = 51,
	TCA_FLOWER_KEY_ICMPV4_TYPE_MASK = 52,
	TCA_FLOWER_KEY_ICMPV6_CODE = 53,
	TCA_FLOWER_KEY_ICMPV6_CODE_MASK = 54,
	TCA_FLOWER_KEY_ICMPV6_TYPE = 55,
	TCA_FLOWER_KEY_ICMPV6_TYPE_MASK = 56,
	TCA_FLOWER_KEY_ARP_SIP = 57,
	TCA_FLOWER_KEY_ARP_SIP_MASK = 58,
	TCA_FLOWER_KEY_ARP_TIP = 59,
	TCA_FLOWER_KEY_ARP_TIP_MASK = 60,
	TCA_FLOWER_KEY_ARP_OP = 61,
	TCA_FLOWER_KEY_ARP_OP_MASK = 62,
	TCA_FLOWER_KEY_ARP_SHA = 63,
	TCA_FLOWER_KEY_ARP_SHA_MASK = 64,
	TCA_FLOWER_KEY_ARP_THA = 65,
	TCA_FLOWER_KEY_ARP_THA_MASK = 66,
	TCA_FLOWER_KEY_MPLS_TTL = 67,
	TCA_FLOWER_KEY_MPLS_BOS = 68,
	TCA_FLOWER_KEY_MPLS_TC = 69,
	TCA_FLOWER_KEY_MPLS_LABEL = 70,
	TCA_FLOWER_KEY_TCP_FLAGS = 71,
	TCA_FLOWER_KEY_TCP_FLAGS_MASK = 72,
	TCA_FLOWER_KEY_IP_TOS = 73,
	TCA_FLOWER_KEY_IP_TOS_MASK = 74,
	TCA_FLOWER_KEY_IP_TTL = 75,
	TCA_FLOWER_KEY_IP_TTL_MASK = 76,
	TCA_FLOWER_KEY_CVLAN_ID = 77,
	TCA_FLOWER_KEY_CVLAN_PRIO = 78,
	TCA_FLOWER_KEY_CVLAN_ETH_TYPE = 79,
	TCA_FLOWER_KEY_ENC_IP_TOS = 80,
	TCA_FLOWER_KEY_ENC_IP_TOS_MASK = 81,
	TCA_FLOWER_KEY_ENC_IP_TTL = 82,
	TCA_FLOWER_KEY_ENC_IP_TTL_MASK = 83,
	TCA_FLOWER_KEY_ENC_OPTS = 84,
	TCA_FLOWER_KEY_ENC_OPTS_MASK = 85,
	TCA_FLOWER_IN_HW_COUNT = 86,
	TCA_FLOWER_KEY_PORT_SRC_MIN = 87,
	TCA_FLOWER_KEY_PORT_SRC_MAX = 88,
	TCA_FLOWER_KEY_PORT_DST_MIN = 89,
	TCA_FLOWER_KEY_PORT_DST_MAX = 90,
	TCA_FLOWER_KEY_CT_STATE = 91,
	TCA_FLOWER_KEY_CT_STATE_MASK = 92,
	TCA_FLOWER_KEY_CT_ZONE = 93,
	TCA_FLOWER_KEY_CT_ZONE_MASK = 94,
	TCA_FLOWER_KEY_CT_MARK = 95,
	TCA_FLOWER_KEY_CT_MARK_MASK = 96,
	TCA_FLOWER_KEY_CT_LABELS = 97,
	TCA_FLOWER_KEY_CT_LABELS_MASK = 98,
	TCA_FLOWER_KEY_MPLS_OPTS = 99,
	TCA_FLOWER_KEY_HASH = 100,
	TCA_FLOWER_KEY_HASH_MASK = 101,
	__TCA_FLOWER_MAX = 102,
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
};

enum {
	TCA_FLOWER_KEY_ENC_OPTS_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPTS_GENEVE = 1,
	TCA_FLOWER_KEY_ENC_OPTS_VXLAN = 2,
	TCA_FLOWER_KEY_ENC_OPTS_ERSPAN = 3,
	__TCA_FLOWER_KEY_ENC_OPTS_MAX = 4,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS = 1,
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE = 2,
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA = 3,
	__TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX = 4,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_VXLAN_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP = 1,
	__TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX = 2,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER = 1,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX = 2,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR = 3,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID = 4,
	__TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX = 5,
};

enum {
	TCA_FLOWER_KEY_MPLS_OPTS_UNSPEC = 0,
	TCA_FLOWER_KEY_MPLS_OPTS_LSE = 1,
	__TCA_FLOWER_KEY_MPLS_OPTS_MAX = 2,
};

enum {
	TCA_FLOWER_KEY_MPLS_OPT_LSE_UNSPEC = 0,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH = 1,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL = 2,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS = 3,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_TC = 4,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL = 5,
	__TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX = 6,
};

enum {
	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = 1,
	TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST = 2,
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

struct fl_flow_key {
	struct flow_dissector_key_meta meta;
	struct flow_dissector_key_control control;
	struct flow_dissector_key_control enc_control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_eth_addrs eth;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_arp arp;
	struct flow_dissector_key_keyid enc_key_id;
	union {
		struct flow_dissector_key_ipv4_addrs enc_ipv4;
		struct flow_dissector_key_ipv6_addrs enc_ipv6;
	};
	struct flow_dissector_key_ports enc_tp;
	struct flow_dissector_key_mpls mpls;
	struct flow_dissector_key_tcp tcp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_ip enc_ip;
	struct flow_dissector_key_enc_opts enc_opts;
	union {
		struct flow_dissector_key_ports tp;
		struct {
			struct flow_dissector_key_ports tp_min;
			struct flow_dissector_key_ports tp_max;
		};
	} tp_range;
	struct flow_dissector_key_ct ct;
	struct flow_dissector_key_hash hash;
	int: 32;
};

struct fl_flow_mask_range {
	short unsigned int start;
	short unsigned int end;
};

struct fl_flow_mask {
	struct fl_flow_key key;
	struct fl_flow_mask_range range;
	u32 flags;
	struct rhash_head ht_node;
	struct rhashtable ht;
	struct rhashtable_params filter_ht_params;
	struct flow_dissector dissector;
	struct list_head filters;
	struct rcu_work rwork;
	struct list_head list;
	refcount_t refcnt;
};

struct fl_flow_tmplt {
	struct fl_flow_key dummy_key;
	struct fl_flow_key mask;
	struct flow_dissector dissector;
	struct tcf_chain *chain;
};

struct cls_fl_head {
	struct rhashtable ht;
	spinlock_t masks_lock;
	struct list_head masks;
	struct list_head hw_filters;
	struct rcu_work rwork;
	struct idr handle_idr;
};

struct cls_fl_filter {
	struct fl_flow_mask *mask;
	struct rhash_head ht_node;
	struct fl_flow_key mkey;
	struct tcf_exts exts;
	struct tcf_result res;
	struct fl_flow_key key;
	struct list_head list;
	struct list_head hw_list;
	u32 handle;
	u32 flags;
	u32 in_hw_count;
	struct rcu_work rwork;
	struct net_device *hw_dev;
	refcount_t refcnt;
	bool deleted;
};

enum {
	TCA_EMATCH_TREE_UNSPEC = 0,
	TCA_EMATCH_TREE_HDR = 1,
	TCA_EMATCH_TREE_LIST = 2,
	__TCA_EMATCH_TREE_MAX = 3,
};

struct tcf_ematch_hdr {
	__u16 matchid;
	__u16 kind;
	__u16 flags;
	__u16 pad;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	__NLMSGERR_ATTR_MAX = 5,
	NLMSGERR_ATTR_MAX = 4,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_ops *ops;
	int hdrlen;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	unsigned int opidx;
	u32 op;
	u16 fam_id;
	u8 policies: 1;
	u8 single_op: 1;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state___2 {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
	long: 48;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	int: 32;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	__ETHTOOL_MSG_USER_CNT = 29,
	ETHTOOL_MSG_USER_MAX = 28,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	__ETHTOOL_A_LINKMODES_CNT = 9,
	ETHTOOL_A_LINKMODES_MAX = 8,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	__ETHTOOL_A_LINKSTATE_CNT = 7,
	ETHTOOL_A_LINKSTATE_MAX = 6,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	__ETHTOOL_A_RINGS_CNT = 10,
	ETHTOOL_A_RINGS_MAX = 9,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	__ETHTOOL_A_COALESCE_CNT = 24,
	ETHTOOL_A_COALESCE_MAX = 23,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	__ETHTOOL_A_PAUSE_CNT = 6,
	ETHTOOL_A_PAUSE_MAX = 5,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_req_info {
	struct net_device *dev;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	int pos_hash;
	int pos_idx;
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

typedef const char (* const ethnl_string_array_t)[32];

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[16];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct link_mode_info {
	int speed;
	u8 duplex;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	u32 supported_params;
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	int pos_hash;
	int pos_idx;
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct nf_conn;

struct nf_conntrack_tuple;

struct nf_conntrack;

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
};

struct nfnl_ct_hook {
	struct nf_conn * (*get_ct)(const struct sk_buff *, enum ip_conntrack_info *);
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct net_device *physin;
	struct net_device *physout;
	struct nf_hook_state state;
	u16 size;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct nf_bridge_info {
	enum {
		BRNF_PROTO_UNCHANGED = 0,
		BRNF_PROTO_8021Q = 1,
		BRNF_PROTO_PPPOE = 2,
	} orig_proto: 8;
	u8 pkt_otherhost: 1;
	u8 in_prerouting: 1;
	u8 bridged_dnat: 1;
	__u16 frag_max_size;
	struct net_device *physindev;
	struct net_device *physoutdev;
	union {
		__be32 ipv4_daddr;
		struct in6_addr ipv6_daddr;
		char neigh_header[8];
	};
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	struct module *owner;
};

enum nfnetlink_groups {
	NFNLGRP_NONE = 0,
	NFNLGRP_CONNTRACK_NEW = 1,
	NFNLGRP_CONNTRACK_UPDATE = 2,
	NFNLGRP_CONNTRACK_DESTROY = 3,
	NFNLGRP_CONNTRACK_EXP_NEW = 4,
	NFNLGRP_CONNTRACK_EXP_UPDATE = 5,
	NFNLGRP_CONNTRACK_EXP_DESTROY = 6,
	NFNLGRP_NFTABLES = 7,
	NFNLGRP_ACCT_QUOTA = 8,
	NFNLGRP_NFTRACE = 9,
	__NFNLGRP_MAX = 10,
};

struct nfgenmsg {
	__u8 nfgen_family;
	__u8 version;
	__be16 res_id;
};

enum nfnl_batch_attributes {
	NFNL_BATCH_UNSPEC = 0,
	NFNL_BATCH_GENID = 1,
	__NFNL_BATCH_MAX = 2,
};

struct nfnl_callback {
	int (*call)(struct net *, struct sock *, struct sk_buff *, const struct nlmsghdr *, const struct nlattr * const *, struct netlink_ext_ack *);
	int (*call_rcu)(struct net *, struct sock *, struct sk_buff *, const struct nlmsghdr *, const struct nlattr * const *, struct netlink_ext_ack *);
	int (*call_batch)(struct net *, struct sock *, struct sk_buff *, const struct nlmsghdr *, const struct nlattr * const *, struct netlink_ext_ack *);
	const struct nla_policy *policy;
	const u_int16_t attr_count;
};

enum nfnl_abort_action {
	NFNL_ABORT_NONE = 0,
	NFNL_ABORT_AUTOLOAD = 1,
	NFNL_ABORT_VALIDATE = 2,
};

struct nfnetlink_subsystem {
	const char *name;
	__u8 subsys_id;
	__u8 cb_count;
	const struct nfnl_callback *cb;
	struct module *owner;
	int (*commit)(struct net *, struct sk_buff *);
	int (*abort)(struct net *, struct sk_buff *, enum nfnl_abort_action);
	void (*cleanup)(struct net *);
	bool (*valid_genid)(struct net *, u32);
};

struct nfnl_err {
	struct list_head head;
	struct nlmsghdr *nlh;
	int err;
	struct netlink_ext_ack extack;
};

enum {
	NFNL_BATCH_FAILURE = 1,
	NFNL_BATCH_DONE = 2,
	NFNL_BATCH_REPLAY = 4,
};

struct nf_conntrack {
	atomic_t use;
};

enum nfqnl_msg_types {
	NFQNL_MSG_PACKET = 0,
	NFQNL_MSG_VERDICT = 1,
	NFQNL_MSG_CONFIG = 2,
	NFQNL_MSG_VERDICT_BATCH = 3,
	NFQNL_MSG_MAX = 4,
};

struct nfqnl_msg_packet_hdr {
	__be32 packet_id;
	__be16 hw_protocol;
	__u8 hook;
} __attribute__((packed));

struct nfqnl_msg_packet_hw {
	__be16 hw_addrlen;
	__u16 _pad;
	__u8 hw_addr[8];
};

struct nfqnl_msg_packet_timestamp {
	__be64 sec;
	__be64 usec;
};

enum nfqnl_vlan_attr {
	NFQA_VLAN_UNSPEC = 0,
	NFQA_VLAN_PROTO = 1,
	NFQA_VLAN_TCI = 2,
	__NFQA_VLAN_MAX = 3,
};

enum nfqnl_attr_type {
	NFQA_UNSPEC = 0,
	NFQA_PACKET_HDR = 1,
	NFQA_VERDICT_HDR = 2,
	NFQA_MARK = 3,
	NFQA_TIMESTAMP = 4,
	NFQA_IFINDEX_INDEV = 5,
	NFQA_IFINDEX_OUTDEV = 6,
	NFQA_IFINDEX_PHYSINDEV = 7,
	NFQA_IFINDEX_PHYSOUTDEV = 8,
	NFQA_HWADDR = 9,
	NFQA_PAYLOAD = 10,
	NFQA_CT = 11,
	NFQA_CT_INFO = 12,
	NFQA_CAP_LEN = 13,
	NFQA_SKB_INFO = 14,
	NFQA_EXP = 15,
	NFQA_UID = 16,
	NFQA_GID = 17,
	NFQA_SECCTX = 18,
	NFQA_VLAN = 19,
	NFQA_L2HDR = 20,
	__NFQA_MAX = 21,
};

struct nfqnl_msg_verdict_hdr {
	__be32 verdict;
	__be32 id;
};

enum nfqnl_msg_config_cmds {
	NFQNL_CFG_CMD_NONE = 0,
	NFQNL_CFG_CMD_BIND = 1,
	NFQNL_CFG_CMD_UNBIND = 2,
	NFQNL_CFG_CMD_PF_BIND = 3,
	NFQNL_CFG_CMD_PF_UNBIND = 4,
};

struct nfqnl_msg_config_cmd {
	__u8 command;
	__u8 _pad;
	__be16 pf;
};

enum nfqnl_config_mode {
	NFQNL_COPY_NONE = 0,
	NFQNL_COPY_META = 1,
	NFQNL_COPY_PACKET = 2,
};

struct nfqnl_msg_config_params {
	__be32 copy_range;
	__u8 copy_mode;
} __attribute__((packed));

enum nfqnl_attr_config {
	NFQA_CFG_UNSPEC = 0,
	NFQA_CFG_CMD = 1,
	NFQA_CFG_PARAMS = 2,
	NFQA_CFG_QUEUE_MAXLEN = 3,
	NFQA_CFG_MASK = 4,
	NFQA_CFG_FLAGS = 5,
	__NFQA_CFG_MAX = 6,
};

struct nfqnl_instance {
	struct hlist_node hlist;
	struct callback_head rcu;
	u32 peer_portid;
	unsigned int queue_maxlen;
	unsigned int copy_range;
	unsigned int queue_dropped;
	unsigned int queue_user_dropped;
	u_int16_t queue_num;
	u_int8_t copy_mode;
	u_int32_t flags;
	spinlock_t lock;
	unsigned int queue_total;
	unsigned int id_sequence;
	struct list_head queue_list;
	long: 64;
	long: 64;
};

typedef int (*nfqnl_cmpfn)(struct nf_queue_entry *, long unsigned int);

struct nfnl_queue_net {
	spinlock_t instances_lock;
	struct hlist_head instance_table[16];
};

struct iter_state {
	struct seq_net_private p;
	unsigned int bucket;
};

enum nfulnl_msg_types {
	NFULNL_MSG_PACKET = 0,
	NFULNL_MSG_CONFIG = 1,
	NFULNL_MSG_MAX = 2,
};

struct nfulnl_msg_packet_hdr {
	__be16 hw_protocol;
	__u8 hook;
	__u8 _pad;
};

struct nfulnl_msg_packet_hw {
	__be16 hw_addrlen;
	__u16 _pad;
	__u8 hw_addr[8];
};

struct nfulnl_msg_packet_timestamp {
	__be64 sec;
	__be64 usec;
};

enum nfulnl_vlan_attr {
	NFULA_VLAN_UNSPEC = 0,
	NFULA_VLAN_PROTO = 1,
	NFULA_VLAN_TCI = 2,
	__NFULA_VLAN_MAX = 3,
};

enum nfulnl_attr_type {
	NFULA_UNSPEC = 0,
	NFULA_PACKET_HDR = 1,
	NFULA_MARK = 2,
	NFULA_TIMESTAMP = 3,
	NFULA_IFINDEX_INDEV = 4,
	NFULA_IFINDEX_OUTDEV = 5,
	NFULA_IFINDEX_PHYSINDEV = 6,
	NFULA_IFINDEX_PHYSOUTDEV = 7,
	NFULA_HWADDR = 8,
	NFULA_PAYLOAD = 9,
	NFULA_PREFIX = 10,
	NFULA_UID = 11,
	NFULA_SEQ = 12,
	NFULA_SEQ_GLOBAL = 13,
	NFULA_GID = 14,
	NFULA_HWTYPE = 15,
	NFULA_HWHEADER = 16,
	NFULA_HWLEN = 17,
	NFULA_CT = 18,
	NFULA_CT_INFO = 19,
	NFULA_VLAN = 20,
	NFULA_L2HDR = 21,
	__NFULA_MAX = 22,
};

enum nfulnl_msg_config_cmds {
	NFULNL_CFG_CMD_NONE = 0,
	NFULNL_CFG_CMD_BIND = 1,
	NFULNL_CFG_CMD_UNBIND = 2,
	NFULNL_CFG_CMD_PF_BIND = 3,
	NFULNL_CFG_CMD_PF_UNBIND = 4,
};

struct nfulnl_msg_config_cmd {
	__u8 command;
};

struct nfulnl_msg_config_mode {
	__be32 copy_range;
	__u8 copy_mode;
	__u8 _pad;
} __attribute__((packed));

enum nfulnl_attr_config {
	NFULA_CFG_UNSPEC = 0,
	NFULA_CFG_CMD = 1,
	NFULA_CFG_MODE = 2,
	NFULA_CFG_NLBUFSIZ = 3,
	NFULA_CFG_TIMEOUT = 4,
	NFULA_CFG_QTHRESH = 5,
	NFULA_CFG_FLAGS = 6,
	__NFULA_CFG_MAX = 7,
};

struct nfulnl_instance {
	struct hlist_node hlist;
	spinlock_t lock;
	refcount_t use;
	unsigned int qlen;
	struct sk_buff *skb;
	struct timer_list timer;
	struct net *net;
	struct user_namespace *peer_user_ns;
	u32 peer_portid;
	unsigned int flushtimeout;
	unsigned int nlbufsiz;
	unsigned int qthreshold;
	u_int32_t copy_range;
	u_int32_t seq;
	u_int16_t group_num;
	u_int16_t flags;
	u_int8_t copy_mode;
	struct callback_head rcu;
};

struct nfnl_log_net {
	spinlock_t instances_lock;
	struct hlist_head instance_table[16];
	atomic_t global_seq;
};

struct xt_table_info;

struct xt_table {
	struct list_head list;
	unsigned int valid_hooks;
	struct xt_table_info *private;
	struct module *me;
	u_int8_t af;
	int priority;
	int (*table_init)(struct net *);
	const char name[32];
};

struct xt_action_param;

struct xt_mtchk_param;

struct xt_mtdtor_param;

struct xt_match {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	bool (*match)(const struct sk_buff *, struct xt_action_param *);
	int (*checkentry)(const struct xt_mtchk_param *);
	void (*destroy)(const struct xt_mtdtor_param *);
	void (*compat_from_user)(void *, const void *);
	int (*compat_to_user)(void *, const void *);
	struct module *me;
	const char *table;
	unsigned int matchsize;
	unsigned int usersize;
	unsigned int compatsize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_entry_match {
	union {
		struct {
			__u16 match_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 match_size;
			struct xt_match *match;
		} kernel;
		__u16 match_size;
	} u;
	unsigned char data[0];
};

struct xt_tgchk_param;

struct xt_tgdtor_param;

struct xt_target {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	unsigned int (*target)(struct sk_buff *, const struct xt_action_param *);
	int (*checkentry)(const struct xt_tgchk_param *);
	void (*destroy)(const struct xt_tgdtor_param *);
	void (*compat_from_user)(void *, const void *);
	int (*compat_to_user)(void *, const void *);
	struct module *me;
	const char *table;
	unsigned int targetsize;
	unsigned int usersize;
	unsigned int compatsize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_entry_target {
	union {
		struct {
			__u16 target_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 target_size;
			struct xt_target *target;
		} kernel;
		__u16 target_size;
	} u;
	unsigned char data[0];
};

struct xt_standard_target {
	struct xt_entry_target target;
	int verdict;
};

struct xt_error_target {
	struct xt_entry_target target;
	char errorname[30];
};

struct xt_counters {
	__u64 pcnt;
	__u64 bcnt;
};

struct xt_counters_info {
	char name[32];
	unsigned int num_counters;
	struct xt_counters counters[0];
};

struct xt_action_param {
	union {
		const struct xt_match *match;
		const struct xt_target *target;
	};
	union {
		const void *matchinfo;
		const void *targinfo;
	};
	const struct nf_hook_state *state;
	int fragoff;
	unsigned int thoff;
	bool hotdrop;
};

struct xt_mtchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_match *match;
	void *matchinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_mtdtor_param {
	struct net *net;
	const struct xt_match *match;
	void *matchinfo;
	u_int8_t family;
};

struct xt_tgchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_target *target;
	void *targinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_tgdtor_param {
	struct net *net;
	const struct xt_target *target;
	void *targinfo;
	u_int8_t family;
};

struct xt_table_info {
	unsigned int size;
	unsigned int number;
	unsigned int initial_entries;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int stacksize;
	void ***jumpstack;
	unsigned char entries[0];
};

struct xt_percpu_counter_alloc_state {
	unsigned int off;
	const char *mem;
};

struct compat_xt_entry_match {
	union {
		struct {
			u_int16_t match_size;
			char name[29];
			u_int8_t revision;
		} user;
		struct {
			u_int16_t match_size;
			compat_uptr_t match;
		} kernel;
		u_int16_t match_size;
	} u;
	unsigned char data[0];
};

struct compat_xt_entry_target {
	union {
		struct {
			u_int16_t target_size;
			char name[29];
			u_int8_t revision;
		} user;
		struct {
			u_int16_t target_size;
			compat_uptr_t target;
		} kernel;
		u_int16_t target_size;
	} u;
	unsigned char data[0];
};

struct compat_xt_counters {
	compat_u64 pcnt;
	compat_u64 bcnt;
};

struct compat_xt_counters_info {
	char name[32];
	compat_uint_t num_counters;
	struct compat_xt_counters counters[0];
} __attribute__((packed));

struct compat_delta {
	unsigned int offset;
	int delta;
};

struct xt_af {
	struct mutex mutex;
	struct list_head match;
	struct list_head target;
	struct mutex compat_mutex;
	struct compat_delta *compat_tab;
	unsigned int number;
	unsigned int cur;
};

struct compat_xt_standard_target {
	struct compat_xt_entry_target t;
	compat_uint_t verdict;
};

struct compat_xt_error_target {
	struct compat_xt_entry_target t;
	char errorname[30];
};

struct nf_mttg_trav {
	struct list_head *head;
	struct list_head *curr;
	uint8_t class;
};

enum {
	MTTG_TRAV_INIT = 0,
	MTTG_TRAV_NFP_UNSPEC = 1,
	MTTG_TRAV_NFP_SPEC = 2,
	MTTG_TRAV_DONE = 3,
};

struct xt_tcp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 option;
	__u8 flg_mask;
	__u8 flg_cmp;
	__u8 invflags;
};

struct xt_udp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 invflags;
};

struct xt_bpf_info {
	__u16 bpf_program_num_elem;
	struct sock_filter bpf_program[64];
	struct bpf_prog *filter;
};

enum xt_bpf_modes {
	XT_BPF_MODE_BYTECODE = 0,
	XT_BPF_MODE_FD_PINNED = 1,
	XT_BPF_MODE_FD_ELF = 2,
};

struct xt_bpf_info_v1 {
	__u16 mode;
	__u16 bpf_program_num_elem;
	__s32 fd;
	union {
		struct sock_filter bpf_program[64];
		char path[512];
	};
	struct bpf_prog *filter;
};

enum xt_statistic_mode {
	XT_STATISTIC_MODE_RANDOM = 0,
	XT_STATISTIC_MODE_NTH = 1,
	__XT_STATISTIC_MODE_MAX = 2,
};

enum xt_statistic_flags {
	XT_STATISTIC_INVERT = 1,
};

struct xt_statistic_priv;

struct xt_statistic_info {
	__u16 mode;
	__u16 flags;
	union {
		struct {
			__u32 probability;
		} random;
		struct {
			__u32 every;
			__u32 packet;
			__u32 count;
		} nth;
	} u;
	struct xt_statistic_priv *master;
};

struct xt_statistic_priv {
	atomic_t count;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct mr_table_ops {
	const struct rhashtable_params *rht_params;
	void *cmparg_any;
};

struct vif_device {
	struct net_device *dev;
	long unsigned int bytes_in;
	long unsigned int bytes_out;
	long unsigned int pkt_in;
	long unsigned int pkt_out;
	long unsigned int rate_limit;
	unsigned char threshold;
	short unsigned int flags;
	int link;
	struct netdev_phys_item_id dev_parent_id;
	__be32 local;
	__be32 remote;
};

struct mr_table {
	struct list_head list;
	possible_net_t net;
	struct mr_table_ops ops;
	u32 id;
	struct sock *mroute_sk;
	struct timer_list ipmr_expire_timer;
	struct list_head mfc_unres_queue;
	struct vif_device vif_table[32];
	struct rhltable mfc_hash;
	struct list_head mfc_cache_list;
	int maxvif;
	atomic_t cache_resolve_queue_len;
	bool mroute_do_assert;
	bool mroute_do_pim;
	bool mroute_do_wrvifwhole;
	int mroute_reg_vif_num;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct ip_rt_acct {
	__u32 o_bytes;
	__u32 o_packets;
	__u32 i_bytes;
	__u32 i_packets;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	u8 fa_tos;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 6;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct raw_hashinfo {
	rwlock_t lock;
	struct hlist_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	__be32 imsf_slist[1];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
} __attribute__((packed));

enum {
	BPFILTER_IPT_SO_SET_REPLACE = 64,
	BPFILTER_IPT_SO_SET_ADD_COUNTERS = 65,
	BPFILTER_IPT_SET_MAX = 66,
};

enum {
	BPFILTER_IPT_SO_GET_INFO = 64,
	BPFILTER_IPT_SO_GET_ENTRIES = 65,
	BPFILTER_IPT_SO_GET_REVISION_MATCH = 66,
	BPFILTER_IPT_SO_GET_REVISION_TARGET = 67,
	BPFILTER_IPT_GET_MAX = 68,
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
};

struct tcp_md5sig_pool {
	struct ahash_request *md5_req;
	void *scratch;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

struct mptcp_out_options {};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct tcp_md5sig {
	struct __kernel_sockaddr_storage tcpm_addr;
	__u8 tcpm_flags;
	__u8 tcpm_prefixlen;
	__u16 tcpm_keylen;
	int tcpm_ifindex;
	__u8 tcpm_key[80];
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

struct tcp4_pseudohdr {
	__be32 saddr;
	__be32 daddr;
	__u8 pad;
	__u8 protocol;
	__be16 len;
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	struct tcp_seq_afinfo *bpf_seq_afinfo;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	possible_net_t tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	int: 32;
	int bucket;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	bool (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	__IFA_MAX = 11,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct compat_rtentry {
	u32 rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	u32 rt_pad3;
	unsigned char rt_tos;
	unsigned char rt_class;
	short int rt_pad4;
	short int rt_metric;
	compat_uptr_t rt_dev;
	u32 rt_mtu;
	u32 rt_window;
	short unsigned int rt_irtt;
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct fib_config {
	u8 fc_dst_len;
	u8 fc_tos;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct key_vector *tnode[0];
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	rwlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	__NEXTHOP_GRP_TYPE_MAX = 1,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	__NHA_MAX = 12,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

struct bpfilter_umh_ops {
	struct umd_info info;
	struct mutex lock;
	int (*sockopt)(struct sock *, int, sockptr_t, unsigned int, bool);
	int (*start)();
};

enum tunnel_encap_types {
	TUNNEL_ENCAP_NONE = 0,
	TUNNEL_ENCAP_FOU = 1,
	TUNNEL_ENCAP_GUE = 2,
	TUNNEL_ENCAP_MPLS = 3,
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	u32 o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct tnl_ptk_info {
	__be16 flags;
	__be16 proto;
	__be32 key;
	__be32 seq;
	int hdr_len;
};

struct ip_tunnel_net {
	struct net_device *fb_tunnel_dev;
	struct rtnl_link_ops *rtnl_link_ops;
	struct hlist_head tunnels[128];
	struct ip_tunnel *collect_md_tun;
	int type;
};

struct inet6_protocol {
	void (*early_demux)(struct sk_buff *);
	void (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct fib4_rule {
	struct fib_rule common;
	u8 dst_len;
	u8 src_len;
	u8 tos;
	__be32 src;
	__be32 srcmask;
	__be32 dst;
	__be32 dstmask;
	u32 tclassid;
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

struct pimreghdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
	__be32 flags;
};

typedef short unsigned int vifi_t;

struct vifctl {
	vifi_t vifc_vifi;
	unsigned char vifc_flags;
	unsigned char vifc_threshold;
	unsigned int vifc_rate_limit;
	union {
		struct in_addr vifc_lcl_addr;
		int vifc_lcl_ifindex;
	};
	struct in_addr vifc_rmt_addr;
};

struct mfcctl {
	struct in_addr mfcc_origin;
	struct in_addr mfcc_mcastgrp;
	vifi_t mfcc_parent;
	unsigned char mfcc_ttls[32];
	unsigned int mfcc_pkt_cnt;
	unsigned int mfcc_byte_cnt;
	unsigned int mfcc_wrong_if;
	int mfcc_expire;
};

struct sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_vif_req {
	vifi_t vifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct igmpmsg {
	__u32 unused1;
	__u32 unused2;
	unsigned char im_msgtype;
	unsigned char im_mbz;
	unsigned char im_vif;
	unsigned char im_vif_hi;
	struct in_addr im_src;
	struct in_addr im_dst;
};

enum {
	IPMRA_TABLE_UNSPEC = 0,
	IPMRA_TABLE_ID = 1,
	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
	IPMRA_TABLE_MROUTE_DO_PIM = 5,
	IPMRA_TABLE_VIFS = 6,
	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
	__IPMRA_TABLE_MAX = 8,
};

enum {
	IPMRA_VIF_UNSPEC = 0,
	IPMRA_VIF = 1,
	__IPMRA_VIF_MAX = 2,
};

enum {
	IPMRA_VIFA_UNSPEC = 0,
	IPMRA_VIFA_IFINDEX = 1,
	IPMRA_VIFA_VIF_ID = 2,
	IPMRA_VIFA_FLAGS = 3,
	IPMRA_VIFA_BYTES_IN = 4,
	IPMRA_VIFA_BYTES_OUT = 5,
	IPMRA_VIFA_PACKETS_IN = 6,
	IPMRA_VIFA_PACKETS_OUT = 7,
	IPMRA_VIFA_LOCAL_ADDR = 8,
	IPMRA_VIFA_REMOTE_ADDR = 9,
	IPMRA_VIFA_PAD = 10,
	__IPMRA_VIFA_MAX = 11,
};

enum {
	IPMRA_CREPORT_UNSPEC = 0,
	IPMRA_CREPORT_MSGTYPE = 1,
	IPMRA_CREPORT_VIF_ID = 2,
	IPMRA_CREPORT_SRC_ADDR = 3,
	IPMRA_CREPORT_DST_ADDR = 4,
	IPMRA_CREPORT_PKT = 5,
	IPMRA_CREPORT_TABLE = 6,
	__IPMRA_CREPORT_MAX = 7,
};

struct vif_entry_notifier_info {
	struct fib_notifier_info info;
	struct net_device *dev;
	short unsigned int vif_index;
	short unsigned int vif_flags;
	u32 tb_id;
};

enum {
	MFC_STATIC = 1,
	MFC_OFFLOAD = 2,
};

struct mr_mfc {
	struct rhlist_head mnode;
	short unsigned int mfc_parent;
	int mfc_flags;
	union {
		struct {
			long unsigned int expires;
			struct sk_buff_head unresolved;
		} unres;
		struct {
			long unsigned int last_assert;
			int minvif;
			int maxvif;
			long unsigned int bytes;
			long unsigned int pkt;
			long unsigned int wrong_if;
			long unsigned int lastuse;
			unsigned char ttls[32];
			refcount_t refcount;
		} res;
	} mfc_un;
	struct list_head list;
	struct callback_head rcu;
	void (*free)(struct callback_head *);
};

struct mfc_entry_notifier_info {
	struct fib_notifier_info info;
	struct mr_mfc *mfc;
	u32 tb_id;
};

struct mr_vif_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	int ct;
};

struct mr_mfc_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	struct list_head *cache;
	spinlock_t *lock;
};

struct mfc_cache_cmp_arg {
	__be32 mfc_mcastgrp;
	__be32 mfc_origin;
};

struct mfc_cache {
	struct mr_mfc _c;
	union {
		struct {
			__be32 mfc_mcastgrp;
			__be32 mfc_origin;
		};
		struct mfc_cache_cmp_arg cmparg;
	};
};

struct compat_sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	compat_ulong_t pktcnt;
	compat_ulong_t bytecnt;
	compat_ulong_t wrong_if;
};

struct compat_sioc_vif_req {
	vifi_t vifi;
	compat_ulong_t icount;
	compat_ulong_t ocount;
	compat_ulong_t ibytes;
	compat_ulong_t obytes;
};

struct rta_mfc_stats {
	__u64 mfcs_packets;
	__u64 mfcs_bytes;
	__u64 mfcs_wrong_if;
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

struct xfrm_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm_tunnel *next;
	int priority;
};

struct gre_protocol {
	int (*handler)(struct sk_buff *);
	void (*err_handler)(struct sk_buff *, u32);
};

struct erspan_base_hdr {
	__u8 vlan_upper: 4;
	__u8 ver: 4;
	__u8 vlan: 8;
	__u8 session_id_upper: 2;
	__u8 t: 1;
	__u8 en: 2;
	__u8 cos: 3;
	__u8 session_id: 8;
};

enum {
	IFLA_GRE_UNSPEC = 0,
	IFLA_GRE_LINK = 1,
	IFLA_GRE_IFLAGS = 2,
	IFLA_GRE_OFLAGS = 3,
	IFLA_GRE_IKEY = 4,
	IFLA_GRE_OKEY = 5,
	IFLA_GRE_LOCAL = 6,
	IFLA_GRE_REMOTE = 7,
	IFLA_GRE_TTL = 8,
	IFLA_GRE_TOS = 9,
	IFLA_GRE_PMTUDISC = 10,
	IFLA_GRE_ENCAP_LIMIT = 11,
	IFLA_GRE_FLOWINFO = 12,
	IFLA_GRE_FLAGS = 13,
	IFLA_GRE_ENCAP_TYPE = 14,
	IFLA_GRE_ENCAP_FLAGS = 15,
	IFLA_GRE_ENCAP_SPORT = 16,
	IFLA_GRE_ENCAP_DPORT = 17,
	IFLA_GRE_COLLECT_METADATA = 18,
	IFLA_GRE_IGNORE_DF = 19,
	IFLA_GRE_FWMARK = 20,
	IFLA_GRE_ERSPAN_INDEX = 21,
	IFLA_GRE_ERSPAN_VER = 22,
	IFLA_GRE_ERSPAN_DIR = 23,
	IFLA_GRE_ERSPAN_HWID = 24,
	__IFLA_GRE_MAX = 25,
};

enum erspan_encap_type {
	ERSPAN_ENCAP_NOVLAN = 0,
	ERSPAN_ENCAP_ISL = 1,
	ERSPAN_ENCAP_8021Q = 2,
	ERSPAN_ENCAP_INFRAME = 3,
};

enum erspan_bso {
	BSO_NOERROR = 0,
	BSO_SHORT = 1,
	BSO_OVERSIZED = 2,
	BSO_BAD = 3,
};

struct qtag_prefix {
	__be16 eth_type;
	__be16 tci;
};

struct udp_tunnel_nic_table_entry;

struct udp_tunnel_nic {
	struct work_struct work;
	struct net_device *dev;
	u8 need_sync: 1;
	u8 need_replay: 1;
	u8 work_pending: 1;
	unsigned int n_tables;
	long unsigned int missed;
	struct udp_tunnel_nic_table_entry **entries;
};

struct udp_tunnel_nic_shared_node {
	struct net_device *dev;
	struct list_head list;
};

enum udp_tunnel_nic_table_entry_flags {
	UDP_TUNNEL_NIC_ENTRY_ADD = 1,
	UDP_TUNNEL_NIC_ENTRY_DEL = 2,
	UDP_TUNNEL_NIC_ENTRY_OP_FAIL = 4,
	UDP_TUNNEL_NIC_ENTRY_FROZEN = 8,
};

struct udp_tunnel_nic_table_entry {
	__be16 port;
	u8 type;
	u8 flags;
	u16 use_cnt;
	u8 hw_priv;
};

struct xfrm_input_afinfo {
	u8 family;
	bool is_ipip;
	int (*callback)(struct sk_buff *, u8, int);
};

struct xt_get_revision {
	char name[29];
	__u8 revision;
};

struct ipt_ip {
	struct in_addr src;
	struct in_addr dst;
	struct in_addr smsk;
	struct in_addr dmsk;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u16 proto;
	__u8 flags;
	__u8 invflags;
};

struct ipt_entry {
	struct ipt_ip ip;
	unsigned int nfcache;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct ipt_icmp {
	__u8 type;
	__u8 code[2];
	__u8 invflags;
};

struct ipt_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_entries;
	unsigned int size;
};

struct ipt_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct ipt_entry entries[0];
};

struct ipt_get_entries {
	char name[32];
	unsigned int size;
	struct ipt_entry entrytable[0];
};

struct ipt_standard {
	struct ipt_entry entry;
	struct xt_standard_target target;
};

struct ipt_error {
	struct ipt_entry entry;
	struct xt_error_target target;
};

struct compat_ipt_entry {
	struct ipt_ip ip;
	compat_uint_t nfcache;
	__u16 target_offset;
	__u16 next_offset;
	compat_uint_t comefrom;
	struct compat_xt_counters counters;
	unsigned char elems[0];
};

struct compat_ipt_replace {
	char name[32];
	u32 valid_hooks;
	u32 num_entries;
	u32 size;
	u32 hook_entry[5];
	u32 underflow[5];
	u32 num_counters;
	compat_uptr_t counters;
	struct compat_ipt_entry entries[0];
} __attribute__((packed));

struct compat_ipt_get_entries {
	char name[32];
	compat_uint_t size;
	struct compat_ipt_entry entrytable[0];
} __attribute__((packed));

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	char aad_space[13];
	u8 iv_data[16];
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_NUM_CFGS = 2,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

struct netlbl_audit {
	u32 secid;
	kuid_t loginuid;
	unsigned int sessionid;
};

struct cipso_v4_std_map_tbl {
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} lvl;
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} cat;
};

struct cipso_v4_doi {
	u32 doi;
	u32 type;
	union {
		struct cipso_v4_std_map_tbl *std;
	} map;
	u8 tags[5];
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct cipso_v4_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct cipso_v4_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

struct xfrm_policy_afinfo {
	struct dst_ops *dst_ops;
	struct dst_entry * (*dst_lookup)(struct net *, int, int, const xfrm_address_t *, const xfrm_address_t *, u32);
	int (*get_saddr)(struct net *, int, xfrm_address_t *, xfrm_address_t *, u32);
	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
	struct dst_entry * (*blackhole_route)(struct net *, struct dst_entry *);
};

struct xfrm_state_afinfo {
	u8 family;
	u8 proto;
	const struct xfrm_type_offload *type_offload_esp;
	const struct xfrm_type *type_esp;
	const struct xfrm_type *type_ipip;
	const struct xfrm_type *type_ipip6;
	const struct xfrm_type *type_comp;
	const struct xfrm_type *type_ah;
	const struct xfrm_type *type_routing;
	const struct xfrm_type *type_dstopts;
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*transport_finish)(struct sk_buff *, int);
	void (*local_error)(struct sk_buff *, u32);
};

struct ip6_tnl;

struct xfrm_tunnel_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	union {
		struct ip_tunnel *ip4;
		struct ip6_tnl *ip6;
	} tunnel;
};

struct xfrm_mode_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	__be16 id;
	__be16 frag_off;
	u8 ihl;
	u8 tos;
	u8 ttl;
	u8 protocol;
	u8 optlen;
	u8 flow_lbl[3];
};

struct xfrm_spi_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	unsigned int daddroff;
	unsigned int family;
	__be32 seq;
};

struct xfrm4_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm4_protocol *next;
	int priority;
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

enum {
	TLS_INFO_UNSPEC = 0,
	TLS_INFO_VERSION = 1,
	TLS_INFO_CIPHER = 2,
	TLS_INFO_TXCONF = 3,
	TLS_INFO_RXCONF = 4,
	__TLS_INFO_MAX = 5,
};

enum {
	TLS_BASE = 0,
	TLS_SW = 1,
	TLS_HW = 2,
	TLS_HW_RECORD = 3,
	TLS_NUM_CONFIG = 4,
};

enum {
	TLSV4 = 0,
	TLSV6 = 1,
	TLS_NUM_PROTS = 2,
};

struct tls12_crypto_info_aes_ccm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_msg {
	struct strp_msg rxm;
	u8 control;
};

struct trace_event_raw_tls_device_offload_set {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	int dir;
	u32 tcp_seq;
	int ret;
	char __data[0];
};

struct trace_event_raw_tls_device_decrypted {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	u32 tcp_seq;
	u32 rec_len;
	bool encrypted;
	bool decrypted;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_send {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	u32 tcp_seq;
	int sync_type;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_nh_schedule {
	struct trace_entry ent;
	struct sock *sk;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_nh_delay {
	struct trace_entry ent;
	struct sock *sk;
	u32 sock_data;
	u32 rec_len;
	char __data[0];
};

struct trace_event_raw_tls_device_tx_resync_req {
	struct trace_entry ent;
	struct sock *sk;
	u32 tcp_seq;
	u32 exp_tcp_seq;
	char __data[0];
};

struct trace_event_raw_tls_device_tx_resync_send {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	u32 tcp_seq;
	char __data[0];
};

struct trace_event_data_offsets_tls_device_offload_set {};

struct trace_event_data_offsets_tls_device_decrypted {};

struct trace_event_data_offsets_tls_device_rx_resync_send {};

struct trace_event_data_offsets_tls_device_rx_resync_nh_schedule {};

struct trace_event_data_offsets_tls_device_rx_resync_nh_delay {};

struct trace_event_data_offsets_tls_device_tx_resync_req {};

struct trace_event_data_offsets_tls_device_tx_resync_send {};

typedef void (*btf_trace_tls_device_offload_set)(void *, struct sock *, int, u32, u8 *, int);

typedef void (*btf_trace_tls_device_decrypted)(void *, struct sock *, u32, u8 *, u32, bool, bool);

typedef void (*btf_trace_tls_device_rx_resync_send)(void *, struct sock *, u32, u8 *, int);

typedef void (*btf_trace_tls_device_rx_resync_nh_schedule)(void *, struct sock *);

typedef void (*btf_trace_tls_device_rx_resync_nh_delay)(void *, struct sock *, u32, u32);

typedef void (*btf_trace_tls_device_tx_resync_req)(void *, struct sock *, u32, u32);

typedef void (*btf_trace_tls_device_tx_resync_send)(void *, struct sock *, u32, u8 *);

struct seqcount_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_mutex seqcount_mutex_t;

enum {
	XFRM_STATE_VOID = 0,
	XFRM_STATE_ACQ = 1,
	XFRM_STATE_VALID = 2,
	XFRM_STATE_ERROR = 3,
	XFRM_STATE_EXPIRED = 4,
	XFRM_STATE_DEAD = 5,
};

struct xfrm_if;

struct xfrm_if_cb {
	struct xfrm_if * (*decode_session)(struct sk_buff *, short unsigned int);
};

struct xfrm_if_parms {
	int link;
	u32 if_id;
};

struct xfrm_if {
	struct xfrm_if *next;
	struct net_device *dev;
	struct net *net;
	struct xfrm_if_parms p;
	struct gro_cells gro_cells;
};

struct xfrm_policy_walk {
	struct xfrm_policy_walk_entry walk;
	u8 type;
	u32 seq;
};

struct xfrmk_spdinfo {
	u32 incnt;
	u32 outcnt;
	u32 fwdcnt;
	u32 inscnt;
	u32 outscnt;
	u32 fwdscnt;
	u32 spdhcnt;
	u32 spdhmcnt;
};

struct ip6_mh {
	__u8 ip6mh_proto;
	__u8 ip6mh_hdrlen;
	__u8 ip6mh_type;
	__u8 ip6mh_reserved;
	__u16 ip6mh_cksum;
	__u8 data[0];
};

struct xfrm_flo {
	struct dst_entry *dst_orig;
	u8 flags;
};

struct xfrm_pol_inexact_node {
	struct rb_node node;
	union {
		xfrm_address_t addr;
		struct callback_head rcu;
	};
	u8 prefixlen;
	struct rb_root root;
	struct hlist_head hhead;
};

struct xfrm_pol_inexact_key {
	possible_net_t net;
	u32 if_id;
	u16 family;
	u8 dir;
	u8 type;
};

struct xfrm_pol_inexact_bin {
	struct xfrm_pol_inexact_key k;
	struct rhash_head head;
	struct hlist_head hhead;
	seqcount_spinlock_t count;
	struct rb_root root_d;
	struct rb_root root_s;
	struct list_head inexact_bins;
	struct callback_head rcu;
};

enum xfrm_pol_inexact_candidate_type {
	XFRM_POL_CAND_BOTH = 0,
	XFRM_POL_CAND_SADDR = 1,
	XFRM_POL_CAND_DADDR = 2,
	XFRM_POL_CAND_ANY = 3,
	XFRM_POL_CAND_MAX = 4,
};

struct xfrm_pol_inexact_candidates {
	struct hlist_head *res[4];
};

enum xfrm_ae_ftype_t {
	XFRM_AE_UNSPEC = 0,
	XFRM_AE_RTHR = 1,
	XFRM_AE_RVAL = 2,
	XFRM_AE_LVAL = 4,
	XFRM_AE_ETHR = 8,
	XFRM_AE_CR = 16,
	XFRM_AE_CE = 32,
	XFRM_AE_CU = 64,
	__XFRM_AE_MAX = 65,
};

enum xfrm_nlgroups {
	XFRMNLGRP_NONE = 0,
	XFRMNLGRP_ACQUIRE = 1,
	XFRMNLGRP_EXPIRE = 2,
	XFRMNLGRP_SA = 3,
	XFRMNLGRP_POLICY = 4,
	XFRMNLGRP_AEVENTS = 5,
	XFRMNLGRP_REPORT = 6,
	XFRMNLGRP_MIGRATE = 7,
	XFRMNLGRP_MAPPING = 8,
	__XFRMNLGRP_MAX = 9,
};

enum {
	XFRM_MODE_FLAG_TUNNEL = 1,
};

struct km_event {
	union {
		u32 hard;
		u32 proto;
		u32 byid;
		u32 aevent;
		u32 type;
	} data;
	u32 seq;
	u32 portid;
	u32 event;
	struct net *net;
};

struct xfrm_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	u32 reserved;
	u16 family;
};

struct xfrm_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	u8 proto;
	u8 mode;
	u16 reserved;
	u32 reqid;
	u16 old_family;
	u16 new_family;
};

struct xfrm_mgr {
	struct list_head list;
	int (*notify)(struct xfrm_state *, const struct km_event *);
	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
	int (*report)(struct net *, u8, struct xfrm_selector *, xfrm_address_t *);
	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
	bool (*is_alive)(const struct km_event *);
};

struct xfrmk_sadinfo {
	u32 sadhcnt;
	u32 sadhmcnt;
	u32 sadcnt;
};

struct xfrm_translator {
	int (*alloc_compat)(struct sk_buff *, const struct nlmsghdr *);
	struct nlmsghdr * (*rcv_msg_compat)(const struct nlmsghdr *, int, const struct nla_policy *, struct netlink_ext_ack *);
	int (*xlate_user_policy_sockptr)(u8 **, int);
	struct module *owner;
};

struct ip_beet_phdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 padlen;
	__u8 reserved;
};

struct __ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	bool collect_md;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	__u32 fwmark;
	__u32 index;
	__u8 erspan_ver;
	__u8 dir;
	__u16 hwid;
};

struct ip6_tnl {
	struct ip6_tnl *next;
	struct net_device *dev;
	struct net *net;
	struct __ip6_tnl_parm parms;
	struct flowi fl;
	struct dst_cache dst_cache;
	struct gro_cells gro_cells;
	int err_count;
	long unsigned int err_time;
	__u32 i_seqno;
	__u32 o_seqno;
	int hlen;
	int tun_hlen;
	int encap_hlen;
	struct ip_tunnel_encap encap;
	int mlink;
};

struct xfrm_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	union {
		struct {
			__u32 low;
			__u32 hi;
		} output;
		struct {
			__be32 low;
			__be32 hi;
		} input;
	} seq;
};

struct xfrm_trans_tasklet {
	struct tasklet_struct tasklet;
	struct sk_buff_head queue;
};

struct xfrm_trans_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	int (*finish)(struct net *, struct sock *, struct sk_buff *);
	struct net *net;
};

struct sadb_alg {
	__u8 sadb_alg_id;
	__u8 sadb_alg_ivlen;
	__u16 sadb_alg_minbits;
	__u16 sadb_alg_maxbits;
	__u16 sadb_alg_reserved;
};

struct xfrm_algo_aead_info {
	char *geniv;
	u16 icv_truncbits;
};

struct xfrm_algo_auth_info {
	u16 icv_truncbits;
	u16 icv_fullbits;
};

struct xfrm_algo_encr_info {
	char *geniv;
	u16 blockbits;
	u16 defkeybits;
};

struct xfrm_algo_comp_info {
	u16 threshold;
};

struct xfrm_algo_desc {
	char *name;
	char *compat;
	u8 available: 1;
	u8 pfkey_supported: 1;
	union {
		struct xfrm_algo_aead_info aead;
		struct xfrm_algo_auth_info auth;
		struct xfrm_algo_encr_info encr;
		struct xfrm_algo_comp_info comp;
	} uinfo;
	struct sadb_alg desc;
};

struct xfrm_algo_list {
	struct xfrm_algo_desc *algs;
	int entries;
	u32 type;
	u32 mask;
};

struct xfrm_aead_name {
	const char *name;
	int icvbits;
};

enum {
	XFRM_SHARE_ANY = 0,
	XFRM_SHARE_SESSION = 1,
	XFRM_SHARE_USER = 2,
	XFRM_SHARE_UNIQUE = 3,
};

struct xfrm_user_sec_ctx {
	__u16 len;
	__u16 exttype;
	__u8 ctx_alg;
	__u8 ctx_doi;
	__u16 ctx_len;
};

struct xfrm_user_tmpl {
	struct xfrm_id id;
	__u16 family;
	xfrm_address_t saddr;
	__u32 reqid;
	__u8 mode;
	__u8 share;
	__u8 optional;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
};

struct xfrm_userpolicy_type {
	__u8 type;
	__u16 reserved1;
	__u8 reserved2;
};

enum xfrm_sadattr_type_t {
	XFRMA_SAD_UNSPEC = 0,
	XFRMA_SAD_CNT = 1,
	XFRMA_SAD_HINFO = 2,
	__XFRMA_SAD_MAX = 3,
};

struct xfrmu_sadhinfo {
	__u32 sadhcnt;
	__u32 sadhmcnt;
};

enum xfrm_spdattr_type_t {
	XFRMA_SPD_UNSPEC = 0,
	XFRMA_SPD_INFO = 1,
	XFRMA_SPD_HINFO = 2,
	XFRMA_SPD_IPV4_HTHRESH = 3,
	XFRMA_SPD_IPV6_HTHRESH = 4,
	__XFRMA_SPD_MAX = 5,
};

struct xfrmu_spdinfo {
	__u32 incnt;
	__u32 outcnt;
	__u32 fwdcnt;
	__u32 inscnt;
	__u32 outscnt;
	__u32 fwdscnt;
};

struct xfrmu_spdhinfo {
	__u32 spdhcnt;
	__u32 spdhmcnt;
};

struct xfrmu_spdhthresh {
	__u8 lbits;
	__u8 rbits;
};

struct xfrm_usersa_info {
	struct xfrm_selector sel;
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_stats stats;
	__u32 seq;
	__u32 reqid;
	__u16 family;
	__u8 mode;
	__u8 replay_window;
	__u8 flags;
};

struct xfrm_usersa_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u16 family;
	__u8 proto;
};

struct xfrm_aevent_id {
	struct xfrm_usersa_id sa_id;
	xfrm_address_t saddr;
	__u32 flags;
	__u32 reqid;
};

struct xfrm_userspi_info {
	struct xfrm_usersa_info info;
	__u32 min;
	__u32 max;
};

struct xfrm_userpolicy_info {
	struct xfrm_selector sel;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	__u32 priority;
	__u32 index;
	__u8 dir;
	__u8 action;
	__u8 flags;
	__u8 share;
};

struct xfrm_userpolicy_id {
	struct xfrm_selector sel;
	__u32 index;
	__u8 dir;
};

struct xfrm_user_acquire {
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_selector sel;
	struct xfrm_userpolicy_info policy;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
	__u32 seq;
};

struct xfrm_user_expire {
	struct xfrm_usersa_info state;
	__u8 hard;
};

struct xfrm_user_polexpire {
	struct xfrm_userpolicy_info pol;
	__u8 hard;
};

struct xfrm_usersa_flush {
	__u8 proto;
};

struct xfrm_user_report {
	__u8 proto;
	struct xfrm_selector sel;
};

struct xfrm_user_mapping {
	struct xfrm_usersa_id id;
	__u32 reqid;
	xfrm_address_t old_saddr;
	xfrm_address_t new_saddr;
	__be16 old_sport;
	__be16 new_sport;
};

struct xfrm_user_offload {
	int ifindex;
	__u8 flags;
};

struct xfrm_dump_info {
	struct sk_buff *in_skb;
	struct sk_buff *out_skb;
	u32 nlmsg_seq;
	u16 nlmsg_flags;
};

struct xfrm_link {
	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *nla_pol;
	int nla_max;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct compat_in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	u32 rtmsg_type;
	u16 rtmsg_dst_len;
	u16 rtmsg_src_len;
	u32 rtmsg_metric;
	u32 rtmsg_info;
	u32 rtmsg_flags;
	s32 rtmsg_ifindex;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	__u16 gso_size;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	__IFLA_INET6_MAX = 9,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool promiscuous_mode;
	bool ackreq;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_MAX = 52,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	u32 flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u8 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	struct device dev;
	possible_net_t _net;
	long: 64;
	long: 64;
	long: 64;
	char priv[0];
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		__be16 fifo_hi;
		__be32 fifo_lo;
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_MAX = 9,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct route_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved_l: 3;
	__u8 route_pref: 2;
	__u8 reserved_h: 3;
	__be32 lifetime;
	__u8 prefix[0];
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	u32 __data_loc_name;
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct __rt6_probe_work {
	struct work_struct work;
	struct in6_addr target;
	struct net_device *dev;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_S = 0,
	FWS_L = 1,
	FWS_R = 2,
	FWS_C = 3,
	FWS_U = 4,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct static_key_false_deferred {
	struct static_key_false key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

typedef int mh_filter_t(struct sock *, struct sk_buff *);

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *);

struct ipv6_destopt_hao {
	__u8 type;
	__u8 length;
	struct in6_addr addr;
} __attribute__((packed));

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct tcp6_pseudohdr {
	struct in6_addr saddr;
	struct in6_addr daddr;
	__be32 len;
	__be32 protocol;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct in6_addr addr[0];
		__u8 data[0];
	} segments;
};

struct tlvtype_proc {
	int type;
	bool (*func)(struct sk_buff *, int);
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

struct xfrm6_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_protocol *next;
	int priority;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 vlan_filtered: 1;
	u8 br_netfilter_broute: 1;
};

struct nf_bridge_frag_data;

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct fib6_rule {
	struct fib_rule common;
	struct rt6key src;
	struct rt6key dst;
	u8 tclass;
};

struct calipso_doi;

struct netlbl_calipso_ops {
	int (*doi_add)(struct calipso_doi *, struct netlbl_audit *);
	void (*doi_free)(struct calipso_doi *);
	int (*doi_remove)(u32, struct netlbl_audit *);
	struct calipso_doi * (*doi_getdef)(u32);
	void (*doi_putdef)(struct calipso_doi *);
	int (*doi_walk)(u32 *, int (*)(struct calipso_doi *, void *), void *);
	int (*sock_getattr)(struct sock *, struct netlbl_lsm_secattr *);
	int (*sock_setattr)(struct sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*sock_delattr)(struct sock *);
	int (*req_setattr)(struct request_sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*req_delattr)(struct request_sock *);
	int (*opt_getattr)(const unsigned char *, struct netlbl_lsm_secattr *);
	unsigned char * (*skbuff_optptr)(const struct sk_buff *);
	int (*skbuff_setattr)(struct sk_buff *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	int (*skbuff_delattr)(struct sk_buff *);
	void (*cache_invalidate)();
	int (*cache_add)(const unsigned char *, const struct netlbl_lsm_secattr *);
};

struct calipso_doi {
	u32 doi;
	u32 type;
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct calipso_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct calipso_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

enum {
	SEG6_IPTUNNEL_UNSPEC = 0,
	SEG6_IPTUNNEL_SRH = 1,
	__SEG6_IPTUNNEL_MAX = 2,
};

struct seg6_iptunnel_encap {
	int mode;
	struct ipv6_sr_hdr srh[0];
};

enum {
	SEG6_IPTUN_MODE_INLINE = 0,
	SEG6_IPTUN_MODE_ENCAP = 1,
	SEG6_IPTUN_MODE_L2ENCAP = 2,
};

struct seg6_lwt {
	struct dst_cache cache;
	struct seg6_iptunnel_encap tuninfo[0];
};

enum {
	SEG6_LOCAL_UNSPEC = 0,
	SEG6_LOCAL_ACTION = 1,
	SEG6_LOCAL_SRH = 2,
	SEG6_LOCAL_TABLE = 3,
	SEG6_LOCAL_NH4 = 4,
	SEG6_LOCAL_NH6 = 5,
	SEG6_LOCAL_IIF = 6,
	SEG6_LOCAL_OIF = 7,
	SEG6_LOCAL_BPF = 8,
	__SEG6_LOCAL_MAX = 9,
};

enum {
	SEG6_LOCAL_BPF_PROG_UNSPEC = 0,
	SEG6_LOCAL_BPF_PROG = 1,
	SEG6_LOCAL_BPF_PROG_NAME = 2,
	__SEG6_LOCAL_BPF_PROG_MAX = 3,
};

struct seg6_local_lwt;

struct seg6_action_desc {
	int action;
	long unsigned int attrs;
	int (*input)(struct sk_buff *, struct seg6_local_lwt *);
	int static_headroom;
};

struct seg6_local_lwt {
	int action;
	struct ipv6_sr_hdr *srh;
	int table;
	struct in_addr nh4;
	struct in6_addr nh6;
	int iif;
	int oif;
	struct bpf_lwt_prog bpf;
	int headroom;
	struct seg6_action_desc *desc;
};

struct seg6_action_param {
	int (*parse)(struct nlattr **, struct seg6_local_lwt *);
	int (*put)(struct sk_buff *, struct seg6_local_lwt *);
	int (*cmp)(struct seg6_local_lwt *, struct seg6_local_lwt *);
};

struct xfrm6_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_tunnel *next;
	int priority;
};

struct ip6t_ip6 {
	struct in6_addr src;
	struct in6_addr dst;
	struct in6_addr smsk;
	struct in6_addr dmsk;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u16 proto;
	__u8 tos;
	__u8 flags;
	__u8 invflags;
};

struct ip6t_entry {
	struct ip6t_ip6 ipv6;
	unsigned int nfcache;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct ip6t_standard {
	struct ip6t_entry entry;
	struct xt_standard_target target;
};

struct ip6t_error {
	struct ip6t_entry entry;
	struct xt_error_target target;
};

struct ip6t_icmp {
	__u8 type;
	__u8 code[2];
	__u8 invflags;
};

struct ip6t_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_entries;
	unsigned int size;
};

struct ip6t_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct ip6t_entry entries[0];
};

struct ip6t_get_entries {
	char name[32];
	unsigned int size;
	struct ip6t_entry entrytable[0];
};

struct compat_ip6t_entry {
	struct ip6t_ip6 ipv6;
	compat_uint_t nfcache;
	__u16 target_offset;
	__u16 next_offset;
	compat_uint_t comefrom;
	struct compat_xt_counters counters;
	unsigned char elems[0];
} __attribute__((packed));

struct compat_ip6t_replace {
	char name[32];
	u32 valid_hooks;
	u32 num_entries;
	u32 size;
	u32 hook_entry[5];
	u32 underflow[5];
	u32 num_counters;
	compat_uptr_t counters;
	struct compat_ip6t_entry entries[0];
} __attribute__((packed));

struct compat_ip6t_get_entries {
	char name[32];
	compat_uint_t size;
	struct compat_ip6t_entry entrytable[0];
} __attribute__((packed));

struct ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
};

struct ipv6_tlv_tnl_enc_lim {
	__u8 type;
	__u8 length;
	__u8 encap_limit;
};

struct ip6_tnl_net {
	struct net_device *fb_tnl_dev;
	struct ip6_tnl *tnls_r_l[32];
	struct ip6_tnl *tnls_wc[1];
	struct ip6_tnl **tnls[2];
	struct ip6_tnl *collect_md_tun;
};

struct ipv6_tel_txoption {
	struct ipv6_txoptions ops;
	__u8 dst_opt[8];
};

struct ip6_tnl_parm2 {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
};

struct ip6gre_net {
	struct ip6_tnl *tunnels[128];
	struct ip6_tnl *collect_md_tun;
	struct ip6_tnl *collect_md_tun_erspan;
	struct net_device *fb_tunnel_dev;
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	struct sock *arr[0];
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned int running;
	unsigned int auxdata: 1;
	unsigned int origdev: 1;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	atomic_t tp_drops;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 offloaded: 1;
};

enum br_boolopt_id {
	BR_BOOLOPT_NO_LL_LEARN = 0,
	BR_BOOLOPT_MAX = 1,
};

struct br_boolopt_multi {
	__u32 optval;
	__u32 optmask;
};

enum net_bridge_opts {
	BROPT_VLAN_ENABLED = 0,
	BROPT_VLAN_STATS_ENABLED = 1,
	BROPT_NF_CALL_IPTABLES = 2,
	BROPT_NF_CALL_IP6TABLES = 3,
	BROPT_NF_CALL_ARPTABLES = 4,
	BROPT_GROUP_ADDR_SET = 5,
	BROPT_MULTICAST_ENABLED = 6,
	BROPT_MULTICAST_QUERIER = 7,
	BROPT_MULTICAST_QUERY_USE_IFADDR = 8,
	BROPT_MULTICAST_STATS_ENABLED = 9,
	BROPT_HAS_IPV6_ADDR = 10,
	BROPT_NEIGH_SUPPRESS_ENABLED = 11,
	BROPT_MTU_SET_BY_USER = 12,
	BROPT_VLAN_STATS_PER_PORT = 13,
	BROPT_NO_LL_LEARN = 14,
	BROPT_VLAN_BRIDGE_BINDING = 15,
};

struct net_bridge_mcast_gc {
	struct hlist_node gc_node;
	void (*destroy)(struct net_bridge_mcast_gc *);
};

struct net_bridge_port_group_sg_key {
	struct net_bridge_port *port;
	struct br_ip addr;
};

struct net_bridge_port_group {
	struct net_bridge_port_group *next;
	struct net_bridge_port_group_sg_key key;
	unsigned char eth_addr[6];
	unsigned char flags;
	unsigned char filter_mode;
	unsigned char grp_query_rexmit_cnt;
	unsigned char rt_protocol;
	struct hlist_head src_list;
	unsigned int src_ents;
	struct timer_list timer;
	struct timer_list rexmit_timer;
	struct hlist_node mglist;
	struct rhash_head rhnode;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct net_bridge_mdb_entry {
	struct rhash_head rhnode;
	struct net_bridge *br;
	struct net_bridge_port_group *ports;
	struct br_ip addr;
	bool host_joined;
	struct timer_list timer;
	struct hlist_node mdb_node;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

enum br_pkt_type {
	BR_PKT_UNICAST = 0,
	BR_PKT_MULTICAST = 1,
	BR_PKT_BROADCAST = 2,
};

struct nf_br_ops {
	int (*br_dev_xmit_hook)(struct sk_buff *);
};

enum {
	FDB_NOTIFY_BIT = 1,
	FDB_NOTIFY_INACTIVE_BIT = 2,
};

enum {
	NFEA_UNSPEC = 0,
	NFEA_ACTIVITY_NOTIFY = 1,
	NFEA_DONT_REFRESH = 2,
	__NFEA_MAX = 3,
};

struct __fdb_entry {
	__u8 mac_addr[6];
	__u8 port_no;
	__u8 is_local;
	__u32 ageing_timer_value;
	__u8 port_hi;
	__u8 pad0;
	__u16 unused;
};

struct br_vlan_stats {
	u64 rx_bytes;
	u64 rx_packets;
	u64 tx_bytes;
	u64 tx_packets;
	struct u64_stats_sync syncp;
};

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst *tunnel_dst;
};

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	u8 state;
	struct br_vlan_stats *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	struct br_tunnel_info tinfo;
	struct list_head vlist;
	struct callback_head rcu;
};

enum {
	BR_FDB_LOCAL = 0,
	BR_FDB_STATIC = 1,
	BR_FDB_STICKY = 2,
	BR_FDB_ADDED_BY_USER = 3,
	BR_FDB_ADDED_BY_EXT_LEARN = 4,
	BR_FDB_OFFLOADED = 5,
	BR_FDB_NOTIFY = 6,
	BR_FDB_NOTIFY_INACTIVE = 7,
};

struct br_frame_type {
	__be16 type;
	int (*frame_handler)(struct net_bridge_port *, struct sk_buff *);
	struct hlist_node list;
};

struct __bridge_info {
	__u64 designated_root;
	__u64 bridge_id;
	__u32 root_path_cost;
	__u32 max_age;
	__u32 hello_time;
	__u32 forward_delay;
	__u32 bridge_max_age;
	__u32 bridge_hello_time;
	__u32 bridge_forward_delay;
	__u8 topology_change;
	__u8 topology_change_detected;
	__u8 root_port;
	__u8 stp_enabled;
	__u32 ageing_time;
	__u32 gc_interval;
	__u32 hello_timer_value;
	__u32 tcn_timer_value;
	__u32 topology_change_timer_value;
	__u32 gc_timer_value;
};

struct __port_info {
	__u64 designated_root;
	__u64 designated_bridge;
	__u16 port_id;
	__u16 designated_port;
	__u32 path_cost;
	__u32 designated_cost;
	__u8 state;
	__u8 top_change_ack;
	__u8 config_pending;
	__u8 unused0;
	__u32 message_age_timer_value;
	__u32 forward_delay_timer_value;
	__u32 hold_timer_value;
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 2,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 4,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 8,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		long unsigned int brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		bool mc_disabled;
	} u;
};

struct br_config_bpdu {
	unsigned int topology_change: 1;
	unsigned int topology_change_ack: 1;
	bridge_id root;
	int root_path_cost;
	bridge_id bridge_id;
	port_id port_id;
	int message_age;
	int max_age;
	int hello_time;
	int forward_delay;
};

enum {
	IFLA_BR_UNSPEC = 0,
	IFLA_BR_FORWARD_DELAY = 1,
	IFLA_BR_HELLO_TIME = 2,
	IFLA_BR_MAX_AGE = 3,
	IFLA_BR_AGEING_TIME = 4,
	IFLA_BR_STP_STATE = 5,
	IFLA_BR_PRIORITY = 6,
	IFLA_BR_VLAN_FILTERING = 7,
	IFLA_BR_VLAN_PROTOCOL = 8,
	IFLA_BR_GROUP_FWD_MASK = 9,
	IFLA_BR_ROOT_ID = 10,
	IFLA_BR_BRIDGE_ID = 11,
	IFLA_BR_ROOT_PORT = 12,
	IFLA_BR_ROOT_PATH_COST = 13,
	IFLA_BR_TOPOLOGY_CHANGE = 14,
	IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
	IFLA_BR_HELLO_TIMER = 16,
	IFLA_BR_TCN_TIMER = 17,
	IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
	IFLA_BR_GC_TIMER = 19,
	IFLA_BR_GROUP_ADDR = 20,
	IFLA_BR_FDB_FLUSH = 21,
	IFLA_BR_MCAST_ROUTER = 22,
	IFLA_BR_MCAST_SNOOPING = 23,
	IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
	IFLA_BR_MCAST_QUERIER = 25,
	IFLA_BR_MCAST_HASH_ELASTICITY = 26,
	IFLA_BR_MCAST_HASH_MAX = 27,
	IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
	IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
	IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
	IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
	IFLA_BR_MCAST_QUERIER_INTVL = 32,
	IFLA_BR_MCAST_QUERY_INTVL = 33,
	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
	IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
	IFLA_BR_NF_CALL_IPTABLES = 36,
	IFLA_BR_NF_CALL_IP6TABLES = 37,
	IFLA_BR_NF_CALL_ARPTABLES = 38,
	IFLA_BR_VLAN_DEFAULT_PVID = 39,
	IFLA_BR_PAD = 40,
	IFLA_BR_VLAN_STATS_ENABLED = 41,
	IFLA_BR_MCAST_STATS_ENABLED = 42,
	IFLA_BR_MCAST_IGMP_VERSION = 43,
	IFLA_BR_MCAST_MLD_VERSION = 44,
	IFLA_BR_VLAN_STATS_PER_PORT = 45,
	IFLA_BR_MULTI_BOOLOPT = 46,
	__IFLA_BR_MAX = 47,
};

enum {
	LINK_XSTATS_TYPE_UNSPEC = 0,
	LINK_XSTATS_TYPE_BRIDGE = 1,
	LINK_XSTATS_TYPE_BOND = 2,
	__LINK_XSTATS_TYPE_MAX = 3,
};

struct bridge_vlan_info {
	__u16 flags;
	__u16 vid;
};

struct bridge_vlan_xstats {
	__u64 rx_bytes;
	__u64 rx_packets;
	__u64 tx_bytes;
	__u64 tx_packets;
	__u16 vid;
	__u16 flags;
	__u32 pad2;
};

enum {
	BRIDGE_XSTATS_UNSPEC = 0,
	BRIDGE_XSTATS_VLAN = 1,
	BRIDGE_XSTATS_MCAST = 2,
	BRIDGE_XSTATS_PAD = 3,
	BRIDGE_XSTATS_STP = 4,
	__BRIDGE_XSTATS_MAX = 5,
};

enum {
	BR_GROUPFWD_STP = 1,
	BR_GROUPFWD_MACPAUSE = 2,
	BR_GROUPFWD_LACP = 4,
};

struct vtunnel_info {
	u32 tunid;
	u16 vid;
	u16 flags;
};

enum {
	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC = 0,
	IFLA_BRIDGE_VLAN_TUNNEL_ID = 1,
	IFLA_BRIDGE_VLAN_TUNNEL_VID = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS = 3,
	__IFLA_BRIDGE_VLAN_TUNNEL_MAX = 4,
};

struct brport_attribute {
	struct attribute attr;
	ssize_t (*show)(struct net_bridge_port *, char *);
	int (*store)(struct net_bridge_port *, long unsigned int);
	int (*store_raw)(struct net_bridge_port *, char *);
};

struct pimhdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
};

enum {
	MDB_RTR_TYPE_DISABLED = 0,
	MDB_RTR_TYPE_TEMP_QUERY = 1,
	MDB_RTR_TYPE_PERM = 2,
	MDB_RTR_TYPE_TEMP = 3,
};

struct br_ip_list {
	struct list_head list;
	struct br_ip addr;
};

struct net_bridge_group_src {
	struct hlist_node node;
	struct br_ip addr;
	struct net_bridge_port_group *pg;
	u8 flags;
	u8 src_query_rexmit_cnt;
	struct timer_list timer;
	struct net_bridge *br;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
};

struct switchdev_obj {
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

enum {
	MDBA_UNSPEC = 0,
	MDBA_MDB = 1,
	MDBA_ROUTER = 2,
	__MDBA_MAX = 3,
};

enum {
	MDBA_MDB_UNSPEC = 0,
	MDBA_MDB_ENTRY = 1,
	__MDBA_MDB_MAX = 2,
};

enum {
	MDBA_MDB_ENTRY_UNSPEC = 0,
	MDBA_MDB_ENTRY_INFO = 1,
	__MDBA_MDB_ENTRY_MAX = 2,
};

enum {
	MDBA_MDB_EATTR_UNSPEC = 0,
	MDBA_MDB_EATTR_TIMER = 1,
	MDBA_MDB_EATTR_SRC_LIST = 2,
	MDBA_MDB_EATTR_GROUP_MODE = 3,
	MDBA_MDB_EATTR_SOURCE = 4,
	MDBA_MDB_EATTR_RTPROT = 5,
	__MDBA_MDB_EATTR_MAX = 6,
};

enum {
	MDBA_MDB_SRCLIST_UNSPEC = 0,
	MDBA_MDB_SRCLIST_ENTRY = 1,
	__MDBA_MDB_SRCLIST_MAX = 2,
};

enum {
	MDBA_MDB_SRCATTR_UNSPEC = 0,
	MDBA_MDB_SRCATTR_ADDRESS = 1,
	MDBA_MDB_SRCATTR_TIMER = 2,
	__MDBA_MDB_SRCATTR_MAX = 3,
};

enum {
	MDBA_ROUTER_UNSPEC = 0,
	MDBA_ROUTER_PORT = 1,
	__MDBA_ROUTER_MAX = 2,
};

enum {
	MDBA_ROUTER_PATTR_UNSPEC = 0,
	MDBA_ROUTER_PATTR_TIMER = 1,
	MDBA_ROUTER_PATTR_TYPE = 2,
	__MDBA_ROUTER_PATTR_MAX = 3,
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
			unsigned char mac_addr[6];
		} u;
		__be16 proto;
	} addr;
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	MDBA_SET_ENTRY_ATTRS = 2,
	__MDBA_SET_ENTRY_MAX = 3,
};

enum {
	MDBE_ATTR_UNSPEC = 0,
	MDBE_ATTR_SOURCE = 1,
	__MDBE_ATTR_MAX = 2,
};

struct br_mdb_complete_info {
	struct net_bridge_port *port;
	struct br_ip ip;
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats *vlan_pcpu_stats;
	struct netpoll *netpoll;
};

struct br_vlan_msg {
	__u8 family;
	__u8 reserved1;
	__u16 reserved2;
	__u32 ifindex;
};

enum {
	BRIDGE_VLANDB_DUMP_UNSPEC = 0,
	BRIDGE_VLANDB_DUMP_FLAGS = 1,
	__BRIDGE_VLANDB_DUMP_MAX = 2,
};

enum {
	BRIDGE_VLANDB_UNSPEC = 0,
	BRIDGE_VLANDB_ENTRY = 1,
	__BRIDGE_VLANDB_MAX = 2,
};

enum {
	BRIDGE_VLANDB_ENTRY_UNSPEC = 0,
	BRIDGE_VLANDB_ENTRY_INFO = 1,
	BRIDGE_VLANDB_ENTRY_RANGE = 2,
	BRIDGE_VLANDB_ENTRY_STATE = 3,
	BRIDGE_VLANDB_ENTRY_TUNNEL_INFO = 4,
	BRIDGE_VLANDB_ENTRY_STATS = 5,
	__BRIDGE_VLANDB_ENTRY_MAX = 6,
};

enum {
	BRIDGE_VLANDB_STATS_UNSPEC = 0,
	BRIDGE_VLANDB_STATS_RX_BYTES = 1,
	BRIDGE_VLANDB_STATS_RX_PACKETS = 2,
	BRIDGE_VLANDB_STATS_TX_BYTES = 3,
	BRIDGE_VLANDB_STATS_TX_PACKETS = 4,
	BRIDGE_VLANDB_STATS_PAD = 5,
	__BRIDGE_VLANDB_STATS_MAX = 6,
};

enum {
	BR_VLFLAG_PER_PORT_STATS = 1,
	BR_VLFLAG_ADDED_BY_SWITCHDEV = 2,
};

struct br_vlan_bind_walk_data {
	u16 vid;
	struct net_device *result;
};

struct br_vlan_link_state_walk_data {
	struct net_bridge *br;
};

enum {
	BRIDGE_VLANDB_TINFO_UNSPEC = 0,
	BRIDGE_VLANDB_TINFO_ID = 1,
	BRIDGE_VLANDB_TINFO_CMD = 2,
	__BRIDGE_VLANDB_TINFO_MAX = 3,
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
};

enum {
	SUNRPC_PIPEFS_NFS_PRIO = 0,
	SUNRPC_PIPEFS_RPC_PRIO = 1,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
};

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct connect_timeout_data {
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

typedef __be32 rpc_fraghdr;

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	struct page *sk_pages[259];
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		long unsigned int copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	long unsigned int sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct __kernel_sockaddr_storage srcaddr;
	short unsigned int srcport;
	int xprt_err;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

typedef void (*rpc_action)(struct rpc_task *);

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	long unsigned int timeout;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	long unsigned int backlog;
	long unsigned int rtt;
	long unsigned int execute;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	u32 __data_loc_dstaddr;
	u32 __data_loc_dstport;
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	u32 __data_loc_dstaddr;
	u32 __data_loc_dstport;
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	long unsigned int cong;
	long unsigned int cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	long unsigned int copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	short unsigned int port;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_recv {
	struct trace_entry ent;
	u32 xid;
	int len;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 xid;
	long unsigned int svc_status;
	long unsigned int auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 xid;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 xid;
	int status;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long int error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	unsigned char addr[28];
	char __data[0];
};

struct trace_event_raw_svc_xprt_do_enqueue {
	struct trace_entry ent;
	int pid;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	long unsigned int flags;
	long unsigned int wakeup;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_handle_xprt {
	struct trace_entry ent;
	int len;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 xid;
	long unsigned int execute;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_new_socket {
	struct trace_entry ent;
	long unsigned int type;
	long unsigned int family;
	bool listener;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	long unsigned int socket_state;
	long unsigned int sock_state;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long int status;
	u32 __data_loc_service;
	unsigned char addr[28];
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	long unsigned int family;
	short unsigned int protocol;
	short unsigned int port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 addr;
	u32 port;
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	u32 procname;
	u32 servername;
};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_xs_socket_event {
	u32 dstaddr;
	u32 dstport;
};

struct trace_event_data_offsets_xs_socket_event_done {
	u32 dstaddr;
	u32 dstport;
};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	u32 netid;
};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_recv {
	u32 addr;
};

struct trace_event_data_offsets_svc_authenticate {};

struct trace_event_data_offsets_svc_process {
	u32 service;
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	u32 protocol;
};

struct trace_event_data_offsets_svc_xprt_do_enqueue {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 addr;
	u32 protocol;
	u32 service;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 addr;
};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_handle_xprt {
	u32 addr;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 addr;
};

struct trace_event_data_offsets_svc_deferred_event {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_new_socket {};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
};

struct trace_event_data_offsets_cache_event {
	u32 name;
};

struct trace_event_data_offsets_register_class {
	u32 program;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
};

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const char *, const char *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_cleanup)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_transmit_queued)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, short unsigned int);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, short unsigned int);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct svc_rqst *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, const struct svc_rqst *, const struct xdr_buf *);

typedef void (*btf_trace_svc_recv)(void *, struct svc_rqst *, int);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, int, __be32);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, struct svc_rqst *, int);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_do_enqueue)(void *, struct svc_xprt *, struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_close)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_detach)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_free)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, struct svc_rqst *);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_handle_xprt)(void *, struct svc_xprt *, int);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svcsock_new_socket)(void *, const struct socket *);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

enum {
	SVC_POOL_AUTO = 4294967295,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

struct unix_domain {
	struct auth_domain h;
};

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	short unsigned int r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device **vlan_devices_arrays[16];
};

struct vlan_info {
	struct net_device *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

enum vlan_ioctl_cmds {
	ADD_VLAN_CMD = 0,
	DEL_VLAN_CMD = 1,
	SET_VLAN_INGRESS_PRIORITY_CMD = 2,
	SET_VLAN_EGRESS_PRIORITY_CMD = 3,
	GET_VLAN_INGRESS_PRIORITY_CMD = 4,
	GET_VLAN_EGRESS_PRIORITY_CMD = 5,
	SET_VLAN_NAME_TYPE_CMD = 6,
	SET_VLAN_FLAG_CMD = 7,
	GET_VLAN_REALDEV_NAME_CMD = 8,
	GET_VLAN_VID_CMD = 9,
};

enum vlan_name_types {
	VLAN_NAME_TYPE_PLUS_VID = 0,
	VLAN_NAME_TYPE_RAW_PLUS_VID = 1,
	VLAN_NAME_TYPE_PLUS_VID_NO_PAD = 2,
	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD = 3,
	VLAN_NAME_TYPE_HIGHEST = 4,
};

struct vlan_ioctl_args {
	int cmd;
	char device1[24];
	union {
		char device2[24];
		int VID;
		unsigned int skb_priority;
		unsigned int name_type;
		unsigned int bind_type;
		unsigned int flag;
	} u;
	short int vlan_qos;
};

struct vlan_net {
	struct proc_dir_entry *proc_vlan_dir;
	struct proc_dir_entry *proc_vlan_conf;
	short unsigned int name_type;
};

enum {
	IFLA_VLAN_UNSPEC = 0,
	IFLA_VLAN_ID = 1,
	IFLA_VLAN_FLAGS = 2,
	IFLA_VLAN_EGRESS_QOS = 3,
	IFLA_VLAN_INGRESS_QOS = 4,
	IFLA_VLAN_PROTOCOL = 5,
	__IFLA_VLAN_MAX = 6,
};

struct ifla_vlan_flags {
	__u32 flags;
	__u32 mask;
};

enum {
	IFLA_VLAN_QOS_UNSPEC = 0,
	IFLA_VLAN_QOS_MAPPING = 1,
	__IFLA_VLAN_QOS_MAX = 2,
};

struct ifla_vlan_qos_mapping {
	__u32 from;
	__u32 to;
};

enum nl80211_commands {
	NL80211_CMD_UNSPEC = 0,
	NL80211_CMD_GET_WIPHY = 1,
	NL80211_CMD_SET_WIPHY = 2,
	NL80211_CMD_NEW_WIPHY = 3,
	NL80211_CMD_DEL_WIPHY = 4,
	NL80211_CMD_GET_INTERFACE = 5,
	NL80211_CMD_SET_INTERFACE = 6,
	NL80211_CMD_NEW_INTERFACE = 7,
	NL80211_CMD_DEL_INTERFACE = 8,
	NL80211_CMD_GET_KEY = 9,
	NL80211_CMD_SET_KEY = 10,
	NL80211_CMD_NEW_KEY = 11,
	NL80211_CMD_DEL_KEY = 12,
	NL80211_CMD_GET_BEACON = 13,
	NL80211_CMD_SET_BEACON = 14,
	NL80211_CMD_START_AP = 15,
	NL80211_CMD_NEW_BEACON = 15,
	NL80211_CMD_STOP_AP = 16,
	NL80211_CMD_DEL_BEACON = 16,
	NL80211_CMD_GET_STATION = 17,
	NL80211_CMD_SET_STATION = 18,
	NL80211_CMD_NEW_STATION = 19,
	NL80211_CMD_DEL_STATION = 20,
	NL80211_CMD_GET_MPATH = 21,
	NL80211_CMD_SET_MPATH = 22,
	NL80211_CMD_NEW_MPATH = 23,
	NL80211_CMD_DEL_MPATH = 24,
	NL80211_CMD_SET_BSS = 25,
	NL80211_CMD_SET_REG = 26,
	NL80211_CMD_REQ_SET_REG = 27,
	NL80211_CMD_GET_MESH_CONFIG = 28,
	NL80211_CMD_SET_MESH_CONFIG = 29,
	NL80211_CMD_SET_MGMT_EXTRA_IE = 30,
	NL80211_CMD_GET_REG = 31,
	NL80211_CMD_GET_SCAN = 32,
	NL80211_CMD_TRIGGER_SCAN = 33,
	NL80211_CMD_NEW_SCAN_RESULTS = 34,
	NL80211_CMD_SCAN_ABORTED = 35,
	NL80211_CMD_REG_CHANGE = 36,
	NL80211_CMD_AUTHENTICATE = 37,
	NL80211_CMD_ASSOCIATE = 38,
	NL80211_CMD_DEAUTHENTICATE = 39,
	NL80211_CMD_DISASSOCIATE = 40,
	NL80211_CMD_MICHAEL_MIC_FAILURE = 41,
	NL80211_CMD_REG_BEACON_HINT = 42,
	NL80211_CMD_JOIN_IBSS = 43,
	NL80211_CMD_LEAVE_IBSS = 44,
	NL80211_CMD_TESTMODE = 45,
	NL80211_CMD_CONNECT = 46,
	NL80211_CMD_ROAM = 47,
	NL80211_CMD_DISCONNECT = 48,
	NL80211_CMD_SET_WIPHY_NETNS = 49,
	NL80211_CMD_GET_SURVEY = 50,
	NL80211_CMD_NEW_SURVEY_RESULTS = 51,
	NL80211_CMD_SET_PMKSA = 52,
	NL80211_CMD_DEL_PMKSA = 53,
	NL80211_CMD_FLUSH_PMKSA = 54,
	NL80211_CMD_REMAIN_ON_CHANNEL = 55,
	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL = 56,
	NL80211_CMD_SET_TX_BITRATE_MASK = 57,
	NL80211_CMD_REGISTER_FRAME = 58,
	NL80211_CMD_REGISTER_ACTION = 58,
	NL80211_CMD_FRAME = 59,
	NL80211_CMD_ACTION = 59,
	NL80211_CMD_FRAME_TX_STATUS = 60,
	NL80211_CMD_ACTION_TX_STATUS = 60,
	NL80211_CMD_SET_POWER_SAVE = 61,
	NL80211_CMD_GET_POWER_SAVE = 62,
	NL80211_CMD_SET_CQM = 63,
	NL80211_CMD_NOTIFY_CQM = 64,
	NL80211_CMD_SET_CHANNEL = 65,
	NL80211_CMD_SET_WDS_PEER = 66,
	NL80211_CMD_FRAME_WAIT_CANCEL = 67,
	NL80211_CMD_JOIN_MESH = 68,
	NL80211_CMD_LEAVE_MESH = 69,
	NL80211_CMD_UNPROT_DEAUTHENTICATE = 70,
	NL80211_CMD_UNPROT_DISASSOCIATE = 71,
	NL80211_CMD_NEW_PEER_CANDIDATE = 72,
	NL80211_CMD_GET_WOWLAN = 73,
	NL80211_CMD_SET_WOWLAN = 74,
	NL80211_CMD_START_SCHED_SCAN = 75,
	NL80211_CMD_STOP_SCHED_SCAN = 76,
	NL80211_CMD_SCHED_SCAN_RESULTS = 77,
	NL80211_CMD_SCHED_SCAN_STOPPED = 78,
	NL80211_CMD_SET_REKEY_OFFLOAD = 79,
	NL80211_CMD_PMKSA_CANDIDATE = 80,
	NL80211_CMD_TDLS_OPER = 81,
	NL80211_CMD_TDLS_MGMT = 82,
	NL80211_CMD_UNEXPECTED_FRAME = 83,
	NL80211_CMD_PROBE_CLIENT = 84,
	NL80211_CMD_REGISTER_BEACONS = 85,
	NL80211_CMD_UNEXPECTED_4ADDR_FRAME = 86,
	NL80211_CMD_SET_NOACK_MAP = 87,
	NL80211_CMD_CH_SWITCH_NOTIFY = 88,
	NL80211_CMD_START_P2P_DEVICE = 89,
	NL80211_CMD_STOP_P2P_DEVICE = 90,
	NL80211_CMD_CONN_FAILED = 91,
	NL80211_CMD_SET_MCAST_RATE = 92,
	NL80211_CMD_SET_MAC_ACL = 93,
	NL80211_CMD_RADAR_DETECT = 94,
	NL80211_CMD_GET_PROTOCOL_FEATURES = 95,
	NL80211_CMD_UPDATE_FT_IES = 96,
	NL80211_CMD_FT_EVENT = 97,
	NL80211_CMD_CRIT_PROTOCOL_START = 98,
	NL80211_CMD_CRIT_PROTOCOL_STOP = 99,
	NL80211_CMD_GET_COALESCE = 100,
	NL80211_CMD_SET_COALESCE = 101,
	NL80211_CMD_CHANNEL_SWITCH = 102,
	NL80211_CMD_VENDOR = 103,
	NL80211_CMD_SET_QOS_MAP = 104,
	NL80211_CMD_ADD_TX_TS = 105,
	NL80211_CMD_DEL_TX_TS = 106,
	NL80211_CMD_GET_MPP = 107,
	NL80211_CMD_JOIN_OCB = 108,
	NL80211_CMD_LEAVE_OCB = 109,
	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY = 110,
	NL80211_CMD_TDLS_CHANNEL_SWITCH = 111,
	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH = 112,
	NL80211_CMD_WIPHY_REG_CHANGE = 113,
	NL80211_CMD_ABORT_SCAN = 114,
	NL80211_CMD_START_NAN = 115,
	NL80211_CMD_STOP_NAN = 116,
	NL80211_CMD_ADD_NAN_FUNCTION = 117,
	NL80211_CMD_DEL_NAN_FUNCTION = 118,
	NL80211_CMD_CHANGE_NAN_CONFIG = 119,
	NL80211_CMD_NAN_MATCH = 120,
	NL80211_CMD_SET_MULTICAST_TO_UNICAST = 121,
	NL80211_CMD_UPDATE_CONNECT_PARAMS = 122,
	NL80211_CMD_SET_PMK = 123,
	NL80211_CMD_DEL_PMK = 124,
	NL80211_CMD_PORT_AUTHORIZED = 125,
	NL80211_CMD_RELOAD_REGDB = 126,
	NL80211_CMD_EXTERNAL_AUTH = 127,
	NL80211_CMD_STA_OPMODE_CHANGED = 128,
	NL80211_CMD_CONTROL_PORT_FRAME = 129,
	NL80211_CMD_GET_FTM_RESPONDER_STATS = 130,
	NL80211_CMD_PEER_MEASUREMENT_START = 131,
	NL80211_CMD_PEER_MEASUREMENT_RESULT = 132,
	NL80211_CMD_PEER_MEASUREMENT_COMPLETE = 133,
	NL80211_CMD_NOTIFY_RADAR = 134,
	NL80211_CMD_UPDATE_OWE_INFO = 135,
	NL80211_CMD_PROBE_MESH_LINK = 136,
	NL80211_CMD_SET_TID_CONFIG = 137,
	NL80211_CMD_UNPROT_BEACON = 138,
	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS = 139,
	__NL80211_CMD_AFTER_LAST = 140,
	NL80211_CMD_MAX = 139,
};

enum nl80211_iftype {
	NL80211_IFTYPE_UNSPECIFIED = 0,
	NL80211_IFTYPE_ADHOC = 1,
	NL80211_IFTYPE_STATION = 2,
	NL80211_IFTYPE_AP = 3,
	NL80211_IFTYPE_AP_VLAN = 4,
	NL80211_IFTYPE_WDS = 5,
	NL80211_IFTYPE_MONITOR = 6,
	NL80211_IFTYPE_MESH_POINT = 7,
	NL80211_IFTYPE_P2P_CLIENT = 8,
	NL80211_IFTYPE_P2P_GO = 9,
	NL80211_IFTYPE_P2P_DEVICE = 10,
	NL80211_IFTYPE_OCB = 11,
	NL80211_IFTYPE_NAN = 12,
	NUM_NL80211_IFTYPES = 13,
	NL80211_IFTYPE_MAX = 12,
};

struct nl80211_sta_flag_update {
	__u32 mask;
	__u32 set;
};

enum nl80211_he_gi {
	NL80211_RATE_INFO_HE_GI_0_8 = 0,
	NL80211_RATE_INFO_HE_GI_1_6 = 1,
	NL80211_RATE_INFO_HE_GI_3_2 = 2,
};

enum nl80211_he_ltf {
	NL80211_RATE_INFO_HE_1XLTF = 0,
	NL80211_RATE_INFO_HE_2XLTF = 1,
	NL80211_RATE_INFO_HE_4XLTF = 2,
};

enum nl80211_reg_initiator {
	NL80211_REGDOM_SET_BY_CORE = 0,
	NL80211_REGDOM_SET_BY_USER = 1,
	NL80211_REGDOM_SET_BY_DRIVER = 2,
	NL80211_REGDOM_SET_BY_COUNTRY_IE = 3,
};

enum nl80211_dfs_regions {
	NL80211_DFS_UNSET = 0,
	NL80211_DFS_FCC = 1,
	NL80211_DFS_ETSI = 2,
	NL80211_DFS_JP = 3,
};

enum nl80211_user_reg_hint_type {
	NL80211_USER_REG_HINT_USER = 0,
	NL80211_USER_REG_HINT_CELL_BASE = 1,
	NL80211_USER_REG_HINT_INDOOR = 2,
};

enum nl80211_mntr_flags {
	__NL80211_MNTR_FLAG_INVALID = 0,
	NL80211_MNTR_FLAG_FCSFAIL = 1,
	NL80211_MNTR_FLAG_PLCPFAIL = 2,
	NL80211_MNTR_FLAG_CONTROL = 3,
	NL80211_MNTR_FLAG_OTHER_BSS = 4,
	NL80211_MNTR_FLAG_COOK_FRAMES = 5,
	NL80211_MNTR_FLAG_ACTIVE = 6,
	__NL80211_MNTR_FLAG_AFTER_LAST = 7,
	NL80211_MNTR_FLAG_MAX = 6,
};

enum nl80211_mesh_power_mode {
	NL80211_MESH_POWER_UNKNOWN = 0,
	NL80211_MESH_POWER_ACTIVE = 1,
	NL80211_MESH_POWER_LIGHT_SLEEP = 2,
	NL80211_MESH_POWER_DEEP_SLEEP = 3,
	__NL80211_MESH_POWER_AFTER_LAST = 4,
	NL80211_MESH_POWER_MAX = 3,
};

enum nl80211_ac {
	NL80211_AC_VO = 0,
	NL80211_AC_VI = 1,
	NL80211_AC_BE = 2,
	NL80211_AC_BK = 3,
	NL80211_NUM_ACS = 4,
};

enum nl80211_key_mode {
	NL80211_KEY_RX_TX = 0,
	NL80211_KEY_NO_TX = 1,
	NL80211_KEY_SET_TX = 2,
};

enum nl80211_chan_width {
	NL80211_CHAN_WIDTH_20_NOHT = 0,
	NL80211_CHAN_WIDTH_20 = 1,
	NL80211_CHAN_WIDTH_40 = 2,
	NL80211_CHAN_WIDTH_80 = 3,
	NL80211_CHAN_WIDTH_80P80 = 4,
	NL80211_CHAN_WIDTH_160 = 5,
	NL80211_CHAN_WIDTH_5 = 6,
	NL80211_CHAN_WIDTH_10 = 7,
	NL80211_CHAN_WIDTH_1 = 8,
	NL80211_CHAN_WIDTH_2 = 9,
	NL80211_CHAN_WIDTH_4 = 10,
	NL80211_CHAN_WIDTH_8 = 11,
	NL80211_CHAN_WIDTH_16 = 12,
};

enum nl80211_bss_scan_width {
	NL80211_BSS_CHAN_WIDTH_20 = 0,
	NL80211_BSS_CHAN_WIDTH_10 = 1,
	NL80211_BSS_CHAN_WIDTH_5 = 2,
	NL80211_BSS_CHAN_WIDTH_1 = 3,
	NL80211_BSS_CHAN_WIDTH_2 = 4,
};

enum nl80211_auth_type {
	NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
	NL80211_AUTHTYPE_SHARED_KEY = 1,
	NL80211_AUTHTYPE_FT = 2,
	NL80211_AUTHTYPE_NETWORK_EAP = 3,
	NL80211_AUTHTYPE_SAE = 4,
	NL80211_AUTHTYPE_FILS_SK = 5,
	NL80211_AUTHTYPE_FILS_SK_PFS = 6,
	NL80211_AUTHTYPE_FILS_PK = 7,
	__NL80211_AUTHTYPE_NUM = 8,
	NL80211_AUTHTYPE_MAX = 7,
	NL80211_AUTHTYPE_AUTOMATIC = 8,
};

enum nl80211_mfp {
	NL80211_MFP_NO = 0,
	NL80211_MFP_REQUIRED = 1,
	NL80211_MFP_OPTIONAL = 2,
};

enum nl80211_txrate_gi {
	NL80211_TXRATE_DEFAULT_GI = 0,
	NL80211_TXRATE_FORCE_SGI = 1,
	NL80211_TXRATE_FORCE_LGI = 2,
};

enum nl80211_band {
	NL80211_BAND_2GHZ = 0,
	NL80211_BAND_5GHZ = 1,
	NL80211_BAND_60GHZ = 2,
	NL80211_BAND_6GHZ = 3,
	NL80211_BAND_S1GHZ = 4,
	NUM_NL80211_BANDS = 5,
};

enum nl80211_tx_power_setting {
	NL80211_TX_POWER_AUTOMATIC = 0,
	NL80211_TX_POWER_LIMITED = 1,
	NL80211_TX_POWER_FIXED = 2,
};

enum nl80211_tid_config {
	NL80211_TID_CONFIG_ENABLE = 0,
	NL80211_TID_CONFIG_DISABLE = 1,
};

enum nl80211_tx_rate_setting {
	NL80211_TX_RATE_AUTOMATIC = 0,
	NL80211_TX_RATE_LIMITED = 1,
	NL80211_TX_RATE_FIXED = 2,
};

struct nl80211_wowlan_tcp_data_seq {
	__u32 start;
	__u32 offset;
	__u32 len;
};

struct nl80211_wowlan_tcp_data_token {
	__u32 offset;
	__u32 len;
	__u8 token_stream[0];
};

struct nl80211_wowlan_tcp_data_token_feature {
	__u32 min_len;
	__u32 max_len;
	__u32 bufsize;
};

enum nl80211_coalesce_condition {
	NL80211_COALESCE_CONDITION_MATCH = 0,
	NL80211_COALESCE_CONDITION_NO_MATCH = 1,
};

enum nl80211_hidden_ssid {
	NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
	NL80211_HIDDEN_SSID_ZERO_LEN = 1,
	NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2,
};

enum nl80211_tdls_operation {
	NL80211_TDLS_DISCOVERY_REQ = 0,
	NL80211_TDLS_SETUP = 1,
	NL80211_TDLS_TEARDOWN = 2,
	NL80211_TDLS_ENABLE_LINK = 3,
	NL80211_TDLS_DISABLE_LINK = 4,
};

enum nl80211_feature_flags {
	NL80211_FEATURE_SK_TX_STATUS = 1,
	NL80211_FEATURE_HT_IBSS = 2,
	NL80211_FEATURE_INACTIVITY_TIMER = 4,
	NL80211_FEATURE_CELL_BASE_REG_HINTS = 8,
	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL = 16,
	NL80211_FEATURE_SAE = 32,
	NL80211_FEATURE_LOW_PRIORITY_SCAN = 64,
	NL80211_FEATURE_SCAN_FLUSH = 128,
	NL80211_FEATURE_AP_SCAN = 256,
	NL80211_FEATURE_VIF_TXPOWER = 512,
	NL80211_FEATURE_NEED_OBSS_SCAN = 1024,
	NL80211_FEATURE_P2P_GO_CTWIN = 2048,
	NL80211_FEATURE_P2P_GO_OPPPS = 4096,
	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS = 16384,
	NL80211_FEATURE_FULL_AP_CLIENT_STATE = 32768,
	NL80211_FEATURE_USERSPACE_MPM = 65536,
	NL80211_FEATURE_ACTIVE_MONITOR = 131072,
	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE = 262144,
	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES = 524288,
	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES = 1048576,
	NL80211_FEATURE_QUIET = 2097152,
	NL80211_FEATURE_TX_POWER_INSERTION = 4194304,
	NL80211_FEATURE_ACKTO_ESTIMATION = 8388608,
	NL80211_FEATURE_STATIC_SMPS = 16777216,
	NL80211_FEATURE_DYNAMIC_SMPS = 33554432,
	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION = 67108864,
	NL80211_FEATURE_MAC_ON_CREATE = 134217728,
	NL80211_FEATURE_TDLS_CHANNEL_SWITCH = 268435456,
	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR = 536870912,
	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR = 1073741824,
	NL80211_FEATURE_ND_RANDOM_MAC_ADDR = 2147483648,
};

enum nl80211_ext_feature_index {
	NL80211_EXT_FEATURE_VHT_IBSS = 0,
	NL80211_EXT_FEATURE_RRM = 1,
	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER = 2,
	NL80211_EXT_FEATURE_SCAN_START_TIME = 3,
	NL80211_EXT_FEATURE_BSS_PARENT_TSF = 4,
	NL80211_EXT_FEATURE_SET_SCAN_DWELL = 5,
	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY = 6,
	NL80211_EXT_FEATURE_BEACON_RATE_HT = 7,
	NL80211_EXT_FEATURE_BEACON_RATE_VHT = 8,
	NL80211_EXT_FEATURE_FILS_STA = 9,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA = 10,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED = 11,
	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI = 12,
	NL80211_EXT_FEATURE_CQM_RSSI_LIST = 13,
	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD = 14,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK = 15,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X = 16,
	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME = 17,
	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP = 18,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE = 19,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 20,
	NL80211_EXT_FEATURE_MFP_OPTIONAL = 21,
	NL80211_EXT_FEATURE_LOW_SPAN_SCAN = 22,
	NL80211_EXT_FEATURE_LOW_POWER_SCAN = 23,
	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN = 24,
	NL80211_EXT_FEATURE_DFS_OFFLOAD = 25,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211 = 26,
	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_TXQS = 28,
	NL80211_EXT_FEATURE_SCAN_RANDOM_SN = 29,
	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT = 30,
	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 = 31,
	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER = 32,
	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS = 33,
	NL80211_EXT_FEATURE_AP_PMKSA_CACHING = 34,
	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 35,
	NL80211_EXT_FEATURE_EXT_KEY_ID = 36,
	NL80211_EXT_FEATURE_STA_TX_PWR = 37,
	NL80211_EXT_FEATURE_SAE_OFFLOAD = 38,
	NL80211_EXT_FEATURE_VLAN_OFFLOAD = 39,
	NL80211_EXT_FEATURE_AQL = 40,
	NL80211_EXT_FEATURE_BEACON_PROTECTION = 41,
	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH = 42,
	NL80211_EXT_FEATURE_PROTECTED_TWT = 43,
	NL80211_EXT_FEATURE_DEL_IBSS_STA = 44,
	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS = 45,
	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 46,
	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ = 47,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 48,
	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION = 49,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK = 50,
	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP = 51,
	NL80211_EXT_FEATURE_FILS_DISCOVERY = 52,
	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP = 53,
	NL80211_EXT_FEATURE_BEACON_RATE_HE = 54,
	NUM_NL80211_EXT_FEATURES = 55,
	MAX_NL80211_EXT_FEATURES = 54,
};

enum nl80211_timeout_reason {
	NL80211_TIMEOUT_UNSPECIFIED = 0,
	NL80211_TIMEOUT_SCAN = 1,
	NL80211_TIMEOUT_AUTH = 2,
	NL80211_TIMEOUT_ASSOC = 3,
};

enum nl80211_acl_policy {
	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
	NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1,
};

enum nl80211_smps_mode {
	NL80211_SMPS_OFF = 0,
	NL80211_SMPS_STATIC = 1,
	NL80211_SMPS_DYNAMIC = 2,
	__NL80211_SMPS_AFTER_LAST = 3,
	NL80211_SMPS_MAX = 2,
};

enum nl80211_radar_event {
	NL80211_RADAR_DETECTED = 0,
	NL80211_RADAR_CAC_FINISHED = 1,
	NL80211_RADAR_CAC_ABORTED = 2,
	NL80211_RADAR_NOP_FINISHED = 3,
	NL80211_RADAR_PRE_CAC_EXPIRED = 4,
	NL80211_RADAR_CAC_STARTED = 5,
};

enum nl80211_dfs_state {
	NL80211_DFS_USABLE = 0,
	NL80211_DFS_UNAVAILABLE = 1,
	NL80211_DFS_AVAILABLE = 2,
};

enum nl80211_crit_proto_id {
	NL80211_CRIT_PROTO_UNSPEC = 0,
	NL80211_CRIT_PROTO_DHCP = 1,
	NL80211_CRIT_PROTO_EAPOL = 2,
	NL80211_CRIT_PROTO_APIPA = 3,
	NUM_NL80211_CRIT_PROTO = 4,
};

struct nl80211_vendor_cmd_info {
	__u32 vendor_id;
	__u32 subcmd;
};

enum nl80211_bss_select_attr {
	__NL80211_BSS_SELECT_ATTR_INVALID = 0,
	NL80211_BSS_SELECT_ATTR_RSSI = 1,
	NL80211_BSS_SELECT_ATTR_BAND_PREF = 2,
	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST = 3,
	__NL80211_BSS_SELECT_ATTR_AFTER_LAST = 4,
	NL80211_BSS_SELECT_ATTR_MAX = 3,
};

enum nl80211_nan_function_type {
	NL80211_NAN_FUNC_PUBLISH = 0,
	NL80211_NAN_FUNC_SUBSCRIBE = 1,
	NL80211_NAN_FUNC_FOLLOW_UP = 2,
	__NL80211_NAN_FUNC_TYPE_AFTER_LAST = 3,
	NL80211_NAN_FUNC_MAX_TYPE = 2,
};

enum nl80211_external_auth_action {
	NL80211_EXTERNAL_AUTH_START = 0,
	NL80211_EXTERNAL_AUTH_ABORT = 1,
};

enum nl80211_preamble {
	NL80211_PREAMBLE_LEGACY = 0,
	NL80211_PREAMBLE_HT = 1,
	NL80211_PREAMBLE_VHT = 2,
	NL80211_PREAMBLE_DMG = 3,
	NL80211_PREAMBLE_HE = 4,
};

enum nl80211_sae_pwe_mechanism {
	NL80211_SAE_PWE_UNSPECIFIED = 0,
	NL80211_SAE_PWE_HUNT_AND_PECK = 1,
	NL80211_SAE_PWE_HASH_TO_ELEMENT = 2,
	NL80211_SAE_PWE_BOTH = 3,
};

enum ieee80211_bss_type {
	IEEE80211_BSS_TYPE_ESS = 0,
	IEEE80211_BSS_TYPE_PBSS = 1,
	IEEE80211_BSS_TYPE_IBSS = 2,
	IEEE80211_BSS_TYPE_MBSS = 3,
	IEEE80211_BSS_TYPE_ANY = 4,
};

enum ieee80211_edmg_bw_config {
	IEEE80211_EDMG_BW_CONFIG_4 = 4,
	IEEE80211_EDMG_BW_CONFIG_5 = 5,
	IEEE80211_EDMG_BW_CONFIG_6 = 6,
	IEEE80211_EDMG_BW_CONFIG_7 = 7,
	IEEE80211_EDMG_BW_CONFIG_8 = 8,
	IEEE80211_EDMG_BW_CONFIG_9 = 9,
	IEEE80211_EDMG_BW_CONFIG_10 = 10,
	IEEE80211_EDMG_BW_CONFIG_11 = 11,
	IEEE80211_EDMG_BW_CONFIG_12 = 12,
	IEEE80211_EDMG_BW_CONFIG_13 = 13,
	IEEE80211_EDMG_BW_CONFIG_14 = 14,
	IEEE80211_EDMG_BW_CONFIG_15 = 15,
};

struct ieee80211_edmg {
	u8 channels;
	enum ieee80211_edmg_bw_config bw_config;
};

struct ieee80211_channel;

struct cfg80211_chan_def {
	struct ieee80211_channel *chan;
	enum nl80211_chan_width width;
	u32 center_freq1;
	u32 center_freq2;
	struct ieee80211_edmg edmg;
	u16 freq1_offset;
};

struct wiphy;

struct cfg80211_conn;

struct cfg80211_cached_keys;

struct cfg80211_internal_bss;

struct cfg80211_cqm_config;

struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;
	struct list_head list;
	struct net_device *netdev;
	u32 identifier;
	struct list_head mgmt_registrations;
	spinlock_t mgmt_registrations_lock;
	u8 mgmt_registrations_need_update: 1;
	struct mutex mtx;
	bool use_4addr;
	bool is_running;
	u8 address[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 mesh_id_len;
	u8 mesh_id_up_len;
	struct cfg80211_conn *conn;
	struct cfg80211_cached_keys *connect_keys;
	enum ieee80211_bss_type conn_bss_type;
	u32 conn_owner_nlportid;
	struct work_struct disconnect_wk;
	u8 disconnect_bssid[6];
	struct list_head event_list;
	spinlock_t event_lock;
	struct cfg80211_internal_bss *current_bss;
	struct cfg80211_chan_def preset_chandef;
	struct cfg80211_chan_def chandef;
	bool ibss_fixed;
	bool ibss_dfs_possible;
	bool ps;
	int ps_timeout;
	int beacon_interval;
	u32 ap_unexpected_nlportid;
	u32 owner_nlportid;
	bool nl_owner_dead;
	bool cac_started;
	long unsigned int cac_start_time;
	unsigned int cac_time_ms;
	struct cfg80211_cqm_config *cqm_config;
	struct list_head pmsr_list;
	spinlock_t pmsr_lock;
	struct work_struct pmsr_free_wk;
	long unsigned int unprot_beacon_reported;
};

struct ieee80211_s1g_cap {
	u8 capab_info[10];
	u8 supp_mcs_nss[5];
};

struct ieee80211_mcs_info {
	u8 rx_mask[10];
	__le16 rx_highest;
	u8 tx_params;
	u8 reserved[3];
};

struct ieee80211_ht_cap {
	__le16 cap_info;
	u8 ampdu_params_info;
	struct ieee80211_mcs_info mcs;
	__le16 extended_ht_cap_info;
	__le32 tx_BF_cap_info;
	u8 antenna_selection_info;
} __attribute__((packed));

struct ieee80211_vht_mcs_info {
	__le16 rx_mcs_map;
	__le16 rx_highest;
	__le16 tx_mcs_map;
	__le16 tx_highest;
};

struct ieee80211_vht_cap {
	__le32 vht_cap_info;
	struct ieee80211_vht_mcs_info supp_mcs;
};

struct ieee80211_he_cap_elem {
	u8 mac_cap_info[6];
	u8 phy_cap_info[11];
};

struct ieee80211_he_mcs_nss_supp {
	__le16 rx_mcs_80;
	__le16 tx_mcs_80;
	__le16 rx_mcs_160;
	__le16 tx_mcs_160;
	__le16 rx_mcs_80p80;
	__le16 tx_mcs_80p80;
};

struct ieee80211_he_operation {
	__le32 he_oper_params;
	__le16 he_mcs_nss_set;
	u8 optional[0];
} __attribute__((packed));

enum ieee80211_reasoncode {
	WLAN_REASON_UNSPECIFIED = 1,
	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
	WLAN_REASON_DEAUTH_LEAVING = 3,
	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
	WLAN_REASON_DISASSOC_AP_BUSY = 5,
	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
	WLAN_REASON_DISASSOC_BAD_POWER = 10,
	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
	WLAN_REASON_INVALID_IE = 13,
	WLAN_REASON_MIC_FAILURE = 14,
	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
	WLAN_REASON_IE_DIFFERENT = 17,
	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
	WLAN_REASON_INVALID_AKMP = 20,
	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
	WLAN_REASON_IEEE8021X_FAILED = 23,
	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
	WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE = 25,
	WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED = 26,
	WLAN_REASON_DISASSOC_UNSPECIFIED_QOS = 32,
	WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH = 33,
	WLAN_REASON_DISASSOC_LOW_ACK = 34,
	WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP = 35,
	WLAN_REASON_QSTA_LEAVE_QBSS = 36,
	WLAN_REASON_QSTA_NOT_USE = 37,
	WLAN_REASON_QSTA_REQUIRE_SETUP = 38,
	WLAN_REASON_QSTA_TIMEOUT = 39,
	WLAN_REASON_QSTA_CIPHER_NOT_SUPP = 45,
	WLAN_REASON_MESH_PEER_CANCELED = 52,
	WLAN_REASON_MESH_MAX_PEERS = 53,
	WLAN_REASON_MESH_CONFIG = 54,
	WLAN_REASON_MESH_CLOSE = 55,
	WLAN_REASON_MESH_MAX_RETRIES = 56,
	WLAN_REASON_MESH_CONFIRM_TIMEOUT = 57,
	WLAN_REASON_MESH_INVALID_GTK = 58,
	WLAN_REASON_MESH_INCONSISTENT_PARAM = 59,
	WLAN_REASON_MESH_INVALID_SECURITY = 60,
	WLAN_REASON_MESH_PATH_ERROR = 61,
	WLAN_REASON_MESH_PATH_NOFORWARD = 62,
	WLAN_REASON_MESH_PATH_DEST_UNREACHABLE = 63,
	WLAN_REASON_MAC_EXISTS_IN_MBSS = 64,
	WLAN_REASON_MESH_CHAN_REGULATORY = 65,
	WLAN_REASON_MESH_CHAN = 66,
};

enum ieee80211_key_len {
	WLAN_KEY_LEN_WEP40 = 5,
	WLAN_KEY_LEN_WEP104 = 13,
	WLAN_KEY_LEN_CCMP = 16,
	WLAN_KEY_LEN_CCMP_256 = 32,
	WLAN_KEY_LEN_TKIP = 32,
	WLAN_KEY_LEN_AES_CMAC = 16,
	WLAN_KEY_LEN_SMS4 = 32,
	WLAN_KEY_LEN_GCMP = 16,
	WLAN_KEY_LEN_GCMP_256 = 32,
	WLAN_KEY_LEN_BIP_CMAC_256 = 32,
	WLAN_KEY_LEN_BIP_GMAC_128 = 16,
	WLAN_KEY_LEN_BIP_GMAC_256 = 32,
};

struct ieee80211_he_6ghz_capa {
	__le16 capa;
};

enum environment_cap {
	ENVIRON_ANY = 0,
	ENVIRON_INDOOR = 1,
	ENVIRON_OUTDOOR = 2,
};

struct regulatory_request {
	struct callback_head callback_head;
	int wiphy_idx;
	enum nl80211_reg_initiator initiator;
	enum nl80211_user_reg_hint_type user_reg_hint_type;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	bool intersect;
	bool processed;
	enum environment_cap country_ie_env;
	struct list_head list;
};

enum ieee80211_regulatory_flags {
	REGULATORY_CUSTOM_REG = 1,
	REGULATORY_STRICT_REG = 2,
	REGULATORY_DISABLE_BEACON_HINTS = 4,
	REGULATORY_COUNTRY_IE_FOLLOW_POWER = 8,
	REGULATORY_COUNTRY_IE_IGNORE = 16,
	REGULATORY_ENABLE_RELAX_NO_IR = 32,
	REGULATORY_IGNORE_STALE_KICKOFF = 64,
	REGULATORY_WIPHY_SELF_MANAGED = 128,
};

struct ieee80211_freq_range {
	u32 start_freq_khz;
	u32 end_freq_khz;
	u32 max_bandwidth_khz;
};

struct ieee80211_power_rule {
	u32 max_antenna_gain;
	u32 max_eirp;
};

struct ieee80211_wmm_ac {
	u16 cw_min;
	u16 cw_max;
	u16 cot;
	u8 aifsn;
};

struct ieee80211_wmm_rule {
	struct ieee80211_wmm_ac client[4];
	struct ieee80211_wmm_ac ap[4];
};

struct ieee80211_reg_rule {
	struct ieee80211_freq_range freq_range;
	struct ieee80211_power_rule power_rule;
	struct ieee80211_wmm_rule wmm_rule;
	u32 flags;
	u32 dfs_cac_ms;
	bool has_wmm;
};

struct ieee80211_regdomain {
	struct callback_head callback_head;
	u32 n_reg_rules;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	struct ieee80211_reg_rule reg_rules[0];
};

struct ieee80211_channel {
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u16 hw_value;
	u32 flags;
	int max_antenna_gain;
	int max_power;
	int max_reg_power;
	bool beacon_found;
	u32 orig_flags;
	int orig_mag;
	int orig_mpwr;
	enum nl80211_dfs_state dfs_state;
	long unsigned int dfs_state_entered;
	unsigned int dfs_cac_ms;
};

struct ieee80211_rate {
	u32 flags;
	u16 bitrate;
	u16 hw_value;
	u16 hw_value_short;
};

struct ieee80211_he_obss_pd {
	bool enable;
	u8 sr_ctrl;
	u8 non_srg_max_offset;
	u8 min_offset;
	u8 max_offset;
	u8 bss_color_bitmap[8];
	u8 partial_bssid_bitmap[8];
};

struct cfg80211_he_bss_color {
	u8 color;
	bool enabled;
	bool partial;
};

struct ieee80211_sta_ht_cap {
	u16 cap;
	bool ht_supported;
	u8 ampdu_factor;
	u8 ampdu_density;
	struct ieee80211_mcs_info mcs;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_vht_cap {
	bool vht_supported;
	u32 cap;
	struct ieee80211_vht_mcs_info vht_mcs;
};

struct ieee80211_sta_he_cap {
	bool has_he;
	struct ieee80211_he_cap_elem he_cap_elem;
	struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;
	u8 ppe_thres[25];
} __attribute__((packed));

struct ieee80211_sband_iftype_data {
	u16 types_mask;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_s1g_cap {
	bool s1g;
	u8 cap[10];
	u8 nss_mcs[5];
};

struct ieee80211_supported_band {
	struct ieee80211_channel *channels;
	struct ieee80211_rate *bitrates;
	enum nl80211_band band;
	int n_channels;
	int n_bitrates;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_s1g_cap s1g_cap;
	struct ieee80211_edmg edmg_cap;
	u16 n_iftype_data;
	const struct ieee80211_sband_iftype_data *iftype_data;
};

struct vif_params {
	u32 flags;
	int use_4addr;
	u8 macaddr[6];
	const u8 *vht_mumimo_groups;
	const u8 *vht_mumimo_follow_addr;
};

struct key_params {
	const u8 *key;
	const u8 *seq;
	int key_len;
	int seq_len;
	u16 vlan_id;
	u32 cipher;
	enum nl80211_key_mode mode;
};

struct cfg80211_bitrate_mask {
	struct {
		u32 legacy;
		u8 ht_mcs[10];
		u16 vht_mcs[8];
		u16 he_mcs[8];
		enum nl80211_txrate_gi gi;
		enum nl80211_he_gi he_gi;
		enum nl80211_he_ltf he_ltf;
	} control[5];
};

struct cfg80211_tid_cfg {
	bool config_override;
	u8 tids;
	u64 mask;
	enum nl80211_tid_config noack;
	u8 retry_long;
	u8 retry_short;
	enum nl80211_tid_config ampdu;
	enum nl80211_tid_config rtscts;
	enum nl80211_tid_config amsdu;
	enum nl80211_tx_rate_setting txrate_type;
	struct cfg80211_bitrate_mask txrate_mask;
};

struct cfg80211_tid_config {
	const u8 *peer;
	u32 n_tid_conf;
	struct cfg80211_tid_cfg tid_conf[0];
};

struct survey_info {
	struct ieee80211_channel *channel;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u64 time_bss_rx;
	u32 filled;
	s8 noise;
};

struct cfg80211_crypto_settings {
	u32 wpa_versions;
	u32 cipher_group;
	int n_ciphers_pairwise;
	u32 ciphers_pairwise[5];
	int n_akm_suites;
	u32 akm_suites[2];
	bool control_port;
	__be16 control_port_ethertype;
	bool control_port_no_encrypt;
	bool control_port_over_nl80211;
	bool control_port_no_preauth;
	struct key_params *wep_keys;
	int wep_tx_key;
	const u8 *psk;
	const u8 *sae_pwd;
	u8 sae_pwd_len;
	enum nl80211_sae_pwe_mechanism sae_pwe;
};

struct cfg80211_beacon_data {
	const u8 *head;
	const u8 *tail;
	const u8 *beacon_ies;
	const u8 *proberesp_ies;
	const u8 *assocresp_ies;
	const u8 *probe_resp;
	const u8 *lci;
	const u8 *civicloc;
	s8 ftm_responder;
	size_t head_len;
	size_t tail_len;
	size_t beacon_ies_len;
	size_t proberesp_ies_len;
	size_t assocresp_ies_len;
	size_t probe_resp_len;
	size_t lci_len;
	size_t civicloc_len;
};

struct mac_address {
	u8 addr[6];
};

struct cfg80211_acl_data {
	enum nl80211_acl_policy acl_policy;
	int n_acl_entries;
	struct mac_address mac_addrs[0];
};

struct cfg80211_fils_discovery {
	u32 min_interval;
	u32 max_interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_unsol_bcast_probe_resp {
	u32 interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_ap_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon;
	int beacon_interval;
	int dtim_period;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_hidden_ssid hidden_ssid;
	struct cfg80211_crypto_settings crypto;
	bool privacy;
	enum nl80211_auth_type auth_type;
	enum nl80211_smps_mode smps_mode;
	int inactivity_timeout;
	u8 p2p_ctwindow;
	bool p2p_opp_ps;
	const struct cfg80211_acl_data *acl;
	bool pbss;
	struct cfg80211_bitrate_mask beacon_rate;
	const struct ieee80211_ht_cap *ht_cap;
	const struct ieee80211_vht_cap *vht_cap;
	const struct ieee80211_he_cap_elem *he_cap;
	const struct ieee80211_he_operation *he_oper;
	bool ht_required;
	bool vht_required;
	bool he_required;
	bool twt_responder;
	u32 flags;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_he_bss_color he_bss_color;
	struct cfg80211_fils_discovery fils_discovery;
	struct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;
};

struct cfg80211_csa_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon_csa;
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	unsigned int n_counter_offsets_beacon;
	unsigned int n_counter_offsets_presp;
	struct cfg80211_beacon_data beacon_after;
	bool radar_required;
	bool block_tx;
	u8 count;
};

struct sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct station_parameters {
	const u8 *supported_rates;
	struct net_device *vlan;
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 aid;
	u16 vlan_id;
	u16 peer_aid;
	u8 supported_rates_len;
	u8 plink_action;
	u8 plink_state;
	const struct ieee80211_ht_cap *ht_capa;
	const struct ieee80211_vht_cap *vht_capa;
	u8 uapsd_queues;
	u8 max_sp;
	enum nl80211_mesh_power_mode local_pm;
	u16 capability;
	const u8 *ext_capab;
	u8 ext_capab_len;
	const u8 *supported_channels;
	u8 supported_channels_len;
	const u8 *supported_oper_classes;
	u8 supported_oper_classes_len;
	u8 opmode_notif;
	bool opmode_notif_used;
	int support_p2p_ps;
	const struct ieee80211_he_cap_elem *he_capa;
	u8 he_capa_len;
	u16 airtime_weight;
	struct sta_txpwr txpwr;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
};

struct station_del_parameters {
	const u8 *mac;
	u8 subtype;
	u16 reason_code;
};

struct rate_info {
	u8 flags;
	u8 mcs;
	u16 legacy;
	u8 nss;
	u8 bw;
	u8 he_gi;
	u8 he_dcm;
	u8 he_ru_alloc;
	u8 n_bonded_ch;
};

struct sta_bss_parameters {
	u8 flags;
	u8 dtim_period;
	u16 beacon_interval;
};

struct cfg80211_txq_stats {
	u32 filled;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 flows;
	u32 drops;
	u32 ecn_marks;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
	u32 tx_bytes;
	u32 tx_packets;
	u32 max_flows;
};

struct cfg80211_tid_stats {
	u32 filled;
	u64 rx_msdu;
	u64 tx_msdu;
	u64 tx_msdu_retries;
	u64 tx_msdu_failed;
	struct cfg80211_txq_stats txq_stats;
};

struct station_info {
	u64 filled;
	u32 connected_time;
	u32 inactive_time;
	u64 assoc_at;
	u64 rx_bytes;
	u64 tx_bytes;
	u16 llid;
	u16 plid;
	u8 plink_state;
	s8 signal;
	s8 signal_avg;
	u8 chains;
	s8 chain_signal[4];
	s8 chain_signal_avg[4];
	struct rate_info txrate;
	struct rate_info rxrate;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	struct sta_bss_parameters bss_param;
	struct nl80211_sta_flag_update sta_flags;
	int generation;
	const u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
	u32 beacon_loss_count;
	s64 t_offset;
	enum nl80211_mesh_power_mode local_pm;
	enum nl80211_mesh_power_mode peer_pm;
	enum nl80211_mesh_power_mode nonpeer_pm;
	u32 expected_throughput;
	u64 tx_duration;
	u64 rx_duration;
	u64 rx_beacon;
	u8 rx_beacon_signal_avg;
	u8 connected_to_gate;
	struct cfg80211_tid_stats *pertid;
	s8 ack_signal;
	s8 avg_ack_signal;
	u16 airtime_weight;
	u32 rx_mpdu_count;
	u32 fcs_err_count;
	u32 airtime_link_metric;
	u8 connected_to_as;
};

struct mpath_info {
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	u8 hop_count;
	u32 path_change_count;
	int generation;
};

struct bss_parameters {
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	const u8 *basic_rates;
	u8 basic_rates_len;
	int ap_isolate;
	int ht_opmode;
	s8 p2p_ctwindow;
	s8 p2p_opp_ps;
};

struct mesh_config {
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u16 min_discovery_timeout;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	bool dot11MeshConnectedToMeshGate;
	bool dot11MeshConnectedToAuthServer;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	enum nl80211_mesh_power_mode power_mode;
	u16 dot11MeshAwakeWindowDuration;
	u32 plink_timeout;
	bool dot11MeshNolearn;
};

struct mesh_setup {
	struct cfg80211_chan_def chandef;
	const u8 *mesh_id;
	u8 mesh_id_len;
	u8 sync_method;
	u8 path_sel_proto;
	u8 path_metric;
	u8 auth_id;
	const u8 *ie;
	u8 ie_len;
	bool is_authenticated;
	bool is_secure;
	bool user_mpm;
	u8 dtim_period;
	u16 beacon_interval;
	int mcast_rate[5];
	u32 basic_rates;
	struct cfg80211_bitrate_mask beacon_rate;
	bool userspace_handles_dfs;
	bool control_port_over_nl80211;
};

struct ocb_setup {
	struct cfg80211_chan_def chandef;
};

struct ieee80211_txq_params {
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
};

struct cfg80211_ssid {
	u8 ssid[32];
	u8 ssid_len;
};

struct cfg80211_scan_info {
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	bool aborted;
};

struct cfg80211_scan_6ghz_params {
	u32 short_ssid;
	u32 channel_idx;
	u8 bssid[6];
	bool unsolicited_probe;
	bool short_ssid_valid;
	bool psc_no_listen;
};

struct cfg80211_scan_request {
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u16 duration;
	bool duration_mandatory;
	u32 flags;
	u32 rates[5];
	struct wireless_dev *wdev;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	u8 bssid[6];
	struct wiphy *wiphy;
	long unsigned int scan_start;
	struct cfg80211_scan_info info;
	bool notified;
	bool no_cck;
	bool scan_6ghz;
	u32 n_6ghz_params;
	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
	struct ieee80211_channel *channels[0];
};

enum cfg80211_signal_type {
	CFG80211_SIGNAL_TYPE_NONE = 0,
	CFG80211_SIGNAL_TYPE_MBM = 1,
	CFG80211_SIGNAL_TYPE_UNSPEC = 2,
};

struct ieee80211_txrx_stypes;

struct ieee80211_iface_combination;

struct wiphy_iftype_akm_suites;

struct wiphy_wowlan_support;

struct cfg80211_wowlan;

struct wiphy_iftype_ext_capab;

struct wiphy_coalesce_support;

struct wiphy_vendor_command;

struct cfg80211_pmsr_capabilities;

struct wiphy {
	u8 perm_addr[6];
	u8 addr_mask[6];
	struct mac_address *addresses;
	const struct ieee80211_txrx_stypes *mgmt_stypes;
	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u16 software_iftypes;
	u16 n_addresses;
	u16 interface_modes;
	u16 max_acl_mac_addrs;
	u32 flags;
	u32 regulatory_flags;
	u32 features;
	u8 ext_features[7];
	u32 ap_sme_capa;
	enum cfg80211_signal_type signal_type;
	int bss_priv_size;
	u8 max_scan_ssids;
	u8 max_sched_scan_reqs;
	u8 max_sched_scan_ssids;
	u8 max_match_sets;
	u16 max_scan_ie_len;
	u16 max_sched_scan_ie_len;
	u32 max_sched_scan_plans;
	u32 max_sched_scan_plan_interval;
	u32 max_sched_scan_plan_iterations;
	int n_cipher_suites;
	const u32 *cipher_suites;
	int n_akm_suites;
	const u32 *akm_suites;
	const struct wiphy_iftype_akm_suites *iftype_akm_suites;
	unsigned int num_iftype_akm_suites;
	u8 retry_short;
	u8 retry_long;
	u32 frag_threshold;
	u32 rts_threshold;
	u8 coverage_class;
	char fw_version[32];
	u32 hw_version;
	const struct wiphy_wowlan_support *wowlan;
	struct cfg80211_wowlan *wowlan_config;
	u16 max_remain_on_channel_duration;
	u8 max_num_pmkids;
	u32 available_antennas_tx;
	u32 available_antennas_rx;
	u32 probe_resp_offload;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
	const struct wiphy_iftype_ext_capab *iftype_ext_capab;
	unsigned int num_iftype_ext_capab;
	const void *privid;
	struct ieee80211_supported_band *bands[5];
	void (*reg_notifier)(struct wiphy *, struct regulatory_request *);
	const struct ieee80211_regdomain *regd;
	struct device dev;
	bool registered;
	struct dentry *debugfsdir;
	const struct ieee80211_ht_cap *ht_capa_mod_mask;
	const struct ieee80211_vht_cap *vht_capa_mod_mask;
	struct list_head wdev_list;
	possible_net_t _net;
	const struct wiphy_coalesce_support *coalesce;
	const struct wiphy_vendor_command *vendor_commands;
	const struct nl80211_vendor_cmd_info *vendor_events;
	int n_vendor_commands;
	int n_vendor_events;
	u16 max_ap_assoc_sta;
	u8 max_num_csa_counters;
	u32 bss_select_support;
	u8 nan_supported_bands;
	u32 txq_limit;
	u32 txq_memory_limit;
	u32 txq_quantum;
	long unsigned int tx_queue_len;
	u8 support_mbssid: 1;
	u8 support_only_he_mbssid: 1;
	const struct cfg80211_pmsr_capabilities *pmsr_capa;
	struct {
		u64 peer;
		u64 vif;
		u8 max_retry;
	} tid_config_support;
	u8 max_data_retry_count;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	char priv[0];
};

struct cfg80211_match_set {
	struct cfg80211_ssid ssid;
	u8 bssid[6];
	s32 rssi_thold;
	s32 per_band_rssi_thold[5];
};

struct cfg80211_sched_scan_plan {
	u32 interval;
	u32 iterations;
};

struct cfg80211_bss_select_adjust {
	enum nl80211_band band;
	s8 delta;
};

struct cfg80211_sched_scan_request {
	u64 reqid;
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u32 flags;
	struct cfg80211_match_set *match_sets;
	int n_match_sets;
	s32 min_rssi_thold;
	u32 delay;
	struct cfg80211_sched_scan_plan *scan_plans;
	int n_scan_plans;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	bool relative_rssi_set;
	s8 relative_rssi;
	struct cfg80211_bss_select_adjust rssi_adjust;
	struct wiphy *wiphy;
	struct net_device *dev;
	long unsigned int scan_start;
	bool report_results;
	struct callback_head callback_head;
	u32 owner_nlportid;
	bool nl_owner_dead;
	struct list_head list;
	struct ieee80211_channel *channels[0];
};

struct cfg80211_bss_ies {
	u64 tsf;
	struct callback_head callback_head;
	int len;
	bool from_beacon;
	u8 data[0];
};

struct cfg80211_bss {
	struct ieee80211_channel *channel;
	enum nl80211_bss_scan_width scan_width;
	const struct cfg80211_bss_ies *ies;
	const struct cfg80211_bss_ies *beacon_ies;
	const struct cfg80211_bss_ies *proberesp_ies;
	struct cfg80211_bss *hidden_beacon_bss;
	struct cfg80211_bss *transmitted_bss;
	struct list_head nontrans_list;
	s32 signal;
	u16 beacon_interval;
	u16 capability;
	u8 bssid[6];
	u8 chains;
	s8 chain_signal[4];
	u8 bssid_index;
	u8 max_bssid_indicator;
	int: 24;
	u8 priv[0];
};

struct cfg80211_auth_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	enum nl80211_auth_type auth_type;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	const u8 *auth_data;
	size_t auth_data_len;
};

struct cfg80211_assoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	const u8 *prev_bssid;
	size_t ie_len;
	struct cfg80211_crypto_settings crypto;
	bool use_mfp;
	int: 24;
	u32 flags;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	int: 32;
	const u8 *fils_kek;
	size_t fils_kek_len;
	const u8 *fils_nonces;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	short: 16;
} __attribute__((packed));

struct cfg80211_deauth_request {
	const u8 *bssid;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_disassoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_ibss_params {
	const u8 *ssid;
	const u8 *bssid;
	struct cfg80211_chan_def chandef;
	const u8 *ie;
	u8 ssid_len;
	u8 ie_len;
	u16 beacon_interval;
	u32 basic_rates;
	bool channel_fixed;
	bool privacy;
	bool control_port;
	bool control_port_over_nl80211;
	bool userspace_handles_dfs;
	int: 24;
	int mcast_rate[5];
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct key_params *wep_keys;
	int wep_tx_key;
	int: 32;
} __attribute__((packed));

struct cfg80211_bss_selection {
	enum nl80211_bss_select_attr behaviour;
	union {
		enum nl80211_band band_pref;
		struct cfg80211_bss_select_adjust adjust;
	} param;
};

struct cfg80211_connect_params {
	struct ieee80211_channel *channel;
	struct ieee80211_channel *channel_hint;
	const u8 *bssid;
	const u8 *bssid_hint;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_auth_type auth_type;
	int: 32;
	const u8 *ie;
	size_t ie_len;
	bool privacy;
	int: 24;
	enum nl80211_mfp mfp;
	struct cfg80211_crypto_settings crypto;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	short: 16;
	u32 flags;
	int bg_scan_period;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	bool pbss;
	int: 24;
	struct cfg80211_bss_selection bss_select;
	const u8 *prev_bssid;
	const u8 *fils_erp_username;
	size_t fils_erp_username_len;
	const u8 *fils_erp_realm;
	size_t fils_erp_realm_len;
	u16 fils_erp_next_seq_num;
	long: 48;
	const u8 *fils_erp_rrk;
	size_t fils_erp_rrk_len;
	bool want_1x;
	int: 24;
	struct ieee80211_edmg edmg;
	int: 32;
} __attribute__((packed));

struct cfg80211_pmksa {
	const u8 *bssid;
	const u8 *pmkid;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *ssid;
	size_t ssid_len;
	const u8 *cache_id;
	u32 pmk_lifetime;
	u8 pmk_reauth_threshold;
};

struct cfg80211_pkt_pattern {
	const u8 *mask;
	const u8 *pattern;
	int pattern_len;
	int pkt_offset;
};

struct cfg80211_wowlan_tcp {
	struct socket *sock;
	__be32 src;
	__be32 dst;
	u16 src_port;
	u16 dst_port;
	u8 dst_mac[6];
	int payload_len;
	const u8 *payload;
	struct nl80211_wowlan_tcp_data_seq payload_seq;
	u32 data_interval;
	u32 wake_len;
	const u8 *wake_data;
	const u8 *wake_mask;
	u32 tokens_size;
	struct nl80211_wowlan_tcp_data_token payload_tok;
};

struct cfg80211_wowlan {
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	struct cfg80211_pkt_pattern *patterns;
	struct cfg80211_wowlan_tcp *tcp;
	int n_patterns;
	struct cfg80211_sched_scan_request *nd_config;
};

struct cfg80211_coalesce_rules {
	int delay;
	enum nl80211_coalesce_condition condition;
	struct cfg80211_pkt_pattern *patterns;
	int n_patterns;
};

struct cfg80211_coalesce {
	struct cfg80211_coalesce_rules *rules;
	int n_rules;
};

struct cfg80211_gtk_rekey_data {
	const u8 *kek;
	const u8 *kck;
	const u8 *replay_ctr;
	u32 akm;
	u8 kek_len;
	u8 kck_len;
};

struct cfg80211_update_ft_ies_params {
	u16 md;
	const u8 *ie;
	size_t ie_len;
};

struct cfg80211_mgmt_tx_params {
	struct ieee80211_channel *chan;
	bool offchan;
	unsigned int wait;
	const u8 *buf;
	size_t len;
	bool no_cck;
	bool dont_wait_for_ack;
	int n_csa_offsets;
	const u16 *csa_offsets;
};

struct cfg80211_dscp_exception {
	u8 dscp;
	u8 up;
};

struct cfg80211_dscp_range {
	u8 low;
	u8 high;
};

struct cfg80211_qos_map {
	u8 num_des;
	struct cfg80211_dscp_exception dscp_exception[21];
	struct cfg80211_dscp_range up[8];
};

struct cfg80211_nan_conf {
	u8 master_pref;
	u8 bands;
};

struct cfg80211_nan_func_filter {
	const u8 *filter;
	u8 len;
};

struct cfg80211_nan_func {
	enum nl80211_nan_function_type type;
	u8 service_id[6];
	u8 publish_type;
	bool close_range;
	bool publish_bcast;
	bool subscribe_active;
	u8 followup_id;
	u8 followup_reqid;
	struct mac_address followup_dest;
	u32 ttl;
	const u8 *serv_spec_info;
	u8 serv_spec_info_len;
	bool srf_include;
	const u8 *srf_bf;
	u8 srf_bf_len;
	u8 srf_bf_idx;
	struct mac_address *srf_macs;
	int srf_num_macs;
	struct cfg80211_nan_func_filter *rx_filters;
	struct cfg80211_nan_func_filter *tx_filters;
	u8 num_tx_filters;
	u8 num_rx_filters;
	u8 instance_id;
	u64 cookie;
};

struct cfg80211_pmk_conf {
	const u8 *aa;
	u8 pmk_len;
	const u8 *pmk;
	const u8 *pmk_r0_name;
};

struct cfg80211_external_auth_params {
	enum nl80211_external_auth_action action;
	u8 bssid[6];
	struct cfg80211_ssid ssid;
	unsigned int key_mgmt_suite;
	u16 status;
	const u8 *pmkid;
};

struct cfg80211_ftm_responder_stats {
	u32 filled;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 total_duration_ms;
	u32 unknown_triggers_num;
	u32 reschedule_requests_num;
	u32 out_of_window_triggers_num;
};

struct cfg80211_pmsr_ftm_request_peer {
	enum nl80211_preamble preamble;
	u16 burst_period;
	u8 requested: 1;
	u8 asap: 1;
	u8 request_lci: 1;
	u8 request_civicloc: 1;
	u8 trigger_based: 1;
	u8 non_trigger_based: 1;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	u8 ftmr_retries;
};

struct cfg80211_pmsr_request_peer {
	u8 addr[6];
	struct cfg80211_chan_def chandef;
	u8 report_ap_tsf: 1;
	struct cfg80211_pmsr_ftm_request_peer ftm;
};

struct cfg80211_pmsr_request {
	u64 cookie;
	void *drv_data;
	u32 n_peers;
	u32 nl_portid;
	u32 timeout;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	struct list_head list;
	struct cfg80211_pmsr_request_peer peers[0];
};

struct cfg80211_update_owe_info {
	u8 peer[6];
	u16 status;
	const u8 *ie;
	size_t ie_len;
};

struct mgmt_frame_regs {
	u32 global_stypes;
	u32 interface_stypes;
	u32 global_mcast_stypes;
	u32 interface_mcast_stypes;
};

struct cfg80211_ops {
	int (*suspend)(struct wiphy *, struct cfg80211_wowlan *);
	int (*resume)(struct wiphy *);
	void (*set_wakeup)(struct wiphy *, bool);
	struct wireless_dev * (*add_virtual_intf)(struct wiphy *, const char *, unsigned char, enum nl80211_iftype, struct vif_params *);
	int (*del_virtual_intf)(struct wiphy *, struct wireless_dev *);
	int (*change_virtual_intf)(struct wiphy *, struct net_device *, enum nl80211_iftype, struct vif_params *);
	int (*add_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *, struct key_params *);
	int (*get_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *, void *, void (*)(void *, struct key_params *));
	int (*del_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *);
	int (*set_default_key)(struct wiphy *, struct net_device *, u8, bool, bool);
	int (*set_default_mgmt_key)(struct wiphy *, struct net_device *, u8);
	int (*set_default_beacon_key)(struct wiphy *, struct net_device *, u8);
	int (*start_ap)(struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);
	int (*change_beacon)(struct wiphy *, struct net_device *, struct cfg80211_beacon_data *);
	int (*stop_ap)(struct wiphy *, struct net_device *);
	int (*add_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*del_station)(struct wiphy *, struct net_device *, struct station_del_parameters *);
	int (*change_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*get_station)(struct wiphy *, struct net_device *, const u8 *, struct station_info *);
	int (*dump_station)(struct wiphy *, struct net_device *, int, u8 *, struct station_info *);
	int (*add_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*del_mpath)(struct wiphy *, struct net_device *, const u8 *);
	int (*change_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*get_mpath)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpath)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mpp)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpp)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mesh_config)(struct wiphy *, struct net_device *, struct mesh_config *);
	int (*update_mesh_config)(struct wiphy *, struct net_device *, u32, const struct mesh_config *);
	int (*join_mesh)(struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);
	int (*leave_mesh)(struct wiphy *, struct net_device *);
	int (*join_ocb)(struct wiphy *, struct net_device *, struct ocb_setup *);
	int (*leave_ocb)(struct wiphy *, struct net_device *);
	int (*change_bss)(struct wiphy *, struct net_device *, struct bss_parameters *);
	int (*set_txq_params)(struct wiphy *, struct net_device *, struct ieee80211_txq_params *);
	int (*libertas_set_mesh_channel)(struct wiphy *, struct net_device *, struct ieee80211_channel *);
	int (*set_monitor_channel)(struct wiphy *, struct cfg80211_chan_def *);
	int (*scan)(struct wiphy *, struct cfg80211_scan_request *);
	void (*abort_scan)(struct wiphy *, struct wireless_dev *);
	int (*auth)(struct wiphy *, struct net_device *, struct cfg80211_auth_request *);
	int (*assoc)(struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);
	int (*deauth)(struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);
	int (*disassoc)(struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);
	int (*connect)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *);
	int (*update_connect_params)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);
	int (*disconnect)(struct wiphy *, struct net_device *, u16);
	int (*join_ibss)(struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);
	int (*leave_ibss)(struct wiphy *, struct net_device *);
	int (*set_mcast_rate)(struct wiphy *, struct net_device *, int *);
	int (*set_wiphy_params)(struct wiphy *, u32);
	int (*set_tx_power)(struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);
	int (*get_tx_power)(struct wiphy *, struct wireless_dev *, int *);
	void (*rfkill_poll)(struct wiphy *);
	int (*set_bitrate_mask)(struct wiphy *, struct net_device *, const u8 *, const struct cfg80211_bitrate_mask *);
	int (*dump_survey)(struct wiphy *, struct net_device *, int, struct survey_info *);
	int (*set_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*del_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*flush_pmksa)(struct wiphy *, struct net_device *);
	int (*remain_on_channel)(struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int, u64 *);
	int (*cancel_remain_on_channel)(struct wiphy *, struct wireless_dev *, u64);
	int (*mgmt_tx)(struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *, u64 *);
	int (*mgmt_tx_cancel_wait)(struct wiphy *, struct wireless_dev *, u64);
	int (*set_power_mgmt)(struct wiphy *, struct net_device *, bool, int);
	int (*set_cqm_rssi_config)(struct wiphy *, struct net_device *, s32, u32);
	int (*set_cqm_rssi_range_config)(struct wiphy *, struct net_device *, s32, s32);
	int (*set_cqm_txe_config)(struct wiphy *, struct net_device *, u32, u32, u32);
	void (*update_mgmt_frame_registrations)(struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);
	int (*set_antenna)(struct wiphy *, u32, u32);
	int (*get_antenna)(struct wiphy *, u32 *, u32 *);
	int (*sched_scan_start)(struct wiphy *, struct net_device *, struct cfg80211_sched_scan_request *);
	int (*sched_scan_stop)(struct wiphy *, struct net_device *, u64);
	int (*set_rekey_data)(struct wiphy *, struct net_device *, struct cfg80211_gtk_rekey_data *);
	int (*tdls_mgmt)(struct wiphy *, struct net_device *, const u8 *, u8, u8, u16, u32, bool, const u8 *, size_t);
	int (*tdls_oper)(struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation);
	int (*probe_client)(struct wiphy *, struct net_device *, const u8 *, u64 *);
	int (*set_noack_map)(struct wiphy *, struct net_device *, u16);
	int (*get_channel)(struct wiphy *, struct wireless_dev *, struct cfg80211_chan_def *);
	int (*start_p2p_device)(struct wiphy *, struct wireless_dev *);
	void (*stop_p2p_device)(struct wiphy *, struct wireless_dev *);
	int (*set_mac_acl)(struct wiphy *, struct net_device *, const struct cfg80211_acl_data *);
	int (*start_radar_detection)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32);
	void (*end_cac)(struct wiphy *, struct net_device *);
	int (*update_ft_ies)(struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);
	int (*crit_proto_start)(struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);
	void (*crit_proto_stop)(struct wiphy *, struct wireless_dev *);
	int (*set_coalesce)(struct wiphy *, struct cfg80211_coalesce *);
	int (*channel_switch)(struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);
	int (*set_qos_map)(struct wiphy *, struct net_device *, struct cfg80211_qos_map *);
	int (*set_ap_chanwidth)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *);
	int (*add_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);
	int (*del_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *);
	int (*tdls_channel_switch)(struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);
	void (*tdls_cancel_channel_switch)(struct wiphy *, struct net_device *, const u8 *);
	int (*start_nan)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);
	void (*stop_nan)(struct wiphy *, struct wireless_dev *);
	int (*add_nan_func)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_func *);
	void (*del_nan_func)(struct wiphy *, struct wireless_dev *, u64);
	int (*nan_change_conf)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);
	int (*set_multicast_to_unicast)(struct wiphy *, struct net_device *, const bool);
	int (*get_txq_stats)(struct wiphy *, struct wireless_dev *, struct cfg80211_txq_stats *);
	int (*set_pmk)(struct wiphy *, struct net_device *, const struct cfg80211_pmk_conf *);
	int (*del_pmk)(struct wiphy *, struct net_device *, const u8 *);
	int (*external_auth)(struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);
	int (*tx_control_port)(struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, const __be16, const bool, u64 *);
	int (*get_ftm_responder_stats)(struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	int (*update_owe_info)(struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);
	int (*probe_mesh_link)(struct wiphy *, struct net_device *, const u8 *, size_t);
	int (*set_tid_config)(struct wiphy *, struct net_device *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct wiphy *, struct net_device *, const u8 *, u8);
};

enum wiphy_flags {
	WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK = 1,
	WIPHY_FLAG_SPLIT_SCAN_6GHZ = 4,
	WIPHY_FLAG_NETNS_OK = 8,
	WIPHY_FLAG_PS_ON_BY_DEFAULT = 16,
	WIPHY_FLAG_4ADDR_AP = 32,
	WIPHY_FLAG_4ADDR_STATION = 64,
	WIPHY_FLAG_CONTROL_PORT_PROTOCOL = 128,
	WIPHY_FLAG_IBSS_RSN = 256,
	WIPHY_FLAG_MESH_AUTH = 1024,
	WIPHY_FLAG_SUPPORTS_FW_ROAM = 8192,
	WIPHY_FLAG_AP_UAPSD = 16384,
	WIPHY_FLAG_SUPPORTS_TDLS = 32768,
	WIPHY_FLAG_TDLS_EXTERNAL_SETUP = 65536,
	WIPHY_FLAG_HAVE_AP_SME = 131072,
	WIPHY_FLAG_REPORTS_OBSS = 262144,
	WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD = 524288,
	WIPHY_FLAG_OFFCHAN_TX = 1048576,
	WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL = 2097152,
	WIPHY_FLAG_SUPPORTS_5_10_MHZ = 4194304,
	WIPHY_FLAG_HAS_CHANNEL_SWITCH = 8388608,
	WIPHY_FLAG_HAS_STATIC_WEP = 16777216,
};

struct ieee80211_iface_limit {
	u16 max;
	u16 types;
};

struct ieee80211_iface_combination {
	const struct ieee80211_iface_limit *limits;
	u32 num_different_channels;
	u16 max_interfaces;
	u8 n_limits;
	bool beacon_int_infra_match;
	u8 radar_detect_widths;
	u8 radar_detect_regions;
	u32 beacon_int_min_gcd;
};

struct ieee80211_txrx_stypes {
	u16 tx;
	u16 rx;
};

enum wiphy_wowlan_support_flags {
	WIPHY_WOWLAN_ANY = 1,
	WIPHY_WOWLAN_MAGIC_PKT = 2,
	WIPHY_WOWLAN_DISCONNECT = 4,
	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY = 8,
	WIPHY_WOWLAN_GTK_REKEY_FAILURE = 16,
	WIPHY_WOWLAN_EAP_IDENTITY_REQ = 32,
	WIPHY_WOWLAN_4WAY_HANDSHAKE = 64,
	WIPHY_WOWLAN_RFKILL_RELEASE = 128,
	WIPHY_WOWLAN_NET_DETECT = 256,
};

struct wiphy_wowlan_tcp_support {
	const struct nl80211_wowlan_tcp_data_token_feature *tok;
	u32 data_payload_max;
	u32 data_interval_max;
	u32 wake_payload_max;
	bool seq;
};

struct wiphy_wowlan_support {
	u32 flags;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
	int max_nd_match_sets;
	const struct wiphy_wowlan_tcp_support *tcp;
};

struct wiphy_coalesce_support {
	int n_rules;
	int max_delay;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
};

struct wiphy_vendor_command {
	struct nl80211_vendor_cmd_info info;
	u32 flags;
	int (*doit)(struct wiphy *, struct wireless_dev *, const void *, int);
	int (*dumpit)(struct wiphy *, struct wireless_dev *, struct sk_buff *, const void *, int, long unsigned int *);
	const struct nla_policy *policy;
	unsigned int maxattr;
};

struct wiphy_iftype_ext_capab {
	enum nl80211_iftype iftype;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
};

struct cfg80211_pmsr_capabilities {
	unsigned int max_peers;
	u8 report_ap_tsf: 1;
	u8 randomize_mac_addr: 1;
	struct {
		u32 preambles;
		u32 bandwidths;
		s8 max_bursts_exponent;
		u8 max_ftms_per_burst;
		u8 supported: 1;
		u8 asap: 1;
		u8 non_asap: 1;
		u8 request_lci: 1;
		u8 request_civicloc: 1;
		u8 trigger_based: 1;
		u8 non_trigger_based: 1;
	} ftm;
};

struct wiphy_iftype_akm_suites {
	u16 iftypes_mask;
	const u32 *akm_suites;
	int n_akm_suites;
};

struct cfg80211_cached_keys {
	struct key_params params[4];
	u8 data[52];
	int def;
};

struct cfg80211_internal_bss {
	struct list_head list;
	struct list_head hidden_list;
	struct rb_node rbn;
	u64 ts_boottime;
	long unsigned int ts;
	long unsigned int refcount;
	atomic_t hold;
	u64 parent_tsf;
	u8 parent_bssid[6];
	struct cfg80211_bss pub;
};

struct cfg80211_cqm_config {
	u32 rssi_hyst;
	s32 last_rssi_event_value;
	int n_rssi_thresholds;
	s32 rssi_thresholds[0];
};

struct cfg80211_fils_resp_params {
	const u8 *kek;
	size_t kek_len;
	bool update_erp_next_seq_num;
	u16 erp_next_seq_num;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *pmkid;
};

struct cfg80211_connect_resp_params {
	int status;
	const u8 *bssid;
	struct cfg80211_bss *bss;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
	enum nl80211_timeout_reason timeout_reason;
};

struct cfg80211_roam_info {
	struct ieee80211_channel *channel;
	struct cfg80211_bss *bss;
	const u8 *bssid;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
};

enum rfkill_type {
	RFKILL_TYPE_ALL = 0,
	RFKILL_TYPE_WLAN = 1,
	RFKILL_TYPE_BLUETOOTH = 2,
	RFKILL_TYPE_UWB = 3,
	RFKILL_TYPE_WIMAX = 4,
	RFKILL_TYPE_WWAN = 5,
	RFKILL_TYPE_GPS = 6,
	RFKILL_TYPE_FM = 7,
	RFKILL_TYPE_NFC = 8,
	NUM_RFKILL_TYPES = 9,
};

struct rfkill;

struct rfkill_ops {
	void (*poll)(struct rfkill *, void *);
	void (*query)(struct rfkill *, void *);
	int (*set_block)(void *, bool);
};

struct cfg80211_registered_device {
	const struct cfg80211_ops *ops;
	struct list_head list;
	struct rfkill_ops rfkill_ops;
	struct rfkill *rfkill;
	struct work_struct rfkill_block;
	char country_ie_alpha2[2];
	const struct ieee80211_regdomain *requested_regd;
	enum environment_cap env;
	int wiphy_idx;
	int devlist_generation;
	int wdev_id;
	int opencount;
	wait_queue_head_t dev_wait;
	struct list_head beacon_registrations;
	spinlock_t beacon_registrations_lock;
	int num_running_ifaces;
	int num_running_monitor_ifaces;
	u64 cookie_counter;
	spinlock_t bss_lock;
	struct list_head bss_list;
	struct rb_root bss_tree;
	u32 bss_generation;
	u32 bss_entries;
	struct cfg80211_scan_request *scan_req;
	struct cfg80211_scan_request *int_scan_req;
	struct sk_buff *scan_msg;
	struct list_head sched_scan_req_list;
	time64_t suspend_at;
	struct work_struct scan_done_wk;
	struct genl_info *cur_cmd_info;
	struct work_struct conn_work;
	struct work_struct event_work;
	struct delayed_work dfs_update_channels_wk;
	u32 crit_proto_nlportid;
	struct cfg80211_coalesce *coalesce;
	struct work_struct destroy_work;
	struct work_struct sched_scan_stop_wk;
	struct work_struct sched_scan_res_wk;
	struct cfg80211_chan_def radar_chandef;
	struct work_struct propagate_radar_detect_wk;
	struct cfg80211_chan_def cac_done_chandef;
	struct work_struct propagate_cac_done_wk;
	struct work_struct mgmt_registrations_update_wk;
	long: 64;
	struct wiphy wiphy;
};

enum cfg80211_event_type {
	EVENT_CONNECT_RESULT = 0,
	EVENT_ROAMED = 1,
	EVENT_DISCONNECTED = 2,
	EVENT_IBSS_JOINED = 3,
	EVENT_STOPPED = 4,
	EVENT_PORT_AUTHORIZED = 5,
};

struct cfg80211_event {
	struct list_head list;
	enum cfg80211_event_type type;
	union {
		struct cfg80211_connect_resp_params cr;
		struct cfg80211_roam_info rm;
		struct {
			const u8 *ie;
			size_t ie_len;
			u16 reason;
			bool locally_generated;
		} dc;
		struct {
			u8 bssid[6];
			struct ieee80211_channel *channel;
		} ij;
		struct {
			u8 bssid[6];
		} pa;
	};
};

struct cfg80211_beacon_registration {
	struct list_head list;
	u32 nlportid;
};

struct radiotap_align_size {
	uint8_t align: 4;
	uint8_t size: 4;
};

struct ieee80211_radiotap_namespace {
	const struct radiotap_align_size *align_size;
	int n_bits;
	uint32_t oui;
	uint8_t subns;
};

struct ieee80211_radiotap_vendor_namespaces {
	const struct ieee80211_radiotap_namespace *ns;
	int n_ns;
};

struct ieee80211_radiotap_header;

struct ieee80211_radiotap_iterator {
	struct ieee80211_radiotap_header *_rtheader;
	const struct ieee80211_radiotap_vendor_namespaces *_vns;
	const struct ieee80211_radiotap_namespace *current_namespace;
	unsigned char *_arg;
	unsigned char *_next_ns_data;
	__le32 *_next_bitmap;
	unsigned char *this_arg;
	int this_arg_index;
	int this_arg_size;
	int is_radiotap_ns;
	int _max_length;
	int _arg_index;
	uint32_t _bitmap_shifter;
	int _reset_on_ext;
};

struct ieee80211_radiotap_header {
	uint8_t it_version;
	uint8_t it_pad;
	__le16 it_len;
	__le32 it_present;
};

enum ieee80211_radiotap_presence {
	IEEE80211_RADIOTAP_TSFT = 0,
	IEEE80211_RADIOTAP_FLAGS = 1,
	IEEE80211_RADIOTAP_RATE = 2,
	IEEE80211_RADIOTAP_CHANNEL = 3,
	IEEE80211_RADIOTAP_FHSS = 4,
	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
	IEEE80211_RADIOTAP_ANTENNA = 11,
	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
	IEEE80211_RADIOTAP_RX_FLAGS = 14,
	IEEE80211_RADIOTAP_TX_FLAGS = 15,
	IEEE80211_RADIOTAP_RTS_RETRIES = 16,
	IEEE80211_RADIOTAP_DATA_RETRIES = 17,
	IEEE80211_RADIOTAP_MCS = 19,
	IEEE80211_RADIOTAP_AMPDU_STATUS = 20,
	IEEE80211_RADIOTAP_VHT = 21,
	IEEE80211_RADIOTAP_TIMESTAMP = 22,
	IEEE80211_RADIOTAP_HE = 23,
	IEEE80211_RADIOTAP_HE_MU = 24,
	IEEE80211_RADIOTAP_ZERO_LEN_PSDU = 26,
	IEEE80211_RADIOTAP_LSIG = 27,
	IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,
	IEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,
	IEEE80211_RADIOTAP_EXT = 31,
};

struct ieee80211_hdr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	u8 addr4[6];
};

struct ieee80211s_hdr {
	u8 flags;
	u8 ttl;
	__le32 seqnum;
	u8 eaddr1[6];
	u8 eaddr2[6];
} __attribute__((packed));

enum ieee80211_p2p_attr_id {
	IEEE80211_P2P_ATTR_STATUS = 0,
	IEEE80211_P2P_ATTR_MINOR_REASON = 1,
	IEEE80211_P2P_ATTR_CAPABILITY = 2,
	IEEE80211_P2P_ATTR_DEVICE_ID = 3,
	IEEE80211_P2P_ATTR_GO_INTENT = 4,
	IEEE80211_P2P_ATTR_GO_CONFIG_TIMEOUT = 5,
	IEEE80211_P2P_ATTR_LISTEN_CHANNEL = 6,
	IEEE80211_P2P_ATTR_GROUP_BSSID = 7,
	IEEE80211_P2P_ATTR_EXT_LISTEN_TIMING = 8,
	IEEE80211_P2P_ATTR_INTENDED_IFACE_ADDR = 9,
	IEEE80211_P2P_ATTR_MANAGABILITY = 10,
	IEEE80211_P2P_ATTR_CHANNEL_LIST = 11,
	IEEE80211_P2P_ATTR_ABSENCE_NOTICE = 12,
	IEEE80211_P2P_ATTR_DEVICE_INFO = 13,
	IEEE80211_P2P_ATTR_GROUP_INFO = 14,
	IEEE80211_P2P_ATTR_GROUP_ID = 15,
	IEEE80211_P2P_ATTR_INTERFACE = 16,
	IEEE80211_P2P_ATTR_OPER_CHANNEL = 17,
	IEEE80211_P2P_ATTR_INVITE_FLAGS = 18,
	IEEE80211_P2P_ATTR_VENDOR_SPECIFIC = 221,
	IEEE80211_P2P_ATTR_MAX = 222,
};

enum ieee80211_vht_chanwidth {
	IEEE80211_VHT_CHANWIDTH_USE_HT = 0,
	IEEE80211_VHT_CHANWIDTH_80MHZ = 1,
	IEEE80211_VHT_CHANWIDTH_160MHZ = 2,
	IEEE80211_VHT_CHANWIDTH_80P80MHZ = 3,
};

enum ieee80211_statuscode {
	WLAN_STATUS_SUCCESS = 0,
	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
	WLAN_STATUS_CHALLENGE_FAIL = 15,
	WLAN_STATUS_AUTH_TIMEOUT = 16,
	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
	WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY = 30,
	WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION = 31,
	WLAN_STATUS_INVALID_IE = 40,
	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
	WLAN_STATUS_INVALID_AKMP = 43,
	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
	WLAN_STATUS_UNSPECIFIED_QOS = 32,
	WLAN_STATUS_ASSOC_DENIED_NOBANDWIDTH = 33,
	WLAN_STATUS_ASSOC_DENIED_LOWACK = 34,
	WLAN_STATUS_ASSOC_DENIED_UNSUPP_QOS = 35,
	WLAN_STATUS_REQUEST_DECLINED = 37,
	WLAN_STATUS_INVALID_QOS_PARAM = 38,
	WLAN_STATUS_CHANGE_TSPEC = 39,
	WLAN_STATUS_WAIT_TS_DELAY = 47,
	WLAN_STATUS_NO_DIRECT_LINK = 48,
	WLAN_STATUS_STA_NOT_PRESENT = 49,
	WLAN_STATUS_STA_NOT_QSTA = 50,
	WLAN_STATUS_ANTI_CLOG_REQUIRED = 76,
	WLAN_STATUS_FCG_NOT_SUPP = 78,
	WLAN_STATUS_STA_NO_TBTT = 78,
	WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES = 39,
	WLAN_STATUS_REJECTED_FOR_DELAY_PERIOD = 47,
	WLAN_STATUS_REJECT_WITH_SCHEDULE = 83,
	WLAN_STATUS_PENDING_ADMITTING_FST_SESSION = 86,
	WLAN_STATUS_PERFORMING_FST_NOW = 87,
	WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW = 88,
	WLAN_STATUS_REJECT_U_PID_SETTING = 89,
	WLAN_STATUS_REJECT_DSE_BAND = 96,
	WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
	WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
	WLAN_STATUS_FILS_AUTHENTICATION_FAILURE = 108,
	WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER = 109,
	WLAN_STATUS_SAE_HASH_TO_ELEMENT = 126,
	WLAN_STATUS_SAE_PK = 127,
};

enum ieee80211_eid {
	WLAN_EID_SSID = 0,
	WLAN_EID_SUPP_RATES = 1,
	WLAN_EID_FH_PARAMS = 2,
	WLAN_EID_DS_PARAMS = 3,
	WLAN_EID_CF_PARAMS = 4,
	WLAN_EID_TIM = 5,
	WLAN_EID_IBSS_PARAMS = 6,
	WLAN_EID_COUNTRY = 7,
	WLAN_EID_REQUEST = 10,
	WLAN_EID_QBSS_LOAD = 11,
	WLAN_EID_EDCA_PARAM_SET = 12,
	WLAN_EID_TSPEC = 13,
	WLAN_EID_TCLAS = 14,
	WLAN_EID_SCHEDULE = 15,
	WLAN_EID_CHALLENGE = 16,
	WLAN_EID_PWR_CONSTRAINT = 32,
	WLAN_EID_PWR_CAPABILITY = 33,
	WLAN_EID_TPC_REQUEST = 34,
	WLAN_EID_TPC_REPORT = 35,
	WLAN_EID_SUPPORTED_CHANNELS = 36,
	WLAN_EID_CHANNEL_SWITCH = 37,
	WLAN_EID_MEASURE_REQUEST = 38,
	WLAN_EID_MEASURE_REPORT = 39,
	WLAN_EID_QUIET = 40,
	WLAN_EID_IBSS_DFS = 41,
	WLAN_EID_ERP_INFO = 42,
	WLAN_EID_TS_DELAY = 43,
	WLAN_EID_TCLAS_PROCESSING = 44,
	WLAN_EID_HT_CAPABILITY = 45,
	WLAN_EID_QOS_CAPA = 46,
	WLAN_EID_RSN = 48,
	WLAN_EID_802_15_COEX = 49,
	WLAN_EID_EXT_SUPP_RATES = 50,
	WLAN_EID_AP_CHAN_REPORT = 51,
	WLAN_EID_NEIGHBOR_REPORT = 52,
	WLAN_EID_RCPI = 53,
	WLAN_EID_MOBILITY_DOMAIN = 54,
	WLAN_EID_FAST_BSS_TRANSITION = 55,
	WLAN_EID_TIMEOUT_INTERVAL = 56,
	WLAN_EID_RIC_DATA = 57,
	WLAN_EID_DSE_REGISTERED_LOCATION = 58,
	WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
	WLAN_EID_EXT_CHANSWITCH_ANN = 60,
	WLAN_EID_HT_OPERATION = 61,
	WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
	WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
	WLAN_EID_ANTENNA_INFO = 64,
	WLAN_EID_RSNI = 65,
	WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
	WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
	WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
	WLAN_EID_TIME_ADVERTISEMENT = 69,
	WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
	WLAN_EID_MULTIPLE_BSSID = 71,
	WLAN_EID_BSS_COEX_2040 = 72,
	WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
	WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
	WLAN_EID_RIC_DESCRIPTOR = 75,
	WLAN_EID_MMIE = 76,
	WLAN_EID_ASSOC_COMEBACK_TIME = 77,
	WLAN_EID_EVENT_REQUEST = 78,
	WLAN_EID_EVENT_REPORT = 79,
	WLAN_EID_DIAGNOSTIC_REQUEST = 80,
	WLAN_EID_DIAGNOSTIC_REPORT = 81,
	WLAN_EID_LOCATION_PARAMS = 82,
	WLAN_EID_NON_TX_BSSID_CAP = 83,
	WLAN_EID_SSID_LIST = 84,
	WLAN_EID_MULTI_BSSID_IDX = 85,
	WLAN_EID_FMS_DESCRIPTOR = 86,
	WLAN_EID_FMS_REQUEST = 87,
	WLAN_EID_FMS_RESPONSE = 88,
	WLAN_EID_QOS_TRAFFIC_CAPA = 89,
	WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
	WLAN_EID_TSF_REQUEST = 91,
	WLAN_EID_TSF_RESPOSNE = 92,
	WLAN_EID_WNM_SLEEP_MODE = 93,
	WLAN_EID_TIM_BCAST_REQ = 94,
	WLAN_EID_TIM_BCAST_RESP = 95,
	WLAN_EID_COLL_IF_REPORT = 96,
	WLAN_EID_CHANNEL_USAGE = 97,
	WLAN_EID_TIME_ZONE = 98,
	WLAN_EID_DMS_REQUEST = 99,
	WLAN_EID_DMS_RESPONSE = 100,
	WLAN_EID_LINK_ID = 101,
	WLAN_EID_WAKEUP_SCHEDUL = 102,
	WLAN_EID_CHAN_SWITCH_TIMING = 104,
	WLAN_EID_PTI_CONTROL = 105,
	WLAN_EID_PU_BUFFER_STATUS = 106,
	WLAN_EID_INTERWORKING = 107,
	WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
	WLAN_EID_EXPEDITED_BW_REQ = 109,
	WLAN_EID_QOS_MAP_SET = 110,
	WLAN_EID_ROAMING_CONSORTIUM = 111,
	WLAN_EID_EMERGENCY_ALERT = 112,
	WLAN_EID_MESH_CONFIG = 113,
	WLAN_EID_MESH_ID = 114,
	WLAN_EID_LINK_METRIC_REPORT = 115,
	WLAN_EID_CONGESTION_NOTIFICATION = 116,
	WLAN_EID_PEER_MGMT = 117,
	WLAN_EID_CHAN_SWITCH_PARAM = 118,
	WLAN_EID_MESH_AWAKE_WINDOW = 119,
	WLAN_EID_BEACON_TIMING = 120,
	WLAN_EID_MCCAOP_SETUP_REQ = 121,
	WLAN_EID_MCCAOP_SETUP_RESP = 122,
	WLAN_EID_MCCAOP_ADVERT = 123,
	WLAN_EID_MCCAOP_TEARDOWN = 124,
	WLAN_EID_GANN = 125,
	WLAN_EID_RANN = 126,
	WLAN_EID_EXT_CAPABILITY = 127,
	WLAN_EID_PREQ = 130,
	WLAN_EID_PREP = 131,
	WLAN_EID_PERR = 132,
	WLAN_EID_PXU = 137,
	WLAN_EID_PXUC = 138,
	WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
	WLAN_EID_MIC = 140,
	WLAN_EID_DESTINATION_URI = 141,
	WLAN_EID_UAPSD_COEX = 142,
	WLAN_EID_WAKEUP_SCHEDULE = 143,
	WLAN_EID_EXT_SCHEDULE = 144,
	WLAN_EID_STA_AVAILABILITY = 145,
	WLAN_EID_DMG_TSPEC = 146,
	WLAN_EID_DMG_AT = 147,
	WLAN_EID_DMG_CAP = 148,
	WLAN_EID_CISCO_VENDOR_SPECIFIC = 150,
	WLAN_EID_DMG_OPERATION = 151,
	WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
	WLAN_EID_DMG_BEAM_REFINEMENT = 153,
	WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
	WLAN_EID_AWAKE_WINDOW = 157,
	WLAN_EID_MULTI_BAND = 158,
	WLAN_EID_ADDBA_EXT = 159,
	WLAN_EID_NEXT_PCP_LIST = 160,
	WLAN_EID_PCP_HANDOVER = 161,
	WLAN_EID_DMG_LINK_MARGIN = 162,
	WLAN_EID_SWITCHING_STREAM = 163,
	WLAN_EID_SESSION_TRANSITION = 164,
	WLAN_EID_DYN_TONE_PAIRING_REPORT = 165,
	WLAN_EID_CLUSTER_REPORT = 166,
	WLAN_EID_RELAY_CAP = 167,
	WLAN_EID_RELAY_XFER_PARAM_SET = 168,
	WLAN_EID_BEAM_LINK_MAINT = 169,
	WLAN_EID_MULTIPLE_MAC_ADDR = 170,
	WLAN_EID_U_PID = 171,
	WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
	WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
	WLAN_EID_QUIET_PERIOD_REQ = 175,
	WLAN_EID_QUIET_PERIOD_RESP = 177,
	WLAN_EID_EPAC_POLICY = 182,
	WLAN_EID_CLISTER_TIME_OFF = 183,
	WLAN_EID_INTER_AC_PRIO = 184,
	WLAN_EID_SCS_DESCRIPTOR = 185,
	WLAN_EID_QLOAD_REPORT = 186,
	WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
	WLAN_EID_HL_STREAM_ID = 188,
	WLAN_EID_GCR_GROUP_ADDR = 189,
	WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
	WLAN_EID_VHT_CAPABILITY = 191,
	WLAN_EID_VHT_OPERATION = 192,
	WLAN_EID_EXTENDED_BSS_LOAD = 193,
	WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
	WLAN_EID_VHT_TX_POWER_ENVELOPE = 195,
	WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
	WLAN_EID_AID = 197,
	WLAN_EID_QUIET_CHANNEL = 198,
	WLAN_EID_OPMODE_NOTIF = 199,
	WLAN_EID_REDUCED_NEIGHBOR_REPORT = 201,
	WLAN_EID_AID_REQUEST = 210,
	WLAN_EID_AID_RESPONSE = 211,
	WLAN_EID_S1G_BCN_COMPAT = 213,
	WLAN_EID_S1G_SHORT_BCN_INTERVAL = 214,
	WLAN_EID_S1G_CAPABILITIES = 217,
	WLAN_EID_VENDOR_SPECIFIC = 221,
	WLAN_EID_QOS_PARAMETER = 222,
	WLAN_EID_S1G_OPERATION = 232,
	WLAN_EID_CAG_NUMBER = 237,
	WLAN_EID_AP_CSN = 239,
	WLAN_EID_FILS_INDICATION = 240,
	WLAN_EID_DILS = 241,
	WLAN_EID_FRAGMENT = 242,
	WLAN_EID_RSNX = 244,
	WLAN_EID_EXTENSION = 255,
};

struct element {
	u8 id;
	u8 datalen;
	u8 data[0];
};

enum nl80211_he_ru_alloc {
	NL80211_RATE_INFO_HE_RU_ALLOC_26 = 0,
	NL80211_RATE_INFO_HE_RU_ALLOC_52 = 1,
	NL80211_RATE_INFO_HE_RU_ALLOC_106 = 2,
	NL80211_RATE_INFO_HE_RU_ALLOC_242 = 3,
	NL80211_RATE_INFO_HE_RU_ALLOC_484 = 4,
	NL80211_RATE_INFO_HE_RU_ALLOC_996 = 5,
	NL80211_RATE_INFO_HE_RU_ALLOC_2x996 = 6,
};

enum ieee80211_channel_flags {
	IEEE80211_CHAN_DISABLED = 1,
	IEEE80211_CHAN_NO_IR = 2,
	IEEE80211_CHAN_RADAR = 8,
	IEEE80211_CHAN_NO_HT40PLUS = 16,
	IEEE80211_CHAN_NO_HT40MINUS = 32,
	IEEE80211_CHAN_NO_OFDM = 64,
	IEEE80211_CHAN_NO_80MHZ = 128,
	IEEE80211_CHAN_NO_160MHZ = 256,
	IEEE80211_CHAN_INDOOR_ONLY = 512,
	IEEE80211_CHAN_IR_CONCURRENT = 1024,
	IEEE80211_CHAN_NO_20MHZ = 2048,
	IEEE80211_CHAN_NO_10MHZ = 4096,
	IEEE80211_CHAN_NO_HE = 8192,
	IEEE80211_CHAN_1MHZ = 16384,
	IEEE80211_CHAN_2MHZ = 32768,
	IEEE80211_CHAN_4MHZ = 65536,
	IEEE80211_CHAN_8MHZ = 131072,
	IEEE80211_CHAN_16MHZ = 262144,
};

enum ieee80211_rate_flags {
	IEEE80211_RATE_SHORT_PREAMBLE = 1,
	IEEE80211_RATE_MANDATORY_A = 2,
	IEEE80211_RATE_MANDATORY_B = 4,
	IEEE80211_RATE_MANDATORY_G = 8,
	IEEE80211_RATE_ERP_G = 16,
	IEEE80211_RATE_SUPPORTS_5MHZ = 32,
	IEEE80211_RATE_SUPPORTS_10MHZ = 64,
};

struct iface_combination_params {
	int num_different_channels;
	u8 radar_detect;
	int iftype_num[13];
	u32 new_beacon_int;
};

enum rate_info_flags {
	RATE_INFO_FLAGS_MCS = 1,
	RATE_INFO_FLAGS_VHT_MCS = 2,
	RATE_INFO_FLAGS_SHORT_GI = 4,
	RATE_INFO_FLAGS_DMG = 8,
	RATE_INFO_FLAGS_HE_MCS = 16,
	RATE_INFO_FLAGS_EDMG = 32,
};

enum rate_info_bw {
	RATE_INFO_BW_20 = 0,
	RATE_INFO_BW_5 = 1,
	RATE_INFO_BW_10 = 2,
	RATE_INFO_BW_40 = 3,
	RATE_INFO_BW_80 = 4,
	RATE_INFO_BW_160 = 5,
	RATE_INFO_BW_HE_RU = 6,
};

struct iapp_layer2_update {
	u8 da[6];
	u8 sa[6];
	__be16 len;
	u8 dsap;
	u8 ssap;
	u8 control;
	u8 xid_info[3];
};

enum nl80211_reg_rule_flags {
	NL80211_RRF_NO_OFDM = 1,
	NL80211_RRF_NO_CCK = 2,
	NL80211_RRF_NO_INDOOR = 4,
	NL80211_RRF_NO_OUTDOOR = 8,
	NL80211_RRF_DFS = 16,
	NL80211_RRF_PTP_ONLY = 32,
	NL80211_RRF_PTMP_ONLY = 64,
	NL80211_RRF_NO_IR = 128,
	__NL80211_RRF_NO_IBSS = 256,
	NL80211_RRF_AUTO_BW = 2048,
	NL80211_RRF_IR_CONCURRENT = 4096,
	NL80211_RRF_NO_HT40MINUS = 8192,
	NL80211_RRF_NO_HT40PLUS = 16384,
	NL80211_RRF_NO_80MHZ = 32768,
	NL80211_RRF_NO_160MHZ = 65536,
	NL80211_RRF_NO_HE = 131072,
};

enum nl80211_channel_type {
	NL80211_CHAN_NO_HT = 0,
	NL80211_CHAN_HT20 = 1,
	NL80211_CHAN_HT40MINUS = 2,
	NL80211_CHAN_HT40PLUS = 3,
};

enum ieee80211_regd_source {
	REGD_SOURCE_INTERNAL_DB = 0,
	REGD_SOURCE_CRDA = 1,
	REGD_SOURCE_CACHED = 2,
};

enum reg_request_treatment {
	REG_REQ_OK = 0,
	REG_REQ_IGNORE = 1,
	REG_REQ_INTERSECT = 2,
	REG_REQ_ALREADY_SET = 3,
};

struct reg_beacon {
	struct list_head list;
	struct ieee80211_channel chan;
};

struct reg_regdb_apply_request {
	struct list_head list;
	const struct ieee80211_regdomain *regdom;
};

struct fwdb_country {
	u8 alpha2[2];
	__be16 coll_ptr;
};

struct fwdb_header {
	__be32 magic;
	__be32 version;
	struct fwdb_country country[0];
};

struct fwdb_collection {
	u8 len;
	u8 n_rules;
	u8 dfs_region;
	char: 8;
};

enum fwdb_flags {
	FWDB_FLAG_NO_OFDM = 1,
	FWDB_FLAG_NO_OUTDOOR = 2,
	FWDB_FLAG_DFS = 4,
	FWDB_FLAG_NO_IR = 8,
	FWDB_FLAG_AUTO_BW = 16,
};

struct fwdb_wmm_ac {
	u8 ecw;
	u8 aifsn;
	__be16 cot;
};

struct fwdb_wmm_rule {
	struct fwdb_wmm_ac client[4];
	struct fwdb_wmm_ac ap[4];
};

struct fwdb_rule {
	u8 len;
	u8 flags;
	__be16 max_eirp;
	__be32 start;
	__be32 end;
	__be32 max_bw;
	__be16 cac_timeout;
	__be16 wmm_ptr;
};

enum nl80211_scan_flags {
	NL80211_SCAN_FLAG_LOW_PRIORITY = 1,
	NL80211_SCAN_FLAG_FLUSH = 2,
	NL80211_SCAN_FLAG_AP = 4,
	NL80211_SCAN_FLAG_RANDOM_ADDR = 8,
	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME = 16,
	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP = 32,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE = 64,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 128,
	NL80211_SCAN_FLAG_LOW_SPAN = 256,
	NL80211_SCAN_FLAG_LOW_POWER = 512,
	NL80211_SCAN_FLAG_HIGH_ACCURACY = 1024,
	NL80211_SCAN_FLAG_RANDOM_SN = 2048,
	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT = 4096,
	NL80211_SCAN_FLAG_FREQ_KHZ = 8192,
	NL80211_SCAN_FLAG_COLOCATED_6GHZ = 16384,
};

struct ieee80211_msrment_ie {
	u8 token;
	u8 mode;
	u8 type;
	u8 request[0];
};

struct ieee80211_ext_chansw_ie {
	u8 mode;
	u8 new_operating_class;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_tpc_report_ie {
	u8 tx_power;
	u8 link_margin;
};

struct ieee80211_s1g_bcn_compat_ie {
	__le16 compat_info;
	__le16 beacon_int;
	__le32 tsf_completion;
};

struct ieee80211_s1g_oper_ie {
	u8 ch_width;
	u8 oper_class;
	u8 primary_ch;
	u8 oper_ch;
	__le16 basic_mcs_nss;
};

struct ieee80211_ext {
	__le16 frame_control;
	__le16 duration;
	union {
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 variable[0];
		} __attribute__((packed)) s1g_beacon;
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 next_tbtt[3];
			u8 variable[0];
		} __attribute__((packed)) s1g_short_beacon;
	} u;
} __attribute__((packed));

struct ieee80211_mgmt {
	__le16 frame_control;
	__le16 duration;
	u8 da[6];
	u8 sa[6];
	u8 bssid[6];
	__le16 seq_ctrl;
	union {
		struct {
			__le16 auth_alg;
			__le16 auth_transaction;
			__le16 status_code;
			u8 variable[0];
		} auth;
		struct {
			__le16 reason_code;
		} deauth;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 variable[0];
		} assoc_req;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 current_ap[6];
			u8 variable[0];
		} reassoc_req;
		struct {
			__le16 reason_code;
		} disassoc;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} __attribute__((packed)) beacon;
		struct {
			u8 variable[0];
		} probe_req;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} __attribute__((packed)) probe_resp;
		struct {
			u8 category;
			union {
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 status_code;
					u8 variable[0];
				} wme_action;
				struct {
					u8 action_code;
					u8 variable[0];
				} chan_switch;
				struct {
					u8 action_code;
					struct ieee80211_ext_chansw_ie data;
					u8 variable[0];
				} ext_chan_switch;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 element_id;
					u8 length;
					struct ieee80211_msrment_ie msr_elem;
				} measurement;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capab;
					__le16 timeout;
					__le16 start_seq_num;
					u8 variable[0];
				} addba_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 status;
					__le16 capab;
					__le16 timeout;
				} addba_resp;
				struct {
					u8 action_code;
					__le16 params;
					__le16 reason_code;
				} __attribute__((packed)) delba;
				struct {
					u8 action_code;
					u8 variable[0];
				} self_prot;
				struct {
					u8 action_code;
					u8 variable[0];
				} mesh_action;
				struct {
					u8 action;
					u8 trans_id[2];
				} sa_query;
				struct {
					u8 action;
					u8 smps_control;
				} ht_smps;
				struct {
					u8 action_code;
					u8 chanwidth;
				} ht_notify_cw;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capability;
					u8 variable[0];
				} tdls_discover_resp;
				struct {
					u8 action_code;
					u8 operating_mode;
				} vht_opmode_notif;
				struct {
					u8 action_code;
					u8 membership[8];
					u8 position[16];
				} vht_group_notif;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 tpc_elem_id;
					u8 tpc_elem_length;
					struct ieee80211_tpc_report_ie tpc;
				} tpc_report;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 follow_up;
					u8 tod[6];
					u8 toa[6];
					__le16 tod_error;
					__le16 toa_error;
					u8 variable[0];
				} __attribute__((packed)) ftm;
			} u;
		} __attribute__((packed)) action;
	} u;
} __attribute__((packed));

struct ieee80211_ht_operation {
	u8 primary_chan;
	u8 ht_param;
	__le16 operation_mode;
	__le16 stbc_param;
	u8 basic_set[16];
};

enum ieee80211_eid_ext {
	WLAN_EID_EXT_ASSOC_DELAY_INFO = 1,
	WLAN_EID_EXT_FILS_REQ_PARAMS = 2,
	WLAN_EID_EXT_FILS_KEY_CONFIRM = 3,
	WLAN_EID_EXT_FILS_SESSION = 4,
	WLAN_EID_EXT_FILS_HLP_CONTAINER = 5,
	WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN = 6,
	WLAN_EID_EXT_KEY_DELIVERY = 7,
	WLAN_EID_EXT_FILS_WRAPPED_DATA = 8,
	WLAN_EID_EXT_FILS_PUBLIC_KEY = 12,
	WLAN_EID_EXT_FILS_NONCE = 13,
	WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE = 14,
	WLAN_EID_EXT_HE_CAPABILITY = 35,
	WLAN_EID_EXT_HE_OPERATION = 36,
	WLAN_EID_EXT_UORA = 37,
	WLAN_EID_EXT_HE_MU_EDCA = 38,
	WLAN_EID_EXT_HE_SPR = 39,
	WLAN_EID_EXT_NDP_FEEDBACK_REPORT_PARAMSET = 41,
	WLAN_EID_EXT_BSS_COLOR_CHG_ANN = 42,
	WLAN_EID_EXT_QUIET_TIME_PERIOD_SETUP = 43,
	WLAN_EID_EXT_ESS_REPORT = 45,
	WLAN_EID_EXT_OPS = 46,
	WLAN_EID_EXT_HE_BSS_LOAD = 47,
	WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME = 52,
	WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION = 55,
	WLAN_EID_EXT_NON_INHERITANCE = 56,
	WLAN_EID_EXT_KNOWN_BSSID = 57,
	WLAN_EID_EXT_SHORT_SSID_LIST = 58,
	WLAN_EID_EXT_HE_6GHZ_CAPA = 59,
	WLAN_EID_EXT_UL_MU_POWER_CAPA = 60,
};

struct ieee80211_neighbor_ap_info {
	u8 tbtt_info_hdr;
	u8 tbtt_info_len;
	u8 op_class;
	u8 channel;
};

enum ieee80211_privacy {
	IEEE80211_PRIVACY_ON = 0,
	IEEE80211_PRIVACY_OFF = 1,
	IEEE80211_PRIVACY_ANY = 2,
};

struct cfg80211_inform_bss {
	struct ieee80211_channel *chan;
	enum nl80211_bss_scan_width scan_width;
	s32 signal;
	u64 boottime_ns;
	u64 parent_tsf;
	u8 parent_bssid[6];
	u8 chains;
	s8 chain_signal[4];
};

enum cfg80211_bss_frame_type {
	CFG80211_BSS_FTYPE_UNKNOWN = 0,
	CFG80211_BSS_FTYPE_BEACON = 1,
	CFG80211_BSS_FTYPE_PRESP = 2,
};

struct cfg80211_colocated_ap {
	struct list_head list;
	u8 bssid[6];
	u8 ssid[32];
	size_t ssid_len;
	u32 short_ssid;
	u32 center_freq;
	u8 unsolicited_probe: 1;
	u8 oct_recommended: 1;
	u8 same_ssid: 1;
	u8 multi_bss: 1;
	u8 transmitted_bssid: 1;
	u8 colocated_ess: 1;
	u8 short_ssid_valid: 1;
};

enum bss_compare_mode {
	BSS_CMP_REGULAR = 0,
	BSS_CMP_HIDE_ZLEN = 1,
	BSS_CMP_HIDE_NUL = 2,
};

struct cfg80211_non_tx_bss {
	struct cfg80211_bss *tx_bss;
	u8 max_bssid_indicator;
	u8 bssid_index;
};

enum ieee80211_vht_mcs_support {
	IEEE80211_VHT_MCS_SUPPORT_0_7 = 0,
	IEEE80211_VHT_MCS_SUPPORT_0_8 = 1,
	IEEE80211_VHT_MCS_SUPPORT_0_9 = 2,
	IEEE80211_VHT_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_he_mcs_support {
	IEEE80211_HE_MCS_SUPPORT_0_7 = 0,
	IEEE80211_HE_MCS_SUPPORT_0_9 = 1,
	IEEE80211_HE_MCS_SUPPORT_0_11 = 2,
	IEEE80211_HE_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_mesh_sync_method {
	IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET = 1,
	IEEE80211_SYNC_METHOD_VENDOR = 255,
};

enum ieee80211_mesh_path_protocol {
	IEEE80211_PATH_PROTOCOL_HWMP = 1,
	IEEE80211_PATH_PROTOCOL_VENDOR = 255,
};

enum ieee80211_mesh_path_metric {
	IEEE80211_PATH_METRIC_AIRTIME = 1,
	IEEE80211_PATH_METRIC_VENDOR = 255,
};

enum nl80211_attrs {
	NL80211_ATTR_UNSPEC = 0,
	NL80211_ATTR_WIPHY = 1,
	NL80211_ATTR_WIPHY_NAME = 2,
	NL80211_ATTR_IFINDEX = 3,
	NL80211_ATTR_IFNAME = 4,
	NL80211_ATTR_IFTYPE = 5,
	NL80211_ATTR_MAC = 6,
	NL80211_ATTR_KEY_DATA = 7,
	NL80211_ATTR_KEY_IDX = 8,
	NL80211_ATTR_KEY_CIPHER = 9,
	NL80211_ATTR_KEY_SEQ = 10,
	NL80211_ATTR_KEY_DEFAULT = 11,
	NL80211_ATTR_BEACON_INTERVAL = 12,
	NL80211_ATTR_DTIM_PERIOD = 13,
	NL80211_ATTR_BEACON_HEAD = 14,
	NL80211_ATTR_BEACON_TAIL = 15,
	NL80211_ATTR_STA_AID = 16,
	NL80211_ATTR_STA_FLAGS = 17,
	NL80211_ATTR_STA_LISTEN_INTERVAL = 18,
	NL80211_ATTR_STA_SUPPORTED_RATES = 19,
	NL80211_ATTR_STA_VLAN = 20,
	NL80211_ATTR_STA_INFO = 21,
	NL80211_ATTR_WIPHY_BANDS = 22,
	NL80211_ATTR_MNTR_FLAGS = 23,
	NL80211_ATTR_MESH_ID = 24,
	NL80211_ATTR_STA_PLINK_ACTION = 25,
	NL80211_ATTR_MPATH_NEXT_HOP = 26,
	NL80211_ATTR_MPATH_INFO = 27,
	NL80211_ATTR_BSS_CTS_PROT = 28,
	NL80211_ATTR_BSS_SHORT_PREAMBLE = 29,
	NL80211_ATTR_BSS_SHORT_SLOT_TIME = 30,
	NL80211_ATTR_HT_CAPABILITY = 31,
	NL80211_ATTR_SUPPORTED_IFTYPES = 32,
	NL80211_ATTR_REG_ALPHA2 = 33,
	NL80211_ATTR_REG_RULES = 34,
	NL80211_ATTR_MESH_CONFIG = 35,
	NL80211_ATTR_BSS_BASIC_RATES = 36,
	NL80211_ATTR_WIPHY_TXQ_PARAMS = 37,
	NL80211_ATTR_WIPHY_FREQ = 38,
	NL80211_ATTR_WIPHY_CHANNEL_TYPE = 39,
	NL80211_ATTR_KEY_DEFAULT_MGMT = 40,
	NL80211_ATTR_MGMT_SUBTYPE = 41,
	NL80211_ATTR_IE = 42,
	NL80211_ATTR_MAX_NUM_SCAN_SSIDS = 43,
	NL80211_ATTR_SCAN_FREQUENCIES = 44,
	NL80211_ATTR_SCAN_SSIDS = 45,
	NL80211_ATTR_GENERATION = 46,
	NL80211_ATTR_BSS = 47,
	NL80211_ATTR_REG_INITIATOR = 48,
	NL80211_ATTR_REG_TYPE = 49,
	NL80211_ATTR_SUPPORTED_COMMANDS = 50,
	NL80211_ATTR_FRAME = 51,
	NL80211_ATTR_SSID = 52,
	NL80211_ATTR_AUTH_TYPE = 53,
	NL80211_ATTR_REASON_CODE = 54,
	NL80211_ATTR_KEY_TYPE = 55,
	NL80211_ATTR_MAX_SCAN_IE_LEN = 56,
	NL80211_ATTR_CIPHER_SUITES = 57,
	NL80211_ATTR_FREQ_BEFORE = 58,
	NL80211_ATTR_FREQ_AFTER = 59,
	NL80211_ATTR_FREQ_FIXED = 60,
	NL80211_ATTR_WIPHY_RETRY_SHORT = 61,
	NL80211_ATTR_WIPHY_RETRY_LONG = 62,
	NL80211_ATTR_WIPHY_FRAG_THRESHOLD = 63,
	NL80211_ATTR_WIPHY_RTS_THRESHOLD = 64,
	NL80211_ATTR_TIMED_OUT = 65,
	NL80211_ATTR_USE_MFP = 66,
	NL80211_ATTR_STA_FLAGS2 = 67,
	NL80211_ATTR_CONTROL_PORT = 68,
	NL80211_ATTR_TESTDATA = 69,
	NL80211_ATTR_PRIVACY = 70,
	NL80211_ATTR_DISCONNECTED_BY_AP = 71,
	NL80211_ATTR_STATUS_CODE = 72,
	NL80211_ATTR_CIPHER_SUITES_PAIRWISE = 73,
	NL80211_ATTR_CIPHER_SUITE_GROUP = 74,
	NL80211_ATTR_WPA_VERSIONS = 75,
	NL80211_ATTR_AKM_SUITES = 76,
	NL80211_ATTR_REQ_IE = 77,
	NL80211_ATTR_RESP_IE = 78,
	NL80211_ATTR_PREV_BSSID = 79,
	NL80211_ATTR_KEY = 80,
	NL80211_ATTR_KEYS = 81,
	NL80211_ATTR_PID = 82,
	NL80211_ATTR_4ADDR = 83,
	NL80211_ATTR_SURVEY_INFO = 84,
	NL80211_ATTR_PMKID = 85,
	NL80211_ATTR_MAX_NUM_PMKIDS = 86,
	NL80211_ATTR_DURATION = 87,
	NL80211_ATTR_COOKIE = 88,
	NL80211_ATTR_WIPHY_COVERAGE_CLASS = 89,
	NL80211_ATTR_TX_RATES = 90,
	NL80211_ATTR_FRAME_MATCH = 91,
	NL80211_ATTR_ACK = 92,
	NL80211_ATTR_PS_STATE = 93,
	NL80211_ATTR_CQM = 94,
	NL80211_ATTR_LOCAL_STATE_CHANGE = 95,
	NL80211_ATTR_AP_ISOLATE = 96,
	NL80211_ATTR_WIPHY_TX_POWER_SETTING = 97,
	NL80211_ATTR_WIPHY_TX_POWER_LEVEL = 98,
	NL80211_ATTR_TX_FRAME_TYPES = 99,
	NL80211_ATTR_RX_FRAME_TYPES = 100,
	NL80211_ATTR_FRAME_TYPE = 101,
	NL80211_ATTR_CONTROL_PORT_ETHERTYPE = 102,
	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT = 103,
	NL80211_ATTR_SUPPORT_IBSS_RSN = 104,
	NL80211_ATTR_WIPHY_ANTENNA_TX = 105,
	NL80211_ATTR_WIPHY_ANTENNA_RX = 106,
	NL80211_ATTR_MCAST_RATE = 107,
	NL80211_ATTR_OFFCHANNEL_TX_OK = 108,
	NL80211_ATTR_BSS_HT_OPMODE = 109,
	NL80211_ATTR_KEY_DEFAULT_TYPES = 110,
	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION = 111,
	NL80211_ATTR_MESH_SETUP = 112,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX = 113,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX = 114,
	NL80211_ATTR_SUPPORT_MESH_AUTH = 115,
	NL80211_ATTR_STA_PLINK_STATE = 116,
	NL80211_ATTR_WOWLAN_TRIGGERS = 117,
	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED = 118,
	NL80211_ATTR_SCHED_SCAN_INTERVAL = 119,
	NL80211_ATTR_INTERFACE_COMBINATIONS = 120,
	NL80211_ATTR_SOFTWARE_IFTYPES = 121,
	NL80211_ATTR_REKEY_DATA = 122,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS = 123,
	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN = 124,
	NL80211_ATTR_SCAN_SUPP_RATES = 125,
	NL80211_ATTR_HIDDEN_SSID = 126,
	NL80211_ATTR_IE_PROBE_RESP = 127,
	NL80211_ATTR_IE_ASSOC_RESP = 128,
	NL80211_ATTR_STA_WME = 129,
	NL80211_ATTR_SUPPORT_AP_UAPSD = 130,
	NL80211_ATTR_ROAM_SUPPORT = 131,
	NL80211_ATTR_SCHED_SCAN_MATCH = 132,
	NL80211_ATTR_MAX_MATCH_SETS = 133,
	NL80211_ATTR_PMKSA_CANDIDATE = 134,
	NL80211_ATTR_TX_NO_CCK_RATE = 135,
	NL80211_ATTR_TDLS_ACTION = 136,
	NL80211_ATTR_TDLS_DIALOG_TOKEN = 137,
	NL80211_ATTR_TDLS_OPERATION = 138,
	NL80211_ATTR_TDLS_SUPPORT = 139,
	NL80211_ATTR_TDLS_EXTERNAL_SETUP = 140,
	NL80211_ATTR_DEVICE_AP_SME = 141,
	NL80211_ATTR_DONT_WAIT_FOR_ACK = 142,
	NL80211_ATTR_FEATURE_FLAGS = 143,
	NL80211_ATTR_PROBE_RESP_OFFLOAD = 144,
	NL80211_ATTR_PROBE_RESP = 145,
	NL80211_ATTR_DFS_REGION = 146,
	NL80211_ATTR_DISABLE_HT = 147,
	NL80211_ATTR_HT_CAPABILITY_MASK = 148,
	NL80211_ATTR_NOACK_MAP = 149,
	NL80211_ATTR_INACTIVITY_TIMEOUT = 150,
	NL80211_ATTR_RX_SIGNAL_DBM = 151,
	NL80211_ATTR_BG_SCAN_PERIOD = 152,
	NL80211_ATTR_WDEV = 153,
	NL80211_ATTR_USER_REG_HINT_TYPE = 154,
	NL80211_ATTR_CONN_FAILED_REASON = 155,
	NL80211_ATTR_AUTH_DATA = 156,
	NL80211_ATTR_VHT_CAPABILITY = 157,
	NL80211_ATTR_SCAN_FLAGS = 158,
	NL80211_ATTR_CHANNEL_WIDTH = 159,
	NL80211_ATTR_CENTER_FREQ1 = 160,
	NL80211_ATTR_CENTER_FREQ2 = 161,
	NL80211_ATTR_P2P_CTWINDOW = 162,
	NL80211_ATTR_P2P_OPPPS = 163,
	NL80211_ATTR_LOCAL_MESH_POWER_MODE = 164,
	NL80211_ATTR_ACL_POLICY = 165,
	NL80211_ATTR_MAC_ADDRS = 166,
	NL80211_ATTR_MAC_ACL_MAX = 167,
	NL80211_ATTR_RADAR_EVENT = 168,
	NL80211_ATTR_EXT_CAPA = 169,
	NL80211_ATTR_EXT_CAPA_MASK = 170,
	NL80211_ATTR_STA_CAPABILITY = 171,
	NL80211_ATTR_STA_EXT_CAPABILITY = 172,
	NL80211_ATTR_PROTOCOL_FEATURES = 173,
	NL80211_ATTR_SPLIT_WIPHY_DUMP = 174,
	NL80211_ATTR_DISABLE_VHT = 175,
	NL80211_ATTR_VHT_CAPABILITY_MASK = 176,
	NL80211_ATTR_MDID = 177,
	NL80211_ATTR_IE_RIC = 178,
	NL80211_ATTR_CRIT_PROT_ID = 179,
	NL80211_ATTR_MAX_CRIT_PROT_DURATION = 180,
	NL80211_ATTR_PEER_AID = 181,
	NL80211_ATTR_COALESCE_RULE = 182,
	NL80211_ATTR_CH_SWITCH_COUNT = 183,
	NL80211_ATTR_CH_SWITCH_BLOCK_TX = 184,
	NL80211_ATTR_CSA_IES = 185,
	NL80211_ATTR_CNTDWN_OFFS_BEACON = 186,
	NL80211_ATTR_CNTDWN_OFFS_PRESP = 187,
	NL80211_ATTR_RXMGMT_FLAGS = 188,
	NL80211_ATTR_STA_SUPPORTED_CHANNELS = 189,
	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES = 190,
	NL80211_ATTR_HANDLE_DFS = 191,
	NL80211_ATTR_SUPPORT_5_MHZ = 192,
	NL80211_ATTR_SUPPORT_10_MHZ = 193,
	NL80211_ATTR_OPMODE_NOTIF = 194,
	NL80211_ATTR_VENDOR_ID = 195,
	NL80211_ATTR_VENDOR_SUBCMD = 196,
	NL80211_ATTR_VENDOR_DATA = 197,
	NL80211_ATTR_VENDOR_EVENTS = 198,
	NL80211_ATTR_QOS_MAP = 199,
	NL80211_ATTR_MAC_HINT = 200,
	NL80211_ATTR_WIPHY_FREQ_HINT = 201,
	NL80211_ATTR_MAX_AP_ASSOC_STA = 202,
	NL80211_ATTR_TDLS_PEER_CAPABILITY = 203,
	NL80211_ATTR_SOCKET_OWNER = 204,
	NL80211_ATTR_CSA_C_OFFSETS_TX = 205,
	NL80211_ATTR_MAX_CSA_COUNTERS = 206,
	NL80211_ATTR_TDLS_INITIATOR = 207,
	NL80211_ATTR_USE_RRM = 208,
	NL80211_ATTR_WIPHY_DYN_ACK = 209,
	NL80211_ATTR_TSID = 210,
	NL80211_ATTR_USER_PRIO = 211,
	NL80211_ATTR_ADMITTED_TIME = 212,
	NL80211_ATTR_SMPS_MODE = 213,
	NL80211_ATTR_OPER_CLASS = 214,
	NL80211_ATTR_MAC_MASK = 215,
	NL80211_ATTR_WIPHY_SELF_MANAGED_REG = 216,
	NL80211_ATTR_EXT_FEATURES = 217,
	NL80211_ATTR_SURVEY_RADIO_STATS = 218,
	NL80211_ATTR_NETNS_FD = 219,
	NL80211_ATTR_SCHED_SCAN_DELAY = 220,
	NL80211_ATTR_REG_INDOOR = 221,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS = 222,
	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL = 223,
	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS = 224,
	NL80211_ATTR_SCHED_SCAN_PLANS = 225,
	NL80211_ATTR_PBSS = 226,
	NL80211_ATTR_BSS_SELECT = 227,
	NL80211_ATTR_STA_SUPPORT_P2P_PS = 228,
	NL80211_ATTR_PAD = 229,
	NL80211_ATTR_IFTYPE_EXT_CAPA = 230,
	NL80211_ATTR_MU_MIMO_GROUP_DATA = 231,
	NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR = 232,
	NL80211_ATTR_SCAN_START_TIME_TSF = 233,
	NL80211_ATTR_SCAN_START_TIME_TSF_BSSID = 234,
	NL80211_ATTR_MEASUREMENT_DURATION = 235,
	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY = 236,
	NL80211_ATTR_MESH_PEER_AID = 237,
	NL80211_ATTR_NAN_MASTER_PREF = 238,
	NL80211_ATTR_BANDS = 239,
	NL80211_ATTR_NAN_FUNC = 240,
	NL80211_ATTR_NAN_MATCH = 241,
	NL80211_ATTR_FILS_KEK = 242,
	NL80211_ATTR_FILS_NONCES = 243,
	NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED = 244,
	NL80211_ATTR_BSSID = 245,
	NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI = 246,
	NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST = 247,
	NL80211_ATTR_TIMEOUT_REASON = 248,
	NL80211_ATTR_FILS_ERP_USERNAME = 249,
	NL80211_ATTR_FILS_ERP_REALM = 250,
	NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM = 251,
	NL80211_ATTR_FILS_ERP_RRK = 252,
	NL80211_ATTR_FILS_CACHE_ID = 253,
	NL80211_ATTR_PMK = 254,
	NL80211_ATTR_SCHED_SCAN_MULTI = 255,
	NL80211_ATTR_SCHED_SCAN_MAX_REQS = 256,
	NL80211_ATTR_WANT_1X_4WAY_HS = 257,
	NL80211_ATTR_PMKR0_NAME = 258,
	NL80211_ATTR_PORT_AUTHORIZED = 259,
	NL80211_ATTR_EXTERNAL_AUTH_ACTION = 260,
	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT = 261,
	NL80211_ATTR_NSS = 262,
	NL80211_ATTR_ACK_SIGNAL = 263,
	NL80211_ATTR_CONTROL_PORT_OVER_NL80211 = 264,
	NL80211_ATTR_TXQ_STATS = 265,
	NL80211_ATTR_TXQ_LIMIT = 266,
	NL80211_ATTR_TXQ_MEMORY_LIMIT = 267,
	NL80211_ATTR_TXQ_QUANTUM = 268,
	NL80211_ATTR_HE_CAPABILITY = 269,
	NL80211_ATTR_FTM_RESPONDER = 270,
	NL80211_ATTR_FTM_RESPONDER_STATS = 271,
	NL80211_ATTR_TIMEOUT = 272,
	NL80211_ATTR_PEER_MEASUREMENTS = 273,
	NL80211_ATTR_AIRTIME_WEIGHT = 274,
	NL80211_ATTR_STA_TX_POWER_SETTING = 275,
	NL80211_ATTR_STA_TX_POWER = 276,
	NL80211_ATTR_SAE_PASSWORD = 277,
	NL80211_ATTR_TWT_RESPONDER = 278,
	NL80211_ATTR_HE_OBSS_PD = 279,
	NL80211_ATTR_WIPHY_EDMG_CHANNELS = 280,
	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG = 281,
	NL80211_ATTR_VLAN_ID = 282,
	NL80211_ATTR_HE_BSS_COLOR = 283,
	NL80211_ATTR_IFTYPE_AKM_SUITES = 284,
	NL80211_ATTR_TID_CONFIG = 285,
	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH = 286,
	NL80211_ATTR_PMK_LIFETIME = 287,
	NL80211_ATTR_PMK_REAUTH_THRESHOLD = 288,
	NL80211_ATTR_RECEIVE_MULTICAST = 289,
	NL80211_ATTR_WIPHY_FREQ_OFFSET = 290,
	NL80211_ATTR_CENTER_FREQ1_OFFSET = 291,
	NL80211_ATTR_SCAN_FREQ_KHZ = 292,
	NL80211_ATTR_HE_6GHZ_CAPABILITY = 293,
	NL80211_ATTR_FILS_DISCOVERY = 294,
	NL80211_ATTR_UNSOL_BCAST_PROBE_RESP = 295,
	NL80211_ATTR_S1G_CAPABILITY = 296,
	NL80211_ATTR_S1G_CAPABILITY_MASK = 297,
	NL80211_ATTR_SAE_PWE = 298,
	__NL80211_ATTR_AFTER_LAST = 299,
	NUM_NL80211_ATTR = 299,
	NL80211_ATTR_MAX = 298,
};

enum nl80211_sta_flags {
	__NL80211_STA_FLAG_INVALID = 0,
	NL80211_STA_FLAG_AUTHORIZED = 1,
	NL80211_STA_FLAG_SHORT_PREAMBLE = 2,
	NL80211_STA_FLAG_WME = 3,
	NL80211_STA_FLAG_MFP = 4,
	NL80211_STA_FLAG_AUTHENTICATED = 5,
	NL80211_STA_FLAG_TDLS_PEER = 6,
	NL80211_STA_FLAG_ASSOCIATED = 7,
	__NL80211_STA_FLAG_AFTER_LAST = 8,
	NL80211_STA_FLAG_MAX = 7,
};

enum nl80211_sta_p2p_ps_status {
	NL80211_P2P_PS_UNSUPPORTED = 0,
	NL80211_P2P_PS_SUPPORTED = 1,
	NUM_NL80211_P2P_PS_STATUS = 2,
};

enum nl80211_rate_info {
	__NL80211_RATE_INFO_INVALID = 0,
	NL80211_RATE_INFO_BITRATE = 1,
	NL80211_RATE_INFO_MCS = 2,
	NL80211_RATE_INFO_40_MHZ_WIDTH = 3,
	NL80211_RATE_INFO_SHORT_GI = 4,
	NL80211_RATE_INFO_BITRATE32 = 5,
	NL80211_RATE_INFO_VHT_MCS = 6,
	NL80211_RATE_INFO_VHT_NSS = 7,
	NL80211_RATE_INFO_80_MHZ_WIDTH = 8,
	NL80211_RATE_INFO_80P80_MHZ_WIDTH = 9,
	NL80211_RATE_INFO_160_MHZ_WIDTH = 10,
	NL80211_RATE_INFO_10_MHZ_WIDTH = 11,
	NL80211_RATE_INFO_5_MHZ_WIDTH = 12,
	NL80211_RATE_INFO_HE_MCS = 13,
	NL80211_RATE_INFO_HE_NSS = 14,
	NL80211_RATE_INFO_HE_GI = 15,
	NL80211_RATE_INFO_HE_DCM = 16,
	NL80211_RATE_INFO_HE_RU_ALLOC = 17,
	__NL80211_RATE_INFO_AFTER_LAST = 18,
	NL80211_RATE_INFO_MAX = 17,
};

enum nl80211_sta_bss_param {
	__NL80211_STA_BSS_PARAM_INVALID = 0,
	NL80211_STA_BSS_PARAM_CTS_PROT = 1,
	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE = 2,
	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME = 3,
	NL80211_STA_BSS_PARAM_DTIM_PERIOD = 4,
	NL80211_STA_BSS_PARAM_BEACON_INTERVAL = 5,
	__NL80211_STA_BSS_PARAM_AFTER_LAST = 6,
	NL80211_STA_BSS_PARAM_MAX = 5,
};

enum nl80211_sta_info {
	__NL80211_STA_INFO_INVALID = 0,
	NL80211_STA_INFO_INACTIVE_TIME = 1,
	NL80211_STA_INFO_RX_BYTES = 2,
	NL80211_STA_INFO_TX_BYTES = 3,
	NL80211_STA_INFO_LLID = 4,
	NL80211_STA_INFO_PLID = 5,
	NL80211_STA_INFO_PLINK_STATE = 6,
	NL80211_STA_INFO_SIGNAL = 7,
	NL80211_STA_INFO_TX_BITRATE = 8,
	NL80211_STA_INFO_RX_PACKETS = 9,
	NL80211_STA_INFO_TX_PACKETS = 10,
	NL80211_STA_INFO_TX_RETRIES = 11,
	NL80211_STA_INFO_TX_FAILED = 12,
	NL80211_STA_INFO_SIGNAL_AVG = 13,
	NL80211_STA_INFO_RX_BITRATE = 14,
	NL80211_STA_INFO_BSS_PARAM = 15,
	NL80211_STA_INFO_CONNECTED_TIME = 16,
	NL80211_STA_INFO_STA_FLAGS = 17,
	NL80211_STA_INFO_BEACON_LOSS = 18,
	NL80211_STA_INFO_T_OFFSET = 19,
	NL80211_STA_INFO_LOCAL_PM = 20,
	NL80211_STA_INFO_PEER_PM = 21,
	NL80211_STA_INFO_NONPEER_PM = 22,
	NL80211_STA_INFO_RX_BYTES64 = 23,
	NL80211_STA_INFO_TX_BYTES64 = 24,
	NL80211_STA_INFO_CHAIN_SIGNAL = 25,
	NL80211_STA_INFO_CHAIN_SIGNAL_AVG = 26,
	NL80211_STA_INFO_EXPECTED_THROUGHPUT = 27,
	NL80211_STA_INFO_RX_DROP_MISC = 28,
	NL80211_STA_INFO_BEACON_RX = 29,
	NL80211_STA_INFO_BEACON_SIGNAL_AVG = 30,
	NL80211_STA_INFO_TID_STATS = 31,
	NL80211_STA_INFO_RX_DURATION = 32,
	NL80211_STA_INFO_PAD = 33,
	NL80211_STA_INFO_ACK_SIGNAL = 34,
	NL80211_STA_INFO_ACK_SIGNAL_AVG = 35,
	NL80211_STA_INFO_RX_MPDUS = 36,
	NL80211_STA_INFO_FCS_ERROR_COUNT = 37,
	NL80211_STA_INFO_CONNECTED_TO_GATE = 38,
	NL80211_STA_INFO_TX_DURATION = 39,
	NL80211_STA_INFO_AIRTIME_WEIGHT = 40,
	NL80211_STA_INFO_AIRTIME_LINK_METRIC = 41,
	NL80211_STA_INFO_ASSOC_AT_BOOTTIME = 42,
	NL80211_STA_INFO_CONNECTED_TO_AS = 43,
	__NL80211_STA_INFO_AFTER_LAST = 44,
	NL80211_STA_INFO_MAX = 43,
};

enum nl80211_tid_stats {
	__NL80211_TID_STATS_INVALID = 0,
	NL80211_TID_STATS_RX_MSDU = 1,
	NL80211_TID_STATS_TX_MSDU = 2,
	NL80211_TID_STATS_TX_MSDU_RETRIES = 3,
	NL80211_TID_STATS_TX_MSDU_FAILED = 4,
	NL80211_TID_STATS_PAD = 5,
	NL80211_TID_STATS_TXQ_STATS = 6,
	NUM_NL80211_TID_STATS = 7,
	NL80211_TID_STATS_MAX = 6,
};

enum nl80211_txq_stats {
	__NL80211_TXQ_STATS_INVALID = 0,
	NL80211_TXQ_STATS_BACKLOG_BYTES = 1,
	NL80211_TXQ_STATS_BACKLOG_PACKETS = 2,
	NL80211_TXQ_STATS_FLOWS = 3,
	NL80211_TXQ_STATS_DROPS = 4,
	NL80211_TXQ_STATS_ECN_MARKS = 5,
	NL80211_TXQ_STATS_OVERLIMIT = 6,
	NL80211_TXQ_STATS_OVERMEMORY = 7,
	NL80211_TXQ_STATS_COLLISIONS = 8,
	NL80211_TXQ_STATS_TX_BYTES = 9,
	NL80211_TXQ_STATS_TX_PACKETS = 10,
	NL80211_TXQ_STATS_MAX_FLOWS = 11,
	NUM_NL80211_TXQ_STATS = 12,
	NL80211_TXQ_STATS_MAX = 11,
};

enum nl80211_mpath_info {
	__NL80211_MPATH_INFO_INVALID = 0,
	NL80211_MPATH_INFO_FRAME_QLEN = 1,
	NL80211_MPATH_INFO_SN = 2,
	NL80211_MPATH_INFO_METRIC = 3,
	NL80211_MPATH_INFO_EXPTIME = 4,
	NL80211_MPATH_INFO_FLAGS = 5,
	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT = 6,
	NL80211_MPATH_INFO_DISCOVERY_RETRIES = 7,
	NL80211_MPATH_INFO_HOP_COUNT = 8,
	NL80211_MPATH_INFO_PATH_CHANGE = 9,
	__NL80211_MPATH_INFO_AFTER_LAST = 10,
	NL80211_MPATH_INFO_MAX = 9,
};

enum nl80211_band_iftype_attr {
	__NL80211_BAND_IFTYPE_ATTR_INVALID = 0,
	NL80211_BAND_IFTYPE_ATTR_IFTYPES = 1,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC = 2,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY = 3,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET = 4,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE = 5,
	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA = 6,
	__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST = 7,
	NL80211_BAND_IFTYPE_ATTR_MAX = 6,
};

enum nl80211_band_attr {
	__NL80211_BAND_ATTR_INVALID = 0,
	NL80211_BAND_ATTR_FREQS = 1,
	NL80211_BAND_ATTR_RATES = 2,
	NL80211_BAND_ATTR_HT_MCS_SET = 3,
	NL80211_BAND_ATTR_HT_CAPA = 4,
	NL80211_BAND_ATTR_HT_AMPDU_FACTOR = 5,
	NL80211_BAND_ATTR_HT_AMPDU_DENSITY = 6,
	NL80211_BAND_ATTR_VHT_MCS_SET = 7,
	NL80211_BAND_ATTR_VHT_CAPA = 8,
	NL80211_BAND_ATTR_IFTYPE_DATA = 9,
	NL80211_BAND_ATTR_EDMG_CHANNELS = 10,
	NL80211_BAND_ATTR_EDMG_BW_CONFIG = 11,
	__NL80211_BAND_ATTR_AFTER_LAST = 12,
	NL80211_BAND_ATTR_MAX = 11,
};

enum nl80211_wmm_rule {
	__NL80211_WMMR_INVALID = 0,
	NL80211_WMMR_CW_MIN = 1,
	NL80211_WMMR_CW_MAX = 2,
	NL80211_WMMR_AIFSN = 3,
	NL80211_WMMR_TXOP = 4,
	__NL80211_WMMR_LAST = 5,
	NL80211_WMMR_MAX = 4,
};

enum nl80211_frequency_attr {
	__NL80211_FREQUENCY_ATTR_INVALID = 0,
	NL80211_FREQUENCY_ATTR_FREQ = 1,
	NL80211_FREQUENCY_ATTR_DISABLED = 2,
	NL80211_FREQUENCY_ATTR_NO_IR = 3,
	__NL80211_FREQUENCY_ATTR_NO_IBSS = 4,
	NL80211_FREQUENCY_ATTR_RADAR = 5,
	NL80211_FREQUENCY_ATTR_MAX_TX_POWER = 6,
	NL80211_FREQUENCY_ATTR_DFS_STATE = 7,
	NL80211_FREQUENCY_ATTR_DFS_TIME = 8,
	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS = 9,
	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS = 10,
	NL80211_FREQUENCY_ATTR_NO_80MHZ = 11,
	NL80211_FREQUENCY_ATTR_NO_160MHZ = 12,
	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME = 13,
	NL80211_FREQUENCY_ATTR_INDOOR_ONLY = 14,
	NL80211_FREQUENCY_ATTR_IR_CONCURRENT = 15,
	NL80211_FREQUENCY_ATTR_NO_20MHZ = 16,
	NL80211_FREQUENCY_ATTR_NO_10MHZ = 17,
	NL80211_FREQUENCY_ATTR_WMM = 18,
	NL80211_FREQUENCY_ATTR_NO_HE = 19,
	NL80211_FREQUENCY_ATTR_OFFSET = 20,
	NL80211_FREQUENCY_ATTR_1MHZ = 21,
	NL80211_FREQUENCY_ATTR_2MHZ = 22,
	NL80211_FREQUENCY_ATTR_4MHZ = 23,
	NL80211_FREQUENCY_ATTR_8MHZ = 24,
	NL80211_FREQUENCY_ATTR_16MHZ = 25,
	__NL80211_FREQUENCY_ATTR_AFTER_LAST = 26,
	NL80211_FREQUENCY_ATTR_MAX = 25,
};

enum nl80211_bitrate_attr {
	__NL80211_BITRATE_ATTR_INVALID = 0,
	NL80211_BITRATE_ATTR_RATE = 1,
	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE = 2,
	__NL80211_BITRATE_ATTR_AFTER_LAST = 3,
	NL80211_BITRATE_ATTR_MAX = 2,
};

enum nl80211_reg_type {
	NL80211_REGDOM_TYPE_COUNTRY = 0,
	NL80211_REGDOM_TYPE_WORLD = 1,
	NL80211_REGDOM_TYPE_CUSTOM_WORLD = 2,
	NL80211_REGDOM_TYPE_INTERSECTION = 3,
};

enum nl80211_reg_rule_attr {
	__NL80211_REG_RULE_ATTR_INVALID = 0,
	NL80211_ATTR_REG_RULE_FLAGS = 1,
	NL80211_ATTR_FREQ_RANGE_START = 2,
	NL80211_ATTR_FREQ_RANGE_END = 3,
	NL80211_ATTR_FREQ_RANGE_MAX_BW = 4,
	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN = 5,
	NL80211_ATTR_POWER_RULE_MAX_EIRP = 6,
	NL80211_ATTR_DFS_CAC_TIME = 7,
	__NL80211_REG_RULE_ATTR_AFTER_LAST = 8,
	NL80211_REG_RULE_ATTR_MAX = 7,
};

enum nl80211_sched_scan_match_attr {
	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID = 0,
	NL80211_SCHED_SCAN_MATCH_ATTR_SSID = 1,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI = 2,
	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI = 3,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST = 4,
	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID = 5,
	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI = 6,
	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST = 7,
	NL80211_SCHED_SCAN_MATCH_ATTR_MAX = 6,
};

enum nl80211_survey_info {
	__NL80211_SURVEY_INFO_INVALID = 0,
	NL80211_SURVEY_INFO_FREQUENCY = 1,
	NL80211_SURVEY_INFO_NOISE = 2,
	NL80211_SURVEY_INFO_IN_USE = 3,
	NL80211_SURVEY_INFO_TIME = 4,
	NL80211_SURVEY_INFO_TIME_BUSY = 5,
	NL80211_SURVEY_INFO_TIME_EXT_BUSY = 6,
	NL80211_SURVEY_INFO_TIME_RX = 7,
	NL80211_SURVEY_INFO_TIME_TX = 8,
	NL80211_SURVEY_INFO_TIME_SCAN = 9,
	NL80211_SURVEY_INFO_PAD = 10,
	NL80211_SURVEY_INFO_TIME_BSS_RX = 11,
	NL80211_SURVEY_INFO_FREQUENCY_OFFSET = 12,
	__NL80211_SURVEY_INFO_AFTER_LAST = 13,
	NL80211_SURVEY_INFO_MAX = 12,
};

enum nl80211_meshconf_params {
	__NL80211_MESHCONF_INVALID = 0,
	NL80211_MESHCONF_RETRY_TIMEOUT = 1,
	NL80211_MESHCONF_CONFIRM_TIMEOUT = 2,
	NL80211_MESHCONF_HOLDING_TIMEOUT = 3,
	NL80211_MESHCONF_MAX_PEER_LINKS = 4,
	NL80211_MESHCONF_MAX_RETRIES = 5,
	NL80211_MESHCONF_TTL = 6,
	NL80211_MESHCONF_AUTO_OPEN_PLINKS = 7,
	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES = 8,
	NL80211_MESHCONF_PATH_REFRESH_TIME = 9,
	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT = 10,
	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT = 11,
	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL = 12,
	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME = 13,
	NL80211_MESHCONF_HWMP_ROOTMODE = 14,
	NL80211_MESHCONF_ELEMENT_TTL = 15,
	NL80211_MESHCONF_HWMP_RANN_INTERVAL = 16,
	NL80211_MESHCONF_GATE_ANNOUNCEMENTS = 17,
	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL = 18,
	NL80211_MESHCONF_FORWARDING = 19,
	NL80211_MESHCONF_RSSI_THRESHOLD = 20,
	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR = 21,
	NL80211_MESHCONF_HT_OPMODE = 22,
	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT = 23,
	NL80211_MESHCONF_HWMP_ROOT_INTERVAL = 24,
	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL = 25,
	NL80211_MESHCONF_POWER_MODE = 26,
	NL80211_MESHCONF_AWAKE_WINDOW = 27,
	NL80211_MESHCONF_PLINK_TIMEOUT = 28,
	NL80211_MESHCONF_CONNECTED_TO_GATE = 29,
	NL80211_MESHCONF_NOLEARN = 30,
	NL80211_MESHCONF_CONNECTED_TO_AS = 31,
	__NL80211_MESHCONF_ATTR_AFTER_LAST = 32,
	NL80211_MESHCONF_ATTR_MAX = 31,
};

enum nl80211_mesh_setup_params {
	__NL80211_MESH_SETUP_INVALID = 0,
	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL = 1,
	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC = 2,
	NL80211_MESH_SETUP_IE = 3,
	NL80211_MESH_SETUP_USERSPACE_AUTH = 4,
	NL80211_MESH_SETUP_USERSPACE_AMPE = 5,
	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC = 6,
	NL80211_MESH_SETUP_USERSPACE_MPM = 7,
	NL80211_MESH_SETUP_AUTH_PROTOCOL = 8,
	__NL80211_MESH_SETUP_ATTR_AFTER_LAST = 9,
	NL80211_MESH_SETUP_ATTR_MAX = 8,
};

enum nl80211_txq_attr {
	__NL80211_TXQ_ATTR_INVALID = 0,
	NL80211_TXQ_ATTR_AC = 1,
	NL80211_TXQ_ATTR_TXOP = 2,
	NL80211_TXQ_ATTR_CWMIN = 3,
	NL80211_TXQ_ATTR_CWMAX = 4,
	NL80211_TXQ_ATTR_AIFS = 5,
	__NL80211_TXQ_ATTR_AFTER_LAST = 6,
	NL80211_TXQ_ATTR_MAX = 5,
};

enum nl80211_bss {
	__NL80211_BSS_INVALID = 0,
	NL80211_BSS_BSSID = 1,
	NL80211_BSS_FREQUENCY = 2,
	NL80211_BSS_TSF = 3,
	NL80211_BSS_BEACON_INTERVAL = 4,
	NL80211_BSS_CAPABILITY = 5,
	NL80211_BSS_INFORMATION_ELEMENTS = 6,
	NL80211_BSS_SIGNAL_MBM = 7,
	NL80211_BSS_SIGNAL_UNSPEC = 8,
	NL80211_BSS_STATUS = 9,
	NL80211_BSS_SEEN_MS_AGO = 10,
	NL80211_BSS_BEACON_IES = 11,
	NL80211_BSS_CHAN_WIDTH = 12,
	NL80211_BSS_BEACON_TSF = 13,
	NL80211_BSS_PRESP_DATA = 14,
	NL80211_BSS_LAST_SEEN_BOOTTIME = 15,
	NL80211_BSS_PAD = 16,
	NL80211_BSS_PARENT_TSF = 17,
	NL80211_BSS_PARENT_BSSID = 18,
	NL80211_BSS_CHAIN_SIGNAL = 19,
	NL80211_BSS_FREQUENCY_OFFSET = 20,
	__NL80211_BSS_AFTER_LAST = 21,
	NL80211_BSS_MAX = 20,
};

enum nl80211_bss_status {
	NL80211_BSS_STATUS_AUTHENTICATED = 0,
	NL80211_BSS_STATUS_ASSOCIATED = 1,
	NL80211_BSS_STATUS_IBSS_JOINED = 2,
};

enum nl80211_key_type {
	NL80211_KEYTYPE_GROUP = 0,
	NL80211_KEYTYPE_PAIRWISE = 1,
	NL80211_KEYTYPE_PEERKEY = 2,
	NUM_NL80211_KEYTYPES = 3,
};

enum nl80211_wpa_versions {
	NL80211_WPA_VERSION_1 = 1,
	NL80211_WPA_VERSION_2 = 2,
	NL80211_WPA_VERSION_3 = 4,
};

enum nl80211_key_default_types {
	__NL80211_KEY_DEFAULT_TYPE_INVALID = 0,
	NL80211_KEY_DEFAULT_TYPE_UNICAST = 1,
	NL80211_KEY_DEFAULT_TYPE_MULTICAST = 2,
	NUM_NL80211_KEY_DEFAULT_TYPES = 3,
};

enum nl80211_key_attributes {
	__NL80211_KEY_INVALID = 0,
	NL80211_KEY_DATA = 1,
	NL80211_KEY_IDX = 2,
	NL80211_KEY_CIPHER = 3,
	NL80211_KEY_SEQ = 4,
	NL80211_KEY_DEFAULT = 5,
	NL80211_KEY_DEFAULT_MGMT = 6,
	NL80211_KEY_TYPE = 7,
	NL80211_KEY_DEFAULT_TYPES = 8,
	NL80211_KEY_MODE = 9,
	NL80211_KEY_DEFAULT_BEACON = 10,
	__NL80211_KEY_AFTER_LAST = 11,
	NL80211_KEY_MAX = 10,
};

enum nl80211_tx_rate_attributes {
	__NL80211_TXRATE_INVALID = 0,
	NL80211_TXRATE_LEGACY = 1,
	NL80211_TXRATE_HT = 2,
	NL80211_TXRATE_VHT = 3,
	NL80211_TXRATE_GI = 4,
	NL80211_TXRATE_HE = 5,
	NL80211_TXRATE_HE_GI = 6,
	NL80211_TXRATE_HE_LTF = 7,
	__NL80211_TXRATE_AFTER_LAST = 8,
	NL80211_TXRATE_MAX = 7,
};

struct nl80211_txrate_vht {
	__u16 mcs[8];
};

struct nl80211_txrate_he {
	__u16 mcs[8];
};

enum nl80211_ps_state {
	NL80211_PS_DISABLED = 0,
	NL80211_PS_ENABLED = 1,
};

enum nl80211_attr_cqm {
	__NL80211_ATTR_CQM_INVALID = 0,
	NL80211_ATTR_CQM_RSSI_THOLD = 1,
	NL80211_ATTR_CQM_RSSI_HYST = 2,
	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT = 3,
	NL80211_ATTR_CQM_PKT_LOSS_EVENT = 4,
	NL80211_ATTR_CQM_TXE_RATE = 5,
	NL80211_ATTR_CQM_TXE_PKTS = 6,
	NL80211_ATTR_CQM_TXE_INTVL = 7,
	NL80211_ATTR_CQM_BEACON_LOSS_EVENT = 8,
	NL80211_ATTR_CQM_RSSI_LEVEL = 9,
	__NL80211_ATTR_CQM_AFTER_LAST = 10,
	NL80211_ATTR_CQM_MAX = 9,
};

enum nl80211_cqm_rssi_threshold_event {
	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW = 0,
	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH = 1,
	NL80211_CQM_RSSI_BEACON_LOSS_EVENT = 2,
};

enum nl80211_tid_config_attr {
	__NL80211_TID_CONFIG_ATTR_INVALID = 0,
	NL80211_TID_CONFIG_ATTR_PAD = 1,
	NL80211_TID_CONFIG_ATTR_VIF_SUPP = 2,
	NL80211_TID_CONFIG_ATTR_PEER_SUPP = 3,
	NL80211_TID_CONFIG_ATTR_OVERRIDE = 4,
	NL80211_TID_CONFIG_ATTR_TIDS = 5,
	NL80211_TID_CONFIG_ATTR_NOACK = 6,
	NL80211_TID_CONFIG_ATTR_RETRY_SHORT = 7,
	NL80211_TID_CONFIG_ATTR_RETRY_LONG = 8,
	NL80211_TID_CONFIG_ATTR_AMPDU_CTRL = 9,
	NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL = 10,
	NL80211_TID_CONFIG_ATTR_AMSDU_CTRL = 11,
	NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE = 12,
	NL80211_TID_CONFIG_ATTR_TX_RATE = 13,
	__NL80211_TID_CONFIG_ATTR_AFTER_LAST = 14,
	NL80211_TID_CONFIG_ATTR_MAX = 13,
};

enum nl80211_packet_pattern_attr {
	__NL80211_PKTPAT_INVALID = 0,
	NL80211_PKTPAT_MASK = 1,
	NL80211_PKTPAT_PATTERN = 2,
	NL80211_PKTPAT_OFFSET = 3,
	NUM_NL80211_PKTPAT = 4,
	MAX_NL80211_PKTPAT = 3,
};

struct nl80211_pattern_support {
	__u32 max_patterns;
	__u32 min_pattern_len;
	__u32 max_pattern_len;
	__u32 max_pkt_offset;
};

enum nl80211_wowlan_triggers {
	__NL80211_WOWLAN_TRIG_INVALID = 0,
	NL80211_WOWLAN_TRIG_ANY = 1,
	NL80211_WOWLAN_TRIG_DISCONNECT = 2,
	NL80211_WOWLAN_TRIG_MAGIC_PKT = 3,
	NL80211_WOWLAN_TRIG_PKT_PATTERN = 4,
	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED = 5,
	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE = 6,
	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST = 7,
	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE = 8,
	NL80211_WOWLAN_TRIG_RFKILL_RELEASE = 9,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211 = 10,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN = 11,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023 = 12,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN = 13,
	NL80211_WOWLAN_TRIG_TCP_CONNECTION = 14,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH = 15,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST = 16,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS = 17,
	NL80211_WOWLAN_TRIG_NET_DETECT = 18,
	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS = 19,
	NUM_NL80211_WOWLAN_TRIG = 20,
	MAX_NL80211_WOWLAN_TRIG = 19,
};

enum nl80211_wowlan_tcp_attrs {
	__NL80211_WOWLAN_TCP_INVALID = 0,
	NL80211_WOWLAN_TCP_SRC_IPV4 = 1,
	NL80211_WOWLAN_TCP_DST_IPV4 = 2,
	NL80211_WOWLAN_TCP_DST_MAC = 3,
	NL80211_WOWLAN_TCP_SRC_PORT = 4,
	NL80211_WOWLAN_TCP_DST_PORT = 5,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD = 6,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ = 7,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN = 8,
	NL80211_WOWLAN_TCP_DATA_INTERVAL = 9,
	NL80211_WOWLAN_TCP_WAKE_PAYLOAD = 10,
	NL80211_WOWLAN_TCP_WAKE_MASK = 11,
	NUM_NL80211_WOWLAN_TCP = 12,
	MAX_NL80211_WOWLAN_TCP = 11,
};

struct nl80211_coalesce_rule_support {
	__u32 max_rules;
	struct nl80211_pattern_support pat;
	__u32 max_delay;
};

enum nl80211_attr_coalesce_rule {
	__NL80211_COALESCE_RULE_INVALID = 0,
	NL80211_ATTR_COALESCE_RULE_DELAY = 1,
	NL80211_ATTR_COALESCE_RULE_CONDITION = 2,
	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN = 3,
	NUM_NL80211_ATTR_COALESCE_RULE = 4,
	NL80211_ATTR_COALESCE_RULE_MAX = 3,
};

enum nl80211_iface_limit_attrs {
	NL80211_IFACE_LIMIT_UNSPEC = 0,
	NL80211_IFACE_LIMIT_MAX = 1,
	NL80211_IFACE_LIMIT_TYPES = 2,
	NUM_NL80211_IFACE_LIMIT = 3,
	MAX_NL80211_IFACE_LIMIT = 2,
};

enum nl80211_if_combination_attrs {
	NL80211_IFACE_COMB_UNSPEC = 0,
	NL80211_IFACE_COMB_LIMITS = 1,
	NL80211_IFACE_COMB_MAXNUM = 2,
	NL80211_IFACE_COMB_STA_AP_BI_MATCH = 3,
	NL80211_IFACE_COMB_NUM_CHANNELS = 4,
	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS = 5,
	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS = 6,
	NL80211_IFACE_COMB_BI_MIN_GCD = 7,
	NUM_NL80211_IFACE_COMB = 8,
	MAX_NL80211_IFACE_COMB = 7,
};

enum nl80211_plink_state {
	NL80211_PLINK_LISTEN = 0,
	NL80211_PLINK_OPN_SNT = 1,
	NL80211_PLINK_OPN_RCVD = 2,
	NL80211_PLINK_CNF_RCVD = 3,
	NL80211_PLINK_ESTAB = 4,
	NL80211_PLINK_HOLDING = 5,
	NL80211_PLINK_BLOCKED = 6,
	NUM_NL80211_PLINK_STATES = 7,
	MAX_NL80211_PLINK_STATES = 6,
};

enum plink_actions {
	NL80211_PLINK_ACTION_NO_ACTION = 0,
	NL80211_PLINK_ACTION_OPEN = 1,
	NL80211_PLINK_ACTION_BLOCK = 2,
	NUM_NL80211_PLINK_ACTIONS = 3,
};

enum nl80211_rekey_data {
	__NL80211_REKEY_DATA_INVALID = 0,
	NL80211_REKEY_DATA_KEK = 1,
	NL80211_REKEY_DATA_KCK = 2,
	NL80211_REKEY_DATA_REPLAY_CTR = 3,
	NL80211_REKEY_DATA_AKM = 4,
	NUM_NL80211_REKEY_DATA = 5,
	MAX_NL80211_REKEY_DATA = 4,
};

enum nl80211_sta_wme_attr {
	__NL80211_STA_WME_INVALID = 0,
	NL80211_STA_WME_UAPSD_QUEUES = 1,
	NL80211_STA_WME_MAX_SP = 2,
	__NL80211_STA_WME_AFTER_LAST = 3,
	NL80211_STA_WME_MAX = 2,
};

enum nl80211_pmksa_candidate_attr {
	__NL80211_PMKSA_CANDIDATE_INVALID = 0,
	NL80211_PMKSA_CANDIDATE_INDEX = 1,
	NL80211_PMKSA_CANDIDATE_BSSID = 2,
	NL80211_PMKSA_CANDIDATE_PREAUTH = 3,
	NUM_NL80211_PMKSA_CANDIDATE = 4,
	MAX_NL80211_PMKSA_CANDIDATE = 3,
};

enum nl80211_connect_failed_reason {
	NL80211_CONN_FAIL_MAX_CLIENTS = 0,
	NL80211_CONN_FAIL_BLOCKED_CLIENT = 1,
};

enum nl80211_protocol_features {
	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP = 1,
};

enum nl80211_sched_scan_plan {
	__NL80211_SCHED_SCAN_PLAN_INVALID = 0,
	NL80211_SCHED_SCAN_PLAN_INTERVAL = 1,
	NL80211_SCHED_SCAN_PLAN_ITERATIONS = 2,
	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST = 3,
	NL80211_SCHED_SCAN_PLAN_MAX = 2,
};

struct nl80211_bss_select_rssi_adjust {
	__u8 band;
	__s8 delta;
};

enum nl80211_nan_publish_type {
	NL80211_NAN_SOLICITED_PUBLISH = 1,
	NL80211_NAN_UNSOLICITED_PUBLISH = 2,
};

enum nl80211_nan_func_term_reason {
	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST = 0,
	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED = 1,
	NL80211_NAN_FUNC_TERM_REASON_ERROR = 2,
};

enum nl80211_nan_func_attributes {
	__NL80211_NAN_FUNC_INVALID = 0,
	NL80211_NAN_FUNC_TYPE = 1,
	NL80211_NAN_FUNC_SERVICE_ID = 2,
	NL80211_NAN_FUNC_PUBLISH_TYPE = 3,
	NL80211_NAN_FUNC_PUBLISH_BCAST = 4,
	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE = 5,
	NL80211_NAN_FUNC_FOLLOW_UP_ID = 6,
	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID = 7,
	NL80211_NAN_FUNC_FOLLOW_UP_DEST = 8,
	NL80211_NAN_FUNC_CLOSE_RANGE = 9,
	NL80211_NAN_FUNC_TTL = 10,
	NL80211_NAN_FUNC_SERVICE_INFO = 11,
	NL80211_NAN_FUNC_SRF = 12,
	NL80211_NAN_FUNC_RX_MATCH_FILTER = 13,
	NL80211_NAN_FUNC_TX_MATCH_FILTER = 14,
	NL80211_NAN_FUNC_INSTANCE_ID = 15,
	NL80211_NAN_FUNC_TERM_REASON = 16,
	NUM_NL80211_NAN_FUNC_ATTR = 17,
	NL80211_NAN_FUNC_ATTR_MAX = 16,
};

enum nl80211_nan_srf_attributes {
	__NL80211_NAN_SRF_INVALID = 0,
	NL80211_NAN_SRF_INCLUDE = 1,
	NL80211_NAN_SRF_BF = 2,
	NL80211_NAN_SRF_BF_IDX = 3,
	NL80211_NAN_SRF_MAC_ADDRS = 4,
	NUM_NL80211_NAN_SRF_ATTR = 5,
	NL80211_NAN_SRF_ATTR_MAX = 4,
};

enum nl80211_nan_match_attributes {
	__NL80211_NAN_MATCH_INVALID = 0,
	NL80211_NAN_MATCH_FUNC_LOCAL = 1,
	NL80211_NAN_MATCH_FUNC_PEER = 2,
	NUM_NL80211_NAN_MATCH_ATTR = 3,
	NL80211_NAN_MATCH_ATTR_MAX = 2,
};

enum nl80211_ftm_responder_attributes {
	__NL80211_FTM_RESP_ATTR_INVALID = 0,
	NL80211_FTM_RESP_ATTR_ENABLED = 1,
	NL80211_FTM_RESP_ATTR_LCI = 2,
	NL80211_FTM_RESP_ATTR_CIVICLOC = 3,
	__NL80211_FTM_RESP_ATTR_LAST = 4,
	NL80211_FTM_RESP_ATTR_MAX = 3,
};

enum nl80211_ftm_responder_stats {
	__NL80211_FTM_STATS_INVALID = 0,
	NL80211_FTM_STATS_SUCCESS_NUM = 1,
	NL80211_FTM_STATS_PARTIAL_NUM = 2,
	NL80211_FTM_STATS_FAILED_NUM = 3,
	NL80211_FTM_STATS_ASAP_NUM = 4,
	NL80211_FTM_STATS_NON_ASAP_NUM = 5,
	NL80211_FTM_STATS_TOTAL_DURATION_MSEC = 6,
	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM = 7,
	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM = 8,
	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM = 9,
	NL80211_FTM_STATS_PAD = 10,
	__NL80211_FTM_STATS_AFTER_LAST = 11,
	NL80211_FTM_STATS_MAX = 10,
};

enum nl80211_peer_measurement_type {
	NL80211_PMSR_TYPE_INVALID = 0,
	NL80211_PMSR_TYPE_FTM = 1,
	NUM_NL80211_PMSR_TYPES = 2,
	NL80211_PMSR_TYPE_MAX = 1,
};

enum nl80211_peer_measurement_req {
	__NL80211_PMSR_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_REQ_ATTR_DATA = 1,
	NL80211_PMSR_REQ_ATTR_GET_AP_TSF = 2,
	NUM_NL80211_PMSR_REQ_ATTRS = 3,
	NL80211_PMSR_REQ_ATTR_MAX = 2,
};

enum nl80211_peer_measurement_peer_attrs {
	__NL80211_PMSR_PEER_ATTR_INVALID = 0,
	NL80211_PMSR_PEER_ATTR_ADDR = 1,
	NL80211_PMSR_PEER_ATTR_CHAN = 2,
	NL80211_PMSR_PEER_ATTR_REQ = 3,
	NL80211_PMSR_PEER_ATTR_RESP = 4,
	NUM_NL80211_PMSR_PEER_ATTRS = 5,
	NL80211_PMSR_PEER_ATTR_MAX = 4,
};

enum nl80211_peer_measurement_attrs {
	__NL80211_PMSR_ATTR_INVALID = 0,
	NL80211_PMSR_ATTR_MAX_PEERS = 1,
	NL80211_PMSR_ATTR_REPORT_AP_TSF = 2,
	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR = 3,
	NL80211_PMSR_ATTR_TYPE_CAPA = 4,
	NL80211_PMSR_ATTR_PEERS = 5,
	NUM_NL80211_PMSR_ATTR = 6,
	NL80211_PMSR_ATTR_MAX = 5,
};

enum nl80211_peer_measurement_ftm_capa {
	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_CAPA_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP = 2,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI = 3,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC = 4,
	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES = 5,
	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS = 6,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT = 7,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED = 9,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED = 10,
	NUM_NL80211_PMSR_FTM_CAPA_ATTR = 11,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX = 10,
};

enum nl80211_peer_measurement_ftm_req {
	__NL80211_PMSR_FTM_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_REQ_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE = 2,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP = 3,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD = 4,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION = 5,
	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST = 6,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES = 7,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI = 8,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC = 9,
	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED = 10,
	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED = 11,
	NUM_NL80211_PMSR_FTM_REQ_ATTR = 12,
	NL80211_PMSR_FTM_REQ_ATTR_MAX = 11,
};

enum nl80211_obss_pd_attributes {
	__NL80211_HE_OBSS_PD_ATTR_INVALID = 0,
	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET = 1,
	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET = 2,
	NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET = 3,
	NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP = 4,
	NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP = 5,
	NL80211_HE_OBSS_PD_ATTR_SR_CTRL = 6,
	__NL80211_HE_OBSS_PD_ATTR_LAST = 7,
	NL80211_HE_OBSS_PD_ATTR_MAX = 6,
};

enum nl80211_bss_color_attributes {
	__NL80211_HE_BSS_COLOR_ATTR_INVALID = 0,
	NL80211_HE_BSS_COLOR_ATTR_COLOR = 1,
	NL80211_HE_BSS_COLOR_ATTR_DISABLED = 2,
	NL80211_HE_BSS_COLOR_ATTR_PARTIAL = 3,
	__NL80211_HE_BSS_COLOR_ATTR_LAST = 4,
	NL80211_HE_BSS_COLOR_ATTR_MAX = 3,
};

enum nl80211_iftype_akm_attributes {
	__NL80211_IFTYPE_AKM_ATTR_INVALID = 0,
	NL80211_IFTYPE_AKM_ATTR_IFTYPES = 1,
	NL80211_IFTYPE_AKM_ATTR_SUITES = 2,
	__NL80211_IFTYPE_AKM_ATTR_LAST = 3,
	NL80211_IFTYPE_AKM_ATTR_MAX = 2,
};

enum nl80211_fils_discovery_attributes {
	__NL80211_FILS_DISCOVERY_ATTR_INVALID = 0,
	NL80211_FILS_DISCOVERY_ATTR_INT_MIN = 1,
	NL80211_FILS_DISCOVERY_ATTR_INT_MAX = 2,
	NL80211_FILS_DISCOVERY_ATTR_TMPL = 3,
	__NL80211_FILS_DISCOVERY_ATTR_LAST = 4,
	NL80211_FILS_DISCOVERY_ATTR_MAX = 3,
};

enum nl80211_unsol_bcast_probe_resp_attributes {
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID = 0,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT = 1,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL = 2,
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST = 3,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX = 2,
};

enum survey_info_flags {
	SURVEY_INFO_NOISE_DBM = 1,
	SURVEY_INFO_IN_USE = 2,
	SURVEY_INFO_TIME = 4,
	SURVEY_INFO_TIME_BUSY = 8,
	SURVEY_INFO_TIME_EXT_BUSY = 16,
	SURVEY_INFO_TIME_RX = 32,
	SURVEY_INFO_TIME_TX = 64,
	SURVEY_INFO_TIME_SCAN = 128,
	SURVEY_INFO_TIME_BSS_RX = 256,
};

enum cfg80211_ap_settings_flags {
	AP_SETTINGS_EXTERNAL_AUTH_SUPPORT = 1,
};

enum station_parameters_apply_mask {
	STATION_PARAM_APPLY_UAPSD = 1,
	STATION_PARAM_APPLY_CAPABILITY = 2,
	STATION_PARAM_APPLY_PLINK_STATE = 4,
	STATION_PARAM_APPLY_STA_TXPOWER = 8,
};

enum cfg80211_station_type {
	CFG80211_STA_AP_CLIENT = 0,
	CFG80211_STA_AP_CLIENT_UNASSOC = 1,
	CFG80211_STA_AP_MLME_CLIENT = 2,
	CFG80211_STA_AP_STA = 3,
	CFG80211_STA_IBSS = 4,
	CFG80211_STA_TDLS_PEER_SETUP = 5,
	CFG80211_STA_TDLS_PEER_ACTIVE = 6,
	CFG80211_STA_MESH_PEER_KERNEL = 7,
	CFG80211_STA_MESH_PEER_USER = 8,
};

enum bss_param_flags {
	BSS_PARAM_FLAGS_CTS_PROT = 1,
	BSS_PARAM_FLAGS_SHORT_PREAMBLE = 2,
	BSS_PARAM_FLAGS_SHORT_SLOT_TIME = 4,
};

enum monitor_flags {
	MONITOR_FLAG_CHANGED = 1,
	MONITOR_FLAG_FCSFAIL = 2,
	MONITOR_FLAG_PLCPFAIL = 4,
	MONITOR_FLAG_CONTROL = 8,
	MONITOR_FLAG_OTHER_BSS = 16,
	MONITOR_FLAG_COOK_FRAMES = 32,
	MONITOR_FLAG_ACTIVE = 64,
};

enum mpath_info_flags {
	MPATH_INFO_FRAME_QLEN = 1,
	MPATH_INFO_SN = 2,
	MPATH_INFO_METRIC = 4,
	MPATH_INFO_EXPTIME = 8,
	MPATH_INFO_DISCOVERY_TIMEOUT = 16,
	MPATH_INFO_DISCOVERY_RETRIES = 32,
	MPATH_INFO_FLAGS = 64,
	MPATH_INFO_HOP_COUNT = 128,
	MPATH_INFO_PATH_CHANGE = 256,
};

enum cfg80211_assoc_req_flags {
	ASSOC_REQ_DISABLE_HT = 1,
	ASSOC_REQ_DISABLE_VHT = 2,
	ASSOC_REQ_USE_RRM = 4,
	CONNECT_REQ_EXTERNAL_AUTH_SUPPORT = 8,
};

enum cfg80211_connect_params_changed {
	UPDATE_ASSOC_IES = 1,
	UPDATE_FILS_ERP_INFO = 2,
	UPDATE_AUTH_TYPE = 4,
};

enum wiphy_params_flags {
	WIPHY_PARAM_RETRY_SHORT = 1,
	WIPHY_PARAM_RETRY_LONG = 2,
	WIPHY_PARAM_FRAG_THRESHOLD = 4,
	WIPHY_PARAM_RTS_THRESHOLD = 8,
	WIPHY_PARAM_COVERAGE_CLASS = 16,
	WIPHY_PARAM_DYN_ACK = 32,
	WIPHY_PARAM_TXQ_LIMIT = 64,
	WIPHY_PARAM_TXQ_MEMORY_LIMIT = 128,
	WIPHY_PARAM_TXQ_QUANTUM = 256,
};

struct cfg80211_wowlan_nd_match {
	struct cfg80211_ssid ssid;
	int n_channels;
	u32 channels[0];
};

struct cfg80211_wowlan_nd_info {
	int n_matches;
	struct cfg80211_wowlan_nd_match *matches[0];
};

struct cfg80211_wowlan_wakeup {
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool packet_80211;
	bool tcp_match;
	bool tcp_connlost;
	bool tcp_nomoretokens;
	s32 pattern_idx;
	u32 packet_present_len;
	u32 packet_len;
	const void *packet;
	struct cfg80211_wowlan_nd_info *net_detect;
};

enum cfg80211_nan_conf_changes {
	CFG80211_NAN_CONF_CHANGED_PREF = 1,
	CFG80211_NAN_CONF_CHANGED_BANDS = 2,
};

enum wiphy_vendor_command_flags {
	WIPHY_VENDOR_CMD_NEED_WDEV = 1,
	WIPHY_VENDOR_CMD_NEED_NETDEV = 2,
	WIPHY_VENDOR_CMD_NEED_RUNNING = 4,
};

enum wiphy_opmode_flag {
	STA_OPMODE_MAX_BW_CHANGED = 1,
	STA_OPMODE_SMPS_MODE_CHANGED = 2,
	STA_OPMODE_N_SS_CHANGED = 4,
};

struct sta_opmode_info {
	u32 changed;
	enum nl80211_smps_mode smps_mode;
	enum nl80211_chan_width bw;
	u8 rx_nss;
};

struct cfg80211_ft_event_params {
	const u8 *ies;
	size_t ies_len;
	const u8 *target_ap;
	const u8 *ric_ies;
	size_t ric_ies_len;
};

struct cfg80211_nan_match_params {
	enum nl80211_nan_function_type type;
	u8 inst_id;
	u8 peer_inst_id;
	const u8 *addr;
	u8 info_len;
	const u8 *info;
	u64 cookie;
};

enum nl80211_multicast_groups {
	NL80211_MCGRP_CONFIG = 0,
	NL80211_MCGRP_SCAN = 1,
	NL80211_MCGRP_REGULATORY = 2,
	NL80211_MCGRP_MLME = 3,
	NL80211_MCGRP_VENDOR = 4,
	NL80211_MCGRP_NAN = 5,
	NL80211_MCGRP_TESTMODE = 6,
};

struct key_parse {
	struct key_params p;
	int idx;
	int type;
	bool def;
	bool defmgmt;
	bool defbeacon;
	bool def_uni;
	bool def_multi;
};

struct nl80211_dump_wiphy_state {
	s64 filter_wiphy;
	long int start;
	long int split_start;
	long int band_start;
	long int chan_start;
	long int capa_start;
	bool split;
};

struct get_key_cookie {
	struct sk_buff *msg;
	int error;
	int idx;
};

enum ieee80211_category {
	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	WLAN_CATEGORY_QOS = 1,
	WLAN_CATEGORY_DLS = 2,
	WLAN_CATEGORY_BACK = 3,
	WLAN_CATEGORY_PUBLIC = 4,
	WLAN_CATEGORY_RADIO_MEASUREMENT = 5,
	WLAN_CATEGORY_HT = 7,
	WLAN_CATEGORY_SA_QUERY = 8,
	WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION = 9,
	WLAN_CATEGORY_WNM = 10,
	WLAN_CATEGORY_WNM_UNPROTECTED = 11,
	WLAN_CATEGORY_TDLS = 12,
	WLAN_CATEGORY_MESH_ACTION = 13,
	WLAN_CATEGORY_MULTIHOP_ACTION = 14,
	WLAN_CATEGORY_SELF_PROTECTED = 15,
	WLAN_CATEGORY_DMG = 16,
	WLAN_CATEGORY_WMM = 17,
	WLAN_CATEGORY_FST = 18,
	WLAN_CATEGORY_UNPROT_DMG = 20,
	WLAN_CATEGORY_VHT = 21,
	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
};

struct cfg80211_mgmt_registration {
	struct list_head list;
	struct wireless_dev *wdev;
	u32 nlportid;
	int match_len;
	__le16 frame_type;
	bool multicast_rx;
	u8 match[0];
};

struct cfg80211_conn {
	struct cfg80211_connect_params params;
	enum {
		CFG80211_CONN_SCANNING = 0,
		CFG80211_CONN_SCAN_AGAIN = 1,
		CFG80211_CONN_AUTHENTICATE_NEXT = 2,
		CFG80211_CONN_AUTHENTICATING = 3,
		CFG80211_CONN_AUTH_FAILED_TIMEOUT = 4,
		CFG80211_CONN_ASSOCIATE_NEXT = 5,
		CFG80211_CONN_ASSOCIATING = 6,
		CFG80211_CONN_ASSOC_FAILED = 7,
		CFG80211_CONN_ASSOC_FAILED_TIMEOUT = 8,
		CFG80211_CONN_DEAUTH = 9,
		CFG80211_CONN_ABANDON = 10,
		CFG80211_CONN_CONNECTED = 11,
	} state;
	u8 bssid[6];
	u8 prev_bssid[6];
	const u8 *ie;
	size_t ie_len;
	bool auto_auth;
	bool prev_bssid_valid;
};

enum cfg80211_chan_mode {
	CHAN_MODE_UNDEFINED = 0,
	CHAN_MODE_SHARED = 1,
	CHAN_MODE_EXCLUSIVE = 2,
};

struct trace_event_raw_rdev_suspend {
	struct trace_entry ent;
	char wiphy_name[32];
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool valid_wow;
	char __data[0];
};

struct trace_event_raw_rdev_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_scan {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_enabled_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_add_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 __data_loc_vir_intf_name;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_cookie_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_change_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_key_handle {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	u8 key_index;
	bool pairwise;
	char __data[0];
};

struct trace_event_raw_rdev_add_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	u8 key_index;
	bool pairwise;
	u8 mode;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	bool unicast;
	bool multicast;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_mgmt_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_beacon_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	int beacon_interval;
	int dtim_period;
	char ssid[33];
	enum nl80211_hidden_ssid hidden_ssid;
	u32 wpa_ver;
	bool privacy;
	enum nl80211_auth_type auth_type;
	int inactivity_timeout;
	char __data[0];
};

struct trace_event_raw_rdev_change_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_head;
	u32 __data_loc_tail;
	u32 __data_loc_beacon_ies;
	u32 __data_loc_proberesp_ies;
	u32 __data_loc_assocresp_ies;
	u32 __data_loc_probe_resp;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_station_add_change {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 capability;
	u16 aid;
	u8 plink_action;
	u8 plink_state;
	u8 uapsd_queues;
	u8 max_sp;
	u8 opmode_notif;
	bool opmode_notif_used;
	u8 ht_capa[26];
	u8 vht_capa[12];
	char vlan[16];
	u32 __data_loc_supported_rates;
	u32 __data_loc_ext_capab;
	u32 __data_loc_supported_channels;
	u32 __data_loc_supported_oper_classes;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_mac_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	char __data[0];
};

struct trace_event_raw_station_del {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u8 subtype;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_dump_station {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_station_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_mpath_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpath {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_get_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mpath_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_update_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	u32 mask;
	char __data[0];
};

struct trace_event_raw_rdev_join_mesh {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	char __data[0];
};

struct trace_event_raw_rdev_change_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	int ap_isolate;
	int ht_opmode;
	char __data[0];
};

struct trace_event_raw_rdev_set_txq_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
	char __data[0];
};

struct trace_event_raw_rdev_libertas_set_mesh_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_rdev_set_monitor_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_auth_type auth_type;
	char __data[0];
};

struct trace_event_raw_rdev_assoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 prev_bssid[6];
	bool use_mfp;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_rdev_deauth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_disassoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	bool local_state_change;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx_cancel_wait {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_set_power_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	int timeout;
	char __data[0];
};

struct trace_event_raw_rdev_connect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	enum nl80211_auth_type auth_type;
	bool privacy;
	u32 wpa_versions;
	u32 flags;
	u8 prev_bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_update_connect_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_thold;
	u32 rssi_hyst;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_range_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_low;
	s32 rssi_high;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_txe_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 rate;
	u32 pkts;
	u32 intvl;
	char __data[0];
};

struct trace_event_raw_rdev_disconnect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	char __data[0];
};

struct trace_event_raw_rdev_join_ocb {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_rdev_set_wiphy_params {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_set_tx_power {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_tx_power_setting type;
	int mbm;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int func_ret;
	int func_fill;
	char __data[0];
};

struct trace_event_raw_rdev_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_update_mgmt_frame_registrations {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 global_stypes;
	u16 interface_stypes;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_rdev_return_void_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_tx_rx_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u64 id;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 action_code;
	u8 dialog_token;
	u16 status_code;
	u32 peer_capability;
	bool initiator;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_rdev_dump_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_survey_info {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	int ret;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u32 filled;
	s8 noise;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_oper {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	char __data[0];
};

struct trace_event_raw_rdev_pmksa {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_probe_client {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_cookie {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_cancel_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	bool offchan;
	unsigned int wait;
	bool no_cck;
	bool dont_wait_for_ack;
	char __data[0];
};

struct trace_event_raw_rdev_tx_control_port {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	__be16 proto;
	bool unencrypted;
	char __data[0];
};

struct trace_event_raw_rdev_set_noack_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 noack_map;
	char __data[0];
};

struct trace_event_raw_rdev_return_chandef {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_rdev_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_rdev_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 func_type;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_set_mac_acl {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 acl_policy;
	char __data[0];
};

struct trace_event_raw_rdev_update_ft_ies {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 md;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_start {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 proto;
	u16 duration;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_stop {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_rdev_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	bool radar_required;
	bool block_tx;
	u8 count;
	u32 __data_loc_bcn_ofs;
	u32 __data_loc_pres_ofs;
	char __data[0];
};

struct trace_event_raw_rdev_set_qos_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 num_des;
	u8 dscp_exception[42];
	u8 up[16];
	char __data[0];
};

struct trace_event_raw_rdev_set_ap_chanwidth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_add_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	u8 user_prio;
	u16 admitted_time;
	char __data[0];
};

struct trace_event_raw_rdev_del_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	u8 oper_class;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	u8 pmk_len;
	u8 pmk_r0_name_len;
	u32 __data_loc_pmk;
	u32 __data_loc_pmk_r0_name;
	char __data[0];
};

struct trace_event_raw_rdev_del_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	char __data[0];
};

struct trace_event_raw_rdev_external_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 ssid[33];
	u16 status;
	char __data[0];
};

struct trace_event_raw_rdev_start_radar_detection {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 cac_time_ms;
	char __data[0];
};

struct trace_event_raw_rdev_set_mcast_rate {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int mcast_rate[5];
	char __data[0];
};

struct trace_event_raw_rdev_set_coalesce {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_rules;
	char __data[0];
};

struct trace_event_raw_rdev_set_multicast_to_unicast {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u64 timestamp;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 duration;
	u32 unknown_triggers;
	u32 reschedule;
	u32 out_of_window;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_bool {
	struct trace_entry ent;
	bool ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 macaddr[6];
	char __data[0];
};

struct trace_event_raw_netdev_evt_only {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_cfg80211_send_rx_assoc {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_netdev_frame_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mlme_mgmt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	char __data[0];
};

struct trace_event_raw_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_michael_mic_failure {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	enum nl80211_key_type key_type;
	int key_id;
	u8 tsc[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel_expired {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mgmt_expired {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_new_sta {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_mgmt {
	struct trace_entry ent;
	u32 id;
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_mgmt_tx_status {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	bool ack;
	char __data[0];
};

struct trace_event_raw_cfg80211_control_port_tx_status {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	bool ack;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_control_port {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int len;
	u8 from[6];
	u16 proto;
	bool unencrypted;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_rssi_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_cqm_rssi_threshold_event rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_cfg80211_reg_can_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	enum nl80211_iftype iftype;
	bool check_no_ir;
	char __data[0];
};

struct trace_event_raw_cfg80211_chandef_dfs_required {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_started_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_radar_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_cac_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_radar_event evt;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_ibss_joined {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_probe_status {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	u64 cookie;
	bool acked;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_pktloss_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 num_packets;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmksa_candidate_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int index;
	u8 bssid[6];
	bool preauth;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_obss_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_tdls_oper_request {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_cfg80211_scan_done {
	struct trace_entry ent;
	u32 n_channels;
	u32 __data_loc_ie;
	u32 rates[5];
	u32 wdev_id;
	u8 wiphy_mac[6];
	bool no_cck;
	bool aborted;
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	char __data[0];
};

struct trace_event_raw_wiphy_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_get_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u8 bssid[6];
	u32 __data_loc_ssid;
	enum ieee80211_bss_type bss_type;
	enum ieee80211_privacy privacy;
	char __data[0];
};

struct trace_event_raw_cfg80211_inform_bss_frame {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	enum nl80211_bss_scan_width scan_width;
	u32 __data_loc_mgmt;
	s32 signal;
	u64 ts_boottime;
	u64 parent_tsf;
	u8 parent_bssid[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_bss_evt {
	struct trace_entry ent;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_uint {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_u32 {
	struct trace_entry ent;
	u32 ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_wowlan_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	bool non_wireless;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	s32 pattern_idx;
	u32 packet_len;
	u32 __data_loc_packet;
	char __data[0];
};

struct trace_event_raw_cfg80211_ft_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_ies;
	u8 target_ap[6];
	u32 __data_loc_ric_ies;
	char __data[0];
};

struct trace_event_raw_cfg80211_stop_iface {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_report {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_update_owe_info {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u16 status;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_cfg80211_update_owe_info_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_probe_mesh_link {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_reset_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tids;
	char __data[0];
};

struct trace_event_data_offsets_rdev_suspend {};

struct trace_event_data_offsets_rdev_return_int {};

struct trace_event_data_offsets_rdev_scan {};

struct trace_event_data_offsets_wiphy_only_evt {};

struct trace_event_data_offsets_wiphy_enabled_evt {};

struct trace_event_data_offsets_rdev_add_virtual_intf {
	u32 vir_intf_name;
};

struct trace_event_data_offsets_wiphy_wdev_evt {};

struct trace_event_data_offsets_wiphy_wdev_cookie_evt {};

struct trace_event_data_offsets_rdev_change_virtual_intf {};

struct trace_event_data_offsets_key_handle {};

struct trace_event_data_offsets_rdev_add_key {};

struct trace_event_data_offsets_rdev_set_default_key {};

struct trace_event_data_offsets_rdev_set_default_mgmt_key {};

struct trace_event_data_offsets_rdev_set_default_beacon_key {};

struct trace_event_data_offsets_rdev_start_ap {};

struct trace_event_data_offsets_rdev_change_beacon {
	u32 head;
	u32 tail;
	u32 beacon_ies;
	u32 proberesp_ies;
	u32 assocresp_ies;
	u32 probe_resp;
};

struct trace_event_data_offsets_wiphy_netdev_evt {};

struct trace_event_data_offsets_station_add_change {
	u32 supported_rates;
	u32 ext_capab;
	u32 supported_channels;
	u32 supported_oper_classes;
};

struct trace_event_data_offsets_wiphy_netdev_mac_evt {};

struct trace_event_data_offsets_station_del {};

struct trace_event_data_offsets_rdev_dump_station {};

struct trace_event_data_offsets_rdev_return_int_station_info {};

struct trace_event_data_offsets_mpath_evt {};

struct trace_event_data_offsets_rdev_dump_mpath {};

struct trace_event_data_offsets_rdev_get_mpp {};

struct trace_event_data_offsets_rdev_dump_mpp {};

struct trace_event_data_offsets_rdev_return_int_mpath_info {};

struct trace_event_data_offsets_rdev_return_int_mesh_config {};

struct trace_event_data_offsets_rdev_update_mesh_config {};

struct trace_event_data_offsets_rdev_join_mesh {};

struct trace_event_data_offsets_rdev_change_bss {};

struct trace_event_data_offsets_rdev_set_txq_params {};

struct trace_event_data_offsets_rdev_libertas_set_mesh_channel {};

struct trace_event_data_offsets_rdev_set_monitor_channel {};

struct trace_event_data_offsets_rdev_auth {};

struct trace_event_data_offsets_rdev_assoc {};

struct trace_event_data_offsets_rdev_deauth {};

struct trace_event_data_offsets_rdev_disassoc {};

struct trace_event_data_offsets_rdev_mgmt_tx_cancel_wait {};

struct trace_event_data_offsets_rdev_set_power_mgmt {};

struct trace_event_data_offsets_rdev_connect {};

struct trace_event_data_offsets_rdev_update_connect_params {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_config {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_range_config {};

struct trace_event_data_offsets_rdev_set_cqm_txe_config {};

struct trace_event_data_offsets_rdev_disconnect {};

struct trace_event_data_offsets_rdev_join_ibss {};

struct trace_event_data_offsets_rdev_join_ocb {};

struct trace_event_data_offsets_rdev_set_wiphy_params {};

struct trace_event_data_offsets_rdev_set_tx_power {};

struct trace_event_data_offsets_rdev_return_int_int {};

struct trace_event_data_offsets_rdev_set_bitrate_mask {};

struct trace_event_data_offsets_rdev_update_mgmt_frame_registrations {};

struct trace_event_data_offsets_rdev_return_int_tx_rx {};

struct trace_event_data_offsets_rdev_return_void_tx_rx {};

struct trace_event_data_offsets_tx_rx_evt {};

struct trace_event_data_offsets_wiphy_netdev_id_evt {};

struct trace_event_data_offsets_rdev_tdls_mgmt {
	u32 buf;
};

struct trace_event_data_offsets_rdev_dump_survey {};

struct trace_event_data_offsets_rdev_return_int_survey_info {};

struct trace_event_data_offsets_rdev_tdls_oper {};

struct trace_event_data_offsets_rdev_pmksa {};

struct trace_event_data_offsets_rdev_probe_client {};

struct trace_event_data_offsets_rdev_remain_on_channel {};

struct trace_event_data_offsets_rdev_return_int_cookie {};

struct trace_event_data_offsets_rdev_cancel_remain_on_channel {};

struct trace_event_data_offsets_rdev_mgmt_tx {};

struct trace_event_data_offsets_rdev_tx_control_port {};

struct trace_event_data_offsets_rdev_set_noack_map {};

struct trace_event_data_offsets_rdev_return_chandef {};

struct trace_event_data_offsets_rdev_start_nan {};

struct trace_event_data_offsets_rdev_nan_change_conf {};

struct trace_event_data_offsets_rdev_add_nan_func {};

struct trace_event_data_offsets_rdev_del_nan_func {};

struct trace_event_data_offsets_rdev_set_mac_acl {};

struct trace_event_data_offsets_rdev_update_ft_ies {
	u32 ie;
};

struct trace_event_data_offsets_rdev_crit_proto_start {};

struct trace_event_data_offsets_rdev_crit_proto_stop {};

struct trace_event_data_offsets_rdev_channel_switch {
	u32 bcn_ofs;
	u32 pres_ofs;
};

struct trace_event_data_offsets_rdev_set_qos_map {};

struct trace_event_data_offsets_rdev_set_ap_chanwidth {};

struct trace_event_data_offsets_rdev_add_tx_ts {};

struct trace_event_data_offsets_rdev_del_tx_ts {};

struct trace_event_data_offsets_rdev_tdls_channel_switch {};

struct trace_event_data_offsets_rdev_tdls_cancel_channel_switch {};

struct trace_event_data_offsets_rdev_set_pmk {
	u32 pmk;
	u32 pmk_r0_name;
};

struct trace_event_data_offsets_rdev_del_pmk {};

struct trace_event_data_offsets_rdev_external_auth {};

struct trace_event_data_offsets_rdev_start_radar_detection {};

struct trace_event_data_offsets_rdev_set_mcast_rate {};

struct trace_event_data_offsets_rdev_set_coalesce {};

struct trace_event_data_offsets_rdev_set_multicast_to_unicast {};

struct trace_event_data_offsets_rdev_get_ftm_responder_stats {};

struct trace_event_data_offsets_cfg80211_return_bool {};

struct trace_event_data_offsets_cfg80211_netdev_mac_evt {};

struct trace_event_data_offsets_netdev_evt_only {};

struct trace_event_data_offsets_cfg80211_send_rx_assoc {};

struct trace_event_data_offsets_netdev_frame_event {
	u32 frame;
};

struct trace_event_data_offsets_cfg80211_tx_mlme_mgmt {
	u32 frame;
};

struct trace_event_data_offsets_netdev_mac_evt {};

struct trace_event_data_offsets_cfg80211_michael_mic_failure {};

struct trace_event_data_offsets_cfg80211_ready_on_channel {};

struct trace_event_data_offsets_cfg80211_ready_on_channel_expired {};

struct trace_event_data_offsets_cfg80211_tx_mgmt_expired {};

struct trace_event_data_offsets_cfg80211_new_sta {};

struct trace_event_data_offsets_cfg80211_rx_mgmt {};

struct trace_event_data_offsets_cfg80211_mgmt_tx_status {};

struct trace_event_data_offsets_cfg80211_control_port_tx_status {};

struct trace_event_data_offsets_cfg80211_rx_control_port {};

struct trace_event_data_offsets_cfg80211_cqm_rssi_notify {};

struct trace_event_data_offsets_cfg80211_reg_can_beacon {};

struct trace_event_data_offsets_cfg80211_chandef_dfs_required {};

struct trace_event_data_offsets_cfg80211_ch_switch_notify {};

struct trace_event_data_offsets_cfg80211_ch_switch_started_notify {};

struct trace_event_data_offsets_cfg80211_radar_event {};

struct trace_event_data_offsets_cfg80211_cac_event {};

struct trace_event_data_offsets_cfg80211_rx_evt {};

struct trace_event_data_offsets_cfg80211_ibss_joined {};

struct trace_event_data_offsets_cfg80211_probe_status {};

struct trace_event_data_offsets_cfg80211_cqm_pktloss_notify {};

struct trace_event_data_offsets_cfg80211_pmksa_candidate_notify {};

struct trace_event_data_offsets_cfg80211_report_obss_beacon {};

struct trace_event_data_offsets_cfg80211_tdls_oper_request {};

struct trace_event_data_offsets_cfg80211_scan_done {
	u32 ie;
};

struct trace_event_data_offsets_wiphy_id_evt {};

struct trace_event_data_offsets_cfg80211_get_bss {
	u32 ssid;
};

struct trace_event_data_offsets_cfg80211_inform_bss_frame {
	u32 mgmt;
};

struct trace_event_data_offsets_cfg80211_bss_evt {};

struct trace_event_data_offsets_cfg80211_return_uint {};

struct trace_event_data_offsets_cfg80211_return_u32 {};

struct trace_event_data_offsets_cfg80211_report_wowlan_wakeup {
	u32 packet;
};

struct trace_event_data_offsets_cfg80211_ft_event {
	u32 ies;
	u32 ric_ies;
};

struct trace_event_data_offsets_cfg80211_stop_iface {};

struct trace_event_data_offsets_cfg80211_pmsr_report {};

struct trace_event_data_offsets_cfg80211_pmsr_complete {};

struct trace_event_data_offsets_rdev_update_owe_info {
	u32 ie;
};

struct trace_event_data_offsets_cfg80211_update_owe_info_event {
	u32 ie;
};

struct trace_event_data_offsets_rdev_probe_mesh_link {};

struct trace_event_data_offsets_rdev_set_tid_config {};

struct trace_event_data_offsets_rdev_reset_tid_config {};

typedef void (*btf_trace_rdev_suspend)(void *, struct wiphy *, struct cfg80211_wowlan *);

typedef void (*btf_trace_rdev_return_int)(void *, struct wiphy *, int);

typedef void (*btf_trace_rdev_scan)(void *, struct wiphy *, struct cfg80211_scan_request *);

typedef void (*btf_trace_rdev_resume)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_return_void)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_get_antenna)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_rfkill_poll)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_set_wakeup)(void *, struct wiphy *, bool);

typedef void (*btf_trace_rdev_add_virtual_intf)(void *, struct wiphy *, char *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_return_wdev)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_del_virtual_intf)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_change_virtual_intf)(void *, struct wiphy *, struct net_device *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_get_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_del_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_add_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *, u8);

typedef void (*btf_trace_rdev_set_default_key)(void *, struct wiphy *, struct net_device *, u8, bool, bool);

typedef void (*btf_trace_rdev_set_default_mgmt_key)(void *, struct wiphy *, struct net_device *, u8);

typedef void (*btf_trace_rdev_set_default_beacon_key)(void *, struct wiphy *, struct net_device *, u8);

typedef void (*btf_trace_rdev_start_ap)(void *, struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);

typedef void (*btf_trace_rdev_change_beacon)(void *, struct wiphy *, struct net_device *, struct cfg80211_beacon_data *);

typedef void (*btf_trace_rdev_stop_ap)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_set_rekey_data)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_get_mesh_config)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_mesh)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ibss)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ocb)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_flush_pmksa)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_end_cac)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_add_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_change_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_del_station)(void *, struct wiphy *, struct net_device *, struct station_del_parameters *);

typedef void (*btf_trace_rdev_get_station)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_del_mpath)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_dump_station)(void *, struct wiphy *, struct net_device *, int, u8 *);

typedef void (*btf_trace_rdev_return_int_station_info)(void *, struct wiphy *, int, struct station_info *);

typedef void (*btf_trace_rdev_add_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_change_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpath)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpp)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpp)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_return_int_mpath_info)(void *, struct wiphy *, int, struct mpath_info *);

typedef void (*btf_trace_rdev_return_int_mesh_config)(void *, struct wiphy *, int, struct mesh_config *);

typedef void (*btf_trace_rdev_update_mesh_config)(void *, struct wiphy *, struct net_device *, u32, const struct mesh_config *);

typedef void (*btf_trace_rdev_join_mesh)(void *, struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);

typedef void (*btf_trace_rdev_change_bss)(void *, struct wiphy *, struct net_device *, struct bss_parameters *);

typedef void (*btf_trace_rdev_set_txq_params)(void *, struct wiphy *, struct net_device *, struct ieee80211_txq_params *);

typedef void (*btf_trace_rdev_libertas_set_mesh_channel)(void *, struct wiphy *, struct net_device *, struct ieee80211_channel *);

typedef void (*btf_trace_rdev_set_monitor_channel)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_auth_request *);

typedef void (*btf_trace_rdev_assoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);

typedef void (*btf_trace_rdev_deauth)(void *, struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);

typedef void (*btf_trace_rdev_disassoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);

typedef void (*btf_trace_rdev_mgmt_tx_cancel_wait)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_set_power_mgmt)(void *, struct wiphy *, struct net_device *, bool, int);

typedef void (*btf_trace_rdev_connect)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *);

typedef void (*btf_trace_rdev_update_connect_params)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_config)(void *, struct wiphy *, struct net_device *, s32, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_range_config)(void *, struct wiphy *, struct net_device *, s32, s32);

typedef void (*btf_trace_rdev_set_cqm_txe_config)(void *, struct wiphy *, struct net_device *, u32, u32, u32);

typedef void (*btf_trace_rdev_disconnect)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_join_ibss)(void *, struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);

typedef void (*btf_trace_rdev_join_ocb)(void *, struct wiphy *, struct net_device *, const struct ocb_setup *);

typedef void (*btf_trace_rdev_set_wiphy_params)(void *, struct wiphy *, u32);

typedef void (*btf_trace_rdev_get_tx_power)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_set_tx_power)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);

typedef void (*btf_trace_rdev_return_int_int)(void *, struct wiphy *, int, int);

typedef void (*btf_trace_rdev_set_bitrate_mask)(void *, struct wiphy *, struct net_device *, const u8 *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_rdev_update_mgmt_frame_registrations)(void *, struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);

typedef void (*btf_trace_rdev_return_int_tx_rx)(void *, struct wiphy *, int, u32, u32);

typedef void (*btf_trace_rdev_return_void_tx_rx)(void *, struct wiphy *, u32, u32, u32, u32);

typedef void (*btf_trace_rdev_set_antenna)(void *, struct wiphy *, u32, u32);

typedef void (*btf_trace_rdev_sched_scan_start)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_sched_scan_stop)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_tdls_mgmt)(void *, struct wiphy *, struct net_device *, u8 *, u8, u8, u16, u32, bool, const u8 *, size_t);

typedef void (*btf_trace_rdev_dump_survey)(void *, struct wiphy *, struct net_device *, int);

typedef void (*btf_trace_rdev_return_int_survey_info)(void *, struct wiphy *, int, struct survey_info *);

typedef void (*btf_trace_rdev_tdls_oper)(void *, struct wiphy *, struct net_device *, u8 *, enum nl80211_tdls_operation);

typedef void (*btf_trace_rdev_probe_client)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_del_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_rdev_return_int_cookie)(void *, struct wiphy *, int, u64);

typedef void (*btf_trace_rdev_cancel_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_mgmt_tx)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *);

typedef void (*btf_trace_rdev_tx_control_port)(void *, struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, __be16, bool);

typedef void (*btf_trace_rdev_set_noack_map)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_get_channel)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_return_chandef)(void *, struct wiphy *, int, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_start_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_stop_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_start_nan)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_rdev_nan_change_conf)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_rdev_stop_nan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_add_nan_func)(void *, struct wiphy *, struct wireless_dev *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_rdev_del_nan_func)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_set_mac_acl)(void *, struct wiphy *, struct net_device *, struct cfg80211_acl_data *);

typedef void (*btf_trace_rdev_update_ft_ies)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);

typedef void (*btf_trace_rdev_crit_proto_start)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);

typedef void (*btf_trace_rdev_crit_proto_stop)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_channel_switch)(void *, struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);

typedef void (*btf_trace_rdev_set_qos_map)(void *, struct wiphy *, struct net_device *, struct cfg80211_qos_map *);

typedef void (*btf_trace_rdev_set_ap_chanwidth)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_add_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);

typedef void (*btf_trace_rdev_del_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *);

typedef void (*btf_trace_rdev_tdls_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_tdls_cancel_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_pmk)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmk_conf *);

typedef void (*btf_trace_rdev_del_pmk)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_external_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);

typedef void (*btf_trace_rdev_start_radar_detection)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32);

typedef void (*btf_trace_rdev_set_mcast_rate)(void *, struct wiphy *, struct net_device *, int *);

typedef void (*btf_trace_rdev_set_coalesce)(void *, struct wiphy *, struct cfg80211_coalesce *);

typedef void (*btf_trace_rdev_abort_scan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_set_multicast_to_unicast)(void *, struct wiphy *, struct net_device *, const bool);

typedef void (*btf_trace_rdev_get_txq_stats)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_get_ftm_responder_stats)(void *, struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_rdev_start_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_abort_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_cfg80211_return_bool)(void *, bool);

typedef void (*btf_trace_cfg80211_notify_new_peer_candidate)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_rx_auth)(void *, struct net_device *);

typedef void (*btf_trace_cfg80211_send_rx_assoc)(void *, struct net_device *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_rx_unprot_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_rx_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_tx_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_send_auth_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_assoc_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_michael_mic_failure)(void *, struct net_device *, const u8 *, enum nl80211_key_type, int, const u8 *);

typedef void (*btf_trace_cfg80211_ready_on_channel)(void *, struct wireless_dev *, u64, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_cfg80211_ready_on_channel_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_tx_mgmt_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_new_sta)(void *, struct net_device *, const u8 *, struct station_info *);

typedef void (*btf_trace_cfg80211_del_sta)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_mgmt)(void *, struct wireless_dev *, int, int);

typedef void (*btf_trace_cfg80211_mgmt_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_control_port_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_rx_control_port)(void *, struct net_device *, struct sk_buff *, bool);

typedef void (*btf_trace_cfg80211_cqm_rssi_notify)(void *, struct net_device *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_cfg80211_reg_can_beacon)(void *, struct wiphy *, struct cfg80211_chan_def *, enum nl80211_iftype, bool);

typedef void (*btf_trace_cfg80211_chandef_dfs_required)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_ch_switch_notify)(void *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_ch_switch_started_notify)(void *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_radar_event)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_cac_event)(void *, struct net_device *, enum nl80211_radar_event);

typedef void (*btf_trace_cfg80211_rx_spurious_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_unexpected_4addr_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_ibss_joined)(void *, struct net_device *, const u8 *, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_probe_status)(void *, struct net_device *, const u8 *, u64, bool);

typedef void (*btf_trace_cfg80211_cqm_pktloss_notify)(void *, struct net_device *, const u8 *, u32);

typedef void (*btf_trace_cfg80211_gtk_rekey_notify)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_pmksa_candidate_notify)(void *, struct net_device *, int, const u8 *, bool);

typedef void (*btf_trace_cfg80211_report_obss_beacon)(void *, struct wiphy *, const u8 *, size_t, int, int);

typedef void (*btf_trace_cfg80211_tdls_oper_request)(void *, struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation, u16);

typedef void (*btf_trace_cfg80211_scan_done)(void *, struct cfg80211_scan_request *, struct cfg80211_scan_info *);

typedef void (*btf_trace_cfg80211_sched_scan_stopped)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_sched_scan_results)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_get_bss)(void *, struct wiphy *, struct ieee80211_channel *, const u8 *, const u8 *, size_t, enum ieee80211_bss_type, enum ieee80211_privacy);

typedef void (*btf_trace_cfg80211_inform_bss_frame)(void *, struct wiphy *, struct cfg80211_inform_bss *, struct ieee80211_mgmt *, size_t);

typedef void (*btf_trace_cfg80211_return_bss)(void *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_return_uint)(void *, unsigned int);

typedef void (*btf_trace_cfg80211_return_u32)(void *, u32);

typedef void (*btf_trace_cfg80211_report_wowlan_wakeup)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_wowlan_wakeup *);

typedef void (*btf_trace_cfg80211_ft_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_ft_event_params *);

typedef void (*btf_trace_cfg80211_stop_iface)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_cfg80211_pmsr_report)(void *, struct wiphy *, struct wireless_dev *, u64, const u8 *);

typedef void (*btf_trace_cfg80211_pmsr_complete)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_update_owe_info)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_cfg80211_update_owe_info_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_rdev_probe_mesh_link)(void *, struct wiphy *, struct net_device *, const u8 *, const u8 *, size_t);

typedef void (*btf_trace_rdev_set_tid_config)(void *, struct wiphy *, struct net_device *, struct cfg80211_tid_config *);

typedef void (*btf_trace_rdev_reset_tid_config)(void *, struct wiphy *, struct net_device *, const u8 *, u8);

enum nl80211_peer_measurement_status {
	NL80211_PMSR_STATUS_SUCCESS = 0,
	NL80211_PMSR_STATUS_REFUSED = 1,
	NL80211_PMSR_STATUS_TIMEOUT = 2,
	NL80211_PMSR_STATUS_FAILURE = 3,
};

enum nl80211_peer_measurement_resp {
	__NL80211_PMSR_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_RESP_ATTR_DATA = 1,
	NL80211_PMSR_RESP_ATTR_STATUS = 2,
	NL80211_PMSR_RESP_ATTR_HOST_TIME = 3,
	NL80211_PMSR_RESP_ATTR_AP_TSF = 4,
	NL80211_PMSR_RESP_ATTR_FINAL = 5,
	NL80211_PMSR_RESP_ATTR_PAD = 6,
	NUM_NL80211_PMSR_RESP_ATTRS = 7,
	NL80211_PMSR_RESP_ATTR_MAX = 6,
};

enum nl80211_peer_measurement_ftm_failure_reasons {
	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED = 0,
	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE = 1,
	NL80211_PMSR_FTM_FAILURE_REJECTED = 2,
	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL = 3,
	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE = 4,
	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP = 5,
	NL80211_PMSR_FTM_FAILURE_PEER_BUSY = 6,
	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS = 7,
};

enum nl80211_peer_measurement_ftm_resp {
	__NL80211_PMSR_FTM_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON = 1,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX = 2,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS = 3,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES = 4,
	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME = 5,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP = 6,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION = 7,
	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG = 9,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD = 10,
	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE = 11,
	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE = 12,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG = 13,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE = 14,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD = 15,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG = 16,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE = 17,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD = 18,
	NL80211_PMSR_FTM_RESP_ATTR_LCI = 19,
	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC = 20,
	NL80211_PMSR_FTM_RESP_ATTR_PAD = 21,
	NUM_NL80211_PMSR_FTM_RESP_ATTR = 22,
	NL80211_PMSR_FTM_RESP_ATTR_MAX = 21,
};

struct cfg80211_pmsr_ftm_result {
	const u8 *lci;
	const u8 *civicloc;
	unsigned int lci_len;
	unsigned int civicloc_len;
	enum nl80211_peer_measurement_ftm_failure_reasons failure_reason;
	u32 num_ftmr_attempts;
	u32 num_ftmr_successes;
	s16 burst_index;
	u8 busy_retry_time;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	s32 rssi_avg;
	s32 rssi_spread;
	struct rate_info tx_rate;
	struct rate_info rx_rate;
	s64 rtt_avg;
	s64 rtt_variance;
	s64 rtt_spread;
	s64 dist_avg;
	s64 dist_variance;
	s64 dist_spread;
	u16 num_ftmr_attempts_valid: 1;
	u16 num_ftmr_successes_valid: 1;
	u16 rssi_avg_valid: 1;
	u16 rssi_spread_valid: 1;
	u16 tx_rate_valid: 1;
	u16 rx_rate_valid: 1;
	u16 rtt_avg_valid: 1;
	u16 rtt_variance_valid: 1;
	u16 rtt_spread_valid: 1;
	u16 dist_avg_valid: 1;
	u16 dist_variance_valid: 1;
	u16 dist_spread_valid: 1;
};

struct cfg80211_pmsr_result {
	u64 host_time;
	u64 ap_tsf;
	enum nl80211_peer_measurement_status status;
	u8 addr[6];
	u8 final: 1;
	u8 ap_tsf_valid: 1;
	enum nl80211_peer_measurement_type type;
	union {
		struct cfg80211_pmsr_ftm_result ftm;
	};
};

struct ieee80211_channel_sw_ie {
	u8 mode;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_sec_chan_offs_ie {
	u8 sec_chan_offs;
};

struct ieee80211_mesh_chansw_params_ie {
	u8 mesh_ttl;
	u8 mesh_flags;
	__le16 mesh_reason;
	__le16 mesh_pre_value;
};

struct ieee80211_wide_bw_chansw_ie {
	u8 new_channel_width;
	u8 new_center_freq_seg0;
	u8 new_center_freq_seg1;
};

struct ieee80211_tim_ie {
	u8 dtim_count;
	u8 dtim_period;
	u8 bitmap_ctrl;
	u8 virtual_map[1];
};

struct ieee80211_meshconf_ie {
	u8 meshconf_psel;
	u8 meshconf_pmetric;
	u8 meshconf_congest;
	u8 meshconf_synch;
	u8 meshconf_auth;
	u8 meshconf_form;
	u8 meshconf_cap;
};

struct ieee80211_rann_ie {
	u8 rann_flags;
	u8 rann_hopcount;
	u8 rann_ttl;
	u8 rann_addr[6];
	__le32 rann_seq;
	__le32 rann_interval;
	__le32 rann_metric;
} __attribute__((packed));

struct ieee80211_addba_ext_ie {
	u8 data;
};

struct ieee80211_aid_response_ie {
	__le16 aid;
	u8 switch_count;
	__le16 response_int;
} __attribute__((packed));

struct ieee80211_ch_switch_timing {
	__le16 switch_time;
	__le16 switch_timeout;
};

struct ieee80211_tdls_lnkie {
	u8 ie_type;
	u8 ie_len;
	u8 bssid[6];
	u8 init_sta[6];
	u8 resp_sta[6];
};

struct ieee80211_p2p_noa_desc {
	u8 count;
	__le32 duration;
	__le32 interval;
	__le32 start_time;
} __attribute__((packed));

struct ieee80211_p2p_noa_attr {
	u8 index;
	u8 oppps_ctwindow;
	struct ieee80211_p2p_noa_desc desc[4];
} __attribute__((packed));

struct ieee80211_vht_operation {
	u8 chan_width;
	u8 center_freq_seg0_idx;
	u8 center_freq_seg1_idx;
	__le16 basic_mcs_set;
} __attribute__((packed));

struct ieee80211_he_spr {
	u8 he_sr_control;
	u8 optional[0];
};

struct ieee80211_he_mu_edca_param_ac_rec {
	u8 aifsn;
	u8 ecw_min_max;
	u8 mu_edca_timer;
};

struct ieee80211_mu_edca_param_set {
	u8 mu_qos_info;
	struct ieee80211_he_mu_edca_param_ac_rec ac_be;
	struct ieee80211_he_mu_edca_param_ac_rec ac_bk;
	struct ieee80211_he_mu_edca_param_ac_rec ac_vi;
	struct ieee80211_he_mu_edca_param_ac_rec ac_vo;
};

struct ieee80211_timeout_interval_ie {
	u8 type;
	__le32 value;
} __attribute__((packed));

struct ieee80211_bss_max_idle_period_ie {
	__le16 max_idle_period;
	u8 idle_options;
} __attribute__((packed));

struct ieee80211_bssid_index {
	u8 bssid_index;
	u8 dtim_period;
	u8 dtim_count;
};

struct ieee80211_multiple_bssid_configuration {
	u8 bssid_count;
	u8 profile_periodicity;
};

enum ieee80211_radiotap_mcs_have {
	IEEE80211_RADIOTAP_MCS_HAVE_BW = 1,
	IEEE80211_RADIOTAP_MCS_HAVE_MCS = 2,
	IEEE80211_RADIOTAP_MCS_HAVE_GI = 4,
	IEEE80211_RADIOTAP_MCS_HAVE_FMT = 8,
	IEEE80211_RADIOTAP_MCS_HAVE_FEC = 16,
	IEEE80211_RADIOTAP_MCS_HAVE_STBC = 32,
};

enum ieee80211_radiotap_vht_known {
	IEEE80211_RADIOTAP_VHT_KNOWN_STBC = 1,
	IEEE80211_RADIOTAP_VHT_KNOWN_TXOP_PS_NA = 2,
	IEEE80211_RADIOTAP_VHT_KNOWN_GI = 4,
	IEEE80211_RADIOTAP_VHT_KNOWN_SGI_NSYM_DIS = 8,
	IEEE80211_RADIOTAP_VHT_KNOWN_LDPC_EXTRA_OFDM_SYM = 16,
	IEEE80211_RADIOTAP_VHT_KNOWN_BEAMFORMED = 32,
	IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH = 64,
	IEEE80211_RADIOTAP_VHT_KNOWN_GROUP_ID = 128,
	IEEE80211_RADIOTAP_VHT_KNOWN_PARTIAL_AID = 256,
};

enum ieee80211_max_queues {
	IEEE80211_MAX_QUEUES = 16,
	IEEE80211_MAX_QUEUE_MAP = 65535,
};

struct ieee80211_tx_queue_params {
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool acm;
	bool uapsd;
	bool mu_edca;
	struct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;
};

struct ieee80211_low_level_stats {
	unsigned int dot11ACKFailureCount;
	unsigned int dot11RTSFailureCount;
	unsigned int dot11FCSErrorCount;
	unsigned int dot11RTSSuccessCount;
};

struct ieee80211_chanctx_conf {
	struct cfg80211_chan_def def;
	struct cfg80211_chan_def min_def;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	bool radar_enabled;
	long: 40;
	u8 drv_priv[0];
};

enum ieee80211_chanctx_switch_mode {
	CHANCTX_SWMODE_REASSIGN_VIF = 0,
	CHANCTX_SWMODE_SWAP_CONTEXTS = 1,
};

struct ieee80211_vif;

struct ieee80211_vif_chanctx_switch {
	struct ieee80211_vif *vif;
	struct ieee80211_chanctx_conf *old_ctx;
	struct ieee80211_chanctx_conf *new_ctx;
};

struct ieee80211_mu_group_data {
	u8 membership[8];
	u8 position[16];
};

struct ieee80211_fils_discovery {
	u32 min_interval;
	u32 max_interval;
};

struct ieee80211_ftm_responder_params;

struct ieee80211_bss_conf {
	const u8 *bssid;
	u8 htc_trig_based_pkt_ext;
	bool multi_sta_back_32bit;
	bool uora_exists;
	bool ack_enabled;
	u8 uora_ocw_range;
	u16 frame_time_rts_th;
	bool he_support;
	bool twt_requester;
	bool twt_responder;
	bool twt_protected;
	bool assoc;
	bool ibss_joined;
	bool ibss_creator;
	u16 aid;
	bool use_cts_prot;
	bool use_short_preamble;
	bool use_short_slot;
	bool enable_beacon;
	u8 dtim_period;
	u16 beacon_int;
	u16 assoc_capability;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	struct ieee80211_rate *beacon_rate;
	int mcast_rate[5];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	u32 cqm_rssi_hyst;
	s32 cqm_rssi_low;
	s32 cqm_rssi_high;
	struct cfg80211_chan_def chandef;
	struct ieee80211_mu_group_data mu_group;
	__be32 arp_addr_list[4];
	int arp_addr_cnt;
	bool qos;
	bool idle;
	bool ps;
	u8 ssid[32];
	size_t ssid_len;
	bool hidden_ssid;
	int txpower;
	enum nl80211_tx_power_setting txpower_type;
	struct ieee80211_p2p_noa_attr p2p_noa_attr;
	bool allow_p2p_go_ps;
	u16 max_idle_period;
	bool protected_keep_alive;
	bool ftm_responder;
	struct ieee80211_ftm_responder_params *ftmr_params;
	bool nontransmitted;
	u8 transmitter_bssid[6];
	u8 bssid_index;
	u8 bssid_indicator;
	bool ema_ap;
	u8 profile_periodicity;
	struct {
		u32 params;
		u16 nss_set;
	} he_oper;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_he_bss_color he_bss_color;
	struct ieee80211_fils_discovery fils_discovery;
	u32 unsol_bcast_probe_resp_interval;
	bool s1g;
	struct cfg80211_bitrate_mask beacon_tx_rate;
};

struct ieee80211_txq;

struct ieee80211_vif {
	enum nl80211_iftype type;
	struct ieee80211_bss_conf bss_conf;
	u8 addr[6];
	bool p2p;
	bool csa_active;
	bool mu_mimo_owner;
	u8 cab_queue;
	u8 hw_queue[4];
	struct ieee80211_txq *txq;
	struct ieee80211_chanctx_conf *chanctx_conf;
	u32 driver_flags;
	u32 offload_flags;
	bool probe_req_reg;
	bool rx_mcast_action_reg;
	bool txqs_stopped[4];
	short: 16;
	u8 drv_priv[0];
};

enum ieee80211_bss_change {
	BSS_CHANGED_ASSOC = 1,
	BSS_CHANGED_ERP_CTS_PROT = 2,
	BSS_CHANGED_ERP_PREAMBLE = 4,
	BSS_CHANGED_ERP_SLOT = 8,
	BSS_CHANGED_HT = 16,
	BSS_CHANGED_BASIC_RATES = 32,
	BSS_CHANGED_BEACON_INT = 64,
	BSS_CHANGED_BSSID = 128,
	BSS_CHANGED_BEACON = 256,
	BSS_CHANGED_BEACON_ENABLED = 512,
	BSS_CHANGED_CQM = 1024,
	BSS_CHANGED_IBSS = 2048,
	BSS_CHANGED_ARP_FILTER = 4096,
	BSS_CHANGED_QOS = 8192,
	BSS_CHANGED_IDLE = 16384,
	BSS_CHANGED_SSID = 32768,
	BSS_CHANGED_AP_PROBE_RESP = 65536,
	BSS_CHANGED_PS = 131072,
	BSS_CHANGED_TXPOWER = 262144,
	BSS_CHANGED_P2P_PS = 524288,
	BSS_CHANGED_BEACON_INFO = 1048576,
	BSS_CHANGED_BANDWIDTH = 2097152,
	BSS_CHANGED_OCB = 4194304,
	BSS_CHANGED_MU_GROUPS = 8388608,
	BSS_CHANGED_KEEP_ALIVE = 16777216,
	BSS_CHANGED_MCAST_RATE = 33554432,
	BSS_CHANGED_FTM_RESPONDER = 67108864,
	BSS_CHANGED_TWT = 134217728,
	BSS_CHANGED_HE_OBSS_PD = 268435456,
	BSS_CHANGED_HE_BSS_COLOR = 536870912,
	BSS_CHANGED_FILS_DISCOVERY = 1073741824,
	BSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 2147483648,
};

enum ieee80211_event_type {
	RSSI_EVENT = 0,
	MLME_EVENT = 1,
	BAR_RX_EVENT = 2,
	BA_FRAME_TIMEOUT = 3,
};

enum ieee80211_rssi_event_data {
	RSSI_EVENT_HIGH = 0,
	RSSI_EVENT_LOW = 1,
};

struct ieee80211_rssi_event {
	enum ieee80211_rssi_event_data data;
};

enum ieee80211_mlme_event_data {
	AUTH_EVENT = 0,
	ASSOC_EVENT = 1,
	DEAUTH_RX_EVENT = 2,
	DEAUTH_TX_EVENT = 3,
};

enum ieee80211_mlme_event_status {
	MLME_SUCCESS = 0,
	MLME_DENIED = 1,
	MLME_TIMEOUT = 2,
};

struct ieee80211_mlme_event {
	enum ieee80211_mlme_event_data data;
	enum ieee80211_mlme_event_status status;
	u16 reason;
};

struct ieee80211_sta;

struct ieee80211_ba_event {
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
};

enum ieee80211_sta_rx_bandwidth {
	IEEE80211_STA_RX_BW_20 = 0,
	IEEE80211_STA_RX_BW_40 = 1,
	IEEE80211_STA_RX_BW_80 = 2,
	IEEE80211_STA_RX_BW_160 = 3,
};

enum ieee80211_smps_mode {
	IEEE80211_SMPS_AUTOMATIC = 0,
	IEEE80211_SMPS_OFF = 1,
	IEEE80211_SMPS_STATIC = 2,
	IEEE80211_SMPS_DYNAMIC = 3,
	IEEE80211_SMPS_NUM_MODES = 4,
};

struct ieee80211_sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct ieee80211_sta_rates;

struct ieee80211_sta {
	u32 supp_rates[5];
	u8 addr[6];
	u16 aid;
	struct ieee80211_sta_ht_cap ht_cap;
	short: 16;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	char: 8;
	u16 max_rx_aggregation_subframes;
	bool wme;
	u8 uapsd_queues;
	u8 max_sp;
	u8 rx_nss;
	enum ieee80211_sta_rx_bandwidth bandwidth;
	enum ieee80211_smps_mode smps_mode;
	int: 32;
	struct ieee80211_sta_rates *rates;
	bool tdls;
	bool tdls_initiator;
	bool mfp;
	u8 max_amsdu_subframes;
	u16 max_amsdu_len;
	bool support_p2p_ps;
	char: 8;
	u16 max_rc_amsdu_len;
	u16 max_tid_amsdu_len[16];
	short: 16;
	struct ieee80211_sta_txpwr txpwr;
	int: 32;
	struct ieee80211_txq *txq[17];
	u8 drv_priv[0];
} __attribute__((packed));

struct ieee80211_event {
	enum ieee80211_event_type type;
	union {
		struct ieee80211_rssi_event rssi;
		struct ieee80211_mlme_event mlme;
		struct ieee80211_ba_event ba;
	} u;
};

struct ieee80211_ftm_responder_params {
	const u8 *lci;
	const u8 *civicloc;
	size_t lci_len;
	size_t civicloc_len;
};

struct ieee80211_tx_rate {
	s8 idx;
	u16 count: 5;
	u16 flags: 11;
} __attribute__((packed));

struct ieee80211_key_conf {
	atomic64_t tx_pn;
	u32 cipher;
	u8 icv_len;
	u8 iv_len;
	u8 hw_key_idx;
	s8 keyidx;
	u16 flags;
	u8 keylen;
	u8 key[0];
};

struct ieee80211_tx_info {
	u32 flags;
	u32 band: 3;
	u32 ack_frame_id: 13;
	u32 hw_queue: 4;
	u32 tx_time_est: 10;
	union {
		struct {
			union {
				struct {
					struct ieee80211_tx_rate rates[4];
					s8 rts_cts_rate_idx;
					u8 use_rts: 1;
					u8 use_cts_prot: 1;
					u8 short_preamble: 1;
					u8 skip_table: 1;
				};
				long unsigned int jiffies;
			};
			struct ieee80211_vif *vif;
			struct ieee80211_key_conf *hw_key;
			u32 flags;
			codel_time_t enqueue_time;
		} control;
		struct {
			u64 cookie;
		} ack;
		struct {
			struct ieee80211_tx_rate rates[4];
			s32 ack_signal;
			u8 ampdu_ack_len;
			u8 ampdu_len;
			u8 antenna;
			u16 tx_time;
			bool is_valid_ack_signal;
			void *status_driver_data[2];
		} status;
		struct {
			struct ieee80211_tx_rate driver_rates[4];
			u8 pad[4];
			void *rate_driver_data[3];
		};
		void *driver_data[5];
	};
};

struct ieee80211_tx_status {
	struct ieee80211_sta *sta;
	struct ieee80211_tx_info *info;
	struct sk_buff *skb;
	struct rate_info *rate;
	struct list_head *free_list;
};

struct ieee80211_scan_ies {
	const u8 *ies[5];
	size_t len[5];
	const u8 *common_ies;
	size_t common_ie_len;
};

struct ieee80211_rx_status {
	u64 mactime;
	u64 boottime_ns;
	u32 device_timestamp;
	u32 ampdu_reference;
	u32 flag;
	u16 freq: 13;
	u16 freq_offset: 1;
	u8 enc_flags;
	u8 encoding: 2;
	u8 bw: 3;
	u8 he_ru: 3;
	u8 he_gi: 2;
	u8 he_dcm: 1;
	u8 rate_idx;
	u8 nss;
	u8 rx_flags;
	u8 band;
	u8 antenna;
	s8 signal;
	u8 chains;
	s8 chain_signal[4];
	u8 ampdu_delimiter_crc;
	u8 zero_length_psdu_type;
};

enum ieee80211_conf_flags {
	IEEE80211_CONF_MONITOR = 1,
	IEEE80211_CONF_PS = 2,
	IEEE80211_CONF_IDLE = 4,
	IEEE80211_CONF_OFFCHANNEL = 8,
};

enum ieee80211_conf_changed {
	IEEE80211_CONF_CHANGE_SMPS = 2,
	IEEE80211_CONF_CHANGE_LISTEN_INTERVAL = 4,
	IEEE80211_CONF_CHANGE_MONITOR = 8,
	IEEE80211_CONF_CHANGE_PS = 16,
	IEEE80211_CONF_CHANGE_POWER = 32,
	IEEE80211_CONF_CHANGE_CHANNEL = 64,
	IEEE80211_CONF_CHANGE_RETRY_LIMITS = 128,
	IEEE80211_CONF_CHANGE_IDLE = 256,
};

struct ieee80211_conf {
	u32 flags;
	int power_level;
	int dynamic_ps_timeout;
	u16 listen_interval;
	u8 ps_dtim_period;
	u8 long_frame_max_tx_count;
	u8 short_frame_max_tx_count;
	struct cfg80211_chan_def chandef;
	bool radar_enabled;
	enum ieee80211_smps_mode smps_mode;
};

struct ieee80211_channel_switch {
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	struct cfg80211_chan_def chandef;
	u8 count;
	u32 delay;
};

struct ieee80211_txq {
	struct ieee80211_vif *vif;
	struct ieee80211_sta *sta;
	u8 tid;
	u8 ac;
	long: 48;
	u8 drv_priv[0];
};

struct ieee80211_key_seq {
	union {
		struct {
			u32 iv32;
			u16 iv16;
		} tkip;
		struct {
			u8 pn[6];
		} ccmp;
		struct {
			u8 pn[6];
		} aes_cmac;
		struct {
			u8 pn[6];
		} aes_gmac;
		struct {
			u8 pn[6];
		} gcmp;
		struct {
			u8 seq[16];
			u8 seq_len;
		} hw;
	};
};

struct ieee80211_cipher_scheme {
	u32 cipher;
	u16 iftype;
	u8 hdr_len;
	u8 pn_len;
	u8 pn_off;
	u8 key_idx_off;
	u8 key_idx_mask;
	u8 key_idx_shift;
	u8 mic_len;
};

enum set_key_cmd {
	SET_KEY = 0,
	DISABLE_KEY = 1,
};

enum ieee80211_sta_state {
	IEEE80211_STA_NOTEXIST = 0,
	IEEE80211_STA_NONE = 1,
	IEEE80211_STA_AUTH = 2,
	IEEE80211_STA_ASSOC = 3,
	IEEE80211_STA_AUTHORIZED = 4,
};

struct ieee80211_sta_rates {
	struct callback_head callback_head;
	struct {
		s8 idx;
		u8 count;
		u8 count_cts;
		u8 count_rts;
		u16 flags;
	} rate[4];
};

enum sta_notify_cmd {
	STA_NOTIFY_SLEEP = 0,
	STA_NOTIFY_AWAKE = 1,
};

struct ieee80211_tx_control {
	struct ieee80211_sta *sta;
};

enum ieee80211_hw_flags {
	IEEE80211_HW_HAS_RATE_CONTROL = 0,
	IEEE80211_HW_RX_INCLUDES_FCS = 1,
	IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING = 2,
	IEEE80211_HW_SIGNAL_UNSPEC = 3,
	IEEE80211_HW_SIGNAL_DBM = 4,
	IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC = 5,
	IEEE80211_HW_SPECTRUM_MGMT = 6,
	IEEE80211_HW_AMPDU_AGGREGATION = 7,
	IEEE80211_HW_SUPPORTS_PS = 8,
	IEEE80211_HW_PS_NULLFUNC_STACK = 9,
	IEEE80211_HW_SUPPORTS_DYNAMIC_PS = 10,
	IEEE80211_HW_MFP_CAPABLE = 11,
	IEEE80211_HW_WANT_MONITOR_VIF = 12,
	IEEE80211_HW_NO_AUTO_VIF = 13,
	IEEE80211_HW_SW_CRYPTO_CONTROL = 14,
	IEEE80211_HW_SUPPORT_FAST_XMIT = 15,
	IEEE80211_HW_REPORTS_TX_ACK_STATUS = 16,
	IEEE80211_HW_CONNECTION_MONITOR = 17,
	IEEE80211_HW_QUEUE_CONTROL = 18,
	IEEE80211_HW_SUPPORTS_PER_STA_GTK = 19,
	IEEE80211_HW_AP_LINK_PS = 20,
	IEEE80211_HW_TX_AMPDU_SETUP_IN_HW = 21,
	IEEE80211_HW_SUPPORTS_RC_TABLE = 22,
	IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF = 23,
	IEEE80211_HW_TIMING_BEACON_ONLY = 24,
	IEEE80211_HW_SUPPORTS_HT_CCK_RATES = 25,
	IEEE80211_HW_CHANCTX_STA_CSA = 26,
	IEEE80211_HW_SUPPORTS_CLONED_SKBS = 27,
	IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS = 28,
	IEEE80211_HW_TDLS_WIDER_BW = 29,
	IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU = 30,
	IEEE80211_HW_BEACON_TX_STATUS = 31,
	IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR = 32,
	IEEE80211_HW_SUPPORTS_REORDERING_BUFFER = 33,
	IEEE80211_HW_USES_RSS = 34,
	IEEE80211_HW_TX_AMSDU = 35,
	IEEE80211_HW_TX_FRAG_LIST = 36,
	IEEE80211_HW_REPORTS_LOW_ACK = 37,
	IEEE80211_HW_SUPPORTS_TX_FRAG = 38,
	IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA = 39,
	IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP = 40,
	IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP = 41,
	IEEE80211_HW_BUFF_MMPDU_TXQ = 42,
	IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW = 43,
	IEEE80211_HW_STA_MMPDU_TXQ = 44,
	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN = 45,
	IEEE80211_HW_SUPPORTS_MULTI_BSSID = 46,
	IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID = 47,
	IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT = 48,
	IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD = 49,
	NUM_IEEE80211_HW_FLAGS = 50,
};

struct ieee80211_hw {
	struct ieee80211_conf conf;
	struct wiphy *wiphy;
	const char *rate_control_algorithm;
	void *priv;
	long unsigned int flags[1];
	unsigned int extra_tx_headroom;
	unsigned int extra_beacon_tailroom;
	int vif_data_size;
	int sta_data_size;
	int chanctx_data_size;
	int txq_data_size;
	u16 queues;
	u16 max_listen_interval;
	s8 max_signal;
	u8 max_rates;
	u8 max_report_rates;
	u8 max_rate_tries;
	u16 max_rx_aggregation_subframes;
	u16 max_tx_aggregation_subframes;
	u8 max_tx_fragments;
	u8 offchannel_tx_hw_queue;
	u8 radiotap_mcs_details;
	u16 radiotap_vht_details;
	struct {
		int units_pos;
		s16 accuracy;
	} radiotap_timestamp;
	netdev_features_t netdev_features;
	u8 uapsd_queues;
	u8 uapsd_max_sp_len;
	u8 n_cipher_schemes;
	const struct ieee80211_cipher_scheme *cipher_schemes;
	u8 max_nan_de_entries;
	u8 tx_sk_pacing_shift;
	u8 weight_multiplier;
	u32 max_mtu;
};

struct ieee80211_scan_request {
	struct ieee80211_scan_ies ies;
	struct cfg80211_scan_request req;
};

struct ieee80211_tdls_ch_sw_params {
	struct ieee80211_sta *sta;
	struct cfg80211_chan_def *chandef;
	u8 action_code;
	u32 status;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	struct sk_buff *tmpl_skb;
	u32 ch_sw_tm_ie;
};

enum ieee80211_filter_flags {
	FIF_ALLMULTI = 2,
	FIF_FCSFAIL = 4,
	FIF_PLCPFAIL = 8,
	FIF_BCN_PRBRESP_PROMISC = 16,
	FIF_CONTROL = 32,
	FIF_OTHER_BSS = 64,
	FIF_PSPOLL = 128,
	FIF_PROBE_REQ = 256,
	FIF_MCAST_ACTION = 512,
};

enum ieee80211_ampdu_mlme_action {
	IEEE80211_AMPDU_RX_START = 0,
	IEEE80211_AMPDU_RX_STOP = 1,
	IEEE80211_AMPDU_TX_START = 2,
	IEEE80211_AMPDU_TX_STOP_CONT = 3,
	IEEE80211_AMPDU_TX_STOP_FLUSH = 4,
	IEEE80211_AMPDU_TX_STOP_FLUSH_CONT = 5,
	IEEE80211_AMPDU_TX_OPERATIONAL = 6,
};

struct ieee80211_ampdu_params {
	enum ieee80211_ampdu_mlme_action action;
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
	u16 buf_size;
	bool amsdu;
	u16 timeout;
};

enum ieee80211_frame_release_type {
	IEEE80211_FRAME_RELEASE_PSPOLL = 0,
	IEEE80211_FRAME_RELEASE_UAPSD = 1,
};

enum ieee80211_roc_type {
	IEEE80211_ROC_TYPE_NORMAL = 0,
	IEEE80211_ROC_TYPE_MGMT_TX = 1,
};

enum ieee80211_reconfig_type {
	IEEE80211_RECONFIG_TYPE_RESTART = 0,
	IEEE80211_RECONFIG_TYPE_SUSPEND = 1,
};

struct ieee80211_ops {
	void (*tx)(struct ieee80211_hw *, struct ieee80211_tx_control *, struct sk_buff *);
	int (*start)(struct ieee80211_hw *);
	void (*stop)(struct ieee80211_hw *);
	int (*suspend)(struct ieee80211_hw *, struct cfg80211_wowlan *);
	int (*resume)(struct ieee80211_hw *);
	void (*set_wakeup)(struct ieee80211_hw *, bool);
	int (*add_interface)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*change_interface)(struct ieee80211_hw *, struct ieee80211_vif *, enum nl80211_iftype, bool);
	void (*remove_interface)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*config)(struct ieee80211_hw *, u32);
	void (*bss_info_changed)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, u32);
	int (*start_ap)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*stop_ap)(struct ieee80211_hw *, struct ieee80211_vif *);
	u64 (*prepare_multicast)(struct ieee80211_hw *, struct netdev_hw_addr_list *);
	void (*configure_filter)(struct ieee80211_hw *, unsigned int, unsigned int *, u64);
	void (*config_iface_filter)(struct ieee80211_hw *, struct ieee80211_vif *, unsigned int, unsigned int);
	int (*set_tim)(struct ieee80211_hw *, struct ieee80211_sta *, bool);
	int (*set_key)(struct ieee80211_hw *, enum set_key_cmd, struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *);
	void (*update_tkip_key)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32, u16 *);
	void (*set_rekey_data)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_gtk_rekey_data *);
	void (*set_default_unicast_key)(struct ieee80211_hw *, struct ieee80211_vif *, int);
	int (*hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_scan_request *);
	void (*cancel_hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*sched_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *);
	int (*sched_scan_stop)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*sw_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, const u8 *);
	void (*sw_scan_complete)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*get_stats)(struct ieee80211_hw *, struct ieee80211_low_level_stats *);
	void (*get_key_seq)(struct ieee80211_hw *, struct ieee80211_key_conf *, struct ieee80211_key_seq *);
	int (*set_frag_threshold)(struct ieee80211_hw *, u32);
	int (*set_rts_threshold)(struct ieee80211_hw *, u32);
	int (*sta_add)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	int (*sta_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_notify)(struct ieee80211_hw *, struct ieee80211_vif *, enum sta_notify_cmd, struct ieee80211_sta *);
	int (*sta_set_txpwr)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	int (*sta_state)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, enum ieee80211_sta_state, enum ieee80211_sta_state);
	void (*sta_pre_rcu_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_rc_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u32);
	void (*sta_rate_tbl_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_statistics)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct station_info *);
	int (*conf_tx)(struct ieee80211_hw *, struct ieee80211_vif *, u16, const struct ieee80211_tx_queue_params *);
	u64 (*get_tsf)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*set_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, u64);
	void (*offset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, s64);
	void (*reset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*tx_last_beacon)(struct ieee80211_hw *);
	int (*ampdu_action)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_ampdu_params *);
	int (*get_survey)(struct ieee80211_hw *, int, struct survey_info *);
	void (*rfkill_poll)(struct ieee80211_hw *);
	void (*set_coverage_class)(struct ieee80211_hw *, s16);
	void (*flush)(struct ieee80211_hw *, struct ieee80211_vif *, u32, bool);
	void (*channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*set_antenna)(struct ieee80211_hw *, u32, u32);
	int (*get_antenna)(struct ieee80211_hw *, u32 *, u32 *);
	int (*remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel *, int, enum ieee80211_roc_type);
	int (*cancel_remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*set_ringparam)(struct ieee80211_hw *, u32, u32);
	void (*get_ringparam)(struct ieee80211_hw *, u32 *, u32 *, u32 *, u32 *);
	bool (*tx_frames_pending)(struct ieee80211_hw *);
	int (*set_bitrate_mask)(struct ieee80211_hw *, struct ieee80211_vif *, const struct cfg80211_bitrate_mask *);
	void (*event_callback)(struct ieee80211_hw *, struct ieee80211_vif *, const struct ieee80211_event *);
	void (*allow_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);
	void (*release_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);
	int (*get_et_sset_count)(struct ieee80211_hw *, struct ieee80211_vif *, int);
	void (*get_et_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct ethtool_stats *, u64 *);
	void (*get_et_strings)(struct ieee80211_hw *, struct ieee80211_vif *, u32, u8 *);
	void (*mgd_prepare_tx)(struct ieee80211_hw *, struct ieee80211_vif *, u16);
	void (*mgd_protect_tdls_discover)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*add_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *);
	void (*remove_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *);
	void (*change_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *, u32);
	int (*assign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *);
	void (*unassign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *);
	int (*switch_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif_chanctx_switch *, int, enum ieee80211_chanctx_switch_mode);
	void (*reconfig_complete)(struct ieee80211_hw *, enum ieee80211_reconfig_type);
	void (*ipv6_addr_change)(struct ieee80211_hw *, struct ieee80211_vif *, struct inet6_dev *);
	void (*channel_switch_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_chan_def *);
	int (*pre_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*post_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*abort_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*channel_switch_rx_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*join_ibss)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*leave_ibss)(struct ieee80211_hw *, struct ieee80211_vif *);
	u32 (*get_expected_throughput)(struct ieee80211_hw *, struct ieee80211_sta *);
	int (*get_txpower)(struct ieee80211_hw *, struct ieee80211_vif *, int *);
	int (*tdls_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8, struct cfg80211_chan_def *, struct sk_buff *, u32);
	void (*tdls_cancel_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*tdls_recv_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_tdls_ch_sw_params *);
	void (*wake_tx_queue)(struct ieee80211_hw *, struct ieee80211_txq *);
	void (*sync_rx_queues)(struct ieee80211_hw *);
	int (*start_nan)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_nan_conf *);
	int (*stop_nan)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*nan_change_conf)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_nan_conf *, u32);
	int (*add_nan_func)(struct ieee80211_hw *, struct ieee80211_vif *, const struct cfg80211_nan_func *);
	void (*del_nan_func)(struct ieee80211_hw *, struct ieee80211_vif *, u8);
	bool (*can_aggregate_in_amsdu)(struct ieee80211_hw *, struct sk_buff *, struct sk_buff *);
	int (*get_ftm_responder_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_pmsr_request *);
	int (*set_tid_config)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8);
	void (*update_vif_offload)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*sta_set_4addr)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, bool);
};

struct ieee80211_tx_rate_control {
	struct ieee80211_hw *hw;
	struct ieee80211_supported_band *sband;
	struct ieee80211_bss_conf *bss_conf;
	struct sk_buff *skb;
	struct ieee80211_tx_rate reported_rate;
	bool rts;
	bool short_preamble;
	u32 rate_idx_mask;
	u8 *rate_idx_mcs_mask;
	bool bss;
};

enum rate_control_capabilities {
	RATE_CTRL_CAPA_VHT_EXT_NSS_BW = 1,
};

struct rate_control_ops {
	long unsigned int capa;
	const char *name;
	void * (*alloc)(struct ieee80211_hw *);
	void (*add_debugfs)(struct ieee80211_hw *, void *, struct dentry *);
	void (*free)(void *);
	void * (*alloc_sta)(void *, struct ieee80211_sta *, gfp_t);
	void (*rate_init)(void *, struct ieee80211_supported_band *, struct cfg80211_chan_def *, struct ieee80211_sta *, void *);
	void (*rate_update)(void *, struct ieee80211_supported_band *, struct cfg80211_chan_def *, struct ieee80211_sta *, void *, u32);
	void (*free_sta)(void *, struct ieee80211_sta *, void *);
	void (*tx_status_ext)(void *, struct ieee80211_supported_band *, void *, struct ieee80211_tx_status *);
	void (*tx_status)(void *, struct ieee80211_supported_band *, struct ieee80211_sta *, void *, struct sk_buff *);
	void (*get_rate)(void *, struct ieee80211_sta *, void *, struct ieee80211_tx_rate_control *);
	void (*add_sta_debugfs)(void *, void *, struct dentry *);
	u32 (*get_expected_throughput)(void *);
};

struct fq_tin;

struct fq_flow___2 {
	struct fq_tin *tin;
	struct list_head flowchain;
	struct list_head backlogchain;
	struct sk_buff_head queue;
	u32 backlog;
	int deficit;
};

struct fq_tin {
	struct list_head new_flows;
	struct list_head old_flows;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 overlimit;
	u32 collisions;
	u32 flows;
	u32 tx_bytes;
	u32 tx_packets;
};

struct fq {
	struct fq_flow___2 *flows;
	struct list_head backlogs;
	spinlock_t lock;
	u32 flows_cnt;
	u32 limit;
	u32 memory_limit;
	u32 memory_usage;
	u32 quantum;
	u32 backlog;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
};

enum ieee80211_internal_tkip_state {
	TKIP_STATE_NOT_INIT = 0,
	TKIP_STATE_PHASE1_DONE = 1,
	TKIP_STATE_PHASE1_HW_UPLOADED = 2,
};

struct tkip_ctx {
	u16 p1k[5];
	u32 p1k_iv32;
	enum ieee80211_internal_tkip_state state;
};

struct tkip_ctx_rx {
	struct tkip_ctx ctx;
	u32 iv32;
	u16 iv16;
};

struct ieee80211_local;

struct ieee80211_sub_if_data;

struct sta_info;

struct ieee80211_key {
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct list_head list;
	unsigned int flags;
	union {
		struct {
			spinlock_t txlock;
			struct tkip_ctx tx;
			struct tkip_ctx_rx rx[16];
			u32 mic_failures;
		} tkip;
		struct {
			u8 rx_pn[102];
			struct crypto_aead *tfm;
			u32 replays;
		} ccmp;
		struct {
			u8 rx_pn[6];
			struct crypto_shash *tfm;
			u32 replays;
			u32 icverrors;
		} aes_cmac;
		struct {
			u8 rx_pn[6];
			struct crypto_aead *tfm;
			u32 replays;
			u32 icverrors;
		} aes_gmac;
		struct {
			u8 rx_pn[102];
			struct crypto_aead *tfm;
			u32 replays;
		} gcmp;
		struct {
			u8 rx_pn[272];
		} gen;
	} u;
	struct ieee80211_key_conf conf;
};

enum mac80211_scan_state {
	SCAN_DECISION = 0,
	SCAN_SET_CHANNEL = 1,
	SCAN_SEND_PROBE = 2,
	SCAN_SUSPEND = 3,
	SCAN_RESUME = 4,
	SCAN_ABORT = 5,
};

struct rate_control_ref;

struct ieee80211_local {
	struct ieee80211_hw hw;
	struct fq fq;
	struct codel_vars *cvars;
	struct codel_params cparams;
	spinlock_t active_txq_lock[4];
	struct list_head active_txqs[4];
	u16 schedule_round[4];
	u16 airtime_flags;
	u32 aql_txq_limit_low[4];
	u32 aql_txq_limit_high[4];
	u32 aql_threshold;
	atomic_t aql_total_pending_airtime;
	const struct ieee80211_ops *ops;
	struct workqueue_struct *workqueue;
	long unsigned int queue_stop_reasons[16];
	int q_stop_reasons[160];
	spinlock_t queue_stop_reason_lock;
	int open_count;
	int monitors;
	int cooked_mntrs;
	int fif_fcsfail;
	int fif_plcpfail;
	int fif_control;
	int fif_other_bss;
	int fif_pspoll;
	int fif_probe_req;
	bool probe_req_reg;
	bool rx_mcast_action_reg;
	unsigned int filter_flags;
	bool wiphy_ciphers_allocated;
	bool use_chanctx;
	spinlock_t filter_lock;
	struct work_struct reconfig_filter;
	struct netdev_hw_addr_list mc_list;
	bool tim_in_locked_section;
	bool suspended;
	bool resuming;
	bool quiescing;
	bool started;
	bool in_reconfig;
	bool wowlan;
	struct work_struct radar_detected_work;
	u8 rx_chains;
	u8 sband_allocated;
	int tx_headroom;
	struct tasklet_struct tasklet;
	struct sk_buff_head skb_queue;
	struct sk_buff_head skb_queue_unreliable;
	spinlock_t rx_path_lock;
	struct mutex sta_mtx;
	spinlock_t tim_lock;
	long unsigned int num_sta;
	struct list_head sta_list;
	struct rhltable sta_hash;
	struct timer_list sta_cleanup;
	int sta_generation;
	struct sk_buff_head pending[16];
	struct tasklet_struct tx_pending_tasklet;
	struct tasklet_struct wake_txqs_tasklet;
	atomic_t agg_queue_stop[16];
	atomic_t iff_allmultis;
	struct rate_control_ref *rate_ctrl;
	struct arc4_ctx wep_tx_ctx;
	struct arc4_ctx wep_rx_ctx;
	u32 wep_iv;
	struct list_head interfaces;
	struct list_head mon_list;
	struct mutex iflist_mtx;
	struct mutex key_mtx;
	struct mutex mtx;
	long unsigned int scanning;
	struct cfg80211_ssid scan_ssid;
	struct cfg80211_scan_request *int_scan_req;
	struct cfg80211_scan_request *scan_req;
	struct ieee80211_scan_request *hw_scan_req;
	struct cfg80211_chan_def scan_chandef;
	enum nl80211_band hw_scan_band;
	int scan_channel_idx;
	int scan_ies_len;
	int hw_scan_ies_bufsize;
	struct cfg80211_scan_info scan_info;
	struct work_struct sched_scan_stopped_work;
	struct ieee80211_sub_if_data *sched_scan_sdata;
	struct cfg80211_sched_scan_request *sched_scan_req;
	u8 scan_addr[6];
	long unsigned int leave_oper_channel_time;
	enum mac80211_scan_state next_scan_state;
	struct delayed_work scan_work;
	struct ieee80211_sub_if_data *scan_sdata;
	struct cfg80211_chan_def _oper_chandef;
	struct ieee80211_channel *tmp_channel;
	struct list_head chanctx_list;
	struct mutex chanctx_mtx;
	int total_ps_buffered;
	bool pspolling;
	struct ieee80211_sub_if_data *ps_sdata;
	struct work_struct dynamic_ps_enable_work;
	struct work_struct dynamic_ps_disable_work;
	struct timer_list dynamic_ps_timer;
	struct notifier_block ifa_notifier;
	struct notifier_block ifa6_notifier;
	int dynamic_ps_forced_timeout;
	int user_power_level;
	enum ieee80211_smps_mode smps_mode;
	struct work_struct restart_work;
	struct delayed_work roc_work;
	struct list_head roc_list;
	struct work_struct hw_roc_start;
	struct work_struct hw_roc_done;
	long unsigned int hw_roc_start_time;
	u64 roc_cookie_counter;
	struct idr ack_status_frames;
	spinlock_t ack_status_lock;
	struct ieee80211_sub_if_data *p2p_sdata;
	struct ieee80211_sub_if_data *monitor_sdata;
	struct cfg80211_chan_def monitor_chandef;
	u8 ext_capa[8];
	struct work_struct tdls_chsw_work;
	struct sk_buff_head skb_queue_tdls_chsw;
};

struct ieee80211_fragment_entry {
	struct sk_buff_head skb_list;
	long unsigned int first_frag_time;
	u16 seq;
	u16 extra_len;
	u16 last_frag;
	u8 rx_queue;
	bool check_sequential_pn;
	u8 last_pn[6];
};

struct ps_data {
	u8 tim[256];
	struct sk_buff_head bc_buf;
	atomic_t num_sta_ps;
	int dtim_count;
	bool dtim_bc_mc;
};

struct beacon_data;

struct probe_resp;

struct fils_discovery_data;

struct unsol_bcast_probe_resp_data;

struct ieee80211_if_ap {
	struct beacon_data *beacon;
	struct probe_resp *probe_resp;
	struct fils_discovery_data *fils_discovery;
	struct unsol_bcast_probe_resp_data *unsol_bcast_probe_resp;
	struct cfg80211_beacon_data *next_beacon;
	struct list_head vlans;
	struct ps_data ps;
	atomic_t num_mcast_sta;
	bool multicast_to_unicast;
};

struct ieee80211_if_vlan {
	struct list_head list;
	struct sta_info *sta;
	atomic_t num_mcast_sta;
};

struct ewma_beacon_signal {
	long unsigned int internal;
};

struct ieee80211_sta_tx_tspec {
	long unsigned int time_slice_start;
	u32 admitted_time;
	u8 tsid;
	s8 up;
	u32 consumed_tx_time;
	enum {
		TX_TSPEC_ACTION_NONE = 0,
		TX_TSPEC_ACTION_DOWNGRADE = 1,
		TX_TSPEC_ACTION_STOP_DOWNGRADE = 2,
	} action;
	bool downgraded;
};

struct ieee80211_mgd_auth_data;

struct ieee80211_mgd_assoc_data;

struct ieee80211_if_managed {
	struct timer_list timer;
	struct timer_list conn_mon_timer;
	struct timer_list bcn_mon_timer;
	struct timer_list chswitch_timer;
	struct work_struct monitor_work;
	struct work_struct chswitch_work;
	struct work_struct beacon_connection_loss_work;
	struct work_struct csa_connection_drop_work;
	long unsigned int beacon_timeout;
	long unsigned int probe_timeout;
	int probe_send_count;
	bool nullfunc_failed;
	bool connection_loss;
	short: 16;
	struct cfg80211_bss *associated;
	struct ieee80211_mgd_auth_data *auth_data;
	struct ieee80211_mgd_assoc_data *assoc_data;
	u8 bssid[6];
	bool powersave;
	bool broken_ap;
	bool have_beacon;
	u8 dtim_period;
	short: 16;
	enum ieee80211_smps_mode req_smps;
	enum ieee80211_smps_mode driver_smps_mode;
	int: 32;
	struct work_struct request_smps_work;
	unsigned int flags;
	bool csa_waiting_bcn;
	bool csa_ignored_same_chan;
	bool beacon_crc_valid;
	char: 8;
	u32 beacon_crc;
	bool status_acked;
	bool status_received;
	__le16 status_fc;
	enum {
		IEEE80211_MFP_DISABLED = 0,
		IEEE80211_MFP_OPTIONAL = 1,
		IEEE80211_MFP_REQUIRED = 2,
	} mfp;
	unsigned int uapsd_queues;
	unsigned int uapsd_max_sp_len;
	int wmm_last_param_set;
	int mu_edca_last_param_set;
	u8 use_4addr;
	char: 8;
	s16 p2p_noa_index;
	struct ewma_beacon_signal ave_beacon_signal;
	unsigned int count_beacon_signal;
	unsigned int beacon_loss_count;
	int last_cqm_event_signal;
	int rssi_min_thold;
	int rssi_max_thold;
	int last_ave_beacon_signal;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	u8 tdls_peer[6];
	struct delayed_work tdls_peer_del_work;
	struct sk_buff *orig_teardown_skb;
	struct sk_buff *teardown_skb;
	spinlock_t teardown_lock;
	bool tdls_chan_switch_prohibited;
	bool tdls_wider_bw_prohibited;
	long: 48;
	struct ieee80211_sta_tx_tspec tx_tspec[4];
	struct delayed_work tx_tspec_wk;
	u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
} __attribute__((packed));

struct ieee80211_if_ibss {
	struct timer_list timer;
	struct work_struct csa_connection_drop_work;
	long unsigned int last_scan_completed;
	u32 basic_rates;
	bool fixed_bssid;
	bool fixed_channel;
	bool privacy;
	bool control_port;
	bool userspace_handles_dfs;
	char: 8;
	u8 bssid[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 ie_len;
	long: 48;
	u8 *ie;
	struct cfg80211_chan_def chandef;
	long unsigned int ibss_join_req;
	struct beacon_data *presp;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	int: 32;
	spinlock_t incomplete_lock;
	struct list_head incomplete_stations;
	enum {
		IEEE80211_IBSS_MLME_SEARCH = 0,
		IEEE80211_IBSS_MLME_JOINED = 1,
	} state;
	int: 32;
} __attribute__((packed));

struct mesh_preq_queue {
	struct list_head list;
	u8 dst[6];
	u8 flags;
};

struct mesh_stats {
	__u32 fwded_mcast;
	__u32 fwded_unicast;
	__u32 fwded_frames;
	__u32 dropped_frames_ttl;
	__u32 dropped_frames_no_route;
	__u32 dropped_frames_congestion;
};

struct mesh_rmc;

struct ieee80211_mesh_sync_ops;

struct mesh_csa_settings;

struct mesh_table;

struct ieee80211_if_mesh {
	struct timer_list housekeeping_timer;
	struct timer_list mesh_path_timer;
	struct timer_list mesh_path_root_timer;
	long unsigned int wrkq_flags;
	long unsigned int mbss_changed;
	bool userspace_handles_dfs;
	u8 mesh_id[32];
	size_t mesh_id_len;
	u8 mesh_pp_id;
	u8 mesh_pm_id;
	u8 mesh_cc_id;
	u8 mesh_sp_id;
	u8 mesh_auth_id;
	u32 sn;
	u32 preq_id;
	atomic_t mpaths;
	long unsigned int last_sn_update;
	long unsigned int next_perr;
	long unsigned int last_preq;
	struct mesh_rmc *rmc;
	spinlock_t mesh_preq_queue_lock;
	struct mesh_preq_queue preq_queue;
	int preq_queue_len;
	struct mesh_stats mshstats;
	struct mesh_config mshcfg;
	atomic_t estab_plinks;
	u32 mesh_seqnum;
	bool accepting_plinks;
	int num_gates;
	struct beacon_data *beacon;
	const u8 *ie;
	u8 ie_len;
	enum {
		IEEE80211_MESH_SEC_NONE = 0,
		IEEE80211_MESH_SEC_AUTHED = 1,
		IEEE80211_MESH_SEC_SECURED = 2,
	} security;
	bool user_mpm;
	const struct ieee80211_mesh_sync_ops *sync_ops;
	s64 sync_offset_clockdrift_max;
	spinlock_t sync_offset_lock;
	enum nl80211_mesh_power_mode nonpeer_pm;
	int ps_peers_light_sleep;
	int ps_peers_deep_sleep;
	struct ps_data ps;
	struct mesh_csa_settings *csa;
	enum {
		IEEE80211_MESH_CSA_ROLE_NONE = 0,
		IEEE80211_MESH_CSA_ROLE_INIT = 1,
		IEEE80211_MESH_CSA_ROLE_REPEATER = 2,
	} csa_role;
	u8 chsw_ttl;
	u16 pre_value;
	int meshconf_offset;
	struct mesh_table *mesh_paths;
	struct mesh_table *mpp_paths;
	int mesh_paths_generation;
	int mpp_paths_generation;
};

struct ieee80211_if_ocb {
	struct timer_list housekeeping_timer;
	long unsigned int wrkq_flags;
	spinlock_t incomplete_lock;
	struct list_head incomplete_stations;
	bool joined;
};

struct ieee80211_if_mntr {
	u32 flags;
	u8 mu_follow_addr[6];
	struct list_head list;
};

struct ieee80211_if_nan {
	struct cfg80211_nan_conf conf;
	spinlock_t func_lock;
	struct idr function_inst_ids;
};

struct mac80211_qos_map;

struct ieee80211_chanctx;

struct ieee80211_sub_if_data {
	struct list_head list;
	struct wireless_dev wdev;
	struct list_head key_list;
	int crypto_tx_tailroom_needed_cnt;
	int crypto_tx_tailroom_pending_dec;
	struct delayed_work dec_tailroom_needed_wk;
	struct net_device *dev;
	struct ieee80211_local *local;
	unsigned int flags;
	long unsigned int state;
	char name[16];
	struct ieee80211_fragment_entry fragments[4];
	unsigned int fragment_next;
	u16 noack_map;
	u8 wmm_acm;
	struct ieee80211_key *keys[8];
	struct ieee80211_key *default_unicast_key;
	struct ieee80211_key *default_multicast_key;
	struct ieee80211_key *default_mgmt_key;
	struct ieee80211_key *default_beacon_key;
	u16 sequence_number;
	__be16 control_port_protocol;
	bool control_port_no_encrypt;
	bool control_port_no_preauth;
	bool control_port_over_nl80211;
	int encrypt_headroom;
	atomic_t num_tx_queued;
	struct ieee80211_tx_queue_params tx_conf[4];
	struct mac80211_qos_map *qos_map;
	struct work_struct csa_finalize_work;
	bool csa_block_tx;
	struct cfg80211_chan_def csa_chandef;
	struct list_head assigned_chanctx_list;
	struct list_head reserved_chanctx_list;
	struct ieee80211_chanctx *reserved_chanctx;
	struct cfg80211_chan_def reserved_chandef;
	bool reserved_radar_required;
	bool reserved_ready;
	struct work_struct recalc_smps;
	struct work_struct work;
	struct sk_buff_head skb_queue;
	u8 needed_rx_chains;
	enum ieee80211_smps_mode smps_mode;
	int user_power_level;
	int ap_power_level;
	bool radar_required;
	struct delayed_work dfs_cac_timer_work;
	struct ieee80211_if_ap *bss;
	u32 rc_rateidx_mask[5];
	bool rc_has_mcs_mask[5];
	u8 rc_rateidx_mcs_mask[50];
	bool rc_has_vht_mcs_mask[5];
	u16 rc_rateidx_vht_mcs_mask[40];
	u32 beacon_rateidx_mask[5];
	bool beacon_rate_set;
	union {
		struct ieee80211_if_ap ap;
		struct ieee80211_if_vlan vlan;
		struct ieee80211_if_managed mgd;
		struct ieee80211_if_ibss ibss;
		struct ieee80211_if_mesh mesh;
		struct ieee80211_if_ocb ocb;
		struct ieee80211_if_mntr mntr;
		struct ieee80211_if_nan nan;
	} u;
	struct ieee80211_vif vif;
};

struct ieee80211_sta_rx_stats {
	long unsigned int packets;
	long unsigned int last_rx;
	long unsigned int num_duplicates;
	long unsigned int fragments;
	long unsigned int dropped;
	int last_signal;
	u8 chains;
	s8 chain_signal_last[4];
	u32 last_rate;
	struct u64_stats_sync syncp;
	u64 bytes;
	u64 msdu[17];
};

struct ewma_signal {
	long unsigned int internal;
};

struct ewma_avg_signal {
	long unsigned int internal;
};

struct airtime_info {
	u64 rx_airtime;
	u64 tx_airtime;
	s64 deficit;
	atomic_t aql_tx_pending;
	u32 aql_limit_low;
	u32 aql_limit_high;
};

struct tid_ampdu_rx;

struct tid_ampdu_tx;

struct sta_ampdu_mlme {
	struct mutex mtx;
	struct tid_ampdu_rx *tid_rx[16];
	u8 tid_rx_token[16];
	long unsigned int tid_rx_timer_expired[1];
	long unsigned int tid_rx_stop_requested[1];
	long unsigned int tid_rx_manage_offl[1];
	long unsigned int agg_session_valid[1];
	long unsigned int unexpected_agg[1];
	struct work_struct work;
	struct tid_ampdu_tx *tid_tx[16];
	struct tid_ampdu_tx *tid_start_tx[16];
	long unsigned int last_addba_req_time[16];
	u8 addba_req_num[16];
	u8 dialog_token_allocator;
};

struct ieee80211_fast_tx;

struct ieee80211_fast_rx;

struct sta_info {
	struct list_head list;
	struct list_head free_list;
	struct callback_head callback_head;
	struct rhlist_head hash_node;
	u8 addr[6];
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_key *gtk[8];
	struct ieee80211_key *ptk[4];
	u8 ptk_idx;
	struct rate_control_ref *rate_ctrl;
	void *rate_ctrl_priv;
	spinlock_t rate_ctrl_lock;
	spinlock_t lock;
	struct ieee80211_fast_tx *fast_tx;
	struct ieee80211_fast_rx *fast_rx;
	struct ieee80211_sta_rx_stats *pcpu_rx_stats;
	struct work_struct drv_deliver_wk;
	u16 listen_interval;
	bool dead;
	bool removed;
	bool uploaded;
	enum ieee80211_sta_state sta_state;
	long unsigned int _flags;
	spinlock_t ps_lock;
	struct sk_buff_head ps_tx_buf[4];
	struct sk_buff_head tx_filtered[4];
	long unsigned int driver_buffered_tids;
	long unsigned int txq_buffered_tids;
	u64 assoc_at;
	long int last_connected;
	struct ieee80211_sta_rx_stats rx_stats;
	struct {
		struct ewma_signal signal;
		struct ewma_signal chain_signal[4];
	} rx_stats_avg;
	__le16 last_seq_ctrl[17];
	struct {
		long unsigned int filtered;
		long unsigned int retry_failed;
		long unsigned int retry_count;
		unsigned int lost_packets;
		long unsigned int last_pkt_time;
		u64 msdu_retries[17];
		u64 msdu_failed[17];
		long unsigned int last_ack;
		s8 last_ack_signal;
		bool ack_signal_filled;
		struct ewma_avg_signal avg_ack_signal;
	} status_stats;
	struct {
		u64 packets[4];
		u64 bytes[4];
		struct ieee80211_tx_rate last_rate;
		struct rate_info last_rate_info;
		u64 msdu[17];
	} tx_stats;
	u16 tid_seq[16];
	struct airtime_info airtime[4];
	u16 airtime_weight;
	struct sta_ampdu_mlme ampdu_mlme;
	enum ieee80211_sta_rx_bandwidth cur_max_bandwidth;
	enum ieee80211_smps_mode known_smps_mode;
	const struct ieee80211_cipher_scheme *cipher_scheme;
	struct codel_params cparams;
	u8 reserved_tid;
	struct cfg80211_chan_def tdls_chandef;
	struct ieee80211_sta sta;
};

struct tid_ampdu_tx {
	struct callback_head callback_head;
	struct timer_list session_timer;
	struct timer_list addba_resp_timer;
	struct sk_buff_head pending;
	struct sta_info *sta;
	long unsigned int state;
	long unsigned int last_tx;
	u16 timeout;
	u8 dialog_token;
	u8 stop_initiator;
	bool tx_stop;
	u16 buf_size;
	u16 failed_bar_ssn;
	bool bar_pending;
	bool amsdu;
	u8 tid;
};

struct tid_ampdu_rx {
	struct callback_head callback_head;
	spinlock_t reorder_lock;
	u64 reorder_buf_filtered;
	struct sk_buff_head *reorder_buf;
	long unsigned int *reorder_time;
	struct sta_info *sta;
	struct timer_list session_timer;
	struct timer_list reorder_timer;
	long unsigned int last_rx;
	u16 head_seq_num;
	u16 stored_mpdu_num;
	u16 ssn;
	u16 buf_size;
	u16 timeout;
	u8 tid;
	u8 auto_seq: 1;
	u8 removed: 1;
	u8 started: 1;
};

struct ieee80211_fast_tx {
	struct ieee80211_key *key;
	u8 hdr_len;
	u8 sa_offs;
	u8 da_offs;
	u8 pn_offs;
	u8 band;
	char: 8;
	u8 hdr[56];
	struct callback_head callback_head;
};

struct ieee80211_fast_rx {
	struct net_device *dev;
	enum nl80211_iftype vif_type;
	u8 vif_addr[6];
	u8 rfc1042_hdr[6];
	__be16 control_port_protocol;
	__le16 expected_ds_bits;
	u8 icv_len;
	u8 key: 1;
	u8 internal_forward: 1;
	u8 uses_rss: 1;
	u8 da_offs;
	u8 sa_offs;
	struct callback_head callback_head;
};

struct rate_control_ref {
	const struct rate_control_ops *ops;
	void *priv;
};

struct beacon_data {
	u8 *head;
	u8 *tail;
	int head_len;
	int tail_len;
	struct ieee80211_meshconf_ie *meshconf;
	u16 cntdwn_counter_offsets[2];
	u8 cntdwn_current_counter;
	struct callback_head callback_head;
};

struct probe_resp {
	struct callback_head callback_head;
	int len;
	u16 cntdwn_counter_offsets[2];
	u8 data[0];
};

struct fils_discovery_data {
	struct callback_head callback_head;
	int len;
	u8 data[0];
};

struct unsol_bcast_probe_resp_data {
	struct callback_head callback_head;
	int len;
	u8 data[0];
};

struct ieee80211_mgd_auth_data {
	struct cfg80211_bss *bss;
	long unsigned int timeout;
	int tries;
	u16 algorithm;
	u16 expected_transaction;
	u8 key[13];
	u8 key_len;
	u8 key_idx;
	bool done;
	bool peer_confirmed;
	bool timeout_started;
	u16 sae_trans;
	u16 sae_status;
	size_t data_len;
	u8 data[0];
};

struct ieee80211_mgd_assoc_data {
	struct cfg80211_bss *bss;
	const u8 *supp_rates;
	long unsigned int timeout;
	int tries;
	u16 capability;
	u8 prev_bssid[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 supp_rates_len;
	bool wmm;
	bool uapsd;
	bool need_beacon;
	bool synced;
	bool timeout_started;
	u8 ap_ht_param;
	struct ieee80211_vht_cap ap_vht_cap;
	u8 fils_nonces[32];
	u8 fils_kek[64];
	size_t fils_kek_len;
	size_t ie_len;
	u8 ie[0];
};

struct ieee802_11_elems;

struct ieee80211_mesh_sync_ops {
	void (*rx_bcn_presp)(struct ieee80211_sub_if_data *, u16, struct ieee80211_mgmt *, struct ieee802_11_elems *, struct ieee80211_rx_status *);
	void (*adjust_tsf)(struct ieee80211_sub_if_data *, struct beacon_data *);
};

struct ieee802_11_elems {
	const u8 *ie_start;
	size_t total_len;
	const struct ieee80211_tdls_lnkie *lnk_id;
	const struct ieee80211_ch_switch_timing *ch_sw_timing;
	const u8 *ext_capab;
	const u8 *ssid;
	const u8 *supp_rates;
	const u8 *ds_params;
	const struct ieee80211_tim_ie *tim;
	const u8 *challenge;
	const u8 *rsn;
	const u8 *rsnx;
	const u8 *erp_info;
	const u8 *ext_supp_rates;
	const u8 *wmm_info;
	const u8 *wmm_param;
	const struct ieee80211_ht_cap *ht_cap_elem;
	const struct ieee80211_ht_operation *ht_operation;
	const struct ieee80211_vht_cap *vht_cap_elem;
	const struct ieee80211_vht_operation *vht_operation;
	const struct ieee80211_meshconf_ie *mesh_config;
	const u8 *he_cap;
	const struct ieee80211_he_operation *he_operation;
	const struct ieee80211_he_spr *he_spr;
	const struct ieee80211_mu_edca_param_set *mu_edca_param_set;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
	const u8 *uora_element;
	const u8 *mesh_id;
	const u8 *peering;
	const __le16 *awake_window;
	const u8 *preq;
	const u8 *prep;
	const u8 *perr;
	const struct ieee80211_rann_ie *rann;
	const struct ieee80211_channel_sw_ie *ch_switch_ie;
	const struct ieee80211_ext_chansw_ie *ext_chansw_ie;
	const struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;
	const u8 *max_channel_switch_time;
	const u8 *country_elem;
	const u8 *pwr_constr_elem;
	const u8 *cisco_dtpc_elem;
	const struct ieee80211_timeout_interval_ie *timeout_int;
	const u8 *opmode_notif;
	const struct ieee80211_sec_chan_offs_ie *sec_chan_offs;
	struct ieee80211_mesh_chansw_params_ie *mesh_chansw_params_ie;
	const struct ieee80211_bss_max_idle_period_ie *max_idle_period_ie;
	const struct ieee80211_multiple_bssid_configuration *mbssid_config_ie;
	const struct ieee80211_bssid_index *bssid_index;
	u8 max_bssid_indicator;
	u8 dtim_count;
	u8 dtim_period;
	const struct ieee80211_addba_ext_ie *addba_ext_ie;
	const struct ieee80211_s1g_cap *s1g_capab;
	const struct ieee80211_s1g_oper_ie *s1g_oper;
	const struct ieee80211_s1g_bcn_compat_ie *s1g_bcn_compat;
	const struct ieee80211_aid_response_ie *aid_resp;
	u8 ext_capab_len;
	u8 ssid_len;
	u8 supp_rates_len;
	u8 tim_len;
	u8 challenge_len;
	u8 rsn_len;
	u8 rsnx_len;
	u8 ext_supp_rates_len;
	u8 wmm_info_len;
	u8 wmm_param_len;
	u8 he_cap_len;
	u8 mesh_id_len;
	u8 peering_len;
	u8 preq_len;
	u8 prep_len;
	u8 perr_len;
	u8 country_elem_len;
	u8 bssid_index_len;
	bool parse_error;
};

struct mesh_csa_settings {
	struct callback_head callback_head;
	struct cfg80211_csa_settings settings;
};

struct mesh_rmc {
	struct hlist_head bucket[256];
	u32 idx_mask;
};

struct mesh_table {
	struct hlist_head known_gates;
	spinlock_t gates_lock;
	struct rhashtable rhead;
	struct hlist_head walk_head;
	spinlock_t walk_lock;
	atomic_t entries;
};

enum ieee80211_sub_if_data_flags {
	IEEE80211_SDATA_ALLMULTI = 1,
	IEEE80211_SDATA_OPERATING_GMODE = 4,
	IEEE80211_SDATA_DONT_BRIDGE_PACKETS = 8,
	IEEE80211_SDATA_DISCONNECT_RESUME = 16,
	IEEE80211_SDATA_IN_DRIVER = 32,
};

enum ieee80211_chanctx_mode {
	IEEE80211_CHANCTX_SHARED = 0,
	IEEE80211_CHANCTX_EXCLUSIVE = 1,
};

enum ieee80211_chanctx_replace_state {
	IEEE80211_CHANCTX_REPLACE_NONE = 0,
	IEEE80211_CHANCTX_WILL_BE_REPLACED = 1,
	IEEE80211_CHANCTX_REPLACES_OTHER = 2,
};

struct ieee80211_chanctx {
	struct list_head list;
	struct callback_head callback_head;
	struct list_head assigned_vifs;
	struct list_head reserved_vifs;
	enum ieee80211_chanctx_replace_state replace_state;
	struct ieee80211_chanctx *replace_ctx;
	enum ieee80211_chanctx_mode mode;
	bool driver_present;
	struct ieee80211_chanctx_conf conf;
};

struct mac80211_qos_map {
	struct cfg80211_qos_map qos_map;
	struct callback_head callback_head;
};

enum {
	IEEE80211_RX_MSG = 1,
	IEEE80211_TX_STATUS_MSG = 2,
};

enum queue_stop_reason {
	IEEE80211_QUEUE_STOP_REASON_DRIVER = 0,
	IEEE80211_QUEUE_STOP_REASON_PS = 1,
	IEEE80211_QUEUE_STOP_REASON_CSA = 2,
	IEEE80211_QUEUE_STOP_REASON_AGGREGATION = 3,
	IEEE80211_QUEUE_STOP_REASON_SUSPEND = 4,
	IEEE80211_QUEUE_STOP_REASON_SKB_ADD = 5,
	IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL = 6,
	IEEE80211_QUEUE_STOP_REASON_FLUSH = 7,
	IEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN = 8,
	IEEE80211_QUEUE_STOP_REASON_RESERVE_TID = 9,
	IEEE80211_QUEUE_STOP_REASONS = 10,
};

enum {
	SCAN_SW_SCANNING = 0,
	SCAN_HW_SCANNING = 1,
	SCAN_ONCHANNEL_SCANNING = 2,
	SCAN_COMPLETED = 3,
	SCAN_ABORTED = 4,
	SCAN_HW_CANCELLED = 5,
};

struct ieee80211_bar {
	__le16 frame_control;
	__le16 duration;
	__u8 ra[6];
	__u8 ta[6];
	__le16 control;
	__le16 start_seq_num;
};

enum ieee80211_ht_actioncode {
	WLAN_HT_ACTION_NOTIFY_CHANWIDTH = 0,
	WLAN_HT_ACTION_SMPS = 1,
	WLAN_HT_ACTION_PSMP = 2,
	WLAN_HT_ACTION_PCO_PHASE = 3,
	WLAN_HT_ACTION_CSI = 4,
	WLAN_HT_ACTION_NONCOMPRESSED_BF = 5,
	WLAN_HT_ACTION_COMPRESSED_BF = 6,
	WLAN_HT_ACTION_ASEL_IDX_FEEDBACK = 7,
};

enum ieee80211_tdls_actioncode {
	WLAN_TDLS_SETUP_REQUEST = 0,
	WLAN_TDLS_SETUP_RESPONSE = 1,
	WLAN_TDLS_SETUP_CONFIRM = 2,
	WLAN_TDLS_TEARDOWN = 3,
	WLAN_TDLS_PEER_TRAFFIC_INDICATION = 4,
	WLAN_TDLS_CHANNEL_SWITCH_REQUEST = 5,
	WLAN_TDLS_CHANNEL_SWITCH_RESPONSE = 6,
	WLAN_TDLS_PEER_PSM_REQUEST = 7,
	WLAN_TDLS_PEER_PSM_RESPONSE = 8,
	WLAN_TDLS_PEER_TRAFFIC_RESPONSE = 9,
	WLAN_TDLS_DISCOVERY_REQUEST = 10,
};

enum ieee80211_radiotap_tx_flags {
	IEEE80211_RADIOTAP_F_TX_FAIL = 1,
	IEEE80211_RADIOTAP_F_TX_CTS = 2,
	IEEE80211_RADIOTAP_F_TX_RTS = 4,
	IEEE80211_RADIOTAP_F_TX_NOACK = 8,
	IEEE80211_RADIOTAP_F_TX_NOSEQNO = 16,
	IEEE80211_RADIOTAP_F_TX_ORDER = 32,
};

enum ieee80211_radiotap_mcs_flags {
	IEEE80211_RADIOTAP_MCS_BW_MASK = 3,
	IEEE80211_RADIOTAP_MCS_BW_20 = 0,
	IEEE80211_RADIOTAP_MCS_BW_40 = 1,
	IEEE80211_RADIOTAP_MCS_BW_20L = 2,
	IEEE80211_RADIOTAP_MCS_BW_20U = 3,
	IEEE80211_RADIOTAP_MCS_SGI = 4,
	IEEE80211_RADIOTAP_MCS_FMT_GF = 8,
	IEEE80211_RADIOTAP_MCS_FEC_LDPC = 16,
	IEEE80211_RADIOTAP_MCS_STBC_MASK = 96,
	IEEE80211_RADIOTAP_MCS_STBC_1 = 1,
	IEEE80211_RADIOTAP_MCS_STBC_2 = 2,
	IEEE80211_RADIOTAP_MCS_STBC_3 = 3,
	IEEE80211_RADIOTAP_MCS_STBC_SHIFT = 5,
};

enum ieee80211_radiotap_vht_flags {
	IEEE80211_RADIOTAP_VHT_FLAG_STBC = 1,
	IEEE80211_RADIOTAP_VHT_FLAG_TXOP_PS_NA = 2,
	IEEE80211_RADIOTAP_VHT_FLAG_SGI = 4,
	IEEE80211_RADIOTAP_VHT_FLAG_SGI_NSYM_M10_9 = 8,
	IEEE80211_RADIOTAP_VHT_FLAG_LDPC_EXTRA_OFDM_SYM = 16,
	IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED = 32,
};

struct ieee80211_radiotap_he {
	__le16 data1;
	__le16 data2;
	__le16 data3;
	__le16 data4;
	__le16 data5;
	__le16 data6;
};

enum ieee80211_radiotap_he_bits {
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MASK = 3,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_SU = 0,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_EXT_SU = 1,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MU = 2,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_TRIG = 3,
	IEEE80211_RADIOTAP_HE_DATA1_BSS_COLOR_KNOWN = 4,
	IEEE80211_RADIOTAP_HE_DATA1_BEAM_CHANGE_KNOWN = 8,
	IEEE80211_RADIOTAP_HE_DATA1_UL_DL_KNOWN = 16,
	IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA1_DATA_DCM_KNOWN = 64,
	IEEE80211_RADIOTAP_HE_DATA1_CODING_KNOWN = 128,
	IEEE80211_RADIOTAP_HE_DATA1_LDPC_XSYMSEG_KNOWN = 256,
	IEEE80211_RADIOTAP_HE_DATA1_STBC_KNOWN = 512,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE_KNOWN = 1024,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE2_KNOWN = 2048,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE3_KNOWN = 4096,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE4_KNOWN = 8192,
	IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN = 16384,
	IEEE80211_RADIOTAP_HE_DATA1_DOPPLER_KNOWN = 32768,
	IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_KNOWN = 1,
	IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN = 2,
	IEEE80211_RADIOTAP_HE_DATA2_NUM_LTF_SYMS_KNOWN = 4,
	IEEE80211_RADIOTAP_HE_DATA2_PRE_FEC_PAD_KNOWN = 8,
	IEEE80211_RADIOTAP_HE_DATA2_TXBF_KNOWN = 16,
	IEEE80211_RADIOTAP_HE_DATA2_PE_DISAMBIG_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA2_TXOP_KNOWN = 64,
	IEEE80211_RADIOTAP_HE_DATA2_MIDAMBLE_KNOWN = 128,
	IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET = 16128,
	IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET_KNOWN = 16384,
	IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_SEC = 32768,
	IEEE80211_RADIOTAP_HE_DATA3_BSS_COLOR = 63,
	IEEE80211_RADIOTAP_HE_DATA3_BEAM_CHANGE = 64,
	IEEE80211_RADIOTAP_HE_DATA3_UL_DL = 128,
	IEEE80211_RADIOTAP_HE_DATA3_DATA_MCS = 3840,
	IEEE80211_RADIOTAP_HE_DATA3_DATA_DCM = 4096,
	IEEE80211_RADIOTAP_HE_DATA3_CODING = 8192,
	IEEE80211_RADIOTAP_HE_DATA3_LDPC_XSYMSEG = 16384,
	IEEE80211_RADIOTAP_HE_DATA3_STBC = 32768,
	IEEE80211_RADIOTAP_HE_DATA4_SU_MU_SPTL_REUSE = 15,
	IEEE80211_RADIOTAP_HE_DATA4_MU_STA_ID = 32752,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE1 = 15,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE2 = 240,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE3 = 3840,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE4 = 61440,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC = 15,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ = 0,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_40MHZ = 1,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_80MHZ = 2,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_160MHZ = 3,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_26T = 4,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_52T = 5,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_106T = 6,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_242T = 7,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_484T = 8,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_996T = 9,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_2x996T = 10,
	IEEE80211_RADIOTAP_HE_DATA5_GI = 48,
	IEEE80211_RADIOTAP_HE_DATA5_GI_0_8 = 0,
	IEEE80211_RADIOTAP_HE_DATA5_GI_1_6 = 1,
	IEEE80211_RADIOTAP_HE_DATA5_GI_3_2 = 2,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE = 192,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_UNKNOWN = 0,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_1X = 1,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X = 2,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X = 3,
	IEEE80211_RADIOTAP_HE_DATA5_NUM_LTF_SYMS = 1792,
	IEEE80211_RADIOTAP_HE_DATA5_PRE_FEC_PAD = 12288,
	IEEE80211_RADIOTAP_HE_DATA5_TXBF = 16384,
	IEEE80211_RADIOTAP_HE_DATA5_PE_DISAMBIG = 32768,
	IEEE80211_RADIOTAP_HE_DATA6_NSTS = 15,
	IEEE80211_RADIOTAP_HE_DATA6_DOPPLER = 16,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW = 192,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_20MHZ = 0,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_40MHZ = 1,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_80MHZ = 2,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_160MHZ = 3,
	IEEE80211_RADIOTAP_HE_DATA6_TXOP = 32512,
	IEEE80211_RADIOTAP_HE_DATA6_MIDAMBLE_PDCTY = 32768,
};

enum ieee80211_ac_numbers {
	IEEE80211_AC_VO = 0,
	IEEE80211_AC_VI = 1,
	IEEE80211_AC_BE = 2,
	IEEE80211_AC_BK = 3,
};

enum mac80211_tx_info_flags {
	IEEE80211_TX_CTL_REQ_TX_STATUS = 1,
	IEEE80211_TX_CTL_ASSIGN_SEQ = 2,
	IEEE80211_TX_CTL_NO_ACK = 4,
	IEEE80211_TX_CTL_CLEAR_PS_FILT = 8,
	IEEE80211_TX_CTL_FIRST_FRAGMENT = 16,
	IEEE80211_TX_CTL_SEND_AFTER_DTIM = 32,
	IEEE80211_TX_CTL_AMPDU = 64,
	IEEE80211_TX_CTL_INJECTED = 128,
	IEEE80211_TX_STAT_TX_FILTERED = 256,
	IEEE80211_TX_STAT_ACK = 512,
	IEEE80211_TX_STAT_AMPDU = 1024,
	IEEE80211_TX_STAT_AMPDU_NO_BACK = 2048,
	IEEE80211_TX_CTL_RATE_CTRL_PROBE = 4096,
	IEEE80211_TX_INTFL_OFFCHAN_TX_OK = 8192,
	IEEE80211_TX_CTL_HW_80211_ENCAP = 16384,
	IEEE80211_TX_INTFL_RETRIED = 32768,
	IEEE80211_TX_INTFL_DONT_ENCRYPT = 65536,
	IEEE80211_TX_CTL_NO_PS_BUFFER = 131072,
	IEEE80211_TX_CTL_MORE_FRAMES = 262144,
	IEEE80211_TX_INTFL_RETRANSMISSION = 524288,
	IEEE80211_TX_INTFL_MLME_CONN_TX = 1048576,
	IEEE80211_TX_INTFL_NL80211_FRAME_TX = 2097152,
	IEEE80211_TX_CTL_LDPC = 4194304,
	IEEE80211_TX_CTL_STBC = 25165824,
	IEEE80211_TX_CTL_TX_OFFCHAN = 33554432,
	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE = 67108864,
	IEEE80211_TX_CTL_NO_CCK_RATE = 134217728,
	IEEE80211_TX_STATUS_EOSP = 268435456,
	IEEE80211_TX_CTL_USE_MINRATE = 536870912,
	IEEE80211_TX_CTL_DONTFRAG = 1073741824,
	IEEE80211_TX_STAT_NOACK_TRANSMITTED = 2147483648,
};

enum mac80211_tx_control_flags {
	IEEE80211_TX_CTRL_PORT_CTRL_PROTO = 1,
	IEEE80211_TX_CTRL_PS_RESPONSE = 2,
	IEEE80211_TX_CTRL_RATE_INJECT = 4,
	IEEE80211_TX_CTRL_AMSDU = 8,
	IEEE80211_TX_CTRL_FAST_XMIT = 16,
	IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP = 32,
	IEEE80211_TX_INTCFL_NEED_TXPROCESSING = 64,
	IEEE80211_TX_CTRL_NO_SEQNO = 128,
	IEEE80211_TX_CTRL_DONT_REORDER = 256,
};

enum mac80211_rate_control_flags {
	IEEE80211_TX_RC_USE_RTS_CTS = 1,
	IEEE80211_TX_RC_USE_CTS_PROTECT = 2,
	IEEE80211_TX_RC_USE_SHORT_PREAMBLE = 4,
	IEEE80211_TX_RC_MCS = 8,
	IEEE80211_TX_RC_GREEN_FIELD = 16,
	IEEE80211_TX_RC_40_MHZ_WIDTH = 32,
	IEEE80211_TX_RC_DUP_DATA = 64,
	IEEE80211_TX_RC_SHORT_GI = 128,
	IEEE80211_TX_RC_VHT_MCS = 256,
	IEEE80211_TX_RC_80_MHZ_WIDTH = 512,
	IEEE80211_TX_RC_160_MHZ_WIDTH = 1024,
};

enum ieee80211_sta_info_flags {
	WLAN_STA_AUTH = 0,
	WLAN_STA_ASSOC = 1,
	WLAN_STA_PS_STA = 2,
	WLAN_STA_AUTHORIZED = 3,
	WLAN_STA_SHORT_PREAMBLE = 4,
	WLAN_STA_WDS = 5,
	WLAN_STA_CLEAR_PS_FILT = 6,
	WLAN_STA_MFP = 7,
	WLAN_STA_BLOCK_BA = 8,
	WLAN_STA_PS_DRIVER = 9,
	WLAN_STA_PSPOLL = 10,
	WLAN_STA_TDLS_PEER = 11,
	WLAN_STA_TDLS_PEER_AUTH = 12,
	WLAN_STA_TDLS_INITIATOR = 13,
	WLAN_STA_TDLS_CHAN_SWITCH = 14,
	WLAN_STA_TDLS_OFF_CHANNEL = 15,
	WLAN_STA_TDLS_WIDER_BW = 16,
	WLAN_STA_UAPSD = 17,
	WLAN_STA_SP = 18,
	WLAN_STA_4ADDR_EVENT = 19,
	WLAN_STA_INSERTED = 20,
	WLAN_STA_RATE_CONTROL = 21,
	WLAN_STA_TOFFSET_KNOWN = 22,
	WLAN_STA_MPSP_OWNER = 23,
	WLAN_STA_MPSP_RECIPIENT = 24,
	WLAN_STA_PS_DELIVER = 25,
	WLAN_STA_USES_ENCRYPTION = 26,
	NUM_WLAN_STA_FLAGS = 27,
};

enum ieee80211_sta_flags {
	IEEE80211_STA_CONNECTION_POLL = 2,
	IEEE80211_STA_CONTROL_PORT = 4,
	IEEE80211_STA_DISABLE_HT = 16,
	IEEE80211_STA_MFP_ENABLED = 64,
	IEEE80211_STA_UAPSD_ENABLED = 128,
	IEEE80211_STA_NULLFUNC_ACKED = 256,
	IEEE80211_STA_RESET_SIGNAL_AVE = 512,
	IEEE80211_STA_DISABLE_40MHZ = 1024,
	IEEE80211_STA_DISABLE_VHT = 2048,
	IEEE80211_STA_DISABLE_80P80MHZ = 4096,
	IEEE80211_STA_DISABLE_160MHZ = 8192,
	IEEE80211_STA_DISABLE_WMM = 16384,
	IEEE80211_STA_ENABLE_RRM = 32768,
	IEEE80211_STA_DISABLE_HE = 65536,
};

enum ieee80211_sdata_state_bits {
	SDATA_STATE_RUNNING = 0,
	SDATA_STATE_OFFCHANNEL = 1,
	SDATA_STATE_OFFCHANNEL_BEACON_STOPPED = 2,
};

enum ieee80211_rate_control_changed {
	IEEE80211_RC_BW_CHANGED = 1,
	IEEE80211_RC_SMPS_CHANGED = 2,
	IEEE80211_RC_SUPP_RATES_CHANGED = 4,
	IEEE80211_RC_NSS_CHANGED = 8,
};

struct ieee80211_qos_hdr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	__le16 qos_ctrl;
};

enum ieee80211_vif_flags {
	IEEE80211_VIF_BEACON_FILTER = 1,
	IEEE80211_VIF_SUPPORTS_CQM_RSSI = 2,
	IEEE80211_VIF_SUPPORTS_UAPSD = 4,
	IEEE80211_VIF_GET_NOA_UPDATE = 8,
};

enum ieee80211_agg_stop_reason {
	AGG_STOP_DECLINED = 0,
	AGG_STOP_LOCAL_REQUEST = 1,
	AGG_STOP_PEER_REQUEST = 2,
	AGG_STOP_DESTROY_STA = 3,
};

enum sta_stats_type {
	STA_STATS_RATE_TYPE_INVALID = 0,
	STA_STATS_RATE_TYPE_LEGACY = 1,
	STA_STATS_RATE_TYPE_HT = 2,
	STA_STATS_RATE_TYPE_VHT = 3,
	STA_STATS_RATE_TYPE_HE = 4,
	STA_STATS_RATE_TYPE_S1G = 5,
};

struct txq_info {
	struct fq_tin tin;
	struct fq_flow___2 def_flow;
	struct codel_vars def_cvars;
	struct codel_stats cstats;
	struct sk_buff_head frags;
	struct list_head schedule_order;
	u16 schedule_round;
	long unsigned int flags;
	struct ieee80211_txq txq;
};

enum mac80211_rx_flags {
	RX_FLAG_MMIC_ERROR = 1,
	RX_FLAG_DECRYPTED = 2,
	RX_FLAG_MACTIME_PLCP_START = 4,
	RX_FLAG_MMIC_STRIPPED = 8,
	RX_FLAG_IV_STRIPPED = 16,
	RX_FLAG_FAILED_FCS_CRC = 32,
	RX_FLAG_FAILED_PLCP_CRC = 64,
	RX_FLAG_MACTIME_START = 128,
	RX_FLAG_NO_SIGNAL_VAL = 256,
	RX_FLAG_AMPDU_DETAILS = 512,
	RX_FLAG_PN_VALIDATED = 1024,
	RX_FLAG_DUP_VALIDATED = 2048,
	RX_FLAG_AMPDU_LAST_KNOWN = 4096,
	RX_FLAG_AMPDU_IS_LAST = 8192,
	RX_FLAG_AMPDU_DELIM_CRC_ERROR = 16384,
	RX_FLAG_AMPDU_DELIM_CRC_KNOWN = 32768,
	RX_FLAG_MACTIME_END = 65536,
	RX_FLAG_ONLY_MONITOR = 131072,
	RX_FLAG_SKIP_MONITOR = 262144,
	RX_FLAG_AMSDU_MORE = 524288,
	RX_FLAG_RADIOTAP_VENDOR_DATA = 1048576,
	RX_FLAG_MIC_STRIPPED = 2097152,
	RX_FLAG_ALLOW_SAME_PN = 4194304,
	RX_FLAG_ICV_STRIPPED = 8388608,
	RX_FLAG_AMPDU_EOF_BIT = 16777216,
	RX_FLAG_AMPDU_EOF_BIT_KNOWN = 33554432,
	RX_FLAG_RADIOTAP_HE = 67108864,
	RX_FLAG_RADIOTAP_HE_MU = 134217728,
	RX_FLAG_RADIOTAP_LSIG = 268435456,
	RX_FLAG_NO_PSDU = 536870912,
};

enum ieee80211_key_flags {
	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT = 1,
	IEEE80211_KEY_FLAG_GENERATE_IV = 2,
	IEEE80211_KEY_FLAG_GENERATE_MMIC = 4,
	IEEE80211_KEY_FLAG_PAIRWISE = 8,
	IEEE80211_KEY_FLAG_SW_MGMT_TX = 16,
	IEEE80211_KEY_FLAG_PUT_IV_SPACE = 32,
	IEEE80211_KEY_FLAG_RX_MGMT = 64,
	IEEE80211_KEY_FLAG_RESERVE_TAILROOM = 128,
	IEEE80211_KEY_FLAG_PUT_MIC_SPACE = 256,
	IEEE80211_KEY_FLAG_NO_AUTO_TX = 512,
	IEEE80211_KEY_FLAG_GENERATE_MMIE = 1024,
};

typedef unsigned int ieee80211_tx_result;

struct ieee80211_tx_data {
	struct sk_buff *skb;
	struct sk_buff_head skbs;
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct ieee80211_key *key;
	struct ieee80211_tx_rate rate;
	unsigned int flags;
};

typedef unsigned int ieee80211_rx_result;

struct ieee80211_rx_data {
	struct list_head *list;
	struct sk_buff *skb;
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct ieee80211_key *key;
	unsigned int flags;
	int seqno_idx;
	int security_idx;
	u32 tkip_iv32;
	u16 tkip_iv16;
};

struct ieee80211_mmie {
	u8 element_id;
	u8 length;
	__le16 key_id;
	u8 sequence_number[6];
	u8 mic[8];
};

struct ieee80211_mmie_16 {
	u8 element_id;
	u8 length;
	__le16 key_id;
	u8 sequence_number[6];
	u8 mic[16];
};

enum ieee80211_internal_key_flags {
	KEY_FLAG_UPLOADED_TO_HARDWARE = 1,
	KEY_FLAG_TAINTED = 2,
	KEY_FLAG_CIPHER_SCHEME = 4,
};

enum {
	TKIP_DECRYPT_OK = 0,
	TKIP_DECRYPT_NO_EXT_IV = 4294967295,
	TKIP_DECRYPT_INVALID_KEYIDX = 4294967294,
	TKIP_DECRYPT_REPLAY = 4294967293,
};

enum mac80211_rx_encoding {
	RX_ENC_LEGACY = 0,
	RX_ENC_HT = 1,
	RX_ENC_VHT = 2,
	RX_ENC_HE = 3,
};

struct ieee80211_bss {
	u32 device_ts_beacon;
	u32 device_ts_presp;
	bool wmm_used;
	bool uapsd_supported;
	u8 supp_rates[32];
	size_t supp_rates_len;
	struct ieee80211_rate *beacon_rate;
	u32 vht_cap_info;
	bool has_erp_value;
	u8 erp_value;
	u8 corrupt_data;
	u8 valid_data;
};

enum ieee80211_bss_corrupt_data_flags {
	IEEE80211_BSS_CORRUPT_BEACON = 1,
	IEEE80211_BSS_CORRUPT_PROBE_RESP = 2,
};

enum ieee80211_bss_valid_data_flags {
	IEEE80211_BSS_VALID_WMM = 2,
	IEEE80211_BSS_VALID_RATES = 4,
	IEEE80211_BSS_VALID_ERP = 8,
};

enum {
	IEEE80211_PROBE_FLAG_DIRECTED = 1,
	IEEE80211_PROBE_FLAG_MIN_CONTENT = 2,
	IEEE80211_PROBE_FLAG_RANDOM_SN = 4,
};

struct ieee80211_roc_work {
	struct list_head list;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_channel *chan;
	bool started;
	bool abort;
	bool hw_begun;
	bool notified;
	bool on_channel;
	long unsigned int start_time;
	u32 duration;
	u32 req_duration;
	struct sk_buff *frame;
	u64 cookie;
	u64 mgmt_tx_cookie;
	enum ieee80211_roc_type type;
};

enum ieee80211_back_actioncode {
	WLAN_ACTION_ADDBA_REQ = 0,
	WLAN_ACTION_ADDBA_RESP = 1,
	WLAN_ACTION_DELBA = 2,
};

enum ieee80211_back_parties {
	WLAN_BACK_RECIPIENT = 0,
	WLAN_BACK_INITIATOR = 1,
};

enum txq_info_flags {
	IEEE80211_TXQ_STOP = 0,
	IEEE80211_TXQ_AMPDU = 1,
	IEEE80211_TXQ_NO_AMSDU = 2,
	IEEE80211_TXQ_STOP_NETIF_TX = 3,
};

enum ieee80211_vht_opmode_bits {
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK = 3,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ = 0,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ = 1,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ = 2,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ = 3,
	IEEE80211_OPMODE_NOTIF_BW_160_80P80 = 4,
	IEEE80211_OPMODE_NOTIF_RX_NSS_MASK = 112,
	IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT = 4,
	IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF = 128,
};

enum ieee80211_spectrum_mgmt_actioncode {
	WLAN_ACTION_SPCT_MSR_REQ = 0,
	WLAN_ACTION_SPCT_MSR_RPRT = 1,
	WLAN_ACTION_SPCT_TPC_REQ = 2,
	WLAN_ACTION_SPCT_TPC_RPRT = 3,
	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
};

struct ieee80211_csa_ie {
	struct cfg80211_chan_def chandef;
	u8 mode;
	u8 count;
	u8 ttl;
	u16 pre_value;
	u16 reason_code;
	u32 max_switch_time;
};

enum ieee80211_vht_actioncode {
	WLAN_VHT_ACTION_COMPRESSED_BF = 0,
	WLAN_VHT_ACTION_GROUPID_MGMT = 1,
	WLAN_VHT_ACTION_OPMODE_NOTIF = 2,
};

enum ieee80211_offload_flags {
	IEEE80211_OFFLOAD_ENCAP_ENABLED = 1,
	IEEE80211_OFFLOAD_ENCAP_4ADDR = 2,
};

enum ieee80211_tpt_led_trigger_flags {
	IEEE80211_TPT_LEDTRIG_FL_RADIO = 1,
	IEEE80211_TPT_LEDTRIG_FL_WORK = 2,
	IEEE80211_TPT_LEDTRIG_FL_CONNECTED = 4,
};

struct rate_control_alg {
	struct list_head list;
	const struct rate_control_ops *ops;
};

struct michael_mic_ctx {
	u32 l;
	u32 r;
};

struct ieee80211_csa_settings {
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	int n_counter_offsets_beacon;
	int n_counter_offsets_presp;
	u8 count;
};

struct ieee80211_hdr_3addr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
};

enum ieee80211_ht_chanwidth_values {
	IEEE80211_HT_CHANWIDTH_20MHZ = 0,
	IEEE80211_HT_CHANWIDTH_ANY = 1,
};

struct ieee80211_tdls_data {
	u8 da[6];
	u8 sa[6];
	__be16 ether_type;
	u8 payload_type;
	u8 category;
	u8 action_code;
	union {
		struct {
			u8 dialog_token;
			__le16 capability;
			u8 variable[0];
		} __attribute__((packed)) setup_req;
		struct {
			__le16 status_code;
			u8 dialog_token;
			__le16 capability;
			u8 variable[0];
		} __attribute__((packed)) setup_resp;
		struct {
			__le16 status_code;
			u8 dialog_token;
			u8 variable[0];
		} __attribute__((packed)) setup_cfm;
		struct {
			__le16 reason_code;
			u8 variable[0];
		} teardown;
		struct {
			u8 dialog_token;
			u8 variable[0];
		} discover_req;
		struct {
			u8 target_channel;
			u8 oper_class;
			u8 variable[0];
		} chan_switch_req;
		struct {
			__le16 status_code;
			u8 variable[0];
		} chan_switch_resp;
	} u;
} __attribute__((packed));

enum ieee80211_self_protected_actioncode {
	WLAN_SP_RESERVED = 0,
	WLAN_SP_MESH_PEERING_OPEN = 1,
	WLAN_SP_MESH_PEERING_CONFIRM = 2,
	WLAN_SP_MESH_PEERING_CLOSE = 3,
	WLAN_SP_MGK_INFORM = 4,
	WLAN_SP_MGK_ACK = 5,
};

enum ieee80211_pub_actioncode {
	WLAN_PUB_ACTION_20_40_BSS_COEX = 0,
	WLAN_PUB_ACTION_DSE_ENABLEMENT = 1,
	WLAN_PUB_ACTION_DSE_DEENABLEMENT = 2,
	WLAN_PUB_ACTION_DSE_REG_LOC_ANN = 3,
	WLAN_PUB_ACTION_EXT_CHANSW_ANN = 4,
	WLAN_PUB_ACTION_DSE_MSMT_REQ = 5,
	WLAN_PUB_ACTION_DSE_MSMT_RESP = 6,
	WLAN_PUB_ACTION_MSMT_PILOT = 7,
	WLAN_PUB_ACTION_DSE_PC = 8,
	WLAN_PUB_ACTION_VENDOR_SPECIFIC = 9,
	WLAN_PUB_ACTION_GAS_INITIAL_REQ = 10,
	WLAN_PUB_ACTION_GAS_INITIAL_RESP = 11,
	WLAN_PUB_ACTION_GAS_COMEBACK_REQ = 12,
	WLAN_PUB_ACTION_GAS_COMEBACK_RESP = 13,
	WLAN_PUB_ACTION_TDLS_DISCOVER_RES = 14,
	WLAN_PUB_ACTION_LOC_TRACK_NOTI = 15,
	WLAN_PUB_ACTION_QAB_REQUEST_FRAME = 16,
	WLAN_PUB_ACTION_QAB_RESPONSE_FRAME = 17,
	WLAN_PUB_ACTION_QMF_POLICY = 18,
	WLAN_PUB_ACTION_QMF_POLICY_CHANGE = 19,
	WLAN_PUB_ACTION_QLOAD_REQUEST = 20,
	WLAN_PUB_ACTION_QLOAD_REPORT = 21,
	WLAN_PUB_ACTION_HCCA_TXOP_ADVERT = 22,
	WLAN_PUB_ACTION_HCCA_TXOP_RESPONSE = 23,
	WLAN_PUB_ACTION_PUBLIC_KEY = 24,
	WLAN_PUB_ACTION_CHANNEL_AVAIL_QUERY = 25,
	WLAN_PUB_ACTION_CHANNEL_SCHEDULE_MGMT = 26,
	WLAN_PUB_ACTION_CONTACT_VERI_SIGNAL = 27,
	WLAN_PUB_ACTION_GDD_ENABLEMENT_REQ = 28,
	WLAN_PUB_ACTION_GDD_ENABLEMENT_RESP = 29,
	WLAN_PUB_ACTION_NETWORK_CHANNEL_CONTROL = 30,
	WLAN_PUB_ACTION_WHITE_SPACE_MAP_ANN = 31,
	WLAN_PUB_ACTION_FTM_REQUEST = 32,
	WLAN_PUB_ACTION_FTM = 33,
	WLAN_PUB_ACTION_FILS_DISCOVERY = 34,
};

enum ieee80211_sa_query_action {
	WLAN_ACTION_SA_QUERY_REQUEST = 0,
	WLAN_ACTION_SA_QUERY_RESPONSE = 1,
};

enum ieee80211_radiotap_flags {
	IEEE80211_RADIOTAP_F_CFP = 1,
	IEEE80211_RADIOTAP_F_SHORTPRE = 2,
	IEEE80211_RADIOTAP_F_WEP = 4,
	IEEE80211_RADIOTAP_F_FRAG = 8,
	IEEE80211_RADIOTAP_F_FCS = 16,
	IEEE80211_RADIOTAP_F_DATAPAD = 32,
	IEEE80211_RADIOTAP_F_BADFCS = 64,
};

enum ieee80211_radiotap_channel_flags {
	IEEE80211_CHAN_CCK = 32,
	IEEE80211_CHAN_OFDM = 64,
	IEEE80211_CHAN_2GHZ = 128,
	IEEE80211_CHAN_5GHZ = 256,
	IEEE80211_CHAN_DYN = 1024,
	IEEE80211_CHAN_HALF = 16384,
	IEEE80211_CHAN_QUARTER = 32768,
};

enum ieee80211_radiotap_rx_flags {
	IEEE80211_RADIOTAP_F_RX_BADPLCP = 2,
};

enum ieee80211_radiotap_ampdu_flags {
	IEEE80211_RADIOTAP_AMPDU_REPORT_ZEROLEN = 1,
	IEEE80211_RADIOTAP_AMPDU_IS_ZEROLEN = 2,
	IEEE80211_RADIOTAP_AMPDU_LAST_KNOWN = 4,
	IEEE80211_RADIOTAP_AMPDU_IS_LAST = 8,
	IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR = 16,
	IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN = 32,
	IEEE80211_RADIOTAP_AMPDU_EOF = 64,
	IEEE80211_RADIOTAP_AMPDU_EOF_KNOWN = 128,
};

enum ieee80211_radiotap_vht_coding {
	IEEE80211_RADIOTAP_CODING_LDPC_USER0 = 1,
	IEEE80211_RADIOTAP_CODING_LDPC_USER1 = 2,
	IEEE80211_RADIOTAP_CODING_LDPC_USER2 = 4,
	IEEE80211_RADIOTAP_CODING_LDPC_USER3 = 8,
};

enum ieee80211_radiotap_timestamp_flags {
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_64BIT = 0,
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_32BIT = 1,
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_ACCURACY = 2,
};

struct ieee80211_radiotap_he_mu {
	__le16 flags1;
	__le16 flags2;
	u8 ru_ch1[4];
	u8 ru_ch2[4];
};

struct ieee80211_radiotap_lsig {
	__le16 data1;
	__le16 data2;
};

enum mac80211_rx_encoding_flags {
	RX_ENC_FLAG_SHORTPRE = 1,
	RX_ENC_FLAG_SHORT_GI = 4,
	RX_ENC_FLAG_HT_GF = 8,
	RX_ENC_FLAG_STBC_MASK = 48,
	RX_ENC_FLAG_LDPC = 64,
	RX_ENC_FLAG_BF = 128,
};

struct ieee80211_vendor_radiotap {
	u32 present;
	u8 align;
	u8 oui[3];
	u8 subns;
	u8 pad;
	u16 len;
	u8 data[0];
};

enum ieee80211_packet_rx_flags {
	IEEE80211_RX_AMSDU = 8,
	IEEE80211_RX_MALFORMED_ACTION_FRM = 16,
	IEEE80211_RX_DEFERRED_RELEASE = 32,
};

enum ieee80211_rx_flags {
	IEEE80211_RX_CMNTR = 1,
	IEEE80211_RX_BEACON_REPORTED = 2,
};

struct ieee80211_rts {
	__le16 frame_control;
	__le16 duration;
	u8 ra[6];
	u8 ta[6];
};

struct ieee80211_cts {
	__le16 frame_control;
	__le16 duration;
	u8 ra[6];
};

struct ieee80211_pspoll {
	__le16 frame_control;
	__le16 aid;
	u8 bssid[6];
	u8 ta[6];
};

struct ieee80211_mutable_offsets {
	u16 tim_offset;
	u16 tim_length;
	u16 cntdwn_counter_offs[2];
};

typedef struct sk_buff *fq_tin_dequeue_t(struct fq *, struct fq_tin *, struct fq_flow___2 *);

typedef void fq_skb_free_t(struct fq *, struct fq_tin *, struct fq_flow___2 *, struct sk_buff *);

typedef bool fq_skb_filter_t(struct fq *, struct fq_tin *, struct fq_flow___2 *, struct sk_buff *, void *);

typedef struct fq_flow___2 *fq_flow_get_default_t(struct fq *, struct fq_tin *, int, struct sk_buff *);

enum mesh_path_flags {
	MESH_PATH_ACTIVE = 1,
	MESH_PATH_RESOLVING = 2,
	MESH_PATH_SN_VALID = 4,
	MESH_PATH_FIXED = 8,
	MESH_PATH_RESOLVED = 16,
	MESH_PATH_REQ_QUEUED = 32,
	MESH_PATH_DELETED = 64,
};

struct mesh_path {
	u8 dst[6];
	u8 mpp[6];
	struct rhash_head rhash;
	struct hlist_node walk_list;
	struct hlist_node gate_list;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *next_hop;
	struct timer_list timer;
	struct sk_buff_head frame_queue;
	struct callback_head rcu;
	u32 sn;
	u32 metric;
	u8 hop_count;
	long unsigned int exp_time;
	u32 discovery_timeout;
	u8 discovery_retries;
	enum mesh_path_flags flags;
	spinlock_t state_lock;
	u8 rann_snd_addr[6];
	u32 rann_metric;
	long unsigned int last_preq_to_root;
	bool is_root;
	bool is_gate;
	u32 path_change_count;
};

enum ieee80211_encrypt {
	ENCRYPT_NO = 0,
	ENCRYPT_MGMT = 1,
	ENCRYPT_DATA = 2,
};

enum ieee80211_s1g_chanwidth {
	IEEE80211_S1G_CHANWIDTH_1MHZ = 0,
	IEEE80211_S1G_CHANWIDTH_2MHZ = 1,
	IEEE80211_S1G_CHANWIDTH_4MHZ = 3,
	IEEE80211_S1G_CHANWIDTH_8MHZ = 7,
	IEEE80211_S1G_CHANWIDTH_16MHZ = 15,
};

struct ieee80211_he_6ghz_oper {
	u8 primary;
	u8 control;
	u8 ccfs0;
	u8 ccfs1;
	u8 minrate;
};

enum ieee80211_interface_iteration_flags {
	IEEE80211_IFACE_ITER_NORMAL = 0,
	IEEE80211_IFACE_ITER_RESUME_ALL = 1,
	IEEE80211_IFACE_ITER_ACTIVE = 2,
	IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER = 4,
};

struct ieee80211_noa_data {
	u32 next_tsf;
	bool has_next_tsf;
	u8 absent;
	u8 count[4];
	struct {
		u32 start;
		u32 duration;
		u32 interval;
	} desc[4];
};

enum ieee80211_chanctx_change {
	IEEE80211_CHANCTX_CHANGE_WIDTH = 1,
	IEEE80211_CHANCTX_CHANGE_RX_CHAINS = 2,
	IEEE80211_CHANCTX_CHANGE_RADAR = 4,
	IEEE80211_CHANCTX_CHANGE_CHANNEL = 8,
	IEEE80211_CHANCTX_CHANGE_MIN_WIDTH = 16,
};

struct trace_vif_entry {
	enum nl80211_iftype vif_type;
	bool p2p;
	char vif_name[16];
} __attribute__((packed));

struct trace_chandef_entry {
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
};

struct trace_switch_entry {
	struct trace_vif_entry vif;
	struct trace_chandef_entry old_chandef;
	struct trace_chandef_entry new_chandef;
} __attribute__((packed));

struct trace_event_raw_local_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_local_sdata_addr_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char addr[6];
	char __data[0];
};

struct trace_event_raw_local_u32_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 value;
	char __data[0];
};

struct trace_event_raw_local_sdata_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_return_bool {
	struct trace_entry ent;
	char wiphy_name[32];
	bool ret;
	char __data[0];
};

struct trace_event_raw_drv_return_u32 {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 ret;
	char __data[0];
};

struct trace_event_raw_drv_return_u64 {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 ret;
	char __data[0];
};

struct trace_event_raw_drv_set_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_drv_change_interface {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 new_type;
	bool new_p2p;
	char __data[0];
};

struct trace_event_raw_drv_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	u32 flags;
	int power_level;
	int dynamic_ps_timeout;
	u16 listen_interval;
	u8 long_frame_max_tx_count;
	u8 short_frame_max_tx_count;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	int smps;
	char __data[0];
};

struct trace_event_raw_drv_bss_info_changed {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 changed;
	bool assoc;
	bool ibss_joined;
	bool ibss_creator;
	u16 aid;
	bool cts;
	bool shortpre;
	bool shortslot;
	bool enable_beacon;
	u8 dtimper;
	u16 bcnint;
	u16 assoc_cap;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	int mcast_rate[5];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	s32 cqm_rssi_hyst;
	u32 channel_width;
	u32 channel_cfreq1;
	u32 channel_cfreq1_offset;
	u32 __data_loc_arp_addr_list;
	int arp_addr_cnt;
	bool qos;
	bool idle;
	bool ps;
	u32 __data_loc_ssid;
	bool hidden_ssid;
	int txpower;
	u8 p2p_oppps_ctwindow;
	char __data[0];
};

struct trace_event_raw_drv_prepare_multicast {
	struct trace_entry ent;
	char wiphy_name[32];
	int mc_count;
	char __data[0];
};

struct trace_event_raw_drv_configure_filter {
	struct trace_entry ent;
	char wiphy_name[32];
	unsigned int changed;
	unsigned int total;
	u64 multicast;
	char __data[0];
};

struct trace_event_raw_drv_config_iface_filter {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	unsigned int filter_flags;
	unsigned int changed_flags;
	char __data[0];
};

struct trace_event_raw_drv_set_tim {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	bool set;
	char __data[0];
};

struct trace_event_raw_drv_set_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 cipher;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	char __data[0];
};

struct trace_event_raw_drv_update_tkip_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 iv32;
	char __data[0];
};

struct trace_event_raw_drv_sw_scan_start {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char mac_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_get_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	unsigned int ackfail;
	unsigned int rtsfail;
	unsigned int fcserr;
	unsigned int rtssucc;
	char __data[0];
};

struct trace_event_raw_drv_get_key_seq {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 cipher;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	char __data[0];
};

struct trace_event_raw_drv_set_coverage_class {
	struct trace_entry ent;
	char wiphy_name[32];
	s16 value;
	char __data[0];
};

struct trace_event_raw_drv_sta_notify {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 cmd;
	char __data[0];
};

struct trace_event_raw_drv_sta_state {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 old_state;
	u32 new_state;
	char __data[0];
};

struct trace_event_raw_drv_sta_set_txpwr {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	s16 txpwr;
	u8 type;
	char __data[0];
};

struct trace_event_raw_drv_sta_rc_update {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 changed;
	char __data[0];
};

struct trace_event_raw_sta_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_conf_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u16 ac;
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool uapsd;
	char __data[0];
};

struct trace_event_raw_drv_set_tsf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u64 tsf;
	char __data[0];
};

struct trace_event_raw_drv_offset_tsf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	s64 tsf_offset;
	char __data[0];
};

struct trace_event_raw_drv_ampdu_action {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	enum ieee80211_ampdu_mlme_action ieee80211_ampdu_mlme_action;
	char sta_addr[6];
	u16 tid;
	u16 ssn;
	u16 buf_size;
	bool amsdu;
	u16 timeout;
	u16 action;
	char __data[0];
};

struct trace_event_raw_drv_get_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	int idx;
	char __data[0];
};

struct trace_event_raw_drv_flush {
	struct trace_entry ent;
	char wiphy_name[32];
	bool drop;
	u32 queues;
	char __data[0];
};

struct trace_event_raw_drv_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	char __data[0];
};

struct trace_event_raw_drv_set_antenna {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx_ant;
	u32 rx_ant;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_get_antenna {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx_ant;
	u32 rx_ant;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int center_freq;
	int freq_offset;
	unsigned int duration;
	u32 type;
	char __data[0];
};

struct trace_event_raw_drv_set_ringparam {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_drv_get_ringparam {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_drv_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 legacy_2g;
	u32 legacy_5g;
	char __data[0];
};

struct trace_event_raw_drv_set_rekey_data {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 kek[16];
	u8 kck[16];
	u8 replay_ctr[8];
	char __data[0];
};

struct trace_event_raw_drv_event_callback {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 type;
	char __data[0];
};

struct trace_event_raw_release_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u16 tids;
	int num_frames;
	int reason;
	bool more_data;
	char __data[0];
};

struct trace_event_raw_drv_mgd_prepare_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 duration;
	char __data[0];
};

struct trace_event_raw_local_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	char __data[0];
};

struct trace_event_raw_drv_change_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_drv_switch_vif_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_vifs;
	u32 mode;
	u32 __data_loc_vifs;
	char __data[0];
};

struct trace_event_raw_local_sdata_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	char __data[0];
};

struct trace_event_raw_drv_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 dtimper;
	u16 bcnint;
	u32 __data_loc_ssid;
	bool hidden_ssid;
	char __data[0];
};

struct trace_event_raw_drv_reconfig_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u8 reconfig_type;
	char __data[0];
};

struct trace_event_raw_drv_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 dtimper;
	u16 bcnint;
	u32 __data_loc_ssid;
	char __data[0];
};

struct trace_event_raw_drv_get_expected_throughput {
	struct trace_entry ent;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_drv_stop_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_drv_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 type;
	u8 inst_id;
	char __data[0];
};

struct trace_event_raw_drv_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 instance_id;
	char __data[0];
};

struct trace_event_raw_api_start_tx_ba_session {
	struct trace_entry ent;
	char sta_addr[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_start_tx_ba_cb {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 ra[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_stop_tx_ba_session {
	struct trace_entry ent;
	char sta_addr[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_stop_tx_ba_cb {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 ra[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_beacon_loss {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_api_connection_loss {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_api_cqm_rssi_notify {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_api_scan_completed {
	struct trace_entry ent;
	char wiphy_name[32];
	bool aborted;
	char __data[0];
};

struct trace_event_raw_api_sched_scan_results {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_sched_scan_stopped {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_sta_block_awake {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	bool block;
	char __data[0];
};

struct trace_event_raw_api_chswitch_done {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	bool success;
	char __data[0];
};

struct trace_event_raw_api_gtk_rekey_notify {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 bssid[6];
	u8 replay_ctr[8];
	char __data[0];
};

struct trace_event_raw_api_enable_rssi_reports {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int rssi_min_thold;
	int rssi_max_thold;
	char __data[0];
};

struct trace_event_raw_api_eosp {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_api_send_eosp_nullfunc {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 tid;
	char __data[0];
};

struct trace_event_raw_api_sta_set_buffered {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 tid;
	bool buffered;
	char __data[0];
};

struct trace_event_raw_wake_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 queue;
	u32 reason;
	char __data[0];
};

struct trace_event_raw_stop_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 queue;
	u32 reason;
	char __data[0];
};

struct trace_event_raw_drv_set_default_unicast_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int key_idx;
	char __data[0];
};

struct trace_event_raw_api_radar_detected {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_drv_channel_switch_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_drv_pre_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	char __data[0];
};

struct trace_event_raw_drv_channel_switch_rx_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	char __data[0];
};

struct trace_event_raw_drv_get_txpower {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int dbm;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u8 oper_class;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_drv_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_tdls_recv_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 action_code;
	char sta_addr[6];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 status;
	bool peer_initiator;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	char __data[0];
};

struct trace_event_raw_drv_wake_tx_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u8 ac;
	u8 tid;
	char __data[0];
};

struct trace_event_raw_drv_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_sta_set_4addr {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	bool enabled;
	char __data[0];
};

struct trace_event_data_offsets_local_only_evt {};

struct trace_event_data_offsets_local_sdata_addr_evt {
	u32 vif_name;
};

struct trace_event_data_offsets_local_u32_evt {};

struct trace_event_data_offsets_local_sdata_evt {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_return_int {};

struct trace_event_data_offsets_drv_return_bool {};

struct trace_event_data_offsets_drv_return_u32 {};

struct trace_event_data_offsets_drv_return_u64 {};

struct trace_event_data_offsets_drv_set_wakeup {};

struct trace_event_data_offsets_drv_change_interface {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_config {};

struct trace_event_data_offsets_drv_bss_info_changed {
	u32 vif_name;
	u32 arp_addr_list;
	u32 ssid;
};

struct trace_event_data_offsets_drv_prepare_multicast {};

struct trace_event_data_offsets_drv_configure_filter {};

struct trace_event_data_offsets_drv_config_iface_filter {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_tim {};

struct trace_event_data_offsets_drv_set_key {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_update_tkip_key {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sw_scan_start {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_stats {};

struct trace_event_data_offsets_drv_get_key_seq {};

struct trace_event_data_offsets_drv_set_coverage_class {};

struct trace_event_data_offsets_drv_sta_notify {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_state {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_set_txpwr {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_rc_update {
	u32 vif_name;
};

struct trace_event_data_offsets_sta_event {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_conf_tx {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_tsf {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_offset_tsf {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_ampdu_action {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_survey {};

struct trace_event_data_offsets_drv_flush {};

struct trace_event_data_offsets_drv_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_antenna {};

struct trace_event_data_offsets_drv_get_antenna {};

struct trace_event_data_offsets_drv_remain_on_channel {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_ringparam {};

struct trace_event_data_offsets_drv_get_ringparam {};

struct trace_event_data_offsets_drv_set_bitrate_mask {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_rekey_data {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_event_callback {
	u32 vif_name;
};

struct trace_event_data_offsets_release_evt {};

struct trace_event_data_offsets_drv_mgd_prepare_tx {
	u32 vif_name;
};

struct trace_event_data_offsets_local_chanctx {};

struct trace_event_data_offsets_drv_change_chanctx {};

struct trace_event_data_offsets_drv_switch_vif_chanctx {
	u32 vifs;
};

struct trace_event_data_offsets_local_sdata_chanctx {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_start_ap {
	u32 vif_name;
	u32 ssid;
};

struct trace_event_data_offsets_drv_reconfig_complete {};

struct trace_event_data_offsets_drv_join_ibss {
	u32 vif_name;
	u32 ssid;
};

struct trace_event_data_offsets_drv_get_expected_throughput {};

struct trace_event_data_offsets_drv_start_nan {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_stop_nan {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_nan_change_conf {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_add_nan_func {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_del_nan_func {
	u32 vif_name;
};

struct trace_event_data_offsets_api_start_tx_ba_session {};

struct trace_event_data_offsets_api_start_tx_ba_cb {
	u32 vif_name;
};

struct trace_event_data_offsets_api_stop_tx_ba_session {};

struct trace_event_data_offsets_api_stop_tx_ba_cb {
	u32 vif_name;
};

struct trace_event_data_offsets_api_beacon_loss {
	u32 vif_name;
};

struct trace_event_data_offsets_api_connection_loss {
	u32 vif_name;
};

struct trace_event_data_offsets_api_cqm_rssi_notify {
	u32 vif_name;
};

struct trace_event_data_offsets_api_scan_completed {};

struct trace_event_data_offsets_api_sched_scan_results {};

struct trace_event_data_offsets_api_sched_scan_stopped {};

struct trace_event_data_offsets_api_sta_block_awake {};

struct trace_event_data_offsets_api_chswitch_done {
	u32 vif_name;
};

struct trace_event_data_offsets_api_gtk_rekey_notify {
	u32 vif_name;
};

struct trace_event_data_offsets_api_enable_rssi_reports {
	u32 vif_name;
};

struct trace_event_data_offsets_api_eosp {};

struct trace_event_data_offsets_api_send_eosp_nullfunc {};

struct trace_event_data_offsets_api_sta_set_buffered {};

struct trace_event_data_offsets_wake_queue {};

struct trace_event_data_offsets_stop_queue {};

struct trace_event_data_offsets_drv_set_default_unicast_key {
	u32 vif_name;
};

struct trace_event_data_offsets_api_radar_detected {};

struct trace_event_data_offsets_drv_channel_switch_beacon {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_pre_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_channel_switch_rx_beacon {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_txpower {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_tdls_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_tdls_cancel_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_tdls_recv_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_wake_tx_queue {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_ftm_responder_stats {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_set_4addr {
	u32 vif_name;
};

typedef void (*btf_trace_drv_return_void)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_return_int)(void *, struct ieee80211_local *, int);

typedef void (*btf_trace_drv_return_bool)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_return_u32)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_return_u64)(void *, struct ieee80211_local *, u64);

typedef void (*btf_trace_drv_start)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_get_et_strings)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_get_et_sset_count)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_get_et_stats)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_suspend)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_resume)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_set_wakeup)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_stop)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_add_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_change_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum nl80211_iftype, bool);

typedef void (*btf_trace_drv_remove_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_config)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_bss_info_changed)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *, u32);

typedef void (*btf_trace_drv_prepare_multicast)(void *, struct ieee80211_local *, int);

typedef void (*btf_trace_drv_configure_filter)(void *, struct ieee80211_local *, unsigned int, unsigned int *, u64);

typedef void (*btf_trace_drv_config_iface_filter)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, unsigned int, unsigned int);

typedef void (*btf_trace_drv_set_tim)(void *, struct ieee80211_local *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_drv_set_key)(void *, struct ieee80211_local *, enum set_key_cmd, struct ieee80211_sub_if_data *, struct ieee80211_sta *, struct ieee80211_key_conf *);

typedef void (*btf_trace_drv_update_tkip_key)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32);

typedef void (*btf_trace_drv_hw_scan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_cancel_hw_scan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sched_scan_start)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sched_scan_stop)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sw_scan_start)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const u8 *);

typedef void (*btf_trace_drv_sw_scan_complete)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_get_stats)(void *, struct ieee80211_local *, struct ieee80211_low_level_stats *, int);

typedef void (*btf_trace_drv_get_key_seq)(void *, struct ieee80211_local *, struct ieee80211_key_conf *);

typedef void (*btf_trace_drv_set_frag_threshold)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_set_rts_threshold)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_set_coverage_class)(void *, struct ieee80211_local *, s16);

typedef void (*btf_trace_drv_sta_notify)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum sta_notify_cmd, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_state)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, enum ieee80211_sta_state, enum ieee80211_sta_state);

typedef void (*btf_trace_drv_sta_set_txpwr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_rc_update)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, u32);

typedef void (*btf_trace_drv_sta_statistics)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_add)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_remove)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_pre_rcu_remove)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sync_rx_queues)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_rate_tbl_update)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_conf_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16, const struct ieee80211_tx_queue_params *);

typedef void (*btf_trace_drv_get_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_set_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u64);

typedef void (*btf_trace_drv_offset_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, s64);

typedef void (*btf_trace_drv_reset_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_tx_last_beacon)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_ampdu_action)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_ampdu_params *);

typedef void (*btf_trace_drv_get_survey)(void *, struct ieee80211_local *, int, struct survey_info *);

typedef void (*btf_trace_drv_flush)(void *, struct ieee80211_local *, u32, bool);

typedef void (*btf_trace_drv_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_set_antenna)(void *, struct ieee80211_local *, u32, u32, int);

typedef void (*btf_trace_drv_get_antenna)(void *, struct ieee80211_local *, u32, u32, int);

typedef void (*btf_trace_drv_remain_on_channel)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel *, unsigned int, enum ieee80211_roc_type);

typedef void (*btf_trace_drv_cancel_remain_on_channel)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_set_ringparam)(void *, struct ieee80211_local *, u32, u32);

typedef void (*btf_trace_drv_get_ringparam)(void *, struct ieee80211_local *, u32 *, u32 *, u32 *, u32 *);

typedef void (*btf_trace_drv_tx_frames_pending)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_offchannel_tx_cancel_wait)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_set_bitrate_mask)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_drv_set_rekey_data)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_gtk_rekey_data *);

typedef void (*btf_trace_drv_event_callback)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct ieee80211_event *);

typedef void (*btf_trace_drv_release_buffered_frames)(void *, struct ieee80211_local *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);

typedef void (*btf_trace_drv_allow_buffered_frames)(void *, struct ieee80211_local *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);

typedef void (*btf_trace_drv_mgd_prepare_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16);

typedef void (*btf_trace_drv_mgd_protect_tdls_discover)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_add_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_remove_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_change_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *, u32);

typedef void (*btf_trace_drv_switch_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_vif_chanctx_switch *, int, enum ieee80211_chanctx_switch_mode);

typedef void (*btf_trace_drv_assign_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_unassign_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_start_ap)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_stop_ap)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_reconfig_complete)(void *, struct ieee80211_local *, enum ieee80211_reconfig_type);

typedef void (*btf_trace_drv_ipv6_addr_change)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_join_ibss)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_leave_ibss)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_get_expected_throughput)(void *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_start_nan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_drv_stop_nan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_nan_change_conf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_drv_add_nan_func)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_drv_del_nan_func)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u8);

typedef void (*btf_trace_drv_start_pmsr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_abort_pmsr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_start_tx_ba_session)(void *, struct ieee80211_sta *, u16);

typedef void (*btf_trace_api_start_tx_ba_cb)(void *, struct ieee80211_sub_if_data *, const u8 *, u16);

typedef void (*btf_trace_api_stop_tx_ba_session)(void *, struct ieee80211_sta *, u16);

typedef void (*btf_trace_api_stop_tx_ba_cb)(void *, struct ieee80211_sub_if_data *, const u8 *, u16);

typedef void (*btf_trace_api_restart_hw)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_beacon_loss)(void *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_connection_loss)(void *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_cqm_rssi_notify)(void *, struct ieee80211_sub_if_data *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_api_cqm_beacon_loss_notify)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_scan_completed)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_api_sched_scan_results)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_sched_scan_stopped)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_sta_block_awake)(void *, struct ieee80211_local *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_api_chswitch_done)(void *, struct ieee80211_sub_if_data *, bool);

typedef void (*btf_trace_api_ready_on_channel)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_remain_on_channel_expired)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_gtk_rekey_notify)(void *, struct ieee80211_sub_if_data *, const u8 *, const u8 *);

typedef void (*btf_trace_api_enable_rssi_reports)(void *, struct ieee80211_sub_if_data *, int, int);

typedef void (*btf_trace_api_eosp)(void *, struct ieee80211_local *, struct ieee80211_sta *);

typedef void (*btf_trace_api_send_eosp_nullfunc)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8);

typedef void (*btf_trace_api_sta_set_buffered)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8, bool);

typedef void (*btf_trace_wake_queue)(void *, struct ieee80211_local *, u16, enum queue_stop_reason);

typedef void (*btf_trace_stop_queue)(void *, struct ieee80211_local *, u16, enum queue_stop_reason);

typedef void (*btf_trace_drv_set_default_unicast_key)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, int);

typedef void (*btf_trace_api_radar_detected)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_channel_switch_beacon)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_chan_def *);

typedef void (*btf_trace_drv_pre_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_post_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_abort_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_channel_switch_rx_beacon)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_get_txpower)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, int, int);

typedef void (*btf_trace_drv_tdls_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_drv_tdls_cancel_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_tdls_recv_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_tdls_ch_sw_params *);

typedef void (*btf_trace_drv_wake_tx_queue)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct txq_info *);

typedef void (*btf_trace_drv_get_ftm_responder_stats)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_drv_update_vif_offload)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sta_set_4addr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, bool);

struct ieee80211_country_ie_triplet {
	union {
		struct {
			u8 first_channel;
			u8 num_channels;
			s8 max_power;
		} chans;
		struct {
			u8 reg_extension_id;
			u8 reg_class;
			u8 coverage_class;
		} ext;
	};
};

enum ieee80211_timeout_interval_type {
	WLAN_TIMEOUT_REASSOC_DEADLINE = 1,
	WLAN_TIMEOUT_KEY_LIFETIME = 2,
	WLAN_TIMEOUT_ASSOC_COMEBACK = 3,
};

enum ieee80211_idle_options {
	WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE = 1,
};

struct ieee80211_wmm_ac_param {
	u8 aci_aifsn;
	u8 cw;
	__le16 txop_limit;
};

struct ieee80211_wmm_param_ie {
	u8 element_id;
	u8 len;
	u8 oui[3];
	u8 oui_type;
	u8 oui_subtype;
	u8 version;
	u8 qos_info;
	u8 reserved;
	struct ieee80211_wmm_ac_param ac[4];
};

enum ocb_deferred_task_flags {
	OCB_WORK_HOUSEKEEPING = 0,
};

struct mcs_group {
	u8 shift;
	u16 duration[12];
};

struct netlbl_af4list {
	__be32 addr;
	__be32 mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_af6list {
	struct in6_addr addr;
	struct in6_addr mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_domaddr_map {
	struct list_head list4;
	struct list_head list6;
};

struct netlbl_dommap_def {
	u32 type;
	union {
		struct netlbl_domaddr_map *addrsel;
		struct cipso_v4_doi *cipso;
		struct calipso_doi *calipso;
	};
};

struct netlbl_domaddr4_map {
	struct netlbl_dommap_def def;
	struct netlbl_af4list list;
};

struct netlbl_domaddr6_map {
	struct netlbl_dommap_def def;
	struct netlbl_af6list list;
};

struct netlbl_dom_map {
	char *domain;
	u16 family;
	struct netlbl_dommap_def def;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_domhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

enum {
	NLBL_MGMT_C_UNSPEC = 0,
	NLBL_MGMT_C_ADD = 1,
	NLBL_MGMT_C_REMOVE = 2,
	NLBL_MGMT_C_LISTALL = 3,
	NLBL_MGMT_C_ADDDEF = 4,
	NLBL_MGMT_C_REMOVEDEF = 5,
	NLBL_MGMT_C_LISTDEF = 6,
	NLBL_MGMT_C_PROTOCOLS = 7,
	NLBL_MGMT_C_VERSION = 8,
	__NLBL_MGMT_C_MAX = 9,
};

enum {
	NLBL_MGMT_A_UNSPEC = 0,
	NLBL_MGMT_A_DOMAIN = 1,
	NLBL_MGMT_A_PROTOCOL = 2,
	NLBL_MGMT_A_VERSION = 3,
	NLBL_MGMT_A_CV4DOI = 4,
	NLBL_MGMT_A_IPV6ADDR = 5,
	NLBL_MGMT_A_IPV6MASK = 6,
	NLBL_MGMT_A_IPV4ADDR = 7,
	NLBL_MGMT_A_IPV4MASK = 8,
	NLBL_MGMT_A_ADDRSELECTOR = 9,
	NLBL_MGMT_A_SELECTORLIST = 10,
	NLBL_MGMT_A_FAMILY = 11,
	NLBL_MGMT_A_CLPDOI = 12,
	__NLBL_MGMT_A_MAX = 13,
};

struct netlbl_domhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

enum {
	NLBL_UNLABEL_C_UNSPEC = 0,
	NLBL_UNLABEL_C_ACCEPT = 1,
	NLBL_UNLABEL_C_LIST = 2,
	NLBL_UNLABEL_C_STATICADD = 3,
	NLBL_UNLABEL_C_STATICREMOVE = 4,
	NLBL_UNLABEL_C_STATICLIST = 5,
	NLBL_UNLABEL_C_STATICADDDEF = 6,
	NLBL_UNLABEL_C_STATICREMOVEDEF = 7,
	NLBL_UNLABEL_C_STATICLISTDEF = 8,
	__NLBL_UNLABEL_C_MAX = 9,
};

enum {
	NLBL_UNLABEL_A_UNSPEC = 0,
	NLBL_UNLABEL_A_ACPTFLG = 1,
	NLBL_UNLABEL_A_IPV6ADDR = 2,
	NLBL_UNLABEL_A_IPV6MASK = 3,
	NLBL_UNLABEL_A_IPV4ADDR = 4,
	NLBL_UNLABEL_A_IPV4MASK = 5,
	NLBL_UNLABEL_A_IFACE = 6,
	NLBL_UNLABEL_A_SECCTX = 7,
	__NLBL_UNLABEL_A_MAX = 8,
};

struct netlbl_unlhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

struct netlbl_unlhsh_addr4 {
	u32 secid;
	struct netlbl_af4list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_addr6 {
	u32 secid;
	struct netlbl_af6list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_iface {
	int ifindex;
	struct list_head addr4_list;
	struct list_head addr6_list;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

enum {
	NLBL_CIPSOV4_C_UNSPEC = 0,
	NLBL_CIPSOV4_C_ADD = 1,
	NLBL_CIPSOV4_C_REMOVE = 2,
	NLBL_CIPSOV4_C_LIST = 3,
	NLBL_CIPSOV4_C_LISTALL = 4,
	__NLBL_CIPSOV4_C_MAX = 5,
};

enum {
	NLBL_CIPSOV4_A_UNSPEC = 0,
	NLBL_CIPSOV4_A_DOI = 1,
	NLBL_CIPSOV4_A_MTYPE = 2,
	NLBL_CIPSOV4_A_TAG = 3,
	NLBL_CIPSOV4_A_TAGLST = 4,
	NLBL_CIPSOV4_A_MLSLVLLOC = 5,
	NLBL_CIPSOV4_A_MLSLVLREM = 6,
	NLBL_CIPSOV4_A_MLSLVL = 7,
	NLBL_CIPSOV4_A_MLSLVLLST = 8,
	NLBL_CIPSOV4_A_MLSCATLOC = 9,
	NLBL_CIPSOV4_A_MLSCATREM = 10,
	NLBL_CIPSOV4_A_MLSCAT = 11,
	NLBL_CIPSOV4_A_MLSCATLST = 12,
	__NLBL_CIPSOV4_A_MAX = 13,
};

struct netlbl_cipsov4_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_domhsh_walk_arg___2 {
	struct netlbl_audit *audit_info;
	u32 doi;
};

enum {
	NLBL_CALIPSO_C_UNSPEC = 0,
	NLBL_CALIPSO_C_ADD = 1,
	NLBL_CALIPSO_C_REMOVE = 2,
	NLBL_CALIPSO_C_LIST = 3,
	NLBL_CALIPSO_C_LISTALL = 4,
	__NLBL_CALIPSO_C_MAX = 5,
};

enum {
	NLBL_CALIPSO_A_UNSPEC = 0,
	NLBL_CALIPSO_A_DOI = 1,
	NLBL_CALIPSO_A_MTYPE = 2,
	__NLBL_CALIPSO_A_MAX = 3,
};

struct netlbl_calipso_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

enum p9_msg_t {
	P9_TLERROR = 6,
	P9_RLERROR = 7,
	P9_TSTATFS = 8,
	P9_RSTATFS = 9,
	P9_TLOPEN = 12,
	P9_RLOPEN = 13,
	P9_TLCREATE = 14,
	P9_RLCREATE = 15,
	P9_TSYMLINK = 16,
	P9_RSYMLINK = 17,
	P9_TMKNOD = 18,
	P9_RMKNOD = 19,
	P9_TRENAME = 20,
	P9_RRENAME = 21,
	P9_TREADLINK = 22,
	P9_RREADLINK = 23,
	P9_TGETATTR = 24,
	P9_RGETATTR = 25,
	P9_TSETATTR = 26,
	P9_RSETATTR = 27,
	P9_TXATTRWALK = 30,
	P9_RXATTRWALK = 31,
	P9_TXATTRCREATE = 32,
	P9_RXATTRCREATE = 33,
	P9_TREADDIR = 40,
	P9_RREADDIR = 41,
	P9_TFSYNC = 50,
	P9_RFSYNC = 51,
	P9_TLOCK = 52,
	P9_RLOCK = 53,
	P9_TGETLOCK = 54,
	P9_RGETLOCK = 55,
	P9_TLINK = 70,
	P9_RLINK = 71,
	P9_TMKDIR = 72,
	P9_RMKDIR = 73,
	P9_TRENAMEAT = 74,
	P9_RRENAMEAT = 75,
	P9_TUNLINKAT = 76,
	P9_RUNLINKAT = 77,
	P9_TVERSION = 100,
	P9_RVERSION = 101,
	P9_TAUTH = 102,
	P9_RAUTH = 103,
	P9_TATTACH = 104,
	P9_RATTACH = 105,
	P9_TERROR = 106,
	P9_RERROR = 107,
	P9_TFLUSH = 108,
	P9_RFLUSH = 109,
	P9_TWALK = 110,
	P9_RWALK = 111,
	P9_TOPEN = 112,
	P9_ROPEN = 113,
	P9_TCREATE = 114,
	P9_RCREATE = 115,
	P9_TREAD = 116,
	P9_RREAD = 117,
	P9_TWRITE = 118,
	P9_RWRITE = 119,
	P9_TCLUNK = 120,
	P9_RCLUNK = 121,
	P9_TREMOVE = 122,
	P9_RREMOVE = 123,
	P9_TSTAT = 124,
	P9_RSTAT = 125,
	P9_TWSTAT = 126,
	P9_RWSTAT = 127,
};

enum p9_proto_versions {
	p9_proto_legacy = 0,
	p9_proto_2000u = 1,
	p9_proto_2000L = 2,
};

enum p9_req_status_t {
	REQ_STATUS_ALLOC = 0,
	REQ_STATUS_UNSENT = 1,
	REQ_STATUS_SENT = 2,
	REQ_STATUS_RCVD = 3,
	REQ_STATUS_FLSHD = 4,
	REQ_STATUS_ERROR = 5,
};

struct trace_event_raw_9p_client_req {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	char __data[0];
};

struct trace_event_raw_9p_client_res {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	__u32 err;
	char __data[0];
};

struct trace_event_raw_9p_protocol_dump {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u16 tag;
	unsigned char line[32];
	char __data[0];
};

struct trace_event_data_offsets_9p_client_req {};

struct trace_event_data_offsets_9p_client_res {};

struct trace_event_data_offsets_9p_protocol_dump {};

typedef void (*btf_trace_9p_client_req)(void *, struct p9_client *, int8_t, int);

typedef void (*btf_trace_9p_client_res)(void *, struct p9_client *, int8_t, int, int);

typedef void (*btf_trace_9p_protocol_dump)(void *, struct p9_client *, struct p9_fcall *);

enum {
	Opt_msize = 0,
	Opt_trans = 1,
	Opt_legacy = 2,
	Opt_version = 3,
	Opt_err___10 = 4,
};

struct errormap {
	char *name;
	int val;
	int namelen;
	struct hlist_node list;
};

struct p9_fd_opts {
	int rfd;
	int wfd;
	u16 port;
	bool privport;
};

enum {
	Opt_port___2 = 0,
	Opt_rfdno = 1,
	Opt_wfdno = 2,
	Opt_err___11 = 3,
	Opt_privport = 4,
};

enum {
	Rworksched = 1,
	Rpending = 2,
	Wworksched = 4,
	Wpending = 8,
};

struct p9_conn;

struct p9_poll_wait {
	struct p9_conn *conn;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_addr;
};

struct p9_conn {
	struct list_head mux_list;
	struct p9_client *client;
	int err;
	struct list_head req_list;
	struct list_head unsent_req_list;
	struct p9_req_t *rreq;
	struct p9_req_t *wreq;
	char tmp_buf[7];
	struct p9_fcall rc;
	int wpos;
	int wsize;
	char *wbuf;
	struct list_head poll_pending_link;
	struct p9_poll_wait poll_wait[2];
	poll_table pt;
	struct work_struct rq;
	struct work_struct wq;
	long unsigned int wsched;
};

struct p9_trans_fd {
	struct file *rd;
	struct file *wr;
	struct p9_conn conn;
};

struct virtio_9p_config {
	__virtio16 tag_len;
	__u8 tag[0];
};

struct virtio_chan {
	bool inuse;
	spinlock_t lock;
	struct p9_client *client;
	struct virtio_device *vdev;
	struct virtqueue *vq;
	int ring_bufs_avail;
	wait_queue_head_t *vc_wq;
	long unsigned int p9_max_pages;
	struct scatterlist sg[128];
	char *tag;
	struct list_head chan_list;
};

struct dcbmsg {
	__u8 dcb_family;
	__u8 cmd;
	__u16 dcb_pad;
};

enum dcbnl_commands {
	DCB_CMD_UNDEFINED = 0,
	DCB_CMD_GSTATE = 1,
	DCB_CMD_SSTATE = 2,
	DCB_CMD_PGTX_GCFG = 3,
	DCB_CMD_PGTX_SCFG = 4,
	DCB_CMD_PGRX_GCFG = 5,
	DCB_CMD_PGRX_SCFG = 6,
	DCB_CMD_PFC_GCFG = 7,
	DCB_CMD_PFC_SCFG = 8,
	DCB_CMD_SET_ALL = 9,
	DCB_CMD_GPERM_HWADDR = 10,
	DCB_CMD_GCAP = 11,
	DCB_CMD_GNUMTCS = 12,
	DCB_CMD_SNUMTCS = 13,
	DCB_CMD_PFC_GSTATE = 14,
	DCB_CMD_PFC_SSTATE = 15,
	DCB_CMD_BCN_GCFG = 16,
	DCB_CMD_BCN_SCFG = 17,
	DCB_CMD_GAPP = 18,
	DCB_CMD_SAPP = 19,
	DCB_CMD_IEEE_SET = 20,
	DCB_CMD_IEEE_GET = 21,
	DCB_CMD_GDCBX = 22,
	DCB_CMD_SDCBX = 23,
	DCB_CMD_GFEATCFG = 24,
	DCB_CMD_SFEATCFG = 25,
	DCB_CMD_CEE_GET = 26,
	DCB_CMD_IEEE_DEL = 27,
	__DCB_CMD_ENUM_MAX = 28,
	DCB_CMD_MAX = 27,
};

enum dcbnl_attrs {
	DCB_ATTR_UNDEFINED = 0,
	DCB_ATTR_IFNAME = 1,
	DCB_ATTR_STATE = 2,
	DCB_ATTR_PFC_STATE = 3,
	DCB_ATTR_PFC_CFG = 4,
	DCB_ATTR_NUM_TC = 5,
	DCB_ATTR_PG_CFG = 6,
	DCB_ATTR_SET_ALL = 7,
	DCB_ATTR_PERM_HWADDR = 8,
	DCB_ATTR_CAP = 9,
	DCB_ATTR_NUMTCS = 10,
	DCB_ATTR_BCN = 11,
	DCB_ATTR_APP = 12,
	DCB_ATTR_IEEE = 13,
	DCB_ATTR_DCBX = 14,
	DCB_ATTR_FEATCFG = 15,
	DCB_ATTR_CEE = 16,
	__DCB_ATTR_ENUM_MAX = 17,
	DCB_ATTR_MAX = 16,
};

enum ieee_attrs {
	DCB_ATTR_IEEE_UNSPEC = 0,
	DCB_ATTR_IEEE_ETS = 1,
	DCB_ATTR_IEEE_PFC = 2,
	DCB_ATTR_IEEE_APP_TABLE = 3,
	DCB_ATTR_IEEE_PEER_ETS = 4,
	DCB_ATTR_IEEE_PEER_PFC = 5,
	DCB_ATTR_IEEE_PEER_APP = 6,
	DCB_ATTR_IEEE_MAXRATE = 7,
	DCB_ATTR_IEEE_QCN = 8,
	DCB_ATTR_IEEE_QCN_STATS = 9,
	DCB_ATTR_DCB_BUFFER = 10,
	__DCB_ATTR_IEEE_MAX = 11,
};

enum ieee_attrs_app {
	DCB_ATTR_IEEE_APP_UNSPEC = 0,
	DCB_ATTR_IEEE_APP = 1,
	__DCB_ATTR_IEEE_APP_MAX = 2,
};

enum cee_attrs {
	DCB_ATTR_CEE_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_PG = 1,
	DCB_ATTR_CEE_PEER_PFC = 2,
	DCB_ATTR_CEE_PEER_APP_TABLE = 3,
	DCB_ATTR_CEE_TX_PG = 4,
	DCB_ATTR_CEE_RX_PG = 5,
	DCB_ATTR_CEE_PFC = 6,
	DCB_ATTR_CEE_APP_TABLE = 7,
	DCB_ATTR_CEE_FEAT = 8,
	__DCB_ATTR_CEE_MAX = 9,
};

enum peer_app_attr {
	DCB_ATTR_CEE_PEER_APP_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_APP_INFO = 1,
	DCB_ATTR_CEE_PEER_APP = 2,
	__DCB_ATTR_CEE_PEER_APP_MAX = 3,
};

enum dcbnl_tc_attrs {
	DCB_TC_ATTR_PARAM_UNDEFINED = 0,
	DCB_TC_ATTR_PARAM_PGID = 1,
	DCB_TC_ATTR_PARAM_UP_MAPPING = 2,
	DCB_TC_ATTR_PARAM_STRICT_PRIO = 3,
	DCB_TC_ATTR_PARAM_BW_PCT = 4,
	DCB_TC_ATTR_PARAM_ALL = 5,
	__DCB_TC_ATTR_PARAM_ENUM_MAX = 6,
	DCB_TC_ATTR_PARAM_MAX = 5,
};

enum dcbnl_bcn_attrs {
	DCB_BCN_ATTR_UNDEFINED = 0,
	DCB_BCN_ATTR_RP_0 = 1,
	DCB_BCN_ATTR_RP_1 = 2,
	DCB_BCN_ATTR_RP_2 = 3,
	DCB_BCN_ATTR_RP_3 = 4,
	DCB_BCN_ATTR_RP_4 = 5,
	DCB_BCN_ATTR_RP_5 = 6,
	DCB_BCN_ATTR_RP_6 = 7,
	DCB_BCN_ATTR_RP_7 = 8,
	DCB_BCN_ATTR_RP_ALL = 9,
	DCB_BCN_ATTR_BCNA_0 = 10,
	DCB_BCN_ATTR_BCNA_1 = 11,
	DCB_BCN_ATTR_ALPHA = 12,
	DCB_BCN_ATTR_BETA = 13,
	DCB_BCN_ATTR_GD = 14,
	DCB_BCN_ATTR_GI = 15,
	DCB_BCN_ATTR_TMAX = 16,
	DCB_BCN_ATTR_TD = 17,
	DCB_BCN_ATTR_RMIN = 18,
	DCB_BCN_ATTR_W = 19,
	DCB_BCN_ATTR_RD = 20,
	DCB_BCN_ATTR_RU = 21,
	DCB_BCN_ATTR_WRTT = 22,
	DCB_BCN_ATTR_RI = 23,
	DCB_BCN_ATTR_C = 24,
	DCB_BCN_ATTR_ALL = 25,
	__DCB_BCN_ATTR_ENUM_MAX = 26,
	DCB_BCN_ATTR_MAX = 25,
};

enum dcbnl_app_attrs {
	DCB_APP_ATTR_UNDEFINED = 0,
	DCB_APP_ATTR_IDTYPE = 1,
	DCB_APP_ATTR_ID = 2,
	DCB_APP_ATTR_PRIORITY = 3,
	__DCB_APP_ATTR_ENUM_MAX = 4,
	DCB_APP_ATTR_MAX = 3,
};

enum dcbnl_featcfg_attrs {
	DCB_FEATCFG_ATTR_UNDEFINED = 0,
	DCB_FEATCFG_ATTR_ALL = 1,
	DCB_FEATCFG_ATTR_PG = 2,
	DCB_FEATCFG_ATTR_PFC = 3,
	DCB_FEATCFG_ATTR_APP = 4,
	__DCB_FEATCFG_ATTR_ENUM_MAX = 5,
	DCB_FEATCFG_ATTR_MAX = 4,
};

struct dcb_app_type {
	int ifindex;
	struct dcb_app app;
	struct list_head list;
	u8 dcbx;
};

struct dcb_ieee_app_prio_map {
	u64 map[8];
};

struct dcb_ieee_app_dscp_map {
	u8 map[64];
};

enum dcbevent_notif_type {
	DCB_APP_EVENT = 1,
};

struct reply_func {
	int type;
	int (*cb)(struct net_device *, struct nlmsghdr *, u32, struct nlattr **, struct sk_buff *);
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

struct sockaddr_xdp {
	__u16 sxdp_family;
	__u16 sxdp_flags;
	__u32 sxdp_ifindex;
	__u32 sxdp_queue_id;
	__u32 sxdp_shared_umem_fd;
};

struct xdp_ring_offset {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
	__u64 flags;
};

struct xdp_mmap_offsets {
	struct xdp_ring_offset rx;
	struct xdp_ring_offset tx;
	struct xdp_ring_offset fr;
	struct xdp_ring_offset cr;
};

struct xdp_umem_reg {
	__u64 addr;
	__u64 len;
	__u32 chunk_size;
	__u32 headroom;
	__u32 flags;
};

struct xdp_statistics {
	__u64 rx_dropped;
	__u64 rx_invalid_descs;
	__u64 tx_invalid_descs;
	__u64 rx_ring_full;
	__u64 rx_fill_ring_empty_descs;
	__u64 tx_ring_empty_descs;
};

struct xdp_options {
	__u32 flags;
};

struct xdp_ring;

struct xsk_queue {
	u32 ring_mask;
	u32 nentries;
	u32 cached_prod;
	u32 cached_cons;
	struct xdp_ring *ring;
	u64 invalid_descs;
	u64 queue_empty_descs;
};

struct xdp_ring_offset_v1 {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
};

struct xdp_mmap_offsets_v1 {
	struct xdp_ring_offset_v1 rx;
	struct xdp_ring_offset_v1 tx;
	struct xdp_ring_offset_v1 fr;
	struct xdp_ring_offset_v1 cr;
};

struct xsk_map_node {
	struct list_head node;
	struct xsk_map *map;
	struct xdp_sock **map_entry;
};

struct xdp_ring {
	u32 producer;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad1;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 consumer;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad2;
	u32 flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 pad3;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_rxtx_ring {
	struct xdp_ring ptrs;
	struct xdp_desc desc[0];
};

struct xdp_umem_ring {
	struct xdp_ring ptrs;
	u64 desc[0];
};

struct xsk_dma_map {
	dma_addr_t *dma_pages;
	struct device *dev;
	struct net_device *netdev;
	refcount_t users;
	struct list_head list;
	u32 dma_pages_cnt;
	bool dma_need_sync;
};

struct xdp_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 xdiag_ino;
	__u32 xdiag_show;
	__u32 xdiag_cookie[2];
};

struct xdp_diag_msg {
	__u8 xdiag_family;
	__u8 xdiag_type;
	__u16 pad;
	__u32 xdiag_ino;
	__u32 xdiag_cookie[2];
};

enum {
	XDP_DIAG_NONE = 0,
	XDP_DIAG_INFO = 1,
	XDP_DIAG_UID = 2,
	XDP_DIAG_RX_RING = 3,
	XDP_DIAG_TX_RING = 4,
	XDP_DIAG_UMEM = 5,
	XDP_DIAG_UMEM_FILL_RING = 6,
	XDP_DIAG_UMEM_COMPLETION_RING = 7,
	XDP_DIAG_MEMINFO = 8,
	XDP_DIAG_STATS = 9,
	__XDP_DIAG_MAX = 10,
};

struct xdp_diag_info {
	__u32 ifindex;
	__u32 queue_id;
};

struct xdp_diag_ring {
	__u32 entries;
};

struct xdp_diag_umem {
	__u64 size;
	__u32 id;
	__u32 num_pages;
	__u32 chunk_size;
	__u32 headroom;
	__u32 ifindex;
	__u32 queue_id;
	__u32 flags;
	__u32 refs;
};

struct xdp_diag_stats {
	__u64 n_rx_dropped;
	__u64 n_rx_invalid;
	__u64 n_rx_full;
	__u64 n_fill_ring_empty;
	__u64 n_tx_invalid;
	__u64 n_tx_ring_empty;
};

struct pcibios_fwaddrmap {
	struct list_head list;
	struct pci_dev *dev;
	resource_size_t fw_addr[17];
};

struct pci_check_idx_range {
	int start;
	int end;
};

struct pci_raw_ops {
	int (*read)(unsigned int, unsigned int, unsigned int, int, int, u32 *);
	int (*write)(unsigned int, unsigned int, unsigned int, int, int, u32);
};

struct pci_mmcfg_region {
	struct list_head list;
	struct resource res;
	u64 address;
	char *virt;
	u16 segment;
	u8 start_bus;
	u8 end_bus;
	char name[30];
};

struct acpi_table_mcfg {
	struct acpi_table_header header;
	u8 reserved[8];
};

struct acpi_mcfg_allocation {
	u64 address;
	u16 pci_segment;
	u8 start_bus_number;
	u8 end_bus_number;
	u32 reserved;
};

struct pci_mmcfg_hostbridge_probe {
	u32 bus;
	u32 devfn;
	u32 vendor;
	u32 device;
	const char * (*probe)();
};

typedef bool (*check_reserved_t)(u64, u64, unsigned int);

struct pci_root_info {
	struct acpi_pci_root_info common;
	struct pci_sysdata sd;
	bool mcfg_added;
	u8 start_bus;
	u8 end_bus;
};

struct irq_info___2 {
	u8 bus;
	u8 devfn;
	struct {
		u8 link;
		u16 bitmap;
	} __attribute__((packed)) irq[4];
	u8 slot;
	u8 rfu;
};

struct irq_routing_table {
	u32 signature;
	u16 version;
	u16 size;
	u8 rtr_bus;
	u8 rtr_devfn;
	u16 exclusive_irqs;
	u16 rtr_vendor;
	u16 rtr_device;
	u32 miniport_data;
	u8 rfu[11];
	u8 checksum;
	struct irq_info___2 slots[0];
};

struct irq_router {
	char *name;
	u16 vendor;
	u16 device;
	int (*get)(struct pci_dev *, struct pci_dev *, int);
	int (*set)(struct pci_dev *, struct pci_dev *, int, int);
};

struct irq_router_handler {
	u16 vendor;
	int (*probe)(struct irq_router *, struct pci_dev *, u16);
};

struct pci_setup_rom {
	struct setup_data data;
	uint16_t vendor;
	uint16_t devid;
	uint64_t pcilen;
	long unsigned int segment;
	long unsigned int bus;
	long unsigned int device;
	long unsigned int function;
	uint8_t romdata[0];
};

enum pci_bf_sort_state {
	pci_bf_sort_default = 0,
	pci_force_nobf = 1,
	pci_force_bf = 2,
	pci_dmi_bf = 3,
};

struct pci_root_res {
	struct list_head list;
	struct resource res;
};

struct pci_root_info___2 {
	struct list_head list;
	char name[12];
	struct list_head resources;
	struct resource busn;
	int node;
	int link;
};

struct amd_hostbridge {
	u32 bus;
	u32 slot;
	u32 device;
};

struct saved_msr {
	bool valid;
	struct msr_info info;
};

struct saved_msrs {
	unsigned int num;
	struct saved_msr *array;
};

struct saved_context {
	struct pt_regs regs;
	u16 ds;
	u16 es;
	u16 fs;
	u16 gs;
	long unsigned int kernelmode_gs_base;
	long unsigned int usermode_gs_base;
	long unsigned int fs_base;
	long unsigned int cr0;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	u64 misc_enable;
	bool misc_enable_saved;
	struct saved_msrs saved_msrs;
	long unsigned int efer;
	u16 gdt_pad;
	struct desc_ptr gdt_desc;
	u16 idt_pad;
	struct desc_ptr idt;
	u16 ldt;
	u16 tss;
	long unsigned int tr;
	long unsigned int safety;
	long unsigned int return_address;
} __attribute__((packed));

typedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
