// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:

	api.proto

It has these top-level messages:

	FlowReceipt
	FlowRequest
	FlowUpdate
	FlowKey
	Flow
	FlowLogPolicy
*/
package proto

import (
	fmt "fmt"

	proto1 "github.com/gogo/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// FlowReceipt is a response from the server to a client after publishing a stream of Flows.
type FlowReceipt struct {
}

func (m *FlowReceipt) Reset()                    { *m = FlowReceipt{} }
func (m *FlowReceipt) String() string            { return proto1.CompactTextString(m) }
func (*FlowReceipt) ProtoMessage()               {}
func (*FlowReceipt) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

// FlowRequest defines a message to request a particular selection of aggregated Flow objects.
type FlowRequest struct {
	// StartTimeGt specifies the beginning of a time window with which to filter Flows. Flows
	// will be returned only if their start time occurs after the requested time.
	StartTimeGt int64 `protobuf:"varint,1,opt,name=start_time_gt,json=startTimeGt,proto3" json:"start_time_gt,omitempty"`
	// StartTimeLt specifies the end of a time window with which to filter flows. Flows will
	// be returned only if their start time occurs before the requested time.
	StartTimeLt int64 `protobuf:"varint,2,opt,name=start_time_lt,json=startTimeLt,proto3" json:"start_time_lt,omitempty"`
	// PageNumber specifies the page number to return. It requires that MaxResults is also specified in order
	// to determine page boundaries. Note that pages may change over time as new flow data is collected or expired.
	// Querying the same page at different points in time may return different results.
	PageNumber int64 `protobuf:"varint,3,opt,name=page_number,json=pageNumber,proto3" json:"page_number,omitempty"`
	// PageSize configures the maximum number of results to return as part of this query.
	PageSize int64 `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *FlowRequest) Reset()                    { *m = FlowRequest{} }
func (m *FlowRequest) String() string            { return proto1.CompactTextString(m) }
func (*FlowRequest) ProtoMessage()               {}
func (*FlowRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *FlowRequest) GetStartTimeGt() int64 {
	if m != nil {
		return m.StartTimeGt
	}
	return 0
}

func (m *FlowRequest) GetStartTimeLt() int64 {
	if m != nil {
		return m.StartTimeLt
	}
	return 0
}

func (m *FlowRequest) GetPageNumber() int64 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

func (m *FlowRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// FlowUpdate wraps a Flow with additional metadata.
type FlowUpdate struct {
	// Flow contains the actual flow being sent.
	Flow *Flow `protobuf:"bytes,1,opt,name=flow" json:"flow,omitempty"`
}

func (m *FlowUpdate) Reset()                    { *m = FlowUpdate{} }
func (m *FlowUpdate) String() string            { return proto1.CompactTextString(m) }
func (*FlowUpdate) ProtoMessage()               {}
func (*FlowUpdate) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *FlowUpdate) GetFlow() *Flow {
	if m != nil {
		return m.Flow
	}
	return nil
}

// FlowKey includes the identifying fields for a Flow.
// - Source: Name, namespace, type, and labels.
// - Destination: Name, namespace, type, labels and port
// - Action taken on the connection.
// - Reporter (i.e., measured at source or destination).
// - Protocol of the connection (TCP, UDP, etc.).
type FlowKey struct {
	// SourceName is the name of the source for this Flow. It represents one or more
	// source pods that share a GenerateName.
	SourceName string `protobuf:"bytes,3,opt,name=source_name,json=sourceName,proto3" json:"source_name,omitempty"`
	// SourceNamespace is the namespace of the source pods for this flow.
	SourceNamespace string `protobuf:"bytes,4,opt,name=source_namespace,json=sourceNamespace,proto3" json:"source_namespace,omitempty"`
	// SourceType is the type of the source, used to contextualize the source
	// name and namespace fields.
	//
	// This can be one of:
	//
	// - wep: WorkloadEndpoint (i.e., Pod)
	// - hep: HostEndpoint
	// - ns: NetworkSet
	// - pub/pvt: External network (source name omitted)
	SourceType string `protobuf:"bytes,5,opt,name=source_type,json=sourceType,proto3" json:"source_type,omitempty"`
	// DestName is the name of the destination for this Flow. It represents one or more
	// destination pods that share a GenerateName.
	DestName string `protobuf:"bytes,7,opt,name=dest_name,json=destName,proto3" json:"dest_name,omitempty"`
	// DestNamespace is the namespace of the destination pods for this flow.
	DestNamespace string `protobuf:"bytes,8,opt,name=dest_namespace,json=destNamespace,proto3" json:"dest_namespace,omitempty"`
	// DestType is the type of the destination, used to contextualize the dest
	// name and namespace fields.
	//
	// This can be one of:
	//
	// - wep: WorkloadEndpoint (i.e., Pod)
	// - hep: HostEndpoint
	// - ns: NetworkSet
	// - pub/pvt: External network (dest name omitted)
	DestType string `protobuf:"bytes,9,opt,name=dest_type,json=destType,proto3" json:"dest_type,omitempty"`
	// DestPort is the destination port on the specified protocol accessed by this flow.
	DestPort int64 `protobuf:"varint,10,opt,name=dest_port,json=destPort,proto3" json:"dest_port,omitempty"`
	// DestServiceName is the name of the destination service, if any.
	DestServiceName string `protobuf:"bytes,11,opt,name=dest_service_name,json=destServiceName,proto3" json:"dest_service_name,omitempty"`
	// DestServiceNamespace is the namespace of the destination service, if any.
	DestServiceNamespace string `protobuf:"bytes,12,opt,name=dest_service_namespace,json=destServiceNamespace,proto3" json:"dest_service_namespace,omitempty"`
	// DestServicePortName is the name of the port on the destination service, if any.
	DestServicePortName string `protobuf:"bytes,13,opt,name=dest_service_port_name,json=destServicePortName,proto3" json:"dest_service_port_name,omitempty"`
	// DestServicePort is the port number on the destination service.
	DestServicePort int64 `protobuf:"varint,14,opt,name=dest_service_port,json=destServicePort,proto3" json:"dest_service_port,omitempty"`
	// Proto is the L4 protocol for this flow. Either TCP or UDP.
	Proto string `protobuf:"bytes,15,opt,name=proto,proto3" json:"proto,omitempty"`
	// Reporter is either "src" or "dst", depending on whether this flow was generated
	// at the initating or terminating end of the connection attempt.
	Reporter string `protobuf:"bytes,16,opt,name=reporter,proto3" json:"reporter,omitempty"`
	// Action is the ultimate action taken on the flow. Either Allow or Drop.
	Action string `protobuf:"bytes,17,opt,name=action,proto3" json:"action,omitempty"`
}

func (m *FlowKey) Reset()                    { *m = FlowKey{} }
func (m *FlowKey) String() string            { return proto1.CompactTextString(m) }
func (*FlowKey) ProtoMessage()               {}
func (*FlowKey) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *FlowKey) GetSourceName() string {
	if m != nil {
		return m.SourceName
	}
	return ""
}

func (m *FlowKey) GetSourceNamespace() string {
	if m != nil {
		return m.SourceNamespace
	}
	return ""
}

func (m *FlowKey) GetSourceType() string {
	if m != nil {
		return m.SourceType
	}
	return ""
}

func (m *FlowKey) GetDestName() string {
	if m != nil {
		return m.DestName
	}
	return ""
}

func (m *FlowKey) GetDestNamespace() string {
	if m != nil {
		return m.DestNamespace
	}
	return ""
}

func (m *FlowKey) GetDestType() string {
	if m != nil {
		return m.DestType
	}
	return ""
}

func (m *FlowKey) GetDestPort() int64 {
	if m != nil {
		return m.DestPort
	}
	return 0
}

func (m *FlowKey) GetDestServiceName() string {
	if m != nil {
		return m.DestServiceName
	}
	return ""
}

func (m *FlowKey) GetDestServiceNamespace() string {
	if m != nil {
		return m.DestServiceNamespace
	}
	return ""
}

func (m *FlowKey) GetDestServicePortName() string {
	if m != nil {
		return m.DestServicePortName
	}
	return ""
}

func (m *FlowKey) GetDestServicePort() int64 {
	if m != nil {
		return m.DestServicePort
	}
	return 0
}

func (m *FlowKey) GetProto() string {
	if m != nil {
		return m.Proto
	}
	return ""
}

func (m *FlowKey) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *FlowKey) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

// Flow is a message representing statistics gathered about connections that share common fields,
// aggregated across either time, nodes, or both.
type Flow struct {
	// Key includes the identifying fields for this flow.
	Key *FlowKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	// StartTime is the start time for this flow. It is represented as the number of
	// seconds since the UNIX epoch.
	StartTime int64 `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// EndTime is the end time for this flow. It is always exactly one aggregation
	// interval after the start time.
	EndTime int64 `protobuf:"varint,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// SourceLabels contains the intersection of labels that appear on all source
	// pods that contributed to this flow.
	SourceLabels []string `protobuf:"bytes,4,rep,name=source_labels,json=sourceLabels" json:"source_labels,omitempty"`
	// SourceLabels contains the intersection of labels that appear on all destination
	// pods that contributed to this flow.
	DestLabels []string `protobuf:"bytes,5,rep,name=dest_labels,json=destLabels" json:"dest_labels,omitempty"`
	// Statistics.
	PacketsIn  int64 `protobuf:"varint,6,opt,name=packets_in,json=packetsIn,proto3" json:"packets_in,omitempty"`
	PacketsOut int64 `protobuf:"varint,7,opt,name=packets_out,json=packetsOut,proto3" json:"packets_out,omitempty"`
	BytesIn    int64 `protobuf:"varint,8,opt,name=bytes_in,json=bytesIn,proto3" json:"bytes_in,omitempty"`
	BytesOut   int64 `protobuf:"varint,9,opt,name=bytes_out,json=bytesOut,proto3" json:"bytes_out,omitempty"`
	// NumConnectionsStarted tracks the total number of new connections recorded for this Flow. It counts each
	// connection attempt that matches the FlowKey that was made between this Flow's StartTime and EndTime.
	NumConnectionsStarted int64 `protobuf:"varint,11,opt,name=num_connections_started,json=numConnectionsStarted,proto3" json:"num_connections_started,omitempty"`
	// NumConnectionsCompleted tracks the total number of completed connections recorded for this Flow. It counts each
	// connection that matches the FlowKey that was completed between this Flow's StartTime and EndTime.
	NumConnectionsCompleted int64 `protobuf:"varint,12,opt,name=num_connections_completed,json=numConnectionsCompleted,proto3" json:"num_connections_completed,omitempty"`
	// NumConnectionsLive tracks the total number of still active connections recorded for this Flow. It counts each
	// connection that matches the FlowKey that was active at this Flow's EndTime.
	NumConnectionsLive int64 `protobuf:"varint,13,opt,name=num_connections_live,json=numConnectionsLive,proto3" json:"num_connections_live,omitempty"`
	// Policies includes an entry for each policy rule that took an action on the connections
	// aggregated into this flow.
	Policies *FlowLogPolicy `protobuf:"bytes,14,opt,name=policies" json:"policies,omitempty"`
}

func (m *Flow) Reset()                    { *m = Flow{} }
func (m *Flow) String() string            { return proto1.CompactTextString(m) }
func (*Flow) ProtoMessage()               {}
func (*Flow) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *Flow) GetKey() *FlowKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Flow) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Flow) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *Flow) GetSourceLabels() []string {
	if m != nil {
		return m.SourceLabels
	}
	return nil
}

func (m *Flow) GetDestLabels() []string {
	if m != nil {
		return m.DestLabels
	}
	return nil
}

func (m *Flow) GetPacketsIn() int64 {
	if m != nil {
		return m.PacketsIn
	}
	return 0
}

func (m *Flow) GetPacketsOut() int64 {
	if m != nil {
		return m.PacketsOut
	}
	return 0
}

func (m *Flow) GetBytesIn() int64 {
	if m != nil {
		return m.BytesIn
	}
	return 0
}

func (m *Flow) GetBytesOut() int64 {
	if m != nil {
		return m.BytesOut
	}
	return 0
}

func (m *Flow) GetNumConnectionsStarted() int64 {
	if m != nil {
		return m.NumConnectionsStarted
	}
	return 0
}

func (m *Flow) GetNumConnectionsCompleted() int64 {
	if m != nil {
		return m.NumConnectionsCompleted
	}
	return 0
}

func (m *Flow) GetNumConnectionsLive() int64 {
	if m != nil {
		return m.NumConnectionsLive
	}
	return 0
}

func (m *Flow) GetPolicies() *FlowLogPolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

type FlowLogPolicy struct {
	// AllPolicies is a list of strings containing policy rule information.
	AllPolicies []string `protobuf:"bytes,1,rep,name=all_policies,json=allPolicies" json:"all_policies,omitempty"`
}

func (m *FlowLogPolicy) Reset()                    { *m = FlowLogPolicy{} }
func (m *FlowLogPolicy) String() string            { return proto1.CompactTextString(m) }
func (*FlowLogPolicy) ProtoMessage()               {}
func (*FlowLogPolicy) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *FlowLogPolicy) GetAllPolicies() []string {
	if m != nil {
		return m.AllPolicies
	}
	return nil
}

func init() {
	proto1.RegisterType((*FlowReceipt)(nil), "felix.FlowReceipt")
	proto1.RegisterType((*FlowRequest)(nil), "felix.FlowRequest")
	proto1.RegisterType((*FlowUpdate)(nil), "felix.FlowUpdate")
	proto1.RegisterType((*FlowKey)(nil), "felix.FlowKey")
	proto1.RegisterType((*Flow)(nil), "felix.Flow")
	proto1.RegisterType((*FlowLogPolicy)(nil), "felix.FlowLogPolicy")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FlowAPI service

type FlowAPIClient interface {
	// List is an API call to query for one or more Flows.
	// Matching Flows are streamed back to the caller.
	List(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (FlowAPI_ListClient, error)
}

type flowAPIClient struct {
	cc *grpc.ClientConn
}

func NewFlowAPIClient(cc *grpc.ClientConn) FlowAPIClient {
	return &flowAPIClient{cc}
}

func (c *flowAPIClient) List(ctx context.Context, in *FlowRequest, opts ...grpc.CallOption) (FlowAPI_ListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowAPI_serviceDesc.Streams[0], c.cc, "/felix.FlowAPI/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowAPIListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlowAPI_ListClient interface {
	Recv() (*Flow, error)
	grpc.ClientStream
}

type flowAPIListClient struct {
	grpc.ClientStream
}

func (x *flowAPIListClient) Recv() (*Flow, error) {
	m := new(Flow)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FlowAPI service

type FlowAPIServer interface {
	// List is an API call to query for one or more Flows.
	// Matching Flows are streamed back to the caller.
	List(*FlowRequest, FlowAPI_ListServer) error
}

func RegisterFlowAPIServer(s *grpc.Server, srv FlowAPIServer) {
	s.RegisterService(&_FlowAPI_serviceDesc, srv)
}

func _FlowAPI_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlowRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowAPIServer).List(m, &flowAPIListServer{stream})
}

type FlowAPI_ListServer interface {
	Send(*Flow) error
	grpc.ServerStream
}

type flowAPIListServer struct {
	grpc.ServerStream
}

func (x *flowAPIListServer) Send(m *Flow) error {
	return x.ServerStream.SendMsg(m)
}

var _FlowAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "felix.FlowAPI",
	HandlerType: (*FlowAPIServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _FlowAPI_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// Client API for FlowCollector service

type FlowCollectorClient interface {
	// Connect receives a connection that may stream one or more FlowUpdates. A FlowReceipt is returned
	// to the client by the server after each FlowUpdate.
	Connect(ctx context.Context, opts ...grpc.CallOption) (FlowCollector_ConnectClient, error)
}

type flowCollectorClient struct {
	cc *grpc.ClientConn
}

func NewFlowCollectorClient(cc *grpc.ClientConn) FlowCollectorClient {
	return &flowCollectorClient{cc}
}

func (c *flowCollectorClient) Connect(ctx context.Context, opts ...grpc.CallOption) (FlowCollector_ConnectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FlowCollector_serviceDesc.Streams[0], c.cc, "/felix.FlowCollector/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &flowCollectorConnectClient{stream}
	return x, nil
}

type FlowCollector_ConnectClient interface {
	Send(*FlowUpdate) error
	Recv() (*FlowReceipt, error)
	grpc.ClientStream
}

type flowCollectorConnectClient struct {
	grpc.ClientStream
}

func (x *flowCollectorConnectClient) Send(m *FlowUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flowCollectorConnectClient) Recv() (*FlowReceipt, error) {
	m := new(FlowReceipt)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FlowCollector service

type FlowCollectorServer interface {
	// Connect receives a connection that may stream one or more FlowUpdates. A FlowReceipt is returned
	// to the client by the server after each FlowUpdate.
	Connect(FlowCollector_ConnectServer) error
}

func RegisterFlowCollectorServer(s *grpc.Server, srv FlowCollectorServer) {
	s.RegisterService(&_FlowCollector_serviceDesc, srv)
}

func _FlowCollector_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlowCollectorServer).Connect(&flowCollectorConnectServer{stream})
}

type FlowCollector_ConnectServer interface {
	Send(*FlowReceipt) error
	Recv() (*FlowUpdate, error)
	grpc.ServerStream
}

type flowCollectorConnectServer struct {
	grpc.ServerStream
}

func (x *flowCollectorConnectServer) Send(m *FlowReceipt) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flowCollectorConnectServer) Recv() (*FlowUpdate, error) {
	m := new(FlowUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _FlowCollector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "felix.FlowCollector",
	HandlerType: (*FlowCollectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _FlowCollector_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

func (m *FlowReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowReceipt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FlowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTimeGt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTimeGt))
	}
	if m.StartTimeLt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTimeLt))
	}
	if m.PageNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PageNumber))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *FlowUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flow != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Flow.Size()))
		n1, err := m.Flow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *FlowKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SourceName)))
		i += copy(dAtA[i:], m.SourceName)
	}
	if len(m.SourceNamespace) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SourceNamespace)))
		i += copy(dAtA[i:], m.SourceNamespace)
	}
	if len(m.SourceType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.SourceType)))
		i += copy(dAtA[i:], m.SourceType)
	}
	if len(m.DestName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DestName)))
		i += copy(dAtA[i:], m.DestName)
	}
	if len(m.DestNamespace) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DestNamespace)))
		i += copy(dAtA[i:], m.DestNamespace)
	}
	if len(m.DestType) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DestType)))
		i += copy(dAtA[i:], m.DestType)
	}
	if m.DestPort != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DestPort))
	}
	if len(m.DestServiceName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DestServiceName)))
		i += copy(dAtA[i:], m.DestServiceName)
	}
	if len(m.DestServiceNamespace) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DestServiceNamespace)))
		i += copy(dAtA[i:], m.DestServiceNamespace)
	}
	if len(m.DestServicePortName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.DestServicePortName)))
		i += copy(dAtA[i:], m.DestServicePortName)
	}
	if m.DestServicePort != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DestServicePort))
	}
	if len(m.Proto) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Proto)))
		i += copy(dAtA[i:], m.Proto)
	}
	if len(m.Reporter) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reporter)))
		i += copy(dAtA[i:], m.Reporter)
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	return i, nil
}

func (m *Flow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Key.Size()))
		n2, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EndTime))
	}
	if len(m.SourceLabels) > 0 {
		for _, s := range m.SourceLabels {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DestLabels) > 0 {
		for _, s := range m.DestLabels {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PacketsIn != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PacketsIn))
	}
	if m.PacketsOut != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PacketsOut))
	}
	if m.BytesIn != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BytesIn))
	}
	if m.BytesOut != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BytesOut))
	}
	if m.NumConnectionsStarted != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NumConnectionsStarted))
	}
	if m.NumConnectionsCompleted != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NumConnectionsCompleted))
	}
	if m.NumConnectionsLive != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NumConnectionsLive))
	}
	if m.Policies != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Policies.Size()))
		n3, err := m.Policies.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *FlowLogPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowLogPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllPolicies) > 0 {
		for _, s := range m.AllPolicies {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FlowReceipt) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FlowRequest) Size() (n int) {
	var l int
	_ = l
	if m.StartTimeGt != 0 {
		n += 1 + sovApi(uint64(m.StartTimeGt))
	}
	if m.StartTimeLt != 0 {
		n += 1 + sovApi(uint64(m.StartTimeLt))
	}
	if m.PageNumber != 0 {
		n += 1 + sovApi(uint64(m.PageNumber))
	}
	if m.PageSize != 0 {
		n += 1 + sovApi(uint64(m.PageSize))
	}
	return n
}

func (m *FlowUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Flow != nil {
		l = m.Flow.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *FlowKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SourceNamespace)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.SourceType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DestName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DestNamespace)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DestType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DestPort != 0 {
		n += 1 + sovApi(uint64(m.DestPort))
	}
	l = len(m.DestServiceName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DestServiceNamespace)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DestServicePortName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DestServicePort != 0 {
		n += 1 + sovApi(uint64(m.DestServicePort))
	}
	l = len(m.Proto)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Flow) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovApi(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovApi(uint64(m.EndTime))
	}
	if len(m.SourceLabels) > 0 {
		for _, s := range m.SourceLabels {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.DestLabels) > 0 {
		for _, s := range m.DestLabels {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.PacketsIn != 0 {
		n += 1 + sovApi(uint64(m.PacketsIn))
	}
	if m.PacketsOut != 0 {
		n += 1 + sovApi(uint64(m.PacketsOut))
	}
	if m.BytesIn != 0 {
		n += 1 + sovApi(uint64(m.BytesIn))
	}
	if m.BytesOut != 0 {
		n += 1 + sovApi(uint64(m.BytesOut))
	}
	if m.NumConnectionsStarted != 0 {
		n += 1 + sovApi(uint64(m.NumConnectionsStarted))
	}
	if m.NumConnectionsCompleted != 0 {
		n += 1 + sovApi(uint64(m.NumConnectionsCompleted))
	}
	if m.NumConnectionsLive != 0 {
		n += 1 + sovApi(uint64(m.NumConnectionsLive))
	}
	if m.Policies != nil {
		l = m.Policies.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *FlowLogPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.AllPolicies) > 0 {
		for _, s := range m.AllPolicies {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FlowReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeGt", wireType)
			}
			m.StartTimeGt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeGt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeLt", wireType)
			}
			m.StartTimeLt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeLt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNumber", wireType)
			}
			m.PageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNumber |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flow == nil {
				m.Flow = &Flow{}
			}
			if err := m.Flow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPort", wireType)
			}
			m.DestPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestServiceNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestServiceNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestServicePortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestServicePortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestServicePort", wireType)
			}
			m.DestServicePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestServicePort |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proto = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &FlowKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceLabels = append(m.SourceLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestLabels = append(m.DestLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsIn", wireType)
			}
			m.PacketsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsIn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketsOut", wireType)
			}
			m.PacketsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketsOut |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			m.BytesIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesIn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			m.BytesOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesOut |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumConnectionsStarted", wireType)
			}
			m.NumConnectionsStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumConnectionsStarted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumConnectionsCompleted", wireType)
			}
			m.NumConnectionsCompleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumConnectionsCompleted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumConnectionsLive", wireType)
			}
			m.NumConnectionsLive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumConnectionsLive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policies == nil {
				m.Policies = &FlowLogPolicy{}
			}
			if err := m.Policies.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowLogPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowLogPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowLogPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllPolicies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllPolicies = append(m.AllPolicies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 725 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x54, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0xbe, 0xbe, 0x49, 0x9a, 0xf8, 0x38, 0xe9, 0xcf, 0xdc, 0xdc, 0xd6, 0xed, 0x55, 0xd3, 0xde,
	0x20, 0xa4, 0x16, 0x89, 0x2a, 0x4a, 0x2b, 0x16, 0xec, 0xa0, 0x02, 0x54, 0x35, 0x2a, 0x91, 0x5b,
	0x36, 0x6c, 0x2c, 0xc7, 0x39, 0xad, 0x46, 0x8c, 0x3d, 0xc6, 0x9e, 0xb4, 0xa4, 0x3b, 0xde, 0x00,
	0x89, 0x97, 0x62, 0xc9, 0x23, 0xa0, 0xf2, 0x12, 0x2c, 0xd1, 0x9c, 0x71, 0x12, 0xc7, 0xac, 0xa2,
	0xf9, 0x7e, 0xe6, 0x7c, 0x33, 0xf9, 0x3c, 0x60, 0x07, 0x09, 0x3f, 0x4a, 0x52, 0xa9, 0x24, 0xab,
	0x5d, 0xa3, 0xe0, 0x9f, 0xba, 0x2d, 0x70, 0x5e, 0x0b, 0x79, 0xe7, 0x61, 0x88, 0x3c, 0x51, 0xdd,
	0xaf, 0xd6, 0x6c, 0xfd, 0x71, 0x82, 0x99, 0x62, 0x5d, 0x68, 0x65, 0x2a, 0x48, 0x95, 0xaf, 0x78,
	0x84, 0xfe, 0x8d, 0x72, 0xad, 0x7d, 0xeb, 0xa0, 0xe2, 0x39, 0x04, 0x5e, 0xf1, 0x08, 0xdf, 0x94,
	0x35, 0x42, 0xb9, 0x7f, 0x97, 0x34, 0x03, 0xc5, 0xf6, 0xc0, 0x49, 0x82, 0x1b, 0xf4, 0xe3, 0x49,
	0x34, 0xc2, 0xd4, 0xad, 0x90, 0x02, 0x34, 0x74, 0x41, 0x08, 0xfb, 0x0f, 0x6c, 0x12, 0x64, 0xfc,
	0x1e, 0xdd, 0x2a, 0xd1, 0x0d, 0x0d, 0x5c, 0xf2, 0x7b, 0xec, 0x3e, 0x05, 0xd0, 0xa1, 0xde, 0x25,
	0xe3, 0x40, 0x21, 0xdb, 0x83, 0xea, 0xb5, 0x90, 0x77, 0x14, 0xc5, 0xe9, 0x3b, 0x47, 0x74, 0x90,
	0x23, 0x4a, 0x4d, 0x44, 0xf7, 0x73, 0x15, 0xea, 0x7a, 0x79, 0x8e, 0x53, 0x3d, 0x38, 0x93, 0x93,
	0x34, 0x44, 0x3f, 0x0e, 0x22, 0xa4, 0xc1, 0xb6, 0x07, 0x06, 0xba, 0x08, 0x22, 0x64, 0x87, 0xb0,
	0x5e, 0x10, 0x64, 0x49, 0x10, 0x9a, 0xf9, 0xb6, 0xb7, 0xb6, 0x50, 0x11, 0x5c, 0xd8, 0x4b, 0x4d,
	0x13, 0x74, 0x6b, 0xc5, 0xbd, 0xae, 0xa6, 0x09, 0xea, 0x43, 0x8c, 0x31, 0x53, 0x66, 0x54, 0x9d,
	0xe8, 0x86, 0x06, 0x68, 0xd0, 0x63, 0x58, 0x9d, 0x93, 0x66, 0x4c, 0x83, 0x14, 0xad, 0x99, 0xc2,
	0x0c, 0x99, 0xed, 0x41, 0x23, 0xec, 0xc5, 0x1e, 0x4b, 0x03, 0x12, 0x99, 0x2a, 0x17, 0xcc, 0x2d,
	0x69, 0x60, 0x28, 0x53, 0xc5, 0x9e, 0xc0, 0x06, 0x91, 0x19, 0xa6, 0xb7, 0x7c, 0x76, 0x60, 0xc7,
	0x1c, 0x45, 0x13, 0x97, 0x06, 0xa7, 0x30, 0x27, 0xb0, 0xf9, 0x87, 0xd6, 0x84, 0x6a, 0x92, 0xa1,
	0x5d, 0x32, 0x98, 0x6c, 0xc7, 0x25, 0x97, 0x8e, 0x61, 0xc6, 0xb4, 0xc8, 0xf5, 0x4f, 0xc1, 0xa5,
	0x23, 0xd1, 0xa8, 0x72, 0x2c, 0xca, 0xbe, 0x4a, 0xd9, 0xd7, 0x4a, 0x7a, 0xd6, 0x86, 0x1a, 0xb5,
	0xd3, 0x5d, 0xa3, 0xfd, 0xcc, 0x82, 0xed, 0x40, 0x23, 0x45, 0x6d, 0xc3, 0xd4, 0x5d, 0x37, 0x37,
	0x32, 0x5b, 0xb3, 0x4d, 0x58, 0x09, 0x42, 0xc5, 0x65, 0xec, 0x6e, 0x10, 0x93, 0xaf, 0xba, 0xbf,
	0x2a, 0x50, 0xd5, 0x1d, 0x60, 0xfb, 0x50, 0x39, 0xc7, 0x69, 0x5e, 0x96, 0xd5, 0x42, 0x59, 0xce,
	0x71, 0xea, 0x69, 0x8a, 0xed, 0x02, 0x2c, 0xfa, 0x9b, 0x97, 0xd7, 0x9e, 0x97, 0x97, 0x6d, 0x43,
	0x03, 0xe3, 0xb1, 0x21, 0x4d, 0x6f, 0xeb, 0x18, 0x8f, 0x89, 0x7a, 0x04, 0xad, 0xbc, 0x10, 0x22,
	0x18, 0xa1, 0xc8, 0xdc, 0xea, 0x7e, 0xe5, 0xc0, 0xf6, 0x9a, 0x06, 0x1c, 0x10, 0xa6, 0x5b, 0x43,
	0xe7, 0xcf, 0x25, 0x35, 0x92, 0x80, 0x86, 0x72, 0xc1, 0x2e, 0x40, 0x12, 0x84, 0x1f, 0x50, 0x65,
	0x3e, 0x8f, 0xdd, 0x15, 0x33, 0x3f, 0x47, 0xce, 0x62, 0xf3, 0xe9, 0x18, 0x5a, 0x4e, 0x14, 0xd5,
	0x8a, 0x3e, 0x1d, 0x82, 0xde, 0x4e, 0x94, 0x0e, 0x38, 0x9a, 0x2a, 0x24, 0x77, 0xc3, 0x04, 0xa4,
	0xf5, 0x59, 0xac, 0xfb, 0x62, 0x28, 0xed, 0xb4, 0x4d, 0x5f, 0x08, 0xd0, 0xbe, 0x67, 0xb0, 0x15,
	0x4f, 0x22, 0x3f, 0x94, 0x71, 0x8c, 0x74, 0x69, 0x99, 0x4f, 0xa7, 0xc6, 0x31, 0xb5, 0xa6, 0xe2,
	0xfd, 0x1b, 0x4f, 0xa2, 0xd3, 0x05, 0x7b, 0x69, 0x48, 0xf6, 0x1c, 0xb6, 0xcb, 0xbe, 0x50, 0x46,
	0x89, 0x40, 0xed, 0x6c, 0x92, 0x73, 0x6b, 0xd9, 0x79, 0x3a, 0xa3, 0x59, 0x0f, 0xda, 0x65, 0xaf,
	0xe0, 0xb7, 0xa6, 0x3f, 0x15, 0x8f, 0x2d, 0xdb, 0x06, 0xfc, 0x16, 0x59, 0x0f, 0x1a, 0x89, 0x14,
	0x3c, 0xe4, 0x98, 0x51, 0x6b, 0x9c, 0x7e, 0xbb, 0xf0, 0x27, 0x0e, 0xe4, 0xcd, 0x50, 0xb3, 0x53,
	0x6f, 0xae, 0xea, 0xf6, 0xa1, 0xb5, 0x44, 0xb1, 0xff, 0xa1, 0x19, 0x08, 0xe1, 0xcf, 0xb7, 0xb1,
	0xe8, 0x2f, 0x70, 0x02, 0x21, 0x86, 0x39, 0xd4, 0x3f, 0x31, 0x2f, 0xc6, 0x8b, 0xe1, 0x19, 0x3b,
	0x84, 0xea, 0x80, 0x67, 0x8a, 0xb1, 0xe2, 0xc3, 0x62, 0x9e, 0xc3, 0x9d, 0xe2, 0x63, 0xd3, 0xb3,
	0xfa, 0xaf, 0xcc, 0xa4, 0x53, 0x29, 0x04, 0x86, 0x4a, 0xa6, 0xec, 0x04, 0xea, 0x79, 0x7e, 0xb6,
	0x51, 0x90, 0x9a, 0x87, 0x6b, 0x67, 0x79, 0x47, 0x7a, 0x70, 0x0f, 0xac, 0x9e, 0xf5, 0x72, 0xeb,
	0xdb, 0x43, 0xc7, 0xfa, 0xfe, 0xd0, 0xb1, 0x7e, 0x3c, 0x74, 0xac, 0x2f, 0x3f, 0x3b, 0x7f, 0xbd,
	0x37, 0xc5, 0x1f, 0xad, 0xd0, 0xcf, 0xf1, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x95, 0x4e, 0xf6,
	0xe0, 0xb7, 0x05, 0x00, 0x00,
}
